package remote.wise.businessobject;

import java.io.BufferedReader;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.Set;
import java.net.HttpURLConnection;
import java.net.URL;

import org.apache.logging.log4j.Logger;
import org.hibernate.Query;
import org.hibernate.Session;
import org.hibernate.Transaction;
import org.json.simple.JSONObject;

import com.wipro.mcoreapp.businessobject.EADataPopulationBO;

import remote.wise.EAintegration.Qhandler.ServiceHistoryQHandler;
import remote.wise.EAintegration.dataContract.ServiceHistoryInputContract;
import remote.wise.businessentity.AccountEntity;
import remote.wise.businessentity.AssetControlUnitEntity;
import remote.wise.businessentity.AssetEntity;
import remote.wise.businessentity.AssetEventEntity;
import remote.wise.businessentity.AssetGroupEntity;
import remote.wise.businessentity.AssetGroupProfileEntity;
import remote.wise.businessentity.AssetServiceScheduleEntity;
import remote.wise.businessentity.AssetTypeEntity;
import remote.wise.businessentity.ClientEntity;
import remote.wise.businessentity.EngineTypeEntity;
import remote.wise.businessentity.ProductEntity;
import remote.wise.businessentity.ServiceHistoryEntity;
import remote.wise.businessentity.ServiceScheduleEntity;
import remote.wise.dal.DynamicAMH_DAL;
import remote.wise.dal.DynamicAMS_DAL;
import remote.wise.dal.DynamicAMS_Doc_DAL;
import remote.wise.exception.CustomFault;
import remote.wise.log.BusinessErrorLogging.BusinessErrorLoggerClass;
import remote.wise.log.FatalErrorLogging.FatalLoggerClass;
import remote.wise.log.InfoLogging.InfoLoggerClass;
import remote.wise.log.RejectedPacketLogging.RejectedPktLoggerClass;
import remote.wise.pojo.AMSDoc_DAO;
import remote.wise.pojo.AmsDAO;
import remote.wise.service.implementation.AssetServiceScheduleImpl;
import remote.wise.service.implementation.DomainServiceImpl;
import remote.wise.util.CommonUtil;
import remote.wise.util.ConnectMySQL;
import remote.wise.util.HibernateUtil;
import remote.wise.util.ListToStringConversion;
//import remote.wise.util.WiseLogger;

/**
 * BO class to set and get the
 * serviceScheduleId,serviceName,scheduleName,durationSchedule
 * ,engineHoursSchedule for the specified productId
 * 
 * @author Smitha
 * 
 */
public class ServiceDetailsBO {

	//DefectId:1337 - Rajani Nagaraju - 20130923 - Log4j Changes - Using static logger object all throughout the application
	/*public static WiseLogger businessError = WiseLogger.getLogger("ServiceDetailsBO:","businessError");
	public static WiseLogger fatalError = WiseLogger.getLogger("ServiceDetailsBO:","fatalError");
	public static WiseLogger infoLogger = WiseLogger.getLogger("ServiceDetailsBO:","info");*/

	private int serviceScheduleId;
	private String serviceName;
	private String scheduleName;
	private int durationSchedule;
	private long engineHoursSchedule;
	private int productId;
	private AssetEntity serialNumber;
	private float hoursToNextService;
	private String dbmsPartCode;
	private String jobCardNumber;
	//DF20180423:IM20018382 - An additional field jobCardDetails.
	private String jobCardDetails;
	private Timestamp serviceDate;
	private int assetTypeId;
	private int engineTypeId;
	private int assetGroupId;
	private String engineTypeName;
	private String asset_group_name;
	private String asset_type_name;

	public EngineTypeEntity getEngineTypeEntity(int engineTypeId) {
		EngineTypeEntity EngineTypeEntity = new EngineTypeEntity(engineTypeId);
		return EngineTypeEntity;
	}

	public String getEngineTypeName() {
		return engineTypeName;
	}

	public void setEngineTypeName(String engineTypeName) {
		this.engineTypeName = engineTypeName;
	}

	public String getAsset_group_name() {
		return asset_group_name;
	}

	public void setAsset_group_name(String asset_group_name) {
		this.asset_group_name = asset_group_name;
	}

	public String getAsset_type_name() {
		return asset_type_name;
	}

	public void setAsset_type_name(String asset_type_name) {
		this.asset_type_name = asset_type_name;
	}

	public int getAssetTypeId() {
		return assetTypeId;
	}

	public void setAssetTypeId(int assetTypeId) {
		this.assetTypeId = assetTypeId;
	}

	public int getEngineTypeId() {
		return engineTypeId;
	}

	public void setEngineTypeId(int engineTypeId) {
		this.engineTypeId = engineTypeId;
	}

	public int getAssetGroupId() {
		return assetGroupId;
	}

	public void setAssetGroupId(int assetGroupId) {
		this.assetGroupId = assetGroupId;
	}

	public Timestamp getServiceDate() {
		return serviceDate;
	}

	public void setServiceDate(Timestamp serviceDate) {
		this.serviceDate = serviceDate;
	}

	public String getJobCardNumber() {
		return jobCardNumber;
	}

	public void setJobCardNumber(String jobCardNumber) {
		this.jobCardNumber = jobCardNumber;
	}
	
	//DF20180423:IM20018382 - An additional field jobCardDetails.
	public String getJobCardDetails() {
		return jobCardDetails;
	}

	public void setJobCardDetails(String jobCardDetails) {
		this.jobCardDetails = jobCardDetails;
	}
	
	public float getHoursToNextService() {
		return hoursToNextService;
	}

	public void setHoursToNextService(float hoursToNextService) {
		this.hoursToNextService = hoursToNextService;
	}

	public AssetEntity getSerialNumber() {
		return serialNumber;
	}

	public void setSerialNumber(AssetEntity assetEntity) {
		this.serialNumber = assetEntity;
	}

	public int getProductId() {
		return productId;
	}

	public void setProductId(int productEntity) {
		this.productId = productEntity;
	}

	public int getDurationSchedule() {
		return durationSchedule;
	}

	public void setDurationSchedule(int durationSchedule) {
		this.durationSchedule = durationSchedule;
	}

	public long getEngineHoursSchedule() {
		return engineHoursSchedule;
	}

	public void setEngineHoursSchedule(long engineHoursSchedule) {
		this.engineHoursSchedule = engineHoursSchedule;
	}

	public int getServiceScheduleId() {
		return serviceScheduleId;
	}

	public void setServiceScheduleId(int serviceScheduleId) {
		this.serviceScheduleId = serviceScheduleId;
	}

	public String getServiceName() {
		return serviceName;
	}

	public void setServiceName(String serviceName) {
		this.serviceName = serviceName;
	}

	public String getScheduleName() {
		return scheduleName;
	}

	public void setScheduleName(String scheduleName) {
		this.scheduleName = scheduleName;
	}

	public String getDbmsPartCode() {
		return dbmsPartCode;
	}

	public void setDbmsPartCode(String dbmsPartCode) {
		this.dbmsPartCode = dbmsPartCode;
	}

	//Logger infoLogger = Logger.getLogger("infoLogger");

	// getMethod for master service schedule..
	/**
	 * This method gets
	 * serviceName,scheduleName,durationSchedule,engineHoursSchedule for the
	 * specified assetTypeId,engineTypeId,assetGroupId
	 * 
	 * @param reqObj
	 *            Get the details of
	 *            assetTypeId,engineTypeId,assetGroupId,serviceName by passing
	 *            the same to this request Object
	 * @return Returns respObj for the specified assetTypeId,engineTypeId and
	 *         assetGroupId or serviceName
	 * @throws CustomFault
	 */
	@SuppressWarnings("rawtypes")
	public List<ServiceDetailsBO> getMasterServiceScheduleDetails(
			int assetTypeId, int engineTypeId, int assetGroupId,
			String scheduleName) throws CustomFault {

		Logger bLogger = BusinessErrorLoggerClass.logger;

		//Logger businessError = Logger.getLogger("businessErrorLogger");
		List<ServiceDetailsBO> serviceDetailsList = new LinkedList<ServiceDetailsBO>();
		ServiceDetailsBO serviceBO = null;

		Session session = HibernateUtil.getSessionFactory().openSession();
		session.beginTransaction();
		try {
			String queryString = null;
			if ((assetTypeId == 0) && (engineTypeId == 0)
					&& (assetGroupId == 0) && (scheduleName == null)) {
				queryString = " select a.serviceName, a.scheduleName,a.durationSchedule,a.engineHoursSchedule,a.dbmsPartCode,"
						+ " a.assetTypeId, a.engineTypeId"
						+ ",a.assetGroupId from ServiceScheduleEntity a order by a.scheduleName";
			} else if ((assetTypeId != 0) && (engineTypeId != 0)
					&& (assetGroupId != 0)) {
				queryString = " select a.serviceName, a.scheduleName,a.durationSchedule,a.engineHoursSchedule,a.dbmsPartCode,"
						+ " a.assetTypeId, a.engineTypeId"
						+ ",a.assetGroupId from ServiceScheduleEntity a "
						+ " where a.assetTypeId= "
						+ assetTypeId
						+ ""
						+ " and a.assetGroupId="
						+ assetGroupId
						+ ""
						+ " and a.engineTypeId="
						+ engineTypeId
						+ ""
						+ " order by a.scheduleName";

			} else if (scheduleName != null) {
				queryString = " select a.serviceName, a.scheduleName,a.durationSchedule,a.engineHoursSchedule,a.dbmsPartCode,"
						+ " a.assetTypeId, a.engineTypeId"
						+ ",a.assetGroupId from ServiceScheduleEntity a"
						+ " where a.scheduleName='"
						+ scheduleName
						+ "'  order by a.scheduleName";
			}

			Iterator itr = session.createQuery(queryString).list().iterator();
			Object result[] = null;
			while (itr.hasNext()) {
				serviceBO = new ServiceDetailsBO();
				result = (Object[]) itr.next();
				serviceBO.setServiceName(result[0].toString());
				serviceBO.setScheduleName(result[1].toString());
				serviceBO.setDurationSchedule((Integer) result[2]);
				long a = (Long) result[3];
				int hours = (int) a;
				serviceBO.setEngineHoursSchedule(hours);
				serviceBO.setDbmsPartCode((String) result[4]);
				AssetTypeEntity assetType = (AssetTypeEntity) result[5];
				serviceBO.setAssetTypeId(assetType.getAsset_type_id());
				serviceBO.setAsset_type_name(assetType.getAsset_type_name());
				EngineTypeEntity engineType = (EngineTypeEntity) result[6];
				serviceBO.setEngineTypeName(engineType.getEngineTypeName());
				serviceBO.setEngineTypeId(engineType.getEngineTypeId());
				AssetGroupEntity assetGroup = (AssetGroupEntity) result[7];
				serviceBO.setAssetGroupId(assetGroup.getAsset_group_id());
				serviceBO.setAsset_group_name(assetGroup.getAsset_group_name());

				serviceDetailsList.add(serviceBO);
			}
		} catch (Exception e) {
			bLogger.error("Hello this is an Business Error message" + e.getMessage());
		} finally {
			if (session.getTransaction().isActive())
				session.getTransaction().commit();
			if (session.isOpen()) {
				session.flush();
				session.close();
			}
		}
		return serviceDetailsList;

	}

	// setMethod for master service schedule..
	/**
	 * This method sets the
	 * serviceName,scheduleName,durationSchedule,engineHoursSchedule
	 * ,assetTypeId,engineTypeId,assetGroupId
	 * 
	 * @param reqObj
	 *            Gets the assetTypeId,engineTypeId,assetGroupId
	 * @return Returns respObj for the specified
	 *         assetTypeId,engineTypeId,assetGroupId
	 * @throws CustomFault
	 */

	//***************************************** Set Master Service Schedule Details ***************************************************
	/** This method sets the Service schedule data for a product received from EA System
	 * @param servicePlan - Standard Warranty, Extended Warranty, or annual service contract , or 2000 hrs
	 * @param serviceName Name of the service like  First Free Service
	 * @param scheduleName Name of the service schedule such as  Model - Backhoe Loader - JCB Engine
	 * @param dbmsPartCode dbmsPartCode associated with the schedule
	 * @param assetGroupCode profile Code
	 * @param assetTypeCode model Code
	 * @param engineTypeCode Engine Type Code
	 * @param engineHours Schedule in terms of Engine Hours
	 * @param days Schedule in terms of days
	 * @return
	 */
	public String setMasterServiceScheduleDetails(String servicePlan, String serviceName, String scheduleName, String dbmsPartCode,
			String assetGroupCode,String assetTypeCode,String engineTypeCode,String engineHours,String days)
	{
		String status = "SUCCESS";

		//Logger businessError = Logger.getLogger("businessErrorLogger");
		// Logger fatalError = Logger.getLogger("fatalErrorLogger");

		Logger fLogger = FatalLoggerClass.logger;
		Logger bLogger = BusinessErrorLoggerClass.logger;
		Session session = HibernateUtil.getSessionFactory().getCurrentSession();
		Logger iLogger = InfoLoggerClass.logger;
		//DF20150603 - Rajani Nagaraju - WISE going down issue - Open a new session when the getCurrentSession returns a dirty session(txns which is not yet committed exists)
		if(session.getTransaction().isActive() && session.isDirty())
		{
			iLogger.info("Opening a new session");
			session = HibernateUtil.getSessionFactory().openSession();
		}
		session.beginTransaction();

		try 
		{
			AssetGroupEntity assetGroupObj=null;
			AssetGroupProfileEntity assetGroupProfile =null;
			AssetTypeEntity assetTypeObj=null;
			EngineTypeEntity engineTypeObj=null;

			//get Asset Group Details
			Query assetGroupQuery = session.createQuery("from AssetGroupProfileEntity where asset_grp_code like '"+assetGroupCode+"'");
			Iterator assetGroupItr = assetGroupQuery.list().iterator();
			while(assetGroupItr.hasNext())
			{
				assetGroupProfile = (AssetGroupProfileEntity)assetGroupItr.next();
				assetGroupObj = assetGroupProfile.getAsset_grp_id();
			}
			if(assetGroupObj==null)
			{
				status = "FAILURE";
				throw new CustomFault("Invalid Asset Group Code");
			}


			//get Asset Type Details
			Query assetTypeQuery = session.createQuery("from AssetTypeEntity where assetTypeCode like '"+assetTypeCode+"'");
			Iterator assetTypeItr = assetTypeQuery.list().iterator();
			while(assetTypeItr.hasNext())
			{
				assetTypeObj = (AssetTypeEntity)assetTypeItr.next();
			}
			if(assetTypeObj==null)
			{
				status = "FAILURE";
				throw new CustomFault("Invalid Asset Type Code");
			}


			//get the Engine type details
			Query engineTypeQuery = session.createQuery("from EngineTypeEntity where engineTypeCode like '"+engineTypeCode+"'");
			Iterator engineTypeItr = engineTypeQuery.list().iterator();
			while(engineTypeItr.hasNext())
			{
				engineTypeObj = (EngineTypeEntity)engineTypeItr.next();
			}
			if(engineTypeObj==null)
			{
				status = "FAILURE";
				throw new CustomFault("Invalid Engine Type Code");
			}


			if( !(servicePlan!=null && servicePlan!="" && (servicePlan.replaceAll("\\s","").length()>0) ) )
				servicePlan = null;

			if( !(serviceName!=null && serviceName!="" && (serviceName.replaceAll("\\s","").length()>0) ) )
				serviceName = null;

			if( !(scheduleName!=null && scheduleName!="" && (scheduleName.replaceAll("\\s","").length()>0) ) )
				scheduleName = null;


			Query query = session.createQuery(" from ServiceScheduleEntity where assetGroupId="+assetGroupObj.getAsset_group_id()+" and " +
					" assetTypeId="+assetTypeObj.getAsset_type_id()+" and engineTypeId ="+engineTypeObj.getEngineTypeId());
			Iterator itr = query.list().iterator();
			int insert=1;

			while (itr.hasNext()) 
			{
				ServiceScheduleEntity serviceSchedule = (ServiceScheduleEntity) itr.next();
				serviceSchedule.setScheduleName(scheduleName);

				if(serviceSchedule.getDbmsPartCode().equalsIgnoreCase(dbmsPartCode))
				{
					insert=0;
					serviceSchedule.setServiceName(serviceName);
					serviceSchedule.setDurationSchedule(Integer.parseInt(days));
					serviceSchedule.setEngineHoursSchedule(Long.parseLong(engineHours));

				}

				session.update(serviceSchedule);
			}

			if(insert==1)
			{
				ServiceScheduleEntity newServiceSchedule = new ServiceScheduleEntity();
				newServiceSchedule.setAssetGroupId(assetGroupObj);
				newServiceSchedule.setAssetTypeId(assetTypeObj);
				newServiceSchedule.setDbmsPartCode(dbmsPartCode);
				newServiceSchedule.setDurationSchedule(Integer.parseInt(days));
				newServiceSchedule.setEngineHoursSchedule(Long.parseLong(engineHours));
				newServiceSchedule.setEngineTypeId(engineTypeObj);
				newServiceSchedule.setScheduleName(scheduleName);
				newServiceSchedule.setServiceName(serviceName);

				session.save(newServiceSchedule);

			}


		} 

		catch(CustomFault e)
		{
			status = "FAILURE-"+e.getMessage();
			bLogger.error("Custom Fault: "+ e.getFaultInfo());
		}

		catch(Exception e)
		{
			status = "FAILURE-"+e.getMessage();
			fLogger.fatal("Exception :"+e);
		}

		finally
		{
			try
			{
				if(session.getTransaction().isActive())
				{
					session.getTransaction().commit();
				}
			}
			catch(Exception e)
			{
				status = "FAILURE-"+e.getMessage();
				//DF20150603 - Rajani Nagaraju - WISE going down issue - Adding try catch against commit
				fLogger.fatal("Exception in commiting the record:"+e);
			}

			if(session.isOpen())
			{
				session.flush();
				session.close();
			}
		}

		return status;
	}
	//***************************************** END Of Setting Master Service Schedule Details ***************************************************
	
	
	
		

	//****************************************** Set Service Closure Details for a machine ********************************************************
//	
//	public String setServiceCloserDetails(HashMap<String, String> inputObj )
//	{
//		Logger fLogger = FatalLoggerClass.logger;
//    	Logger iLogger = InfoLoggerClass.logger;
//    	String status="SUCCESS";
//		CommonUtil utilObj = new CommonUtil();
//    	
//    	String assetEventId = inputObj.get("assetEventId");
//    	String completedBy = inputObj.get("completedBy");
//    	String jobCardNo = inputObj.get("jobCardNo");
//    	String engineHrs = inputObj.get("engineHrs");
//    	String jobCardDetails = inputObj.get("comments");
//    	String serviceDate = inputObj.get("serviceDate");
//    	String userId = inputObj.get("loginId");
//    	//DF20170919 @Roopa getting decoded UserId
//    	String loginId = utilObj.getUserId(userId);
//    	if(userId == null){
//    			status="FAILURE";
//    			fLogger.fatal("ServiceDetailsBO:setServiceCloserDetails:AssetEventID :"+assetEventId+":login :"+loginId+" :Exception caused because of invalid login ID :"+userId);
//				return status;
//    	}    	
//    	
//		if(jobCardNo==null||jobCardNo==""||jobCardNo==" "){
//    		jobCardNo=assetEventId;
//    	}
//    	    	
//    	ConnectMySQL connMySql = new ConnectMySQL();
//		Connection conn = null;
//		Connection prodConn1=null;
//		Statement stmt = null;
//		Statement stmt1 = null;
//		Statement stmnt1 = null;
//		ResultSet rs = null;
//		ResultSet rs1 = null;
//		String serialNumber = null, attendedBy = null, nextServiceDate = null, 
//		 serviceTypeId = null, faultId = null, serviceName = null, scheduleName = null ,DBMS_partCode=null;
//		Timestamp eventGeneratedTime=null;
//		int serviceScheduleId=0 ,dealerId = 0;
//		String actionTaken= completedBy;
//		String CMH=(String)engineHrs;
//		String eventSeverity="";
//		int eventID=0;
//		String countryCode="";
//		PreparedStatement preparedStmt_1=null;
//		PreparedStatement preparedStmt=null;
//		try
//		{
//			conn = connMySql.getConnection();
//			stmt = conn.createStatement();
//			stmt1 = conn.createStatement();
//			String sel_Query="select * from asset_event ae,service_schedule ss, asset a where ae.Event_Type_ID=1 and ae.Asset_Event_ID='"+assetEventId+"' and ae.Serial_Number=a.Serial_Number and ae.Service_Schedule_ID=ss.serviceScheduleId and ae.active_status = 1 and ae.PartitionKey = 1";
//			rs = stmt.executeQuery(sel_Query);
//			//rs1= stmt.executeQuery("select * from service_history where serialNumber= '"+serialNumber+"' and serviceScheduleId='"+assetEventId+"'");
//			while(rs.next())
//			{
//				serialNumber = (String)rs.getObject("Serial_Number");
//				eventGeneratedTime = (Timestamp)rs.getObject("Event_Generated_Time");
//				rs1= stmt1.executeQuery("select * from asset_owner_snapshot where Serial_Number='"+serialNumber+"' and account_type = 'Dealer'");
//				if(rs1.next()){
//					dealerId= (Integer)rs1.getObject("Account_ID");
//				}
//				serviceName = (String)rs.getObject("serviceName");
//				scheduleName = (String)rs.getObject("scheduleName");
//				serviceScheduleId = (Integer)rs.getObject("Service_Schedule_ID");
//				DBMS_partCode = (String)rs.getObject("DBMS_partCode");
//				eventSeverity = (String)rs.getObject("Event_Severity");
//				eventID = rs.getInt("Event_ID");
//				countryCode = (String)rs.getObject("country_code");
//			}
//			
//			iLogger.info("ServiceDetailsBO:setServiceCloserDetails: AssetEventID :"+assetEventId+":login :"+loginId+": - Exception because query return null :"+sel_Query);
//
//			String partitionKey = new SimpleDateFormat("yyyyMM").format(eventGeneratedTime);
//
//			
//			String ins_Query = "Insert into service_history values(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)";
//			String upd_Query="update asset_event set Active_Status=0 ,Event_Closed_Time='"+serviceDate+"', PartitionKey='"+partitionKey+"' ,UpdateSource='WISE' where Asset_Event_ID="+assetEventId;
//			iLogger.info("ServiceDetailsBO:setServiceCloserDetails:AssetEventID :"+assetEventId+":login :"+loginId+": - START");
//			preparedStmt = conn.prepareStatement(ins_Query);
//			preparedStmt.setString (1, jobCardNo);
//			preparedStmt.setString (2, serialNumber);
//			preparedStmt.setString (3, serviceDate);
//			preparedStmt.setInt (4, dealerId);
//			preparedStmt.setString (5, attendedBy);
//			preparedStmt.setString (6, nextServiceDate);
//			preparedStmt.setString (7, comments);
//			preparedStmt.setString (8, actionTaken);
//			preparedStmt.setString (9, serviceTypeId);
//			preparedStmt.setString (10, faultId);
//			preparedStmt.setString (11, serviceName);
//			preparedStmt.setString (12, scheduleName);
//			preparedStmt.setString (13, DBMS_partCode);
//			preparedStmt.setInt (14, serviceScheduleId);
//			preparedStmt.setString (15, CMH);
//			int rowAffected=preparedStmt.executeUpdate();
//			if (rowAffected>0){
//				iLogger.info("ServiceDetailsBO:setServiceCloserDetails:AssetEventID :"+assetEventId+":login :"+loginId+": - Record inserted in database :"+ins_Query);
//				PreparedStatement upd_Stmt = conn.prepareStatement(upd_Query);
//				upd_Stmt.executeUpdate();
//				iLogger.info("ServiceDetailsBO:setServiceCloserDetails:AssetEventID :"+assetEventId+":login :"+loginId+": - Record updated in database :"+upd_Query);
//			}
//			
//			
//			//inserting data in Service_Clouser_MoolDA_Failure table to close service from MoolDA reports
//			  iLogger.info("ServiceDetailsBO:setServiceCloserDetails:AssetEventID :"+assetEventId+":login :"+loginId+": Inserting Record in Service_Clouser_MoolDA_Failure table ");
//			  prodConn1 = connMySql.getConnection();
//			  stmnt1 = prodConn1.createStatement();
//			  String service_Clouser="Insert into Service_Clouser_MoolDA_Failure values(?,?,?,?,?,?,?,?)";
//			  iLogger.info("MDA FleetSummaryService :: Query for inserttion in Service_Clouser_MoolDA_Failure :"+service_Clouser);
//			  preparedStmt_1 = conn.prepareStatement(service_Clouser);
//			  preparedStmt_1.setString (1, assetEventId);
//			  preparedStmt_1.setString (2, countryCode);
//			  preparedStmt_1.setString (3, serialNumber);
//			  preparedStmt_1.setString (4, eventSeverity);
//			  preparedStmt_1.setInt (5, eventID);
//			  preparedStmt_1.setString(6, eventGeneratedTime.toString());
//			  preparedStmt_1.setString (7, serviceDate);
//			  preparedStmt_1.setString (8, loginId);
//			  preparedStmt_1.executeUpdate();
//			  iLogger.info("ServiceDetailsBO:setServiceCloserDetails:AssetEventID :"+assetEventId+":login :"+loginId+": Rrecord inserted  in table "+service_Clouser);
//			
//           iLogger.info("ServiceDetailsBO:setServiceCloserDetails:AssetEventID "+assetEventId+" login :"+loginId+"  - END");
//		  	 
//		
//		}
//		
//		catch(Exception e)
//		{
//			fLogger.fatal("ServiceDetailsBO:setServiceCloserDetails:AssetEventID :"+assetEventId+":login :"+loginId+":Exception"+e.getMessage());
//			status="FAILURE";
//			return status;
//		}
//		finally
//		{
//			if(rs!=null)
//				try {
//					rs.close();
//				} catch (SQLException e1) {
//					e1.printStackTrace();
//				}
//			if(rs1!=null)
//				try {
//					rs1.close();
//				} catch (SQLException e1) {
//					e1.printStackTrace();
//				}
//
//			if(stmt!=null)
//				try {
//					stmt.close();
//				} catch (SQLException e1) {
//					// TODO Auto-generated catch block
//					e1.printStackTrace();
//				}
//			if(stmt1!=null)
//				try {
//					stmt1.close();
//				} catch (SQLException e1) {
//					// TODO Auto-generated catch block
//					e1.printStackTrace();
//				}
//			if (conn != null) {
//				try {
//					conn.close();
//				} catch (SQLException e) {
//					e.printStackTrace();
//				}
//			}
//			if (prodConn1 != null) {
//				try {
//					prodConn1.close();
//				} catch (SQLException e) {
//					e.printStackTrace();
//				}
//			}
//			if(stmnt1!=null)
//				try {
//					stmnt1.close();
//				} catch (SQLException e1) {
//					// TODO Auto-generated catch block
//					e1.printStackTrace();
//				}
//			if(preparedStmt_1!=null)
//				try {
//					preparedStmt_1.close();
//				} catch (SQLException e1) {
//					// TODO Auto-generated catch block
//					e1.printStackTrace();
//				}
//			if(preparedStmt!=null)
//				try {
//					preparedStmt.close();
//				} catch (SQLException e1) {
//					// TODO Auto-generated catch block
//					e1.printStackTrace();
//				}
//		
//		}	
//	
//		
//		return status;
//	}

	//****************************************** END of Set Service Closure Details for a machine ********************************************************
	
	
	
	
	
	
	/*@SuppressWarnings("rawtypes")
	public String setMasterServiceScheduleDetails(int assetTypeId,
			int engineTypeId, int assetGroupId, String serviceName,
			String scheduleName, int durationSchedule,
			long engineHoursSchedule, String dbmsPartCode) throws CustomFault {
		Logger businessError = Logger.getLogger("businessErrorLogger");
		Session session1 = HibernateUtil.getSessionFactory()
				.getCurrentSession();
		session1.beginTransaction();

		AssetGroupEntity AssetGroupId = null;
		EngineTypeEntity EngineTypeId = null;
		AssetTypeEntity AssetTypeId = null;
		try {
			//get Client Details
			Properties prop = new Properties();
			String clientName=null;

			prop.load(getClass().getClassLoader().getResourceAsStream("remote/wise/resource/properties/configuration.properties"));
			clientName= prop.getProperty("ClientName");

			IndustryBO industryBoObj = new IndustryBO();
			ClientEntity clientEntity = industryBoObj.getClientEntity(clientName);
			//END of get Client Details	  
          if(! (session1.isOpen() ))
                  {
                              session1 = HibernateUtil.getSessionFactory().getCurrentSession();
                              session1.getTransaction().begin();
                  }

			Query assetTypeQuery = session1
					.createQuery("from AssetTypeEntity where asset_type_id="
							+ assetTypeId+" and client_id="+clientEntity.getClient_id()+"" );
			Iterator assetTypeItr = assetTypeQuery.list().iterator();
			while (assetTypeItr.hasNext()) {
				AssetTypeId = (AssetTypeEntity) assetTypeItr.next();
			}

			Query assetGroupQuery = session1
					.createQuery("from AssetGroupEntity where asset_group_id="
							+ assetGroupId+" and client_id="+clientEntity.getClient_id());
			Iterator assetGroupItr = assetGroupQuery.list().iterator();
			while (assetGroupItr.hasNext()) {
				AssetGroupId = (AssetGroupEntity) assetGroupItr.next();
			}
			Query engineTypeQuery = session1
					.createQuery("from EngineTypeEntity where engineTypeId="
							+ engineTypeId);
			Iterator engineTypeItr = engineTypeQuery.list().iterator();
			while (engineTypeItr.hasNext()) {
				EngineTypeId = (EngineTypeEntity) engineTypeItr.next();
			}

			String queryString = "from ServiceScheduleEntity where assetTypeId= "
					+ assetTypeId
					+ " and engineTypeId="
					+ engineTypeId
					+ "  and assetGroupId=" + assetGroupId;
			Iterator itr = session1.createQuery(queryString).list().iterator();
			int flag = 0;
			while (itr.hasNext()) {
				flag = 1;

				ServiceScheduleEntity servicescheduleEntity = (ServiceScheduleEntity) itr
						.next();
				//System.out
				infoLogger.info("servicescheduleEntity.getScheduleName() is   "
								+ servicescheduleEntity.getScheduleName());
				servicescheduleEntity.setServiceName(serviceName);
				servicescheduleEntity.setScheduleName(scheduleName);
				servicescheduleEntity.setDurationSchedule(durationSchedule);
				servicescheduleEntity
						.setEngineHoursSchedule(engineHoursSchedule);
				servicescheduleEntity.setDbmsPartCode(dbmsPartCode);
				servicescheduleEntity.setAssetGroupId(AssetGroupId);
				servicescheduleEntity.setEngineTypeId(EngineTypeId);
				servicescheduleEntity.setAssetTypeId(AssetTypeId);
				session1.update(servicescheduleEntity);
			}
			if (flag == 0) {
				if (!(session1.isOpen()))

				{

					session1 = HibernateUtil.getSessionFactory().openSession();

					session1.getTransaction().begin();

				}
				ServiceScheduleEntity servicescheduleEntity = new ServiceScheduleEntity();
				servicescheduleEntity.setServiceName(serviceName);
				servicescheduleEntity.setScheduleName(scheduleName);
				servicescheduleEntity.setDurationSchedule(durationSchedule);
				servicescheduleEntity
						.setEngineHoursSchedule(engineHoursSchedule);
				servicescheduleEntity.setAssetGroupId(AssetGroupId);
				servicescheduleEntity.setAssetTypeId(AssetTypeId);
				servicescheduleEntity.setEngineTypeId(EngineTypeId);
				servicescheduleEntity.setDbmsPartCode(dbmsPartCode);

				servicescheduleEntity.save();
			}
		} catch (Exception e) {
			businessError.error("Hello this is an Business Error message"
					+ e.getMessage());
		} finally {

			if (session1.isOpen()) {
				session1.flush();
				session1.close();
			}
		}

		return "SUCCESS";
	} */

	// set method for asset service schedule
	/**
	 * This method sets the
	 * serviceScheduleId,dealerId,scheduled_date,serialNumber
	 * 
	 * @param reqObj
	 *            Gets the installationDate,dealerCode,serialNumber
	 * @return Returns respObj for the specified serialNumber
	 * @throws CustomFault
	 */

	@SuppressWarnings({ "unused", "rawtypes" })
	/*public String setAssetServiceScheduleBO(String installationDate,
			String dealerCode, String serialNumber) throws CustomFault

	{

		String serialNum = null;
		String dealerId1 = null;
		int productId1 = 0;
		int duration = 0;
		AccountEntity account = null;
		try {
            //get Client Details
			Properties prop = new Properties();
			String clientName=null;

			prop.load(getClass().getClassLoader().getResourceAsStream("remote/wise/resource/properties/configuration.properties"));
			clientName= prop.getProperty("ClientName");

			IndustryBO industryBoObj = new IndustryBO();
			ClientEntity clientEntity = industryBoObj.getClientEntity(clientName);
			//END of get Client Details
			String queryString = "from AssetEntity where serial_number= '"
					+ serialNumber + "' and active_status=true and client_id="+clientEntity.getClient_id()+"";

			Iterator itr = session.createQuery(queryString).list().iterator();
			int update = 0;
			while (itr.hasNext()) {
				update = 1;
				AssetEntity assetEntity = (AssetEntity) itr.next();
				if (assetEntity == null) {
					businessError.error("This Asset Entity doesn't exist");
				}

				productId1 = assetEntity.getProductId().getProductId();
				serialNum = assetEntity.getSerial_number().getSerialNumber();
			}

			String query = "from AccountEntity where accountCode= '"
					+ dealerCode + "' and status=true and client_id="+clientEntity.getClient_id()+"";
			Iterator itr2 = session.createQuery(query).list().iterator();
			while (itr2.hasNext()) {
				account = (AccountEntity) itr2.next();
				dealerId1 = account.getAccountCode();
			}

			HashMap<Integer, AssetServiceScheduleEntity> asset = new HashMap<Integer, AssetServiceScheduleEntity>();

			String query2 = "from AssetServiceScheduleEntity where serialNumber = '"
					+ serialNumber + "'";

			Iterator itr3 = session.createQuery(query2).list().iterator();

			Iterator itr4 = session.createQuery(query3).list().iterator();

			while (itr4.hasNext())

			{

				ServiceScheduleEntity schedule = (ServiceScheduleEntity) itr4
						.next();
				serviceScheduleId = schedule.getServiceScheduleId();

				duration = schedule.getDurationSchedule();

				java.util.Date today = new java.util.Date();

				final long oneDay = today.getTime();

				SimpleDateFormat datetimeFormat = new SimpleDateFormat(
						"yyyy-MM-dd hh:mm:ss");

				Date operatingStartDate = null;

				try {

					operatingStartDate = datetimeFormat.parse(installationDate);

				}

				catch (ParseException e) {

					businessError
							.error("Hello this is an Business Error message" + e.getMessage());

				}

				Calendar cal = Calendar.getInstance();

				cal.setTime(operatingStartDate);

				infoLogger.info("Date IS"
						+ datetimeFormat.format(cal.getTime()));

				int num = duration; // here is a number of days to add/subtract

				// add number of days

				cal.add(Calendar.DATE, num);
				infoLogger.info("Date + durationSchedule isss"
						+ datetimeFormat.format(cal.getTime()));
				String lastResult = datetimeFormat.format(cal.getTime());
				Timestamp ts = Timestamp.valueOf(lastResult);

				DomainServiceImpl domainService = new DomainServiceImpl();
				AssetEntity a = domainService.getAssetDetails(serialNumber);
				if (asset.containsKey(schedule.getServiceScheduleId())) {
					AssetServiceScheduleEntity assetService = asset
							.get(schedule.getServiceScheduleId());
					assetService.setDealerId(account);
					assetService.setScheduledDate(ts);
					session.update(assetService);
				} else {
					AssetServiceScheduleEntity assetService = new AssetServiceScheduleEntity();
					assetService.setDealerId(account);
					assetService.setScheduledDate(ts);
					assetService.setSerialNumber(a);
					assetService.setServiceScheduleId(schedule);
					assetService.save();

				}
			}

		} catch (Exception e)

		{
			businessError.error("Hello this is an Business Error message" + e.getMessage());
		}

		finally

		{

			if (session.getTransaction().isActive())

				session.getTransaction().commit();

			if (session.isOpen())

			{

				session.flush();

				session.close();

			}

		}

		return "SUCCESS";

	}*/
	/*public String setAssetServiceScheduleBO(String installationDate,
			String serialNumber) throws CustomFault

	{

		String serialNum = null;
		int productId1 = 0;
		int duration = 0;
		AccountEntity account = null;
		int accountFromId = 0;
		int partnerId = 0;
		int accountId = 0;
		int dealervalue = 0;
		boolean val;
		int dealval = 0;
		Logger businessError = Logger.getLogger("businessErrorLogger");

		Session session = HibernateUtil.getSessionFactory().openSession();

		session.beginTransaction();
		AssetDetailsBO assetBO = new AssetDetailsBO();
		HashMap<String, Integer> dealerCode = null;
		try {
			//get Client Details
			Properties prop = new Properties();
			String clientName=null;

			prop.load(getClass().getClassLoader().getResourceAsStream("remote/wise/resource/properties/configuration.properties"));
			clientName= prop.getProperty("ClientName");

			IndustryBO industryBoObj = new IndustryBO();
			ClientEntity clientEntity = industryBoObj.getClientEntity(clientName);
			//END of get Client Details		
          if(! (session.isOpen() ))
                  {
                              session = HibernateUtil.getSessionFactory().getCurrentSession();
                              session.getTransaction().begin();
                  }

			String queryString = "from AssetEntity where serial_number= '"
					+ serialNumber + "' and active_status=true and client_id="+clientEntity.getClient_id()+"";

			Iterator itr = session.createQuery(queryString).list().iterator();

			int update = 0;
			while (itr.hasNext()) {
				update = 1;
				AssetEntity assetEntity = (AssetEntity) itr.next();
				if (assetEntity == null) {
					businessError.error("This Asset Entity doesn't exist");
				}

				productId1 = assetEntity.getProductId().getProductId();

				serialNum = assetEntity.getSerial_number().getSerialNumber();
			}
	 */
	/*
	 * String query = "from AccountEntity where accountCode= '"+
	 * dealerCode+"'"; Iterator
	 * itr2=session.createQuery(query).list().iterator();
	 * while(itr2.hasNext()) { account = (AccountEntity)itr2.next();
	 * dealerId1=account.getAccountCode(); }
	 */

	/*		dealerCode = assetBO.getAssetOwners(serialNum);
			if (dealerCode.get("Dealer") != null)
				dealval = dealerCode.get("Dealer");

			if (dealval != 0) {
				Set mapSet = (Set) dealerCode.entrySet();
				Iterator mapIterator = mapSet.iterator();

				while (mapIterator.hasNext()) {
					Map.Entry mapEntry = (Map.Entry) mapIterator.next(); // getKey Method of HashMap access a key of map
					String keyValue = (String) mapEntry.getKey(); // getValue method returns corresponding key's value					
					if (keyValue.equalsIgnoreCase("Dealer")) {
						dealervalue = (Integer) mapEntry.getValue();						
					}
				}
			}
			HashMap<Integer, AssetServiceScheduleEntity> asset = new HashMap<Integer, AssetServiceScheduleEntity>();

			String query2 = "from AssetServiceScheduleEntity where serialNumber = '"
					+ serialNumber + "'";

			Iterator itr3 = session.createQuery(query2).list().iterator();

			while (itr3.hasNext())

			{

				AssetServiceScheduleEntity assetSchedule = (AssetServiceScheduleEntity) itr3
						.next();
				asset.put(assetSchedule.getServiceScheduleId()
						.getServiceScheduleId(), assetSchedule);
			}

			String querys = "from ProductEntity where productId= " + productId1+" and clientId="+clientEntity.getClient_id()+"" ;
			Iterator itrs = session.createQuery(querys).list().iterator();

			while (itrs.hasNext())

			{
				ProductEntity product = (ProductEntity) itrs.next();
				assetGroupId = product.getAssetGroupId().getAsset_group_id();
				assetTypeId = product.getAssetTypeId().getAsset_type_id();
				engineTypeId = product.getEngineTypeId().getEngineTypeId();

			}

			String query3 = "from ServiceScheduleEntity where assetGroupId= "
					+ assetGroupId + " and assetTypeId= " + assetTypeId
					+ " and engineTypeId= " + engineTypeId;

			Iterator itr4 = session.createQuery(query3).list().iterator();

			while (itr4.hasNext())

			{

				ServiceScheduleEntity schedule = (ServiceScheduleEntity) itr4
						.next();
				serviceScheduleId = schedule.getServiceScheduleId();

				duration = schedule.getDurationSchedule();

				java.util.Date today = new java.util.Date();

				final long oneDay = today.getTime();

				SimpleDateFormat datetimeFormat = new SimpleDateFormat(
						"yyyy-MM-dd hh:mm:ss");

				Date operatingStartDate = null;

				try {

					operatingStartDate = datetimeFormat.parse(installationDate);

				}

				catch (ParseException e) {
					e.printStackTrace();

					businessError
							.error("Hello this is an Business Error message");

				}

				Calendar cal = Calendar.getInstance();

				cal.setTime(operatingStartDate);

				infoLogger.info("Date IS"
						+ datetimeFormat.format(cal.getTime()));

				int num = duration; // here is a number of days to add/subtract

				// add number of days

				cal.add(Calendar.DATE, num);
				infoLogger.info("Date + durationSchedule isss"
						+ datetimeFormat.format(cal.getTime()));
				String lastResult = datetimeFormat.format(cal.getTime());
				Timestamp ts = Timestamp.valueOf(lastResult);

				DomainServiceImpl domainService = new DomainServiceImpl();
				AssetEntity a = domainService.getAssetDetails(serialNumber);
				String queryAccount = "from AccountEntity where account_id="
						+ dealervalue+" and status=true and client_id="+clientEntity.getClient_id();
				Iterator itra = session.createQuery(queryAccount).list()
						.iterator();
				AccountEntity accountDealer = null;
				while (itra.hasNext())

				{
					accountDealer = (AccountEntity) itra.next();
				}
				if (accountDealer != null) {
					if (asset.containsKey(schedule.getServiceScheduleId())) {


						AssetServiceScheduleEntity assetService = asset
								.get(schedule.getServiceScheduleId());
						assetService.setDealerId(accountDealer);
						assetService.setScheduledDate(ts);
						session.update(assetService);

					} else {

						AssetServiceScheduleEntity assetService = new AssetServiceScheduleEntity();
						assetService.setDealerId(accountDealer);
						assetService.setScheduledDate(ts);
						assetService.setSerialNumber(a);
						assetService.setServiceScheduleId(schedule);
						assetService.save();

					}
				}
			}

		} catch (Exception e)

		{
			e.printStackTrace();
			businessError.error("Hello this is an Business Error message"
					+ e.getMessage());
		}

		finally

		{

			if (session.getTransaction().isActive())

				session.getTransaction().commit();

			if (session.isOpen())

			{

				session.flush();

				session.close();

			}

		}

		return "SUCCESS";

	}


	 */


	//****************************************** Set Service Schedule Details for a machine **************************************
	/** This method sets the service schedule dates for a given machine
	 * @param serialNumber VIN
	 * @param installationDate Date of Installation of the machine at the customer end
	 * @param dealerCode Dealer Code of the Service Dealer
	 * @param customerCode Customer Code of the Customer who owns the machine
	 * @return Returns the status String
	 */
	public String setAssetServiceScheduleBO(String serialNumber,String installationDate, String dealerCode, String customerCode, String messageId)
	{   
		String status ="SUCCESS-Record Processed";

		//	Logger businessError = Logger.getLogger("businessErrorLogger");
		//	Logger fatalError = Logger.getLogger("fatalErrorLogger");

		Logger fLogger = FatalLoggerClass.logger;
		Logger iLogger = InfoLoggerClass.logger;

		Logger bLogger = BusinessErrorLoggerClass.logger;
		Session session = HibernateUtil.getSessionFactory().getCurrentSession();
		//DF20150603 - Rajani Nagaraju - WISE going down issue - Open a new session when the getCurrentSession returns a dirty session(txns which is not yet committed exists)
		if(session.getTransaction().isActive() && session.isDirty())
		{
			iLogger.info("Opening a new session");
			session = HibernateUtil.getSessionFactory().openSession();
		}

		session.beginTransaction();

		try 
		{                            
			AssetEntity asset = null;

			//Validate the VIN
			Query query = session.createQuery("from AssetEntity where serial_number ='"+serialNumber+"'");
			Iterator itr = query.list().iterator();
			while(itr.hasNext())
			{
				asset = (AssetEntity)itr.next();
			}

			/*if(asset==null)
        	{
				//2014-06-18 : Machine Number check for 7 digits - Deepthi
        		if(serialNumber.trim().length() >7)
				{
							serialNumber = serialNumber.substring(serialNumber.length()-7 , serialNumber.length());
				}

        		//DF20140715 - Rajani Nagaraju - Removing preceeding zeros in Machine Number
        		serialNumber=serialNumber.replaceFirst("^0+(?!$)", "");
				Query qryMacNo =session.createQuery("from AssetEntity a where a.machineNumber='"+serialNumber+"'");
				Iterator itrMacNo=qryMacNo.list().iterator();
				while(itrMacNo.hasNext())
				{
					asset= (AssetEntity) itrMacNo.next();				
				}


			}*/
			if(asset==null)
			{
				status = "FAILURE-Invalid VIN:"+serialNumber;
				throw new CustomFault("Invalid PIN: "+serialNumber);
			}
			//2014-06-18 : Machine Number check for 7 digits - Deepthi


			//Validate Installation Date
			SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
			Date vinInstallationDate=null;
			try
			{
				vinInstallationDate = dateFormat.parse(installationDate);
			}
			catch(Exception e)
			{
				status = "FAILURE-"+e.getMessage();
				bLogger.error("EA Processing: AssetInstallation: "+messageId+" : Date Parse Exception for Installation Date"+e);
				return status;
			}

			//Validate dealer Code
			AccountEntity dealerEntity = null;
			Query accountQuery = session.createQuery("from AccountEntity where status=true and accountCode='"+dealerCode+"'");
			Iterator accountItr = accountQuery.list().iterator();
			while(accountItr.hasNext())
			{
				dealerEntity = (AccountEntity)accountItr.next();
			}
			if(dealerEntity==null)
			{
				status = "FAILURE-Master Data not received for the Dealer Code";
				throw new CustomFault("Master Data not received for the Dealer Code");
			}

			if(asset.getProductId()==null || asset.getProductId().getAssetGroupId()==null || asset.getProductId().getAssetTypeId()==null
					|| asset.getProductId().getEngineTypeId()==null)
			{
				throw new CustomFault("Product details not available for the VIN");
			}

			//get the Service Schedule defined for the product to which the machine belongs to
			LinkedHashMap<ServiceScheduleEntity, Integer> servSchDurationMap = new LinkedHashMap<ServiceScheduleEntity, Integer>();
			//-- Key - Service Schedule Entity, Value - Duration Schedule defined (In Days)
			HashMap<Integer, ServiceScheduleEntity> servSchIDEntityMap = new HashMap<Integer, ServiceScheduleEntity>();
			//-- Key - Service Schedule Id, Value - Service Schedule Entity
			
			//DF20191220:Abhishek::Updated query for populating asset service schdule.
			Query q = session.createQuery(" from ServiceScheduleEntity where assetGroupId="+asset.getProductId().getAssetGroupId().getAsset_group_id()+" and " +
					" assetTypeId="+asset.getProductId().getAssetTypeId().getAsset_type_id()+" and engineTypeId="+asset.getProductId().getEngineTypeId().getEngineTypeId()+" " +
					" and ServiceType!='Extended Warranty' order by durationSchedule");
			Iterator itrtr = q.list().iterator();
			while(itrtr.hasNext())
			{
				ServiceScheduleEntity serviceSchedule = (ServiceScheduleEntity)itrtr.next();
				servSchDurationMap.put(serviceSchedule, serviceSchedule.getDurationSchedule());
				servSchIDEntityMap.put(serviceSchedule.getServiceScheduleId(), serviceSchedule);
			}

			if(servSchDurationMap.isEmpty())
			{
				status = "FAILURE-Service Schedule not defined for the product";
				throw new CustomFault("Service Schedule not defined for the product");
			}

			if(session==null || ! (session.isOpen() ))
			{
				session = HibernateUtil.getSessionFactory().getCurrentSession();
				if(session.getTransaction().isActive() && session.isDirty())
				{
					iLogger.info("AssetInstallationLog: "+serialNumber+":Opening a new session");
					session = HibernateUtil.getSessionFactory().openSession();
				}
				session.beginTransaction();

			}

			//Get the AssetServiceSchedule if defined
			Query assetServSch = session.createQuery(" from AssetServiceScheduleEntity where serialNumber ='"+serialNumber+"'");
			Iterator assetServSchItr = assetServSch.list().iterator();
			while(assetServSchItr.hasNext())
			{

				iLogger.info("AssetInstallationLog: "+serialNumber+":AssetServiceScheduleEntity already exist so updating the record");

				AssetServiceScheduleEntity assetService = (AssetServiceScheduleEntity) assetServSchItr.next();
				int duration = assetService.getServiceScheduleId().getDurationSchedule();

				//update the scheduled Date and dealerID
				Calendar c = Calendar.getInstance();
				c.setTime(vinInstallationDate);
				c.add(Calendar.DATE, duration);
				Timestamp scheduledDate = new Timestamp(c.getTime().getTime());

				assetService.setScheduledDate(scheduledDate);
				assetService.setDealerId(dealerEntity);
				session.update(assetService);

				//Remove the record from servSchDurationMap - Since the data in AssetServiceSchedule is already updated
				servSchDurationMap.remove(servSchIDEntityMap.get(assetService.getServiceScheduleId().getServiceScheduleId()));
			}


			//Insert the records into AssetService Schedule
			for(int j=0; j<servSchDurationMap.size(); j++)
			{

				iLogger.info("AssetInstallationLog: "+serialNumber+":AssetServiceScheduleEntity not exist so inserting the record");

				ServiceScheduleEntity servSch = (ServiceScheduleEntity)servSchDurationMap.keySet().toArray()[j];
				int duration = (Integer)servSchDurationMap.values().toArray()[j];

				//get the scheduledDate
				Calendar c = Calendar.getInstance();
				c.setTime(vinInstallationDate);
				c.add(Calendar.DATE, duration);
				Timestamp scheduledDate = new Timestamp(c.getTime().getTime());

				AssetServiceScheduleEntity assetServSchEnt = new AssetServiceScheduleEntity();
				assetServSchEnt.setDealerId(dealerEntity);
				assetServSchEnt.setScheduledDate(scheduledDate);
				assetServSchEnt.setSerialNumber(asset);
				assetServSchEnt.setServiceScheduleId(servSch);

				//DF20160502 - Rajani Nagaraju - Adding EngineHours Schedule - This is required for Service Alert Generation from MOOL
				assetServSchEnt.setEngineHoursSchedule(servSch.getEngineHoursSchedule());
				
				//DF20191220:Abhishek::setting alert_genration_flag=1 as per the requirement of Extwnded warranty services.
				assetServSchEnt.setAlertGenFlag(1);
				
				session.save(assetServSchEnt);
			}

			//Update Installation Date into Asset table
			//DefectID:1285 - Rajani Nagaraju - To set the Installation Date
			String assetGroupName= null;
			SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
			Calendar c = Calendar.getInstance();
			c.setTime(vinInstallationDate);
			asset.setInstall_date(new Timestamp(c.getTime().getTime()));
			
			//DF20180802:KO369761- Calculating renewal data(adding 3 years to Install Date) for non indian machines.
			if(asset.getCountrycode()!= null && !asset.getCountrycode().equals("+91")){
				c.add(Calendar.YEAR, 3);
			}else{
				//DF20180202:KO369761-Calculating Asset Renewal Date based on install date and setting that in asset table.
				if(asset.getProductId().getAssetGroupId()!=null)
					assetGroupName=asset.getProductId().getAssetGroupId().getAsset_group_name();
				Date compDate = sdf.parse("2016-11-15");
				if (assetGroupName!=null && assetGroupName.equalsIgnoreCase("Backhoe")) {
					if (asset.getInstall_date().compareTo(compDate) < 0) {
						c.add(Calendar.MONTH, 24);
					}
					else {
						c.add(Calendar.MONTH, 48);
					}
				}
				else {
					c.add(Calendar.MONTH, 24);
				}
			}
			
			asset.setRenewal_date(new Timestamp(c.getTime().getTime()));
			
			session.update(asset);
			
			session.update(asset);


			//Df20160909 @Roopa comminting the transactions at this time bcoz, there are other methods getting called after this, so session may become invalid
			//DF2016-09-23 : Commenting the way the commit was handled. Commiting the entire block in the finally and changed the order in which the commit was done. First to the Asset profile table then to the Edge proxy table
			/*
        	try
			{

				if(session!=null && session.isOpen())            	
				{
					if(session.getTransaction().isActive())
					{
						session.flush();
						session.getTransaction().commit();
					}              	 
				}
			}

			catch(Exception e)
			{
				fLogger.fatal("Exception in commiting the record:"+e.getMessage());
			}*/

			//DF20140508 - Rajani Nagaraju - Changing the sequence of updating device_status - First into asset_profile, then into edge proxy smart systems table

			//Keerthi : 06/02/14 : update EP table device_info_status to NORMAL. Also asset_profile
			iLogger.info("EA Processing: AssetInstallation: "+messageId+": Updating mode in EP table from installation date service");

			iLogger.info("AssetInstallationLog: "+serialNumber+":Before calling AssetDetailsBO updateVinStatusToEP ");



			iLogger.info("AssetInstallationLog: "+serialNumber+":Before calling updateAssetProfileWithMode ");

			//DF20170517 - SU334449- Commenting the call to the method, and directly executing the query from this method itself, to solve Session Closed Exception
			//String message = String message = updateAssetProfileWithMode(serialNumber,session,"NORMAL");

			query = session.createQuery("UPDATE AssetExtendedDetailsEntity SET Device_Status='NORMAL'" +
					" WHERE serial_number ='"+serialNumber+"'");
			int rows = query.executeUpdate();

			iLogger.info("AssetInstallationLog: "+serialNumber+":After calling updateAssetProfileWithMode : rows updated :"+rows);

			//iLogger.info("EA Processing: AssetInstallation: "+messageId+": Status after updating mode in asset_profile table from installation date service "+message);

			String message = new AssetDetailsBO().updateVinStatusToEP(serialNumber, 0,null,null);

			iLogger.info("AssetInstallationLog: "+serialNumber+":After calling AssetDetailsBO updateVinStatusToEP:"+message);


			iLogger.info("EA Processing: AssetInstallation: "+messageId+": Status after updating mode in EP table from installation date service "+message);
		}

		catch(CustomFault e)
		{
			status = "FAILURE-"+e.getFaultInfo();
			bLogger.error("EA Processing: AssetInstallation: "+messageId+" : "+e.getFaultInfo());

		}

		catch(Exception e)
		{
			status = "FAILURE-"+e.getMessage();
			fLogger.fatal("EA Processing: AssetInstallation: "+messageId+ " Fatal Exception :"+e);
		}


		finally
		{
			//DF20140715 - Rajani Nagaraju - To Avoid Session Close Exception
			//DF20170517 - SU334449- Commenting the way commit and flush is handled, to avoid Session Close Exception
			try
			{
				/*if(session!=null && session.isOpen())
	            {
	          	  if(session.getTransaction().isActive())
	                {
	                      session.getTransaction().commit();
	                      session.flush();
	                }
	            }*/
				if(session.isOpen())
				{
					if(session.getTransaction().isActive())
					{
						session.getTransaction().commit();
					}
				}
			}
			catch(Exception e)
			{
				status = "FAILURE-"+e.getMessage();
				//DF20150603 - Rajani Nagaraju - WISE going down issue - Adding try catch against commit
				fLogger.fatal("Exception in commiting the record:"+e);
			}
			//DF20170517 - SU334449- Adding session.flush() to avoid Session Close Exception
			if(session.isOpen())
			{
				session.flush();
				session.close();
			}
		}
		return status;
	}

	public String updateAssetProfileWithMode(String serialNumber,Session session,String mode){
		Logger iLogger = InfoLoggerClass.logger;

		boolean sessionCreated = false;
		String message = null;
		try{
			if(session==null){
				session = HibernateUtil.getSessionFactory().getCurrentSession();
				session.beginTransaction();
				sessionCreated = true;
			}
			int rows=0;
			Query query = session.createQuery("from AssetExtendedDetailsEntity where serial_number='"+serialNumber+"'");
			Iterator itr3 = query.list().iterator();
			boolean pinExists = false;
			while(itr3.hasNext()){
				pinExists = true;
				break;
			}

			if(pinExists){
				query = session.createQuery("UPDATE AssetExtendedDetailsEntity SET Device_Status='"+mode+"'" +
						" WHERE serial_number ='"+serialNumber+"'");
				rows = query.executeUpdate();
				if(rows>0){
					message = "SUCCESS";
				}
			} 
			else{
				iLogger.info("PIN "+serialNumber + " does not exist in asset_profile table.");
			}
		}
		catch(Exception e){
			message = "FAILURE";
		}
		finally
		{
			if(sessionCreated){
				if(session.getTransaction().isActive()){
					session.getTransaction().commit();
				}	              
				if(session.isOpen()){
					session.flush();
					session.close();
				}
			}


		}
		return message;
	}
	//******************************************** END of Set Service Schedule Details for a machine ***************************************** 

	//get method for asset service schedule 

	/** This method gets serviceScheduleId,dealerId,scheduled_date,serialNumber for the specified serialNumber

	 * @param reqObj Get the details of  serialNumber by passing the same to this request Object

	 * @return Returns respObj for the specified serialNumber

	 * @throws CustomFault

	 */

	public List<AssetServiceScheduleImpl> getAssetServiceScheduleBO(String serialNumber) throws CustomFault{

		// Logger businessError = Logger.getLogger("businessErrorLogger");

		Logger bLogger = BusinessErrorLoggerClass.logger;
		Logger iLogger = InfoLoggerClass.logger;

		List<ServiceDetailsBO> serviceBOList=new LinkedList<ServiceDetailsBO>();

		List<AssetServiceScheduleImpl> assetServiceImpl=new LinkedList<AssetServiceScheduleImpl>();

		List<AssetServiceScheduleImpl> assetServiceImpll=new LinkedList<AssetServiceScheduleImpl>();

		AssetServiceScheduleImpl assetServiceImpl1=new AssetServiceScheduleImpl();

		AssetServiceScheduleImpl assetimplObj=null;
		List<Integer> listOfIds = new LinkedList<Integer>();
		List<Integer> tempListOfIds = new LinkedList<Integer>();
		Long hours=0L;
		String parameterValue=null;   
		Long paramValue=0L;
		String serviceNamee=null;
		Long engineHourRecursive=0L;
		String scheduleNamee=null;
		int serviceScheduleIdDate=0;
		Long engineHours1=0L;
		String serviceEventTypeId=null;
		int scheduleIds=0, scheduleId1=0;
		List<Integer> listOfIds2 = new ArrayList<Integer>();
		List<Long> engineHoursList = new LinkedList<Long>();
		String dealerNamee=null;

		int dealeridss=0;

		Session session = HibernateUtil.getSessionFactory().openSession();

		session.beginTransaction();

		try {
			Properties prop = new Properties();
			try {
				prop.load(getClass().getClassLoader().getResourceAsStream("remote/wise/resource/properties/configuration.properties"));
			} catch (IOException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
			serviceEventTypeId= prop.getProperty("ServiceEventTypeId");
			int serviceScheduleIdtemp=0;        

			String finalQuery=null;                   

			finalQuery="select c.assetServiceScheduleId,c.serialNumber,c.serviceScheduleId,c.scheduledDate," +

              "c.dealerId from AssetServiceScheduleEntity c "+

  "where c.serviceScheduleId in (select b.serviceScheduleId+1 from ServiceHistoryEntity a,ServiceScheduleEntity b " +

  " where a.serialNumber = '" + serialNumber + " ' and a.serviceDate in (select max(serviceDate) from ServiceHistoryEntity l where serialNumber='"+serialNumber+"' )" +

  " and a.dbmsPartCode =b.dbmsPartCode) and c.serialNumber='" + serialNumber + " ' order by c.scheduledDate";

			int scheduleId=0;

			Object result[]=null;               
			boolean flag=false;
			Query query1 = session.createQuery(finalQuery);
			List resultList2 = query1.list();
			int resultSize = resultList2.size();
			if(resultSize==0){
				flag = true;
			}
			if(!flag){
				Iterator itr = resultList2.iterator();

				while(itr.hasNext()){                                             

					result = (Object[]) itr.next();

					int asset=(Integer)result[0];

					ServiceScheduleEntity serviceId= (ServiceScheduleEntity) result[2];

					scheduleId=serviceId.getServiceScheduleId();                      

					Timestamp date = (Timestamp) result[3];      

				}     
			}           
			String querySch = "from AssetServiceScheduleEntity where serialNumber = '"+ serialNumber+"'order by serviceScheduleId";

			query1 = session.createQuery(querySch);

			List resultList = query1.list();

			Iterator itrSch = resultList.iterator();                

			int id=0;

			int dealerids=0;

			Timestamp scheduledates=null;

			List<Integer>reqScheduleIdList = new ArrayList<Integer>();

			List<Integer>reqDealerIdList = new ArrayList<Integer>();

			HashMap<Integer, String> map = new HashMap<Integer, String>();
			HashMap<Integer, Long> Enginemap = new HashMap<Integer, Long>();
			HashMap<Integer, Long> tempEnginemap = new HashMap<Integer, Long>();
			int firstSchedueleId=0;

			while(itrSch.hasNext()){

				assetimplObj = new AssetServiceScheduleImpl();

				AssetServiceScheduleEntity assetSchedule=(AssetServiceScheduleEntity)itrSch.next();                       

				map.put(assetSchedule.getServiceScheduleId().getServiceScheduleId(), assetSchedule.getScheduledDate().toString());                     
				Enginemap.put(assetSchedule.getServiceScheduleId().getServiceScheduleId(), assetSchedule.getServiceScheduleId().getEngineHoursSchedule());
				id=assetSchedule.getServiceScheduleId().getServiceScheduleId();
				if(firstSchedueleId==0){
					firstSchedueleId = id;
				}
				reqScheduleIdList.add(id);

				//    infoLogger.info("reqScheduleIdList  "+reqScheduleIdList.size());

				dealerids=assetSchedule.getDealerId().getAccount_id();

				reqDealerIdList.add(dealerids);

				scheduledates=assetSchedule.getScheduledDate();                      

				ListToStringConversion conversionObj = new ListToStringConversion();

				String reqScheduleIdStringList = conversionObj.getIntegerListString(

						reqScheduleIdList).toString();                  

				String queryall="from ServiceScheduleEntity where serviceScheduleId in ("

                          + reqScheduleIdStringList + " )";

				Iterator itrall=session.createQuery(queryall).list().iterator();                            

				while(itrall.hasNext()){

					ServiceScheduleEntity serviceScheduleEntity1=(ServiceScheduleEntity)itrall.next();

					engineHours1=serviceScheduleEntity1.getEngineHoursSchedule();

					scheduleNamee=serviceScheduleEntity1.getScheduleName();

					serviceNamee=serviceScheduleEntity1.getServiceName();

					scheduleIds=serviceScheduleEntity1.getServiceScheduleId();                                    

				}

				ListToStringConversion conversionObj1 = new ListToStringConversion();

				String reqDealerIdStringList = conversionObj1.getIntegerListString(

						reqDealerIdList).toString();

				String queryAccount1="from AccountEntity where status=true and account_id in ("

                          + reqDealerIdStringList + " )";

				Iterator itrAccount1=session.createQuery(queryAccount1).list().iterator();                                 

				while(itrAccount1.hasNext()){                                       

					AccountEntity accountEntity=(AccountEntity)itrAccount1.next();

					dealerNamee=accountEntity.getAccount_name();

					dealeridss=accountEntity.getAccount_id();

				}                    

				assetimplObj.setServiceScheduleId(scheduleIds);

				assetimplObj.setDealerId(dealeridss);

				assetimplObj.setScheduledDate(scheduledates.toString());      

				assetimplObj.setEngineHoursSchedule(engineHours1);

				assetimplObj.setScheduleName(scheduleNamee);

				assetimplObj.setServiceName(serviceNamee);

				assetimplObj.setDealerName(dealerNamee);                                

				assetServiceImpll.add(assetimplObj);



			}      
			String scheduledDateFunc =null;
			if(flag){//service history does not contain data for given serial no.
				Iterator iterateImpl = assetServiceImpll.iterator();
				HashMap<Integer,String> scheduleMap2= new HashMap<Integer, String>();
				AssetServiceScheduleImpl implObj =null;
				while(iterateImpl.hasNext()){
					implObj = (AssetServiceScheduleImpl)iterateImpl.next();
					scheduleMap2.put(implObj.getServiceScheduleId(), implObj.getScheduledDate());
					listOfIds2.add(implObj.getServiceScheduleId());

				}
				scheduledDateFunc = getHoursToNextService(firstSchedueleId, scheduleMap2, listOfIds2);
			}
			else{
				String timeDate=map.get(scheduleId);

				for (Entry<Integer, String> entry : map.entrySet()) {
					if (entry.getValue().equals(timeDate)) {                      
						int reqKey=entry.getKey();                            

					}
				}
				int index=reqScheduleIdList.indexOf(scheduleId);

				if(index>0){
					for(int a=index;a<reqScheduleIdList.size();a++){
						listOfIds.add(reqScheduleIdList.get(a));             
					}
				}       
				scheduledDateFunc=getHoursToNextService(scheduleId,map,listOfIds);                

			}               
			Calendar currentDate = Calendar.getInstance();

			SimpleDateFormat formatter1 = new SimpleDateFormat("yyyy-MM-dd");            

			String dateNow = formatter1.format(currentDate.getTime());              

			Date date_new = null,date_old =null,date1=null ; 

			int milis1=0,milis2=0,  difference=0,diff=0;

			String hoursToNextService=null;

			try{

				//get Client Details
				String clientName=null;
				prop.load(getClass().getClassLoader().getResourceAsStream("remote/wise/resource/properties/configuration.properties"));
				clientName= prop.getProperty("ClientName");
				IndustryBO industryBoObj = new IndustryBO();
				ClientEntity clientEntity = industryBoObj.getClientEntity(clientName);
				//END of get Client Details	   
				if(! (session.isOpen() ))
				{
					session = HibernateUtil.getSessionFactory().getCurrentSession();
					session.getTransaction().begin();
				}

				if(scheduledDateFunc!=null){

					date_new = formatter1.parse(dateNow);                     

					SimpleDateFormat formatter2 = new SimpleDateFormat("yyyy-MM-dd");

					date_old = formatter2.parse(scheduledDateFunc);        

					milis1 = (int) (date_old.getTime()/(24*60*60*1000));

					milis2 = (int) (date_new.getTime()/(24*60*60*1000));

					difference = milis2 - milis1;                 

					diff=difference*24;             

					hoursToNextService= String.valueOf(diff);              

					//modified date

					Calendar cal = Calendar.getInstance(); 
					cal.setTime(date_new);
					cal.add(Calendar.DATE, -difference); 
					date_new = cal.getTime();
					DateFormat df = new SimpleDateFormat("yyyy-MM-dd");
					String mDate=df.format(date_new) ;                           

					date1 = (Date)df.parse(mDate) ;
					String formattedDate = df.format(date1);                        

					String queryDate = "from AssetServiceScheduleEntity  where scheduledDate like '"+formattedDate+"%' and serialNumber='"+ serialNumber+"'";

					Iterator itrDate=session.createQuery(queryDate).list().iterator();

					while(itrDate.hasNext()){

						AssetServiceScheduleEntity assetService =(AssetServiceScheduleEntity)itrDate.next();
						serviceScheduleIdDate=assetService.getServiceScheduleId().getServiceScheduleId();

					}                            

					String DateQuery="from ServiceScheduleEntity where serviceScheduleId="+serviceScheduleIdDate;
					Iterator itrDate1=session.createQuery(DateQuery).list().iterator();

					String serviceNameDate=null;
					String scheduleNameDate=null;

					while(itrDate1.hasNext()){

						ServiceScheduleEntity ServiceDate =(ServiceScheduleEntity)itrDate1.next();
						serviceNameDate=ServiceDate.getServiceName();
						scheduleNameDate=ServiceDate.getScheduleName();
					}                                             
				}
				/*String hql="select c.parameterValue from AssetMonitoringDetailEntity c where c.transactionNumber=( select max(b.transactionNumber) from AssetMonitoringHeaderEntity b where b.serialNumber='"+serialNumber+"')and c.parameterId=(select max(a.parameterId) from MonitoringParameters a where a.parameterName like 'Hour')";

                    Query query = session.createQuery(hql);
                    Iterator itr2 = query.list().iterator();                                                     

                    while(itr2.hasNext()){                                                 

                           parameterValue=itr2.next().toString();                                                   

                    }
                    double param = Double.valueOf(parameterValue.trim()).doubleValue();*/
				//S Suresh new DAL Layer implementation 
				String txnKey = "ServiceDetailsBO:getAssetServiceScheduleBO";

				/*	List<AmsDAO> snapshotObj=new ArrayList<AmsDAO> ();

    				DynamicAMS_DAL amsDaoObj=new DynamicAMS_DAL();

    				snapshotObj=amsDaoObj.getAMSData(txnKey, serialNumber);

    				//iLogger.debug(txnKey+"::"+"AMS:persistDetailsToDynamicMySql::AMS DAL::getAMSData Size:"+snapshotObj.size());
    			//	String cummOpHours = null;
    				if(snapshotObj.size()>0){

    					//parameters format in AMS
    					//String currParam= LAT|LONG|Enginestatus|Machinehours|ExternalBatteryVoltage|HCT|LOP|InternalBatteryLow
    					//temp = false;
    				String parameters=snapshotObj.get(0).getParameters();
    				String [] currParamList=parameters.split("\\|", -1);
    				 //DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

    				 //CMH
    				if(currParamList.length>2)
    					parameterValue = currParamList[3];
    				}*/

				//DF20161228 @Roopa changing asset_monitoring_snapshot_new to asset_monitoring_snapshot which is having txndata as json column	

				List<AMSDoc_DAO> snapshotObj=new ArrayList<AMSDoc_DAO> ();

				DynamicAMS_Doc_DAL amsDaoObj=new DynamicAMS_Doc_DAL();

				snapshotObj=amsDaoObj.getAMSData(txnKey, serialNumber);
				HashMap<String,String> txnDataMap=new HashMap<String, String>();

				txnDataMap=snapshotObj.get(0).getTxnData();
				parameterValue = txnDataMap.get("CMH");



				double param = 0;
				//END of DAL Layer
				if(parameterValue!=null)
					param = Double.valueOf(parameterValue.trim()).doubleValue();
				//added by smitha on june 27th Defect 690
				List<Integer> frequencyList = new LinkedList<Integer>();
				List<Integer> tempOrderedFreqList = new LinkedList<Integer>();                                               
				Object intResult=null;
				String hql1="select frequency from EventEntity where eventTypeId ="+serviceEventTypeId;
				Iterator itr3=session.createQuery(hql1).list().iterator();
				while(itr3.hasNext()){
					intResult = (Object) itr3.next();
					frequencyList.add((Integer) intResult);
				}
				Collections.sort(frequencyList);                    
				for(int o : frequencyList) {   
					if(o!=0){
						tempOrderedFreqList.add(o);
					}

				} 
				Set mapSet = (Set) Enginemap.entrySet(); 
				Iterator mapIterator = mapSet.iterator(); 
				while (mapIterator.hasNext()) {   
					Map.Entry mapEntry = (Map.Entry) mapIterator.next();  
					int keyValue = (Integer) mapEntry.getKey();                       
					Long value = (Long) mapEntry.getValue();                        
					engineHoursList.add(value);                                            	 
				}
				Long finalEngineHour=0L;
				int engineHourDifference=0; int freg=0;Long eHour=0L;
				for(int i=0;i<tempOrderedFreqList.size();i++){
					freg=tempOrderedFreqList.get(i);
					for(int j=0;j<engineHoursList.size();j++){

						eHour=engineHoursList.get(j);
						engineHourDifference=(int) (engineHoursList.get(j)-freg);
						if(Long.parseLong(parameterValue)>=engineHourDifference && Long.parseLong(parameterValue)<=eHour){
							finalEngineHour=eHour;
						}


					}

				}                   	 
				//added by smitha on Aug 6th 2013...Defect id 1115
				if(finalEngineHour==0L){
					Long newEngineHourdiff=0L;	
					List<Long>hourdiff = new LinkedList<Long>();
					Long diffengine=0L;
					Long finalhour=0L;
					for(int i=0;i<engineHoursList.size();i++){
						if(engineHoursList.get(i)>Long.parseLong(parameterValue)){
							newEngineHourdiff=engineHoursList.get(i)-Long.parseLong(parameterValue);
							hourdiff.add(newEngineHourdiff);
						}
						else{
							newEngineHourdiff=Long.parseLong(parameterValue)-engineHoursList.get(i);
							hourdiff.add(newEngineHourdiff);
						}
					}
					Collections.sort(hourdiff);
					diffengine=hourdiff.get(0);

					finalhour=Long.parseLong(parameterValue)-diffengine;
					finalhour=Math.abs(finalhour);
					finalEngineHour=finalhour;

				}
				//ended...Defect id 1115
				int prodID=0;
				ProductEntity pe =null;
				String querys="select a.productId from AssetEntity a where a.serial_number='"+ serialNumber+"'and a.active_status=true and a.client_id="+clientEntity.getClient_id();
				Iterator itrs =session.createQuery(querys).list().iterator(); 
				while(itrs.hasNext()){ 
					pe = (ProductEntity)itrs.next();
					if(pe!=null){
						prodID=pe.getProductId();         
					}

					iLogger.info("prodID "+prodID);
				}
				int assetGroupId=0,assetTypeId=0,engineTypeId=0;
				String queryp=" from ProductEntity where productId="+ prodID+" and clientId="+clientEntity.getClient_id();
				Iterator itrp =session.createQuery(queryp).list().iterator(); 
				while(itrp.hasNext()){
					ProductEntity prod = (ProductEntity)itrp.next();
					assetGroupId=prod.getAssetGroupId().getAsset_group_id();
					assetTypeId=prod.getAssetTypeId().getAsset_type_id();
					engineTypeId=prod.getEngineTypeId().getEngineTypeId();
				}

				int ServiceScheduleIdFreq=0;
				if(finalEngineHour!=0L){
					String queryFreq1 = "from ServiceScheduleEntity where engineHoursSchedule="+finalEngineHour+"and assetGroupId="+assetGroupId+"and assetTypeId="+assetTypeId+"and engineTypeId="+engineTypeId ;                           
					Iterator itrFreq1=session.createQuery(queryFreq1).list().iterator();
					while(itrFreq1.hasNext()){
						ServiceScheduleEntity service=(ServiceScheduleEntity)itrFreq1.next();
						ServiceScheduleIdFreq=service.getServiceScheduleId();
					}
				}
				//ended Defect ID 690
				String last=null;                                             

				if(serviceScheduleIdDate<ServiceScheduleIdFreq){
					last="from AssetServiceScheduleEntity where serviceScheduleId="+ServiceScheduleIdFreq+" and serialNumber='"+ serialNumber+"'";                    

				}
				else{
					last="from AssetServiceScheduleEntity where serviceScheduleId="+serviceScheduleIdDate+" and serialNumber='"+ serialNumber+"'";

				}
				Iterator itrlast=session.createQuery(last).list().iterator();      

				while(itrlast.hasNext())
				{                                                     

					AssetServiceScheduleEntity assetServicescheduleEntity=(AssetServiceScheduleEntity)itrlast.next();

					scheduleId1=assetServicescheduleEntity.getServiceScheduleId().getServiceScheduleId();

					String scheduledDate=assetServicescheduleEntity.getScheduledDate().toString(); 

					int dealerId=assetServicescheduleEntity.getDealerId().getAccount_id();

					String queryfinal="from ServiceScheduleEntity where serviceScheduleId= "+scheduleId1;
					Iterator itrfinal=session.createQuery(queryfinal).list().iterator(); 

					String serviceName1=null;
					String scheduleName1=null;
					Long engineHours=null;
					while(itrfinal.hasNext()){

						ServiceScheduleEntity serviceScheduleEntity=(ServiceScheduleEntity)itrfinal.next();

						engineHours=serviceScheduleEntity.getEngineHoursSchedule();                                                                     

						scheduleName1=serviceScheduleEntity.getScheduleName();
						serviceName1=serviceScheduleEntity.getServiceName();
						//added by smitha on june 27th 2013 Defect ID 690
						paramValue = Long.parseLong(parameterValue);
						hours=engineHours-paramValue;                                                              
						//end [june 27th 2013]

					}

					String queryAccount="from AccountEntity where account_id= "+dealerId+" and status=true and client_id="+clientEntity.getClient_id();
					Iterator itrAccount=session.createQuery(queryAccount).list().iterator();

					String dealerName=null;
					while(itrAccount.hasNext()){                                                                   

						AccountEntity accountEntity=(AccountEntity)itrAccount.next();
						dealerName=accountEntity.getAccount_name();                                                                     

					}                                                        
				}                               


				Iterator iterResult = assetServiceImpll.iterator();
				AssetServiceScheduleImpl resultlist=null;

				while(iterResult.hasNext()){
					resultlist =(AssetServiceScheduleImpl) iterResult.next();
					if(resultlist.getServiceScheduleId()==scheduleId1){
						resultlist.setHoursToNextService(hours);
					}                                                              
				}            
			}
			catch(Exception e){
				e.printStackTrace();
			}
		}
		finally
		{
			if(session.getTransaction().isActive())
				session.getTransaction().commit();

			if(session.isOpen())

			{
				session.flush();
				session.close();
			}
		}  

		return assetServiceImpll;
	} 
	public String getHoursToNextService(int scheduleId, HashMap<Integer,String> scheduleMap,List<Integer> listOfIds){

		String scheduledDate =null;

		if(scheduleMap!=null){

			scheduledDate=scheduleMap.get(scheduleId);

			Calendar currentDate = Calendar.getInstance();

			SimpleDateFormat formatter1 = new SimpleDateFormat("yyyy-MM-dd");             

			String dateNow = formatter1.format(currentDate.getTime());              

			Date date_new = null;

			try {

				date_new = formatter1.parse(dateNow);                       

			} catch (ParseException e) {             
				e.printStackTrace();
			}
			//difference

			SimpleDateFormat formatter2 = new SimpleDateFormat("yyyy-MM-dd");

			Date date_old =null;

			try {

				if(scheduledDate!=null){
					date_old = formatter2.parse(scheduledDate);  
					int milis1 = (int) (date_old.getTime()/(24*60*60*1000));
					int milis2 = (int) (date_new.getTime()/(24*60*60*1000));
					int difference = milis2 - milis1; 
					if(difference<0){                                                
						return scheduledDate;
					}
					else if(listOfIds!=null){

						if(difference>=0 && difference<=7){                                         

							for(int s=0;s<listOfIds.size();s++){
								if(listOfIds.size()!=1){
									listOfIds.remove(s);                                  

									scheduleId=listOfIds.get(0);                    

									scheduledDate= getHoursToNextService(scheduleId, scheduleMap,listOfIds);
								}                                                       
							}
						}              

						else if(difference>7){                                     

							for(int s=0;s<listOfIds.size();s++){
								if(listOfIds.size()!=1){
									listOfIds.remove(s);

									scheduleId=listOfIds.get(0);                   

									scheduledDate= getHoursToNextService(scheduleId, scheduleMap,listOfIds);                           
								}
							}
						}

					}  

				}

			}
			catch (ParseException e) {                     

				e.printStackTrace();
			}  
		}
		return scheduledDate;
	}

	@SuppressWarnings("rawtypes")
	public List<ServiceDetailsBO> getServiceHistory(String serialNumber) {
		List<ServiceDetailsBO> serviceHistoryList = new LinkedList<ServiceDetailsBO>();

		Session session = HibernateUtil.getSessionFactory().openSession();
		session.beginTransaction();

		try
		{
			Query q = session
					.createQuery("from ServiceHistoryEntity where serialNumber ='"
							+ serialNumber + "' Order By serviceDate desc limit 5");
			Iterator itr = q.list().iterator();

			while (itr.hasNext()) {
				ServiceHistoryEntity historyEntity = (ServiceHistoryEntity) itr
						.next();

				ServiceDetailsBO serviceDetailBO = new ServiceDetailsBO();

				serviceDetailBO.setJobCardNumber(historyEntity
						.getServiceTicketNumber());
				serviceDetailBO.setServiceDate(historyEntity.getServiceDate());
				serviceDetailBO.setServiceName(historyEntity.getServiceName());
				serviceDetailBO.setScheduleName(historyEntity.getScheduleName());
				//DF20180423:IM20018382 - Fetching additional field jobCardDetails set as comments in service_history table.
				serviceDetailBO.setJobCardDetails(historyEntity.getComments());
				serviceHistoryList.add(serviceDetailBO);
			}
		}

		//DefectId:1200 - Rajani Nagaraju -20130917 - Session was not getting closed
		catch (Exception e) {
			e.printStackTrace();

		}
		finally {
			if (session.getTransaction().isActive())
				session.getTransaction().commit();

			if (session.isOpen())
			{
				session.flush();
				session.close();
				//HibernateUtil.closeSession();

			}
		}
		return serviceHistoryList;
	}
	//********************************************** Set Service Details for a machine *************************************************************
	/** This method sets the ServiceHistory details for the given serial number
	 * @param serialNumber VIN as String input
	 * @param dealerCode Service dealer Code
	 * @param jobCardNumber jobCard Number of the service done
	 * @param startDate Date of when the service started
	 * @param endDate Date of when the service completed
	 * @param status Service status
	 * @param dbmsPartCode DBMS partCode w.r.t the service being done
	 * @return
	 */



//	public String setServiceDetails(String serialNumber, String dealerCode, String jobCardNumber,String dbmsPartCode, String servicedDate, String messageId)
//	{
//		String status ="SUCCESS-Record Processed";
//
//		//Logger fatalError = Logger.getLogger("fatalErrorLogger");
//		//Logger businessError = Logger.getLogger("businessErrorLogger");
//		int clientId = 0;
//		String engineHours = null;
//		Logger fLogger = FatalLoggerClass.logger;
//
//		Logger bLogger = BusinessErrorLoggerClass.logger; 
//		int segmentID = 0;
//
//		DateFormat dateStr = new SimpleDateFormat("yyyy-MM-dd");
//		Session session = HibernateUtil.getSessionFactory().getCurrentSession();
//		Logger iLogger = InfoLoggerClass.logger;
//		//DF20150603 - Rajani Nagaraju - WISE going down issue - Open a new session when the getCurrentSession returns a dirty session(txns which is not yet committed exists)
//		if(session.getTransaction().isActive() && session.isDirty())
//		{
//			iLogger.info("Opening a new session");
//			session = HibernateUtil.getSessionFactory().openSession();
//		}
//		session.beginTransaction();
//
//		try
//		{
//			//Validate the serialNumber
//			/*DomainServiceImpl domainService = new DomainServiceImpl();
//			 AssetEntity assetEntity = domainService.getAssetEntity(serialNumber);*/
//
//			//DF20150608 - Rajani Nagaraju - Session Closed Exception on processing service history record
//			AssetEntity assetEntity=null;
//
//			Query serialNumQ = session.createQuery(" from AssetEntity where serial_number='"+serialNumber+"'");
//			Iterator serialNumItr = serialNumQ.list().iterator();
//			while(serialNumItr.hasNext())
//			{
//				assetEntity = (AssetEntity)serialNumItr.next();
//			}
//
//			if(assetEntity==null || assetEntity.getSerial_number()==null)
//			{
//				/*if(serialNumber.trim().length() >7)
//				{
//							serialNumber = serialNumber.substring(serialNumber.length()-7 , serialNumber.length());
//				}*/
//
//
//
//				//DF20140715 - Rajani Nagaraju - Remove Preceeding zeros in Machine Number
//				serialNumber=serialNumber.replaceFirst("^0+(?!$)", "");
//				Query qryMacNo =session.createQuery("from AssetEntity a where a.machineNumber='"+serialNumber+"'");
//				Iterator itrMacNo=qryMacNo.list().iterator();
//				while(itrMacNo.hasNext())
//				{
//					assetEntity = (AssetEntity) itrMacNo.next();		
//
//					//DF20140805 - Rajani Nagaraju - Updating Serial Number from Machine Number
//					serialNumber=assetEntity.getSerial_number().getSerialNumber();
//					segmentID = assetEntity.getSegmentId();
//				}
//
//			}
//
//			if(assetEntity==null || assetEntity.getSerial_number()==null)
//			{
//				AssetControlUnitEntity assetControl=null;
//				Query assetControlQ = session.createQuery(" from AssetControlUnitEntity where serialNumber like '%"+serialNumber+"%'");
//				Iterator assetControlItr = assetControlQ.list().iterator();
//				while(assetControlItr.hasNext())
//				{
//					assetControl= (AssetControlUnitEntity)assetControlItr.next();
//				}
//
//				if(assetControl==null)
//				{
//					status = "FAILURE-PIN Registration Data not received";
//					bLogger.error("EA Processing: AssetServiceDetails: "+messageId+" : PIN Registration Data not received");
//					return status;
//				}
//				else
//				{
//					status = "FAILURE-Roll off Data not received";
//					bLogger.error("EA Processing: AssetServiceDetails: "+messageId+" : Roll off Data not received");
//					return status;
//				}
//
//			}
//
//			//Validate DealerCode - Get the dealer Entity for the given dealerCode
//			Query dealerQuery = session.createQuery("from AccountEntity where status=true and accountCode='"+dealerCode+"'");
//			Iterator itr = dealerQuery.list().iterator();
//			AccountEntity dealerEntity = null;
//			while(itr.hasNext())
//			{
//				dealerEntity = (AccountEntity) itr.next();
//			}
//
//			if(dealerEntity==null)
//			{
//				throw new CustomFault("Dealer Master data is not received for the Dealer:"+dealerCode);
//			}
//
//
//			//Parse the serviced date
//			SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
//			Timestamp vinServicedDate =null;
//			try
//			{
//				vinServicedDate = new Timestamp(dateFormat.parse(servicedDate).getTime());
//			}
//			catch(Exception e)
//			{
//				status = "FAILURE-"+e.getMessage();
//				bLogger.error("EA Processing: AssetServiceDetails: "+messageId+" : Date Parse Exception for Serviced Date"+e);
//				return status;
//			}
//
//			//Check if there are any Active Service Alert for the VIN
//			int ServiceEventTypeId = 0;
//			Properties prop = new Properties();
//			prop.load(getClass().getClassLoader().getResourceAsStream("remote/wise/resource/properties/configuration.properties"));
//			ServiceEventTypeId= Integer.parseInt(prop.getProperty("ServiceEventTypeId"));
//			//int flag =0;
//
//			//DF20150923 - Rajani Nagaraju - JCB0321,JCB0339 Service Alert Completion should close all the active service alerts for previous scehdules (if any) as well
//			//Also there was a problem in wrong serviceNames getting updated in ServiceHistory record
//			//-----------------STEP 1: Get the List of service schedules for which the active alert has to be closed
//			Query serviceListQ = session.createQuery("select b from AssetServiceScheduleEntity a, ServiceScheduleEntity b" +
//					" where a.serviceScheduleId=b.serviceScheduleId and a.serialNumber='"+serialNumber+"'" +
//					" order by b.engineHoursSchedule desc ");
//			Iterator serviceListItr = serviceListQ.list().iterator();
//			List<String> scheduleIdList = new LinkedList<String>();
//			String serviceName = null;
//			String scheduleName =null;
//
//
//			//added by S Suresh to insert newly added column service schedule ID into the service history table 
//			int serviceScheduleID = 0;
//			int addRec=0;
//			while(serviceListItr.hasNext())
//			{
//				ServiceScheduleEntity serviceSch = (ServiceScheduleEntity)serviceListItr.next();
//				if(serviceSch.getDbmsPartCode().equalsIgnoreCase(dbmsPartCode))
//				{
//					addRec=1;
//					//	 scheduleIdList.add(String.valueOf(serviceSch.getServiceScheduleId()));
//
//					serviceName = serviceSch.getServiceName();
//					scheduleName = serviceSch.getScheduleName();
//					serviceScheduleID = serviceSch.getServiceScheduleId();
//				}
//
//				if(addRec==1)
//					scheduleIdList.add(String.valueOf(serviceSch.getServiceScheduleId()));
//
//			}
//
//			if(scheduleIdList.isEmpty())
//			{
//				/* fLogger.fatal("No service schedule defined for the VIN with the given DBMS part Code");
//				 status = "FAILURE-No service schedule defined for the VIN with the given DBMS part Code";
//				 return status;*/
//
//				throw new CustomFault("No service schedule defined for the VIN with the given DBMS part Code and the CallTypeId");
//			}
//
//
//			//-----------------STEP 2: Close any active service alert on the machine for the schedules <= current received schedule
//			ListToStringConversion conversionObj = new  ListToStringConversion();
//			String scheduleIdListAsString = conversionObj.getStringList(scheduleIdList).toString();
//			Query alertClosureQ = session.createQuery(" from AssetEventEntity where serialNumber='"+serialNumber+"' and eventTypeId="+ServiceEventTypeId +
//					" and activeStatus=1 and serviceScheduleId in ("+scheduleIdListAsString+")");
//			Iterator alertClosureItr = alertClosureQ.list().iterator();
//			while(alertClosureItr.hasNext())
//			{
//				AssetEventEntity assetEvent = (AssetEventEntity)alertClosureItr.next();
//				assetEvent.setActiveStatus(0);
//				assetEvent.setEventClosedTime(new Timestamp(new Date().getTime()));
//				
//				//DF20190110- Updating partition key and source.
//				assetEvent.setUpdateSource("WISE");
//				if(assetEvent.getEventGeneratedTime() != null){
//					Date date = new Date();
//					date.setTime(assetEvent.getEventGeneratedTime().getTime());
//					String partitionKey = new SimpleDateFormat("yyyyMM").format(date);
//					assetEvent.setPartitionKey(Integer.parseInt(partitionKey));
//				}
//
//				//DF20160906 @Roopa fix for deleting the records from asset_event table when the service history record is received
//				//session.save(assetEvent);
//				session.update(assetEvent);
//			}
//
//			if(session!=null && session.isOpen()){
//				if(session.getTransaction().isActive())
//				{
//					session.getTransaction().commit();
//				}
//
//				if(session!=null && session.isOpen())
//				{
//					session.flush();
//					session.close();
//
//				}
//			}
//
//
//			//20160711 - @suresh new column has been added to the service history table CMH
//			//-----------------STEP 4: get the CMH when the machine got services (service alert closure)
//
//
//
//			/*String cmhQueryString = "select amd.parameterValue " +
//					"from AssetMonitoringSnapshotEntity ams,AssetMonitoringDetailEntity amd " +
//					"where ams.serialNumber = '"+serialNumber+"' and " +
//							" amd.transactionNumber = ams.latestEventTxn and " +
//							"amd.parameterId = 4 ";*/
//
//			/*String cmhQueryString = "select amd.parameterValue " +
//                    "from AssetMonitoringHeaderEntity amh2,AssetEntity a,AssetMonitoringDetailEntity amd " +
//                    "where a.serial_number = '"+serialNumber+"' and " +
//                                "amh2.segmentId = a.segmentId and " +
//                                "amh2.serialNumber = a.serial_number and " +
//                                "amh2.transactionTime = (" +
//                                "select max(amh.transactionTime) as transactionTime " +
//                                "from asset_monitoring_header amh " +
//                                "where amh.segmentId = amh2.segmentId and " +
//                                "amh.Serial_Number = amh2.Serial_Number and amh.transactionTime like '"+servicedDate+"%' ) " +
//                                "and amd.transactionNumber = amh.transactionNumber and " +
//                                "amd.parameterId = 4 ";
//
//			String cmh = null;
//
//			Query cmhQuery = session.createQuery(cmhQueryString);
//			Iterator cmhIterator = cmhQuery.list().iterator();
//			while(cmhIterator.hasNext()){
//				cmh = (String) cmhIterator.next();
//			}*/
//
//			/*
//
//			Properties prop1 = new Properties();
//			Properties prop2 = new Properties();
//			int engineHoursId = 0;
//			try {
//				prop1.load(getClass().getClassLoader().getResourceAsStream("remote/wise/resource/properties/configuration.properties"));
//				IndustryBO industryBoObj = new IndustryBO();
//				clientId = industryBoObj.getClientEntity(prop1.getProperty("ClientName")).getClient_id();
//
//				prop2.load(getClass().getClassLoader().getResourceAsStream("remote/wise/resource/properties/configuration.properties"));
//
//				engineHours= prop2.getProperty("TotalEngineHours");
//				if(session == null || !session.isOpen()){
//					session = new HibernateUtil().getSessionFactory().openSession();
//					session.beginTransaction();
//				}
//				itr = session.createQuery("select max(a.parameterId), a.parameterName " +
//						" from MonitoringParameters a " +
//						" where parameterName in " +
//							"( '"
//							+ engineHours
//							+ "')"
//							+ " group by a.parameterName"
//							+ " order by a.parameterId").list().iterator();
//
//				Object[] resultObj = null;
//
//				while (itr.hasNext()) {
//					resultObj = (Object[]) itr.next();
//
//					if ( ((String)resultObj[1]).equalsIgnoreCase(engineHours) ) {
//						engineHoursId = (Integer) resultObj[0]; 
//					}
//
//				} // End of itr
//			//	engineON= prop2.getProperty("EngineON");
//			}catch(Exception e){
//					e.printStackTrace();
//				}
//			finally {
//				if(session!=null || session.isOpen())
//				session.close();
//			}
//			//using DAL Layer to get the amh from dynamic amh table 
//			 Calendar cal = Calendar.getInstance();
//			 cal.setTime(dateStr.parse(servicedDate));
//
//			 Timestamp txnTimestamp = new Timestamp(cal.getTimeInMillis());
//			List parametreIDList = new LinkedList();
//			parametreIDList.add(engineHoursId);
//			DynamicAMH_DAL dalObj = new DynamicAMH_DAL();
//			String cmh = dalObj.getLatestCMH(serialNumber, txnTimestamp,segmentID, parametreIDList);*/
//
//			//DF20160914 @Roopa Fetching CMH data from snapshot table(AMS)
//
//			String cmh=null;
//
//			String txnKey="setServiceDetailsViaExecutor";
//			
//			//DF20180508:KO369761 - Pointing to correct DAL class.
//			/*List<AmsDAO> snapshotObj=new ArrayList<AmsDAO> ();
//
//			DynamicAMS_DAL amsDaoObj=new DynamicAMS_DAL();
//
//			snapshotObj=amsDaoObj.getAMSData(txnKey, serialNumber);*/
//			
//			List<AMSDoc_DAO> snapshotObj=new ArrayList<AMSDoc_DAO> ();
//			snapshotObj=DynamicAMS_Doc_DAL.getAMSData(txnKey, serialNumber);
//			HashMap<String,String> txnDataMap=new HashMap<String, String>();
//
//			iLogger.debug(txnKey+"::"+"AMS DAL::getAMSData Size:"+snapshotObj.size());
//
//			if(snapshotObj.size()>0){
//
//				//parameters format in AMS
//				//String currParam= LAT|LONG|Enginestatus|Machinehours|ExternalBatteryVoltage|HCT|LOP|InternalBatteryLow
//				
//				//DF20180508:KO369761 - Pointing to correct DAL class.
//				/*String parameters=snapshotObj.get(0).getParameters();
//				String [] currParamList=parameters.split("\\|", -1);
//
//				cmh = currParamList[3];*/
//				
//				txnDataMap=snapshotObj.get(0).getTxnData();
//				
//				if(txnDataMap!=null && txnDataMap.size()>0){
//					cmh = txnDataMap.get("CMH");
//				}
//			}
//
//
//			//-----------------STEP 3: Insert/Update the record for Service Completion into ServiceHistory tables
//
//			if(session == null || !session.isOpen()){
//				session = new HibernateUtil().getSessionFactory().openSession();
//				session.beginTransaction();
//			}
//			Query serviceCompletionQ = session.createQuery("from ServiceHistoryEntity where serviceTicketNumber='"+jobCardNumber+"'");
//			Iterator serviceCompletionItr = serviceCompletionQ.list().iterator();
//
//			int update=0;
//			while(serviceCompletionItr.hasNext())
//			{
//				update=1;
//
//				ServiceHistoryEntity serviceHistoryObj = (ServiceHistoryEntity)serviceCompletionItr.next();
//				if( ! (serviceHistoryObj.getSerialNumber().getSerial_number().getSerialNumber().equalsIgnoreCase(serialNumber)) )
//				{
//					throw new CustomFault("Same JobCardNumber Details exists for different VIN");
//				}
//				serviceHistoryObj.setDealerId(dealerEntity);
//				serviceHistoryObj.setServiceDate(vinServicedDate);
//				serviceHistoryObj.setDbmsPartCode(dbmsPartCode);
//				serviceHistoryObj.setServiceName(serviceName);
//				serviceHistoryObj.setScheduleName(scheduleName);
//				serviceHistoryObj.setServiceScheduleId(serviceScheduleID);
//				if(cmh!=null)
//					serviceHistoryObj.setCMH(cmh);
//				session.update(serviceHistoryObj);
//			}
//
//
//			if(update==0)
//			{
//				ServiceHistoryEntity newServiceRecord = new ServiceHistoryEntity();
//				newServiceRecord.setSerialNumber(assetEntity);
//				newServiceRecord.setServiceTicketNumber(jobCardNumber);
//				newServiceRecord.setDealerId(dealerEntity);
//				newServiceRecord.setServiceDate(vinServicedDate);
//				newServiceRecord.setDbmsPartCode(dbmsPartCode);
//				newServiceRecord.setServiceName(serviceName);
//				newServiceRecord.setScheduleName(scheduleName);
//				newServiceRecord.setServiceScheduleId(serviceScheduleID);
//				newServiceRecord.setCMH(cmh);
//				session.save(newServiceRecord);
//			}
//
//
//
//
//
//
//			/* Query q = session.createQuery(" from AssetEventEntity where serialNumber='"+serialNumber+"' and eventTypeId="+ServiceEventTypeId+" " +
//			 		" and activeStatus=1 ");
//			 Iterator it = q.list().iterator();
//			 while(it.hasNext())
//			 {
//				 assetEvt = (AssetEventEntity)it.next();
//				 String serviceName = null;
//				 String scheduleName =null;
//				 flag =1;
//
//				 //Check for the valid service history record received
//				 if(assetEvt!=null)
//				 {
//					 String dbmsPartCodeDef = null;
//					 Query serviceSchQuery = session.createQuery("from ServiceScheduleEntity where serviceScheduleId="+assetEvt.getServiceScheduleId());
//					 Iterator serviceSchItr = serviceSchQuery.list().iterator();
//					 while(serviceSchItr.hasNext())
//					 {
//						 ServiceScheduleEntity serSch = (ServiceScheduleEntity)serviceSchItr.next();
//						 dbmsPartCodeDef = serSch.getDbmsPartCode();
//						 serviceName = serSch.getServiceName();
//						 scheduleName = serSch.getScheduleName();
//					 }
//
//					 //DF20150116 - Rajani Nagaraju - Remove the condition of Ignoring the service details record if service record is received for previous service alerts but different alert is raised in LL
//					 if( (dbmsPartCodeDef==null) || (!(dbmsPartCodeDef.equalsIgnoreCase(dbmsPartCode))) )
//					 {
//						 throw new CustomFault("Invalid Service Details received, Service Alert is raised in LL for different DBMS part code");
//					 }
//
//					 //Nullify the assetEvent
//					 else
//					 if((dbmsPartCodeDef!=null) && (dbmsPartCodeDef.equalsIgnoreCase(dbmsPartCode)))
//					 {
//						 assetEvt.setActiveStatus(0);
//						 assetEvt.setEventClosedTime(new Timestamp(new Date().getTime()));
//						 session.save(assetEvt);
//					 }
//
//
//				 }
//
//
//				 else
//				 {
//					 if(assetEntity.getProductId()==null || assetEntity.getProductId().getAssetGroupId()==null || assetEntity.getProductId().getAssetTypeId()==null
//							 || assetEntity.getProductId().getEngineTypeId()==null)
//					 {
//						 throw new CustomFault("Product details not available for the VIN");
//					 }
//					 //get the service name and schedule Name
//					 Query masterServSchQuery = session.createQuery("from ServiceScheduleEntity where dbmsPartCode='"+dbmsPartCode+"'" +
//					 		" and assetGroupId="+assetEntity.getProductId().getAssetGroupId().getAsset_group_id()+" and " +
//					 				" assetTypeId="+assetEntity.getProductId().getAssetTypeId().getAsset_type_id()+" and " +
//					 						" engineTypeId="+assetEntity.getProductId().getEngineTypeId().getEngineTypeId());
//					 Iterator masterServSchItr = masterServSchQuery.list().iterator();
//					 int present =0;
//
//					 while(masterServSchItr.hasNext())
//					 {
//						 present=1;
//						 ServiceScheduleEntity serviceSchedule = (ServiceScheduleEntity)masterServSchItr.next();
//						 serviceName = serviceSchedule.getServiceName();
//						 scheduleName = serviceSchedule.getScheduleName();
//					 }
//
//					 //No service schedule defined for the specific product
//					 if(present==0)
//					 {
//						 throw new CustomFault("No service schedule defined for the product with the given DBMS part Code");
//					 }
//				 } 
//
//				//Insert/update the service history record
//				 Query query = session.createQuery("from ServiceHistoryEntity where serviceTicketNumber='"+jobCardNumber+"'");
//				 Iterator itrtr = query.list().iterator();
//
//				 int update=0;
//
//				 while(itrtr.hasNext())
//				 {
//					 update=1;
//
//					 ServiceHistoryEntity serviceHistoryObj = (ServiceHistoryEntity)itrtr.next();
//					 if( ! (serviceHistoryObj.getSerialNumber().getSerial_number().getSerialNumber().equalsIgnoreCase(serialNumber)) )
//					 {
//						 throw new CustomFault("Same JobCardNumber Details exists for different VIN");
//					 }
//					 serviceHistoryObj.setDealerId(dealerEntity);
//					 serviceHistoryObj.setServiceDate(vinServicedDate);
//					 serviceHistoryObj.setDbmsPartCode(dbmsPartCode);
//					 serviceHistoryObj.setServiceName(serviceName);
//					 serviceHistoryObj.setScheduleName(scheduleName);
//
//					 session.update(serviceHistoryObj);
//				 }
//
//
//				 if(update==0)
//				 {
//					 ServiceHistoryEntity newServiceRecord = new ServiceHistoryEntity();
//					 newServiceRecord.setSerialNumber(assetEntity);
//					 newServiceRecord.setServiceTicketNumber(jobCardNumber);
//					 newServiceRecord.setDealerId(dealerEntity);
//					 newServiceRecord.setServiceDate(vinServicedDate);
//					 newServiceRecord.setDbmsPartCode(dbmsPartCode);
//					 newServiceRecord.setServiceName(serviceName);
//					 newServiceRecord.setScheduleName(scheduleName);
//
//					 session.save(newServiceRecord);
//				 }
//			 }
//
//			 //DefectId:20150805 @Suprava Insert/update serviceHistory Details when assetEvent has no Entry 
//			 if(assetEvt==null && flag ==0){
//				 String serviceName = null;
//				 String scheduleName =null;
//				 iLogger.info("Insert/update serviceHistory Details when assetEvent has no Entry");
//				 if(assetEntity.getProductId()==null || assetEntity.getProductId().getAssetGroupId()==null || assetEntity.getProductId().getAssetTypeId()==null
//							 || assetEntity.getProductId().getEngineTypeId()==null)
//					 {
//						 throw new CustomFault("Product details not available for the VIN");
//					 }
//					 //get the service name and schedule Name
//					 Query masterServSchQuery = session.createQuery("from ServiceScheduleEntity where dbmsPartCode='"+dbmsPartCode+"'" +
//					 		" and assetGroupId="+assetEntity.getProductId().getAssetGroupId().getAsset_group_id()+" and " +
//					 				" assetTypeId="+assetEntity.getProductId().getAssetTypeId().getAsset_type_id()+" and " +
//					 						" engineTypeId="+assetEntity.getProductId().getEngineTypeId().getEngineTypeId());
//					 Iterator masterServSchItr = masterServSchQuery.list().iterator();
//					 int present =0;
//
//					 while(masterServSchItr.hasNext())
//					 {
//						 present=1;
//						 ServiceScheduleEntity serviceSchedule = (ServiceScheduleEntity)masterServSchItr.next();
//						 serviceName = serviceSchedule.getServiceName();
//						 scheduleName = serviceSchedule.getScheduleName();
//					 }
//
//					 //No service schedule defined for the specific product
//					 if(present==0)
//					 {
//						 throw new CustomFault("No service schedule defined for the product with the given DBMS part Code");
//					 }
//					 iLogger.info("serviceName & scheduleName:"+serviceName+"+"+scheduleName); 
//				//Insert/update the service history record
//				 Query query = session.createQuery("from ServiceHistoryEntity where serviceTicketNumber='"+jobCardNumber+"'");
//				 Iterator itrtr = query.list().iterator();
//
//				 int update=0;
//
//				 while(itrtr.hasNext())
//				 {
//					 update=1;
//
//					 ServiceHistoryEntity serviceHistoryObj = (ServiceHistoryEntity)itrtr.next();
//					 if( ! (serviceHistoryObj.getSerialNumber().getSerial_number().getSerialNumber().equalsIgnoreCase(serialNumber)) )
//					 {
//						 throw new CustomFault("Same JobCardNumber Details exists for different VIN");
//					 }
//					 serviceHistoryObj.setDealerId(dealerEntity);
//					 serviceHistoryObj.setServiceDate(vinServicedDate);
//					 serviceHistoryObj.setDbmsPartCode(dbmsPartCode);
//					 serviceHistoryObj.setServiceName(serviceName);
//					 serviceHistoryObj.setScheduleName(scheduleName);
//
//					 session.update(serviceHistoryObj);
//				 }
//
//
//				 if(update==0)
//				 {
//					 ServiceHistoryEntity newServiceRecord = new ServiceHistoryEntity();
//					 newServiceRecord.setSerialNumber(assetEntity);
//					 newServiceRecord.setServiceTicketNumber(jobCardNumber);
//					 newServiceRecord.setDealerId(dealerEntity);
//					 newServiceRecord.setServiceDate(vinServicedDate);
//					 newServiceRecord.setDbmsPartCode(dbmsPartCode);
//					 newServiceRecord.setServiceName(serviceName);
//					 newServiceRecord.setScheduleName(scheduleName);
//
//					 session.save(newServiceRecord);
//				 }
//
//			 }*/
//
//			/*		 String serviceName = null;
//			 String scheduleName =null;
//
//			 //Check for the valid service history record received
//			 if(assetEvt!=null)
//			 {
//				 String dbmsPartCodeDef = null;
//				 Query serviceSchQuery = session.createQuery("from ServiceScheduleEntity where serviceScheduleId="+assetEvt.getServiceScheduleId());
//				 Iterator serviceSchItr = serviceSchQuery.list().iterator();
//				 while(serviceSchItr.hasNext())
//				 {
//					 ServiceScheduleEntity serSch = (ServiceScheduleEntity)serviceSchItr.next();
//					 dbmsPartCodeDef = serSch.getDbmsPartCode();
//					 serviceName = serSch.getServiceName();
//					 scheduleName = serSch.getScheduleName();
//				 }
//
//				 //DF20150116 - Rajani Nagaraju - Remove the condition of Ignoring the service details record if service record is received for previous service alerts but different alert is raised in LL
//				 if( (dbmsPartCodeDef==null) || (!(dbmsPartCodeDef.equalsIgnoreCase(dbmsPartCode))) )
//				 {
//					 throw new CustomFault("Invalid Service Details received, Service Alert is raised in LL for different DBMS part code");
//				 }
//
//				 //Nullify the assetEvent
//				 else
//				 if((dbmsPartCodeDef!=null) && (dbmsPartCodeDef.equalsIgnoreCase(dbmsPartCode)))
//				 {
//					 assetEvt.setActiveStatus(0);
//					 assetEvt.setEventClosedTime(new Timestamp(new Date().getTime()));
//					 session.save(assetEvt);
//				 }
//
//
//			 }
//
//
//			 else
//			 {
//				 if(assetEntity.getProductId()==null || assetEntity.getProductId().getAssetGroupId()==null || assetEntity.getProductId().getAssetTypeId()==null
//						 || assetEntity.getProductId().getEngineTypeId()==null)
//				 {
//					 throw new CustomFault("Product details not available for the VIN");
//				 }
//				 //get the service name and schedule Name
//				 Query masterServSchQuery = session.createQuery("from ServiceScheduleEntity where dbmsPartCode='"+dbmsPartCode+"'" +
//				 		" and assetGroupId="+assetEntity.getProductId().getAssetGroupId().getAsset_group_id()+" and " +
//				 				" assetTypeId="+assetEntity.getProductId().getAssetTypeId().getAsset_type_id()+" and " +
//				 						" engineTypeId="+assetEntity.getProductId().getEngineTypeId().getEngineTypeId());
//				 Iterator masterServSchItr = masterServSchQuery.list().iterator();
//				 int present =0;
//
//				 while(masterServSchItr.hasNext())
//				 {
//					 present=1;
//					 ServiceScheduleEntity serviceSchedule = (ServiceScheduleEntity)masterServSchItr.next();
//					 serviceName = serviceSchedule.getServiceName();
//					 scheduleName = serviceSchedule.getScheduleName();
//				 }
//
//				 //No service schedule defined for the specific product
//				 if(present==0)
//				 {
//					 throw new CustomFault("No service schedule defined for the product with the given DBMS part Code");
//				 }
//			 } */
//
//			/*//Insert/update the service history record
//			 Query query = session.createQuery("from ServiceHistoryEntity where serviceTicketNumber='"+jobCardNumber+"'");
//			 Iterator itrtr = query.list().iterator();
//
//			 int update=0;
//
//			 while(itrtr.hasNext())
//			 {
//				 update=1;
//
//				 ServiceHistoryEntity serviceHistoryObj = (ServiceHistoryEntity)itrtr.next();
//				 if( ! (serviceHistoryObj.getSerialNumber().getSerial_number().getSerialNumber().equalsIgnoreCase(serialNumber)) )
//				 {
//					 throw new CustomFault("Same JobCardNumber Details exists for different VIN");
//				 }
//				 serviceHistoryObj.setDealerId(dealerEntity);
//				 serviceHistoryObj.setServiceDate(vinServicedDate);
//				 serviceHistoryObj.setDbmsPartCode(dbmsPartCode);
//				 serviceHistoryObj.setServiceName(serviceName);
//				 serviceHistoryObj.setScheduleName(scheduleName);
//
//				 session.update(serviceHistoryObj);
//			 }
//
//
//			 if(update==0)
//			 {
//				 ServiceHistoryEntity newServiceRecord = new ServiceHistoryEntity();
//				 newServiceRecord.setSerialNumber(assetEntity);
//				 newServiceRecord.setServiceTicketNumber(jobCardNumber);
//				 newServiceRecord.setDealerId(dealerEntity);
//				 newServiceRecord.setServiceDate(vinServicedDate);
//				 newServiceRecord.setDbmsPartCode(dbmsPartCode);
//				 newServiceRecord.setServiceName(serviceName);
//				 newServiceRecord.setScheduleName(scheduleName);
//
//				 session.save(newServiceRecord);
//			 }*/
//
//			if(session.isOpen())
//				if(session.getTransaction().isActive())
//				{
//					session.getTransaction().commit();
//				}
//
//		} 			 
//
//		catch(CustomFault e)
//		{
//
//			try
//			{
//				if(session.isOpen())
//					if(session.getTransaction().isActive())
//					{
//						session.getTransaction().rollback();
//					}
//			}
//			catch(Exception e1)
//			{
//				//DF20150603 - Rajani Nagaraju - WISE going down issue - Adding try catch against commit
//				fLogger.fatal("Exception in Rolling back the transaction:"+e1);
//			}
//
//			status = "FAILURE-"+e.getFaultInfo();
//			bLogger.error("EA Processing: AssetServiceDetails: "+messageId+" : "+e.getFaultInfo());
//		}
//
//		catch(Exception e)
//		{
//			try{
//				if(session.isOpen())
//					if(session.getTransaction().isActive())
//					{
//						session.getTransaction().rollback();
//					}
//			}
//			catch(Exception e1)
//			{
//				//DF20150603 - Rajani Nagaraju - WISE going down issue - Adding try catch against commit
//				fLogger.fatal("Exception in Rolling back the transaction:"+e1);
//			}
//
//
//			status = "FAILURE-"+e.getMessage();
//			fLogger.fatal("EA Processing: AssetServiceDetails: "+messageId+ " Fatal Exception :"+e);
//		}	 
//
//		finally
//		{
//			if(session.isOpen())
//			{
//				session.flush();
//				session.close();
//			}
//
//		}
//		//Commenting below part since orientdb is not getting used 
//		//DF20160513 - Rajani Nagaraju - Update Service Completion details to close the Alert in OrientAppDB - TAlertTxn (Graph Model)
//		/* iLogger.info("EA Processing: ServiceCompletion: "+messageId+ ": Update Alert details in OrientAppDB");
//		 String messageString = serialNumber+"|"+dealerCode+"|"+jobCardNumber+"|"+dbmsPartCode+"|"+servicedDate;
//		String orientdbStatus = new EADataPopulationBO().ServiceCompletion(messageId, messageId, messageString);
//		iLogger.info("EA Processing: ServiceCompletion:  "+messageId+ ": Update Alert details in OrientAppDB OrientAppDB Status:"+orientdbStatus);*/
//
//		return status;
//	}
	//DF20190423:IM20018382-Adding the additonal field jobCardDetails
	//DF20191220:Abhishek::added new callTypeId for Extended Warranty.
	public String setServiceDetails(String serialNumber, String dealerCode, String jobCardNumber,String dbmsPartCode, String callTypeId, String servicedDate, String jobCardDetails, String messageId)
	{
		String status ="SUCCESS-Record Processed";

		//Logger fatalError = Logger.getLogger("fatalErrorLogger");
		//Logger businessError = Logger.getLogger("businessErrorLogger");
		int clientId = 0;
		String engineHours = null;
		
		//DF20190311 - Abhishek Deshmukh - To close service in MoolDA reports.
		String countryCode=null;
		
		Logger fLogger = FatalLoggerClass.logger;

		Logger bLogger = BusinessErrorLoggerClass.logger; 
		int segmentID = 0;

		DateFormat dateStr = new SimpleDateFormat("yyyy-MM-dd");
		Session session = HibernateUtil.getSessionFactory().getCurrentSession();
		Logger iLogger = InfoLoggerClass.logger;
		//DF20150603 - Rajani Nagaraju - WISE going down issue - Open a new session when the getCurrentSession returns a dirty session(txns which is not yet committed exists)
		if(session.getTransaction().isActive() && session.isDirty())
		{
			iLogger.info("Opening a new session");
			session = HibernateUtil.getSessionFactory().openSession();
		}
		session.beginTransaction();
		Connection prodConn1=null;
		Statement stmnt1=null;
		PreparedStatement preparedStmt_1=null;
		Connection prodConnAESQ=null;
		Statement stmntAESQ=null;
		try
		{
			//Validate the serialNumber
			/*DomainServiceImpl domainService = new DomainServiceImpl();
			 AssetEntity assetEntity = domainService.getAssetEntity(serialNumber);*/

			//DF20150608 - Rajani Nagaraju - Session Closed Exception on processing service history record
			AssetEntity assetEntity=null;
			
			
			
			Query serialNumQ = session.createQuery(" from AssetEntity where serial_number='"+serialNumber+"'");
			Iterator serialNumItr = serialNumQ.list().iterator();
			while(serialNumItr.hasNext())
			{
				assetEntity = (AssetEntity)serialNumItr.next();
			}

			if(assetEntity==null || assetEntity.getSerial_number()==null)
			{
				/*if(serialNumber.trim().length() >7)
				{
							serialNumber = serialNumber.substring(serialNumber.length()-7 , serialNumber.length());
				}*/



				//DF20140715 - Rajani Nagaraju - Remove Preceeding zeros in Machine Number
				serialNumber=serialNumber.replaceFirst("^0+(?!$)", "");
				Query qryMacNo =session.createQuery("from AssetEntity a where a.machineNumber='"+serialNumber+"'");
				Iterator itrMacNo=qryMacNo.list().iterator();
				while(itrMacNo.hasNext())
				{
					assetEntity = (AssetEntity) itrMacNo.next();		

					//DF20190311 - Abhishek Deshmukh - To close service in MoolDA reports.
					countryCode = assetEntity.getCountrycode();
					
					//DF20140805 - Rajani Nagaraju - Updating Serial Number from Machine Number
					serialNumber=assetEntity.getSerial_number().getSerialNumber();
					segmentID = assetEntity.getSegmentId();
				}

			}

			if(assetEntity==null || assetEntity.getSerial_number()==null)
			{
				AssetControlUnitEntity assetControl=null;
				Query assetControlQ = session.createQuery(" from AssetControlUnitEntity where serialNumber like '%"+serialNumber+"%'");
				Iterator assetControlItr = assetControlQ.list().iterator();
				while(assetControlItr.hasNext())
				{
					assetControl= (AssetControlUnitEntity)assetControlItr.next();
				}

				if(assetControl==null)
				{
					status = "FAILURE-PIN Registration Data not received";
					bLogger.error("EA Processing: AssetServiceDetails: "+messageId+" : PIN Registration Data not received");
					return status;
				}
				else
				{
					status = "FAILURE-Roll off Data not received";
					bLogger.error("EA Processing: AssetServiceDetails: "+messageId+" : Roll off Data not received");
					return status;
				}

			}

			//Validate DealerCode - Get the dealer Entity for the given dealerCode
			Query dealerQuery = session.createQuery("from AccountEntity where status=true and accountCode='"+dealerCode+"'");
			Iterator itr = dealerQuery.list().iterator();
			AccountEntity dealerEntity = null;
			while(itr.hasNext())
			{
				dealerEntity = (AccountEntity) itr.next();
			}

			if(dealerEntity==null)
			{
				throw new CustomFault("Dealer Master data is not received for the Dealer:"+dealerCode);
			}


			//Parse the serviced date
			SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
			Timestamp vinServicedDate =null;
			try
			{
				vinServicedDate = new Timestamp(dateFormat.parse(servicedDate).getTime());
			}
			catch(Exception e)
			{
				status = "FAILURE-"+e.getMessage();
				bLogger.error("EA Processing: AssetServiceDetails: "+messageId+" : Date Parse Exception for Serviced Date"+e);
				return status;
			}

			//Check if there are any Active Service Alert for the VIN
			int ServiceEventTypeId = 0;
			Properties prop = new Properties();
			prop.load(getClass().getClassLoader().getResourceAsStream("remote/wise/resource/properties/configuration.properties"));
			ServiceEventTypeId= Integer.parseInt(prop.getProperty("ServiceEventTypeId"));
			//int flag =0;

			//DF20150923 - Rajani Nagaraju - JCB0321,JCB0339 Service Alert Completion should close all the active service alerts for previous scehdules (if any) as well
			//Also there was a problem in wrong serviceNames getting updated in ServiceHistory record
			//-----------------STEP 1: Get the List of service schedules for which the active alert has to be closed
			Query serviceListQ = session.createQuery("select b from AssetServiceScheduleEntity a, ServiceScheduleEntity b" +
					" where a.serviceScheduleId=b.serviceScheduleId and a.serialNumber='"+serialNumber+"'" +
					" order by b.engineHoursSchedule desc ");
			Iterator serviceListItr = serviceListQ.list().iterator();
			List<String> scheduleIdList = new LinkedList<String>();
			String serviceName = null;
			String scheduleName =null;
			int assetEventId =0;
			int eventId = 0;
 			String eventSeverity=null;
 			String eventGeneratedTime = null;
 			Timestamp eventClosedTime= new Timestamp(new Date().getTime());
			//added by S Suresh to insert newly added column service schedule ID into the service history table 
			int serviceScheduleID = 0;
			int addRec=0;
			while(serviceListItr.hasNext())
			{
				ServiceScheduleEntity serviceSch = (ServiceScheduleEntity)serviceListItr.next();
				if((serviceSch.getDbmsPartCode().equalsIgnoreCase(dbmsPartCode))&&(String.valueOf(serviceSch.getCallTypeId()).equalsIgnoreCase(callTypeId)))
				{
					addRec=1;
					//	 scheduleIdList.add(String.valueOf(serviceSch.getServiceScheduleId()));

					serviceName = serviceSch.getServiceName();
					scheduleName = serviceSch.getScheduleName();
					serviceScheduleID = serviceSch.getServiceScheduleId();
				}

				if(addRec==1)
					scheduleIdList.add(String.valueOf(serviceSch.getServiceScheduleId()));

			}

			if(scheduleIdList.isEmpty())
			{
				/* fLogger.fatal("No service schedule defined for the VIN with the given DBMS part Code");
				 status = "FAILURE-No service schedule defined for the VIN with the given DBMS part Code";
				 return status;*/

				throw new CustomFault("No service schedule defined for the VIN with the given DBMS part Code and the CallTypeId");
			}


			//-----------------STEP 2: Close any active service alert on the machine for the schedules <= current received schedule
			ListToStringConversion conversionObj = new  ListToStringConversion();
			String scheduleIdListAsString = conversionObj.getStringList(scheduleIdList).toString();
			Query alertClosureQ = session.createQuery(" from AssetEventEntity where serialNumber='"+serialNumber+"' and eventTypeId="+ServiceEventTypeId +
					" and activeStatus=1 and serviceScheduleId in ("+scheduleIdListAsString+")");
			Iterator alertClosureItr = alertClosureQ.list().iterator();
			while(alertClosureItr.hasNext())
			{
				AssetEventEntity assetEvent = (AssetEventEntity)alertClosureItr.next();
				assetEvent.setActiveStatus(0);
				assetEvent.setEventClosedTime(eventClosedTime);
				
				//DF20190311- Retreving asset event Id to close MoolDA Reports.
				assetEventId = assetEvent.getAssetEventId();
				eventSeverity = assetEvent.getEventSeverity();
				eventId = assetEvent.getEventId().getEventId();
				eventGeneratedTime = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(assetEvent.getEventGeneratedTime());
				
				//DF20190110- Updating partition key and source.
				assetEvent.setUpdateSource("WISE");
				if(assetEvent.getEventGeneratedTime() != null){
					Date date = new Date();
					date.setTime(assetEvent.getEventGeneratedTime().getTime());
					String partitionKey = new SimpleDateFormat("yyyyMM").format(date);
					assetEvent.setPartitionKey(Integer.parseInt(partitionKey));
				}

				//DF20160906 @Roopa fix for deleting the records from asset_event table when the service history record is received
				//session.save(assetEvent);
				session.update(assetEvent);
			}

			if(session!=null && session.isOpen()){
				if(session.getTransaction().isActive())
				{
					session.getTransaction().commit();
				}

				if(session!=null && session.isOpen())
				{
					session.flush();
					session.close();

				}
			}


			//20160711 - @suresh new column has been added to the service history table CMH
			//-----------------STEP 4: get the CMH when the machine got services (service alert closure)



			/*String cmhQueryString = "select amd.parameterValue " +
					"from AssetMonitoringSnapshotEntity ams,AssetMonitoringDetailEntity amd " +
					"where ams.serialNumber = '"+serialNumber+"' and " +
							" amd.transactionNumber = ams.latestEventTxn and " +
							"amd.parameterId = 4 ";*/

			/*String cmhQueryString = "select amd.parameterValue " +
                    "from AssetMonitoringHeaderEntity amh2,AssetEntity a,AssetMonitoringDetailEntity amd " +
                    "where a.serial_number = '"+serialNumber+"' and " +
                                "amh2.segmentId = a.segmentId and " +
                                "amh2.serialNumber = a.serial_number and " +
                                "amh2.transactionTime = (" +
                                "select max(amh.transactionTime) as transactionTime " +
                                "from asset_monitoring_header amh " +
                                "where amh.segmentId = amh2.segmentId and " +
                                "amh.Serial_Number = amh2.Serial_Number and amh.transactionTime like '"+servicedDate+"%' ) " +
                                "and amd.transactionNumber = amh.transactionNumber and " +
                                "amd.parameterId = 4 ";

			String cmh = null;

			Query cmhQuery = session.createQuery(cmhQueryString);
			Iterator cmhIterator = cmhQuery.list().iterator();
			while(cmhIterator.hasNext()){
				cmh = (String) cmhIterator.next();
			}*/

			/*

			Properties prop1 = new Properties();
			Properties prop2 = new Properties();
			int engineHoursId = 0;
			try {
				prop1.load(getClass().getClassLoader().getResourceAsStream("remote/wise/resource/properties/configuration.properties"));
				IndustryBO industryBoObj = new IndustryBO();
				clientId = industryBoObj.getClientEntity(prop1.getProperty("ClientName")).getClient_id();

				prop2.load(getClass().getClassLoader().getResourceAsStream("remote/wise/resource/properties/configuration.properties"));

				engineHours= prop2.getProperty("TotalEngineHours");
				if(session == null || !session.isOpen()){
					session = new HibernateUtil().getSessionFactory().openSession();
					session.beginTransaction();
				}
				itr = session.createQuery("select max(a.parameterId), a.parameterName " +
						" from MonitoringParameters a " +
						" where parameterName in " +
							"( '"
							+ engineHours
							+ "')"
							+ " group by a.parameterName"
							+ " order by a.parameterId").list().iterator();

				Object[] resultObj = null;

				while (itr.hasNext()) {
					resultObj = (Object[]) itr.next();

					if ( ((String)resultObj[1]).equalsIgnoreCase(engineHours) ) {
						engineHoursId = (Integer) resultObj[0]; 
					}

				} // End of itr
			//	engineON= prop2.getProperty("EngineON");
			}catch(Exception e){
					e.printStackTrace();
				}
			finally {
				if(session!=null || session.isOpen())
				session.close();
			}
			//using DAL Layer to get the amh from dynamic amh table 
			 Calendar cal = Calendar.getInstance();
			 cal.setTime(dateStr.parse(servicedDate));

			 Timestamp txnTimestamp = new Timestamp(cal.getTimeInMillis());
			List parametreIDList = new LinkedList();
			parametreIDList.add(engineHoursId);
			DynamicAMH_DAL dalObj = new DynamicAMH_DAL();
			String cmh = dalObj.getLatestCMH(serialNumber, txnTimestamp,segmentID, parametreIDList);*/

			//DF20160914 @Roopa Fetching CMH data from snapshot table(AMS)

			String cmh=null;

			String txnKey="setServiceDetailsViaExecutor";
			
			//DF20180508:KO369761 - Pointing to correct DAL class.
			/*List<AmsDAO> snapshotObj=new ArrayList<AmsDAO> ();

			DynamicAMS_DAL amsDaoObj=new DynamicAMS_DAL();

			snapshotObj=amsDaoObj.getAMSData(txnKey, serialNumber);*/
			
			List<AMSDoc_DAO> snapshotObj=new ArrayList<AMSDoc_DAO> ();
			snapshotObj=DynamicAMS_Doc_DAL.getAMSData(txnKey, serialNumber);
			HashMap<String,String> txnDataMap=new HashMap<String, String>();

			iLogger.debug(txnKey+"::"+"AMS DAL::getAMSData Size:"+snapshotObj.size());

			if(snapshotObj.size()>0){

				//parameters format in AMS
				//String currParam= LAT|LONG|Enginestatus|Machinehours|ExternalBatteryVoltage|HCT|LOP|InternalBatteryLow
				
				//DF20180508:KO369761 - Pointing to correct DAL class.
				/*String parameters=snapshotObj.get(0).getParameters();
				String [] currParamList=parameters.split("\\|", -1);

				cmh = currParamList[3];*/
				
				txnDataMap=snapshotObj.get(0).getTxnData();
				
				if(txnDataMap!=null && txnDataMap.size()>0){
					cmh = txnDataMap.get("CMH");
				}
			}


			//-----------------STEP 3: Insert/Update the record for Service Completion into ServiceHistory tables

			if(session == null || !session.isOpen()){
				session = new HibernateUtil().getSessionFactory().openSession();
				session.beginTransaction();
			}
			Query serviceCompletionQ = session.createQuery("from ServiceHistoryEntity where serviceTicketNumber='"+jobCardNumber+"'");
			Iterator serviceCompletionItr = serviceCompletionQ.list().iterator();

			int update=0;
			while(serviceCompletionItr.hasNext())
			{
				update=1;

				ServiceHistoryEntity serviceHistoryObj = (ServiceHistoryEntity)serviceCompletionItr.next();
				if( ! (serviceHistoryObj.getSerialNumber().getSerial_number().getSerialNumber().equalsIgnoreCase(serialNumber)) )
				{
					throw new CustomFault("Same JobCardNumber Details exists for different VIN");
				}
				serviceHistoryObj.setDealerId(dealerEntity);
				serviceHistoryObj.setServiceDate(vinServicedDate);
				serviceHistoryObj.setDbmsPartCode(dbmsPartCode);
				//DF20191220:Abhishek::added new column Extended Warranty.
				serviceHistoryObj.setCallTypeId(callTypeId);
				serviceHistoryObj.setServiceName(serviceName);
				serviceHistoryObj.setScheduleName(scheduleName);
				serviceHistoryObj.setServiceScheduleId(serviceScheduleID);
				//DF20180423:IM20018382 - An additional field jobCardDetails.
				serviceHistoryObj.setComments(jobCardDetails);
				if(cmh!=null)
					serviceHistoryObj.setCMH(cmh);
				session.update(serviceHistoryObj);
			}


			if(update==0)
			{
				ServiceHistoryEntity newServiceRecord = new ServiceHistoryEntity();
				newServiceRecord.setSerialNumber(assetEntity);
				newServiceRecord.setServiceTicketNumber(jobCardNumber);
				newServiceRecord.setDealerId(dealerEntity);
				newServiceRecord.setServiceDate(vinServicedDate);
				newServiceRecord.setDbmsPartCode(dbmsPartCode);
				//DF20191220:Abhishek::added new column Extended Warranty.
				newServiceRecord.setCallTypeId(callTypeId);
				newServiceRecord.setServiceName(serviceName);
				newServiceRecord.setScheduleName(scheduleName);
				newServiceRecord.setServiceScheduleId(serviceScheduleID);
				newServiceRecord.setCMH(cmh);
				//DF20180423:IM20018382 - An additional field jobCardDetails.
				newServiceRecord.setComments(jobCardDetails);
				session.save(newServiceRecord);
			}

			if(session.isOpen())
				if(session.getTransaction().isActive())
				{
					session.getTransaction().commit();
				}
			ConnectMySQL connMySql=new ConnectMySQL();
			String eventClosedTimeInString = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(eventClosedTime);

			//DF20190320:Abhishek Deshmukh:: To close the service alert in asset_event_sanpshot table.
			String updateAESQ = "update asset_event_snapshot set AlertTxnTimestamp = JSON_SET(AlertTxnTimestamp," +

                                                                                "'$.\""+eventId+"\"', '"+eventClosedTimeInString+"'), AlertStatus = JSON_SET(AlertStatus, '$.\""+eventId+"\"','0' )," +

                                                                                "LastUpdatedTime ='"+eventClosedTimeInString+"',UpdateSource='WISE' where SerialNumber='"+serialNumber+"'";
			iLogger.info("ServiceDetailsBO:setServiceCloserDetails:AssetEventID :"+assetEventId+" : Updating Asset_Event_Snapshot table : "+updateAESQ);
			prodConnAESQ = connMySql.getConnection();
			stmntAESQ = prodConnAESQ.createStatement();
			int row = stmntAESQ.executeUpdate(updateAESQ);
			if(row>0){
				iLogger.info("ServiceDetailsBO:setServiceCloserDetails:AssetEventID :"+assetEventId+" : Updated Asset_Event_Snapshot table : "+updateAESQ+" : Rows affected : "+row);

			}
			else{
				fLogger.fatal("ServiceDetailsBO:setServiceCloserDetails: Error while updating asset_event_snapshot table.");
			}
			
			//DF20190315:Abhishek Deshmukh:: To close the service in MDA Reports.
			String moolStatus = setServiceClouserMoolDAReports(serialNumber,assetEventId, countryCode, eventId ,eventSeverity, eventGeneratedTime, servicedDate);
			
			if((moolStatus.equalsIgnoreCase("FAILURE")||moolStatus.contains("FAILURE"))&&assetEventId!=0){
				iLogger.info("ServiceDetailsBO:setServiceCloserDetails:AssetEventID :"+assetEventId+" : Inserting Record in Service_Clouser_MoolDA_Failure table ");
				  prodConn1 = connMySql.getConnection();
				  stmnt1 = prodConn1.createStatement();
				  String service_Clouser="Insert into Service_Clouser_MoolDA_Failure values(?,?,?,?,?,?,?,?)";
				  iLogger.info("MDA FleetSummaryService :: Query for inserttion in Service_Clouser_MoolDA_Failure :"+service_Clouser);
				  preparedStmt_1 = prodConn1.prepareStatement(service_Clouser);
				  preparedStmt_1.setString (1, Integer.toString(assetEventId));
				  preparedStmt_1.setString (2, countryCode);
				  preparedStmt_1.setString (3, serialNumber);
				  preparedStmt_1.setString (4, eventSeverity);
				  preparedStmt_1.setInt (5, eventId);
				  preparedStmt_1.setString(6, eventGeneratedTime);
				  preparedStmt_1.setString (7, servicedDate);
				  preparedStmt_1.setString (8, "Dummy");
				  preparedStmt_1.executeUpdate();
				  iLogger.info("ServiceDetailsBO:setServiceCloserDetails:AssetEventID :"+assetEventId+": Record inserted  in table "+service_Clouser);
				
	           iLogger.info("ServiceDetailsBO:setServiceCloserDetails:AssetEventID "+assetEventId+"   - END");			  	
			}
		} 			 

		catch(CustomFault e)
		{

			try
			{
				if(session.isOpen())
					if(session.getTransaction().isActive())
					{
						session.getTransaction().rollback();
					}
			}
			catch(Exception e1)
			{
				//DF20150603 - Rajani Nagaraju - WISE going down issue - Adding try catch against commit
				fLogger.fatal("Exception in Rolling back the transaction:"+e1);
			}

			status = "FAILURE-"+e.getFaultInfo();
			bLogger.error("EA Processing: AssetServiceDetails: "+messageId+" : "+e.getFaultInfo());
			
		}

		catch(Exception e)
		{
			try{
				if(session.isOpen())
					if(session.getTransaction().isActive())
					{
						session.getTransaction().rollback();
					}
			}
			catch(Exception e1)
			{
				//DF20150603 - Rajani Nagaraju - WISE going down issue - Adding try catch against commit
				fLogger.fatal("Exception in Rolling back the transaction:"+e1);
			}


			status = "FAILURE-"+e.getMessage();
			fLogger.fatal("EA Processing: AssetServiceDetails: "+messageId+ " Fatal Exception :"+e);
		}	 

		finally
		{
			if(session.isOpen())
			{
				session.flush();
				session.close();
			}
			if(prodConnAESQ!=null)
				try {
					prodConnAESQ.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			if(stmntAESQ!=null)
				try {
					stmntAESQ.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			if(prodConn1!=null)
				try {
					prodConn1.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			if(stmnt1!=null)
				try {
					stmnt1.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			if(preparedStmt_1!=null)
				try {
					preparedStmt_1.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
		}
		//Commenting below part since orientdb is not getting used 
		//DF20160513 - Rajani Nagaraju - Update Service Completion details to close the Alert in OrientAppDB - TAlertTxn (Graph Model)
		/* iLogger.info("EA Processing: ServiceCompletion: "+messageId+ ": Update Alert details in OrientAppDB");
		 String messageString = serialNumber+"|"+dealerCode+"|"+jobCardNumber+"|"+dbmsPartCode+"|"+servicedDate;
		String orientdbStatus = new EADataPopulationBO().ServiceCompletion(messageId, messageId, messageString);
		iLogger.info("EA Processing: ServiceCompletion:  "+messageId+ ": Update Alert details in OrientAppDB OrientAppDB Status:"+orientdbStatus);*/

		return status;
	}
	
	public String setServiceDetails(String serialNumber, String dealerCode, String jobCardNumber,String dbmsPartCode, String servicedDate, String messageId){

		String status ="SUCCESS-Record Processed";

		//Logger fatalError = Logger.getLogger("fatalErrorLogger");
		//Logger businessError = Logger.getLogger("businessErrorLogger");
		int clientId = 0;
		String engineHours = null;
		
		//DF20190311 - Abhishek Deshmukh - To close service in MoolDA reports.
		String countryCode=null;
		
		Logger fLogger = FatalLoggerClass.logger;

		Logger bLogger = BusinessErrorLoggerClass.logger; 
		int segmentID = 0;

		DateFormat dateStr = new SimpleDateFormat("yyyy-MM-dd");
		Session session = HibernateUtil.getSessionFactory().getCurrentSession();
		Logger iLogger = InfoLoggerClass.logger;
		//DF20150603 - Rajani Nagaraju - WISE going down issue - Open a new session when the getCurrentSession returns a dirty session(txns which is not yet committed exists)
		if(session.getTransaction().isActive() && session.isDirty())
		{
			iLogger.info("Opening a new session");
			session = HibernateUtil.getSessionFactory().openSession();
		}
		session.beginTransaction();
		Connection prodConn1=null;
		Statement stmnt1=null;
		PreparedStatement preparedStmt_1=null;
		Connection prodConnAESQ=null;
		Statement stmntAESQ=null;
		try
		{
			//Validate the serialNumber
			/*DomainServiceImpl domainService = new DomainServiceImpl();
			 AssetEntity assetEntity = domainService.getAssetEntity(serialNumber);*/

			//DF20150608 - Rajani Nagaraju - Session Closed Exception on processing service history record
			AssetEntity assetEntity=null;
			
			
			
			Query serialNumQ = session.createQuery(" from AssetEntity where serial_number='"+serialNumber+"'");
			Iterator serialNumItr = serialNumQ.list().iterator();
			while(serialNumItr.hasNext())
			{
				assetEntity = (AssetEntity)serialNumItr.next();
			}

			if(assetEntity==null || assetEntity.getSerial_number()==null)
			{
				/*if(serialNumber.trim().length() >7)
				{
							serialNumber = serialNumber.substring(serialNumber.length()-7 , serialNumber.length());
				}*/



				//DF20140715 - Rajani Nagaraju - Remove Preceeding zeros in Machine Number
				serialNumber=serialNumber.replaceFirst("^0+(?!$)", "");
				Query qryMacNo =session.createQuery("from AssetEntity a where a.machineNumber='"+serialNumber+"'");
				Iterator itrMacNo=qryMacNo.list().iterator();
				while(itrMacNo.hasNext())
				{
					assetEntity = (AssetEntity) itrMacNo.next();		

					//DF20190311 - Abhishek Deshmukh - To close service in MoolDA reports.
					countryCode = assetEntity.getCountrycode();
					
					//DF20140805 - Rajani Nagaraju - Updating Serial Number from Machine Number
					serialNumber=assetEntity.getSerial_number().getSerialNumber();
					segmentID = assetEntity.getSegmentId();
				}

			}

			if(assetEntity==null || assetEntity.getSerial_number()==null)
			{
				AssetControlUnitEntity assetControl=null;
				Query assetControlQ = session.createQuery(" from AssetControlUnitEntity where serialNumber like '%"+serialNumber+"%'");
				Iterator assetControlItr = assetControlQ.list().iterator();
				while(assetControlItr.hasNext())
				{
					assetControl= (AssetControlUnitEntity)assetControlItr.next();
				}

				if(assetControl==null)
				{
					status = "FAILURE-PIN Registration Data not received";
					bLogger.error("EA Processing: AssetServiceDetails: "+messageId+" : PIN Registration Data not received");
					return status;
				}
				else
				{
					status = "FAILURE-Roll off Data not received";
					bLogger.error("EA Processing: AssetServiceDetails: "+messageId+" : Roll off Data not received");
					return status;
				}

			}

			//Validate DealerCode - Get the dealer Entity for the given dealerCode
			Query dealerQuery = session.createQuery("from AccountEntity where status=true and accountCode='"+dealerCode+"'");
			Iterator itr = dealerQuery.list().iterator();
			AccountEntity dealerEntity = null;
			while(itr.hasNext())
			{
				dealerEntity = (AccountEntity) itr.next();
			}

			if(dealerEntity==null)
			{
				throw new CustomFault("Dealer Master data is not received for the Dealer:"+dealerCode);
			}


			//Parse the serviced date
			SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
			Timestamp vinServicedDate =null;
			try
			{
				vinServicedDate = new Timestamp(dateFormat.parse(servicedDate).getTime());
			}
			catch(Exception e)
			{
				status = "FAILURE-"+e.getMessage();
				bLogger.error("EA Processing: AssetServiceDetails: "+messageId+" : Date Parse Exception for Serviced Date"+e);
				return status;
			}

			//Check if there are any Active Service Alert for the VIN
			int ServiceEventTypeId = 0;
			Properties prop = new Properties();
			prop.load(getClass().getClassLoader().getResourceAsStream("remote/wise/resource/properties/configuration.properties"));
			ServiceEventTypeId= Integer.parseInt(prop.getProperty("ServiceEventTypeId"));
			//int flag =0;

			//DF20150923 - Rajani Nagaraju - JCB0321,JCB0339 Service Alert Completion should close all the active service alerts for previous scehdules (if any) as well
			//Also there was a problem in wrong serviceNames getting updated in ServiceHistory record
			//-----------------STEP 1: Get the List of service schedules for which the active alert has to be closed
			Query serviceListQ = session.createQuery("select b from AssetServiceScheduleEntity a, ServiceScheduleEntity b" +
					" where a.serviceScheduleId=b.serviceScheduleId and a.serialNumber='"+serialNumber+"'" +
					" order by b.engineHoursSchedule desc ");
			Iterator serviceListItr = serviceListQ.list().iterator();
			List<String> scheduleIdList = new LinkedList<String>();
			String serviceName = null;
			String scheduleName =null;
			int assetEventId =0;
			int eventId = 0;
 			String eventSeverity=null;
 			String eventGeneratedTime = null;
 			Timestamp eventClosedTime= new Timestamp(new Date().getTime());
			//added by S Suresh to insert newly added column service schedule ID into the service history table 
			int serviceScheduleID = 0;
			int addRec=0;
			while(serviceListItr.hasNext())
			{
				ServiceScheduleEntity serviceSch = (ServiceScheduleEntity)serviceListItr.next();
				if(serviceSch.getDbmsPartCode().equalsIgnoreCase(dbmsPartCode))
				{
					addRec=1;
					//	 scheduleIdList.add(String.valueOf(serviceSch.getServiceScheduleId()));

					serviceName = serviceSch.getServiceName();
					scheduleName = serviceSch.getScheduleName();
					serviceScheduleID = serviceSch.getServiceScheduleId();
				}

				if(addRec==1)
					scheduleIdList.add(String.valueOf(serviceSch.getServiceScheduleId()));

			}

			if(scheduleIdList.isEmpty())
			{
				/* fLogger.fatal("No service schedule defined for the VIN with the given DBMS part Code");
				 status = "FAILURE-No service schedule defined for the VIN with the given DBMS part Code";
				 return status;*/

				throw new CustomFault("No service schedule defined for the VIN with the given DBMS part Code and the CallTypeId");
			}


			//-----------------STEP 2: Close any active service alert on the machine for the schedules <= current received schedule
			ListToStringConversion conversionObj = new  ListToStringConversion();
			String scheduleIdListAsString = conversionObj.getStringList(scheduleIdList).toString();
			Query alertClosureQ = session.createQuery(" from AssetEventEntity where serialNumber='"+serialNumber+"' and eventTypeId="+ServiceEventTypeId +
					" and activeStatus=1 and serviceScheduleId in ("+scheduleIdListAsString+")");
			Iterator alertClosureItr = alertClosureQ.list().iterator();
			while(alertClosureItr.hasNext())
			{
				AssetEventEntity assetEvent = (AssetEventEntity)alertClosureItr.next();
				assetEvent.setActiveStatus(0);
				assetEvent.setEventClosedTime(eventClosedTime);
				
				//DF20190311- Retreving asset event Id to close MoolDA Reports.
				assetEventId = assetEvent.getAssetEventId();
				eventSeverity = assetEvent.getEventSeverity();
				eventId = assetEvent.getEventId().getEventId();
				eventGeneratedTime = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(assetEvent.getEventGeneratedTime());
				
				//DF20190110- Updating partition key and source.
				assetEvent.setUpdateSource("WISE");
				if(assetEvent.getEventGeneratedTime() != null){
					Date date = new Date();
					date.setTime(assetEvent.getEventGeneratedTime().getTime());
					String partitionKey = new SimpleDateFormat("yyyyMM").format(date);
					assetEvent.setPartitionKey(Integer.parseInt(partitionKey));
				}

				//DF20160906 @Roopa fix for deleting the records from asset_event table when the service history record is received
				//session.save(assetEvent);
				session.update(assetEvent);
			}

			if(session!=null && session.isOpen()){
				if(session.getTransaction().isActive())
				{
					session.getTransaction().commit();
				}

				if(session!=null && session.isOpen())
				{
					session.flush();
					session.close();

				}
			}


			//20160711 - @suresh new column has been added to the service history table CMH
			//-----------------STEP 4: get the CMH when the machine got services (service alert closure)



			/*String cmhQueryString = "select amd.parameterValue " +
					"from AssetMonitoringSnapshotEntity ams,AssetMonitoringDetailEntity amd " +
					"where ams.serialNumber = '"+serialNumber+"' and " +
							" amd.transactionNumber = ams.latestEventTxn and " +
							"amd.parameterId = 4 ";*/

			/*String cmhQueryString = "select amd.parameterValue " +
                    "from AssetMonitoringHeaderEntity amh2,AssetEntity a,AssetMonitoringDetailEntity amd " +
                    "where a.serial_number = '"+serialNumber+"' and " +
                                "amh2.segmentId = a.segmentId and " +
                                "amh2.serialNumber = a.serial_number and " +
                                "amh2.transactionTime = (" +
                                "select max(amh.transactionTime) as transactionTime " +
                                "from asset_monitoring_header amh " +
                                "where amh.segmentId = amh2.segmentId and " +
                                "amh.Serial_Number = amh2.Serial_Number and amh.transactionTime like '"+servicedDate+"%' ) " +
                                "and amd.transactionNumber = amh.transactionNumber and " +
                                "amd.parameterId = 4 ";

			String cmh = null;

			Query cmhQuery = session.createQuery(cmhQueryString);
			Iterator cmhIterator = cmhQuery.list().iterator();
			while(cmhIterator.hasNext()){
				cmh = (String) cmhIterator.next();
			}*/

			/*

			Properties prop1 = new Properties();
			Properties prop2 = new Properties();
			int engineHoursId = 0;
			try {
				prop1.load(getClass().getClassLoader().getResourceAsStream("remote/wise/resource/properties/configuration.properties"));
				IndustryBO industryBoObj = new IndustryBO();
				clientId = industryBoObj.getClientEntity(prop1.getProperty("ClientName")).getClient_id();

				prop2.load(getClass().getClassLoader().getResourceAsStream("remote/wise/resource/properties/configuration.properties"));

				engineHours= prop2.getProperty("TotalEngineHours");
				if(session == null || !session.isOpen()){
					session = new HibernateUtil().getSessionFactory().openSession();
					session.beginTransaction();
				}
				itr = session.createQuery("select max(a.parameterId), a.parameterName " +
						" from MonitoringParameters a " +
						" where parameterName in " +
							"( '"
							+ engineHours
							+ "')"
							+ " group by a.parameterName"
							+ " order by a.parameterId").list().iterator();

				Object[] resultObj = null;

				while (itr.hasNext()) {
					resultObj = (Object[]) itr.next();

					if ( ((String)resultObj[1]).equalsIgnoreCase(engineHours) ) {
						engineHoursId = (Integer) resultObj[0]; 
					}

				} // End of itr
			//	engineON= prop2.getProperty("EngineON");
			}catch(Exception e){
					e.printStackTrace();
				}
			finally {
				if(session!=null || session.isOpen())
				session.close();
			}
			//using DAL Layer to get the amh from dynamic amh table 
			 Calendar cal = Calendar.getInstance();
			 cal.setTime(dateStr.parse(servicedDate));

			 Timestamp txnTimestamp = new Timestamp(cal.getTimeInMillis());
			List parametreIDList = new LinkedList();
			parametreIDList.add(engineHoursId);
			DynamicAMH_DAL dalObj = new DynamicAMH_DAL();
			String cmh = dalObj.getLatestCMH(serialNumber, txnTimestamp,segmentID, parametreIDList);*/

			//DF20160914 @Roopa Fetching CMH data from snapshot table(AMS)

			String cmh=null;

			String txnKey="setServiceDetailsViaExecutor";
			
			//DF20180508:KO369761 - Pointing to correct DAL class.
			/*List<AmsDAO> snapshotObj=new ArrayList<AmsDAO> ();

			DynamicAMS_DAL amsDaoObj=new DynamicAMS_DAL();

			snapshotObj=amsDaoObj.getAMSData(txnKey, serialNumber);*/
			
			List<AMSDoc_DAO> snapshotObj=new ArrayList<AMSDoc_DAO> ();
			snapshotObj=DynamicAMS_Doc_DAL.getAMSData(txnKey, serialNumber);
			HashMap<String,String> txnDataMap=new HashMap<String, String>();

			iLogger.debug(txnKey+"::"+"AMS DAL::getAMSData Size:"+snapshotObj.size());

			if(snapshotObj.size()>0){

				//parameters format in AMS
				//String currParam= LAT|LONG|Enginestatus|Machinehours|ExternalBatteryVoltage|HCT|LOP|InternalBatteryLow
				
				//DF20180508:KO369761 - Pointing to correct DAL class.
				/*String parameters=snapshotObj.get(0).getParameters();
				String [] currParamList=parameters.split("\\|", -1);

				cmh = currParamList[3];*/
				
				txnDataMap=snapshotObj.get(0).getTxnData();
				
				if(txnDataMap!=null && txnDataMap.size()>0){
					cmh = txnDataMap.get("CMH");
				}
			}


			//-----------------STEP 3: Insert/Update the record for Service Completion into ServiceHistory tables

			if(session == null || !session.isOpen()){
				session = new HibernateUtil().getSessionFactory().openSession();
				session.beginTransaction();
			}
			Query serviceCompletionQ = session.createQuery("from ServiceHistoryEntity where serviceTicketNumber='"+jobCardNumber+"'");
			Iterator serviceCompletionItr = serviceCompletionQ.list().iterator();

			int update=0;
			while(serviceCompletionItr.hasNext())
			{
				update=1;

				ServiceHistoryEntity serviceHistoryObj = (ServiceHistoryEntity)serviceCompletionItr.next();
				if( ! (serviceHistoryObj.getSerialNumber().getSerial_number().getSerialNumber().equalsIgnoreCase(serialNumber)) )
				{
					throw new CustomFault("Same JobCardNumber Details exists for different VIN");
				}
				serviceHistoryObj.setDealerId(dealerEntity);
				serviceHistoryObj.setServiceDate(vinServicedDate);
				serviceHistoryObj.setDbmsPartCode(dbmsPartCode);
				serviceHistoryObj.setServiceName(serviceName);
				serviceHistoryObj.setScheduleName(scheduleName);
				serviceHistoryObj.setServiceScheduleId(serviceScheduleID);
				//DF20180423:IM20018382 - An additional field jobCardDetails.
				serviceHistoryObj.setComments(jobCardDetails);
				if(cmh!=null)
					serviceHistoryObj.setCMH(cmh);
				session.update(serviceHistoryObj);
			}


			if(update==0)
			{
				ServiceHistoryEntity newServiceRecord = new ServiceHistoryEntity();
				newServiceRecord.setSerialNumber(assetEntity);
				newServiceRecord.setServiceTicketNumber(jobCardNumber);
				newServiceRecord.setDealerId(dealerEntity);
				newServiceRecord.setServiceDate(vinServicedDate);
				newServiceRecord.setDbmsPartCode(dbmsPartCode);
				newServiceRecord.setServiceName(serviceName);
				newServiceRecord.setScheduleName(scheduleName);
				newServiceRecord.setServiceScheduleId(serviceScheduleID);
				newServiceRecord.setCMH(cmh);
				//DF20180423:IM20018382 - An additional field jobCardDetails.
				newServiceRecord.setComments(jobCardDetails);
				session.save(newServiceRecord);
			}

			if(session.isOpen())
				if(session.getTransaction().isActive())
				{
					session.getTransaction().commit();
				}
			ConnectMySQL connMySql=new ConnectMySQL();
			String eventClosedTimeInString = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(eventClosedTime);

			//DF20190320:Abhishek Deshmukh:: To close the service alert in asset_event_sanpshot table.
			String updateAESQ = "update asset_event_snapshot set AlertTxnTimestamp = JSON_SET(AlertTxnTimestamp," +

                                                                                "'$.\""+eventId+"\"', '"+eventClosedTimeInString+"'), AlertStatus = JSON_SET(AlertStatus, '$.\""+eventId+"\"','0' )," +

                                                                                "LastUpdatedTime ='"+eventClosedTimeInString+"',UpdateSource='WISE' where SerialNumber='"+serialNumber+"'";
			iLogger.info("ServiceDetailsBO:setServiceCloserDetails:AssetEventID :"+assetEventId+" : Updating Asset_Event_Snapshot table : "+updateAESQ);
			prodConnAESQ = connMySql.getConnection();
			stmntAESQ = prodConnAESQ.createStatement();
			int row = stmntAESQ.executeUpdate(updateAESQ);
			if(row>0){
				iLogger.info("ServiceDetailsBO:setServiceCloserDetails:AssetEventID :"+assetEventId+" : Updated Asset_Event_Snapshot table : "+updateAESQ+" : Rows affected : "+row);

			}
			else{
				fLogger.fatal("ServiceDetailsBO:setServiceCloserDetails: Error while updating asset_event_snapshot table.");
			}
			
			//DF20190315:Abhishek Deshmukh:: To close the service in MDA Reports.
			String moolStatus = setServiceClouserMoolDAReports(serialNumber,assetEventId, countryCode, eventId ,eventSeverity, eventGeneratedTime, servicedDate);
			
			if((moolStatus.equalsIgnoreCase("FAILURE")||moolStatus.contains("FAILURE"))&&assetEventId!=0){
				iLogger.info("ServiceDetailsBO:setServiceCloserDetails:AssetEventID :"+assetEventId+" : Inserting Record in Service_Clouser_MoolDA_Failure table ");
				  prodConn1 = connMySql.getConnection();
				  stmnt1 = prodConn1.createStatement();
				  String service_Clouser="Insert into Service_Clouser_MoolDA_Failure values(?,?,?,?,?,?,?,?)";
				  iLogger.info("MDA FleetSummaryService :: Query for inserttion in Service_Clouser_MoolDA_Failure :"+service_Clouser);
				  preparedStmt_1 = prodConn1.prepareStatement(service_Clouser);
				  preparedStmt_1.setString (1, Integer.toString(assetEventId));
				  preparedStmt_1.setString (2, countryCode);
				  preparedStmt_1.setString (3, serialNumber);
				  preparedStmt_1.setString (4, eventSeverity);
				  preparedStmt_1.setInt (5, eventId);
				  preparedStmt_1.setString(6, eventGeneratedTime);
				  preparedStmt_1.setString (7, servicedDate);
				  preparedStmt_1.setString (8, "Dummy");
				  preparedStmt_1.executeUpdate();
				  iLogger.info("ServiceDetailsBO:setServiceCloserDetails:AssetEventID :"+assetEventId+": Record inserted  in table "+service_Clouser);
				
	           iLogger.info("ServiceDetailsBO:setServiceCloserDetails:AssetEventID "+assetEventId+"   - END");			  	
			}
		} 			 

		catch(CustomFault e)
		{

			try
			{
				if(session.isOpen())
					if(session.getTransaction().isActive())
					{
						session.getTransaction().rollback();
					}
			}
			catch(Exception e1)
			{
				//DF20150603 - Rajani Nagaraju - WISE going down issue - Adding try catch against commit
				fLogger.fatal("Exception in Rolling back the transaction:"+e1);
			}

			status = "FAILURE-"+e.getFaultInfo();
			bLogger.error("EA Processing: AssetServiceDetails: "+messageId+" : "+e.getFaultInfo());
			
		}

		catch(Exception e)
		{
			try{
				if(session.isOpen())
					if(session.getTransaction().isActive())
					{
						session.getTransaction().rollback();
					}
			}
			catch(Exception e1)
			{
				//DF20150603 - Rajani Nagaraju - WISE going down issue - Adding try catch against commit
				fLogger.fatal("Exception in Rolling back the transaction:"+e1);
			}


			status = "FAILURE-"+e.getMessage();
			fLogger.fatal("EA Processing: AssetServiceDetails: "+messageId+ " Fatal Exception :"+e);
		}	 

		finally
		{
			if(session.isOpen())
			{
				session.flush();
				session.close();
			}
			if(prodConnAESQ!=null)
				try {
					prodConnAESQ.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			if(stmntAESQ!=null)
				try {
					stmntAESQ.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			if(prodConn1!=null)
				try {
					prodConn1.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			if(stmnt1!=null)
				try {
					stmnt1.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			if(preparedStmt_1!=null)
				try {
					preparedStmt_1.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
		}
		//Commenting below part since orientdb is not getting used 
		//DF20160513 - Rajani Nagaraju - Update Service Completion details to close the Alert in OrientAppDB - TAlertTxn (Graph Model)
		/* iLogger.info("EA Processing: ServiceCompletion: "+messageId+ ": Update Alert details in OrientAppDB");
		 String messageString = serialNumber+"|"+dealerCode+"|"+jobCardNumber+"|"+dbmsPartCode+"|"+servicedDate;
		String orientdbStatus = new EADataPopulationBO().ServiceCompletion(messageId, messageId, messageString);
		iLogger.info("EA Processing: ServiceCompletion:  "+messageId+ ": Update Alert details in OrientAppDB OrientAppDB Status:"+orientdbStatus);*/

		return status;		
	}
	
	
	
	//DF20190311:AB369654::For closing MoolDA Reports.
		public String setServiceClouserMoolDAReports(String serialNumber,int assetEventId, String countryCode, int eventID,String eventSeverity,String eventGeneratedTime, String serviceDate) {
			
			OutputStream os = null;
			String output="SUCCESS";
			Logger fLogger = FatalLoggerClass.logger;
			Logger iLogger= InfoLoggerClass.logger;
			BufferedReader br = null;
			String result = null;
			//String eventGeneratedTime_1=eventGeneratedTime.substring(0, eventGeneratedTime.length()-2);
			if(countryCode==null){
				countryCode="+91";
			}
			 iLogger.info("ServiceDetailsBO:setServiceClouserMoolDAReports::Input for closing MoolDA reports: serialNumber: "+serialNumber+" assetEventId: "+Integer.toString(assetEventId)+" countryCode: "+countryCode+" eventID: "+eventID+" eventSeverity: "+eventSeverity+" eventGeneratedTime: "+eventGeneratedTime+" eventClosureTime: "+serviceDate);

			/*ConnectMySQL connMySql = new ConnectMySQL();
			Connection conn = null;
			Statement stmt = null;
			ResultSet rs = null;
			String serialNumber = null;
			String assetEventId = null;
			String countryCode = null;
			String eventSeverity = null;
			int eventID = 0;
			String eventGeneratedTime = null;
			String serviceDate = null;
			String loginId = null;
			 
			
			
			Stack<String> del_assetEventId = new Stack<String>();*/
			try
			{
						/*conn = connMySql.getConnection();
						stmt = conn.createStatement();
						String sel_Query="select * from Service_Clouser_MoolDA_Failure";
						rs = stmt.executeQuery(sel_Query);
						while(rs.next())
						{
							assetEventId = rs.getString("assetEventId");
							countryCode = rs.getString("countryCode");
							serialNumber = rs.getString("serialNumber");
							eventSeverity = rs.getString("eventSeverity");
							eventID = rs.getInt("eventID");
							eventGeneratedTime = rs.getString("eventGeneratedTime");
							serviceDate = rs.getString("serviceDate");
							loginId = rs.getString("loginId");
							 iLogger.info("ServiceClouserReportUpdateImpl:setServiceCloserDetails:AssetEventID :"+assetEventId+":login :"+loginId+": Calling MoolDA AlertClosureService Reports ");*/
							 JSONObject json = new JSONObject();
						 	 json.put("uniqueIdentifier",Integer.toString(assetEventId));
						 	 json.put("countryCode",countryCode);
						 	 json.put("assetID",serialNumber);
						 	 json.put("eventSeverity",eventSeverity);
						 	 json.put("eventID",Integer.toString(eventID));
						 	 json.put("eventGenerationTime",eventGeneratedTime);
						 	 json.put("eventClosureTime",serviceDate+" 00:00:00");
						 	 json.put("loginID","Dummy");
						 	 String request=json.toString();
						 	 String URL= "http://10.179.12.25:26030/MoolDAReports/AlertClosureService/triggerAlertClosure";//PROD 
						 	 //String URL= "http://10.106.68.9:8112/MoolDAReports/AlertClosureService/triggerAlertClosure";//SIT			 
						 	 URL url = new URL(URL);
						 	 HttpURLConnection connection = (HttpURLConnection) url.openConnection();
						 	 connection.setDoOutput(true);
						 	 connection.setRequestMethod("POST");
						 	 connection.setRequestProperty("Content-Type", "application/json");
						 	 os = (OutputStream) connection.getOutputStream();
						 	 os.write(request.getBytes());
						 	 os.flush();
						 	 iLogger.info("setServiceCloserDetails:setServiceCloserDetails:AssetEventID::---> HTTP code from MoolDA :"+connection.getResponseCode());
						 	 if (connection.getResponseCode() != 200 && connection.getResponseCode() != 204) {
						 		output="FAILURE";
						 		iLogger.info("MDAReports report status: FAILURE for setServiceCloserDetails Service Report ::Response Code:"+connection.getResponseCode());
						 		fLogger.fatal("setServiceCloserDetails:setServiceCloserDetails:AssetEventID :"+assetEventId+" Failed : HTTP error code :  Response: "+connection.getResponseCode()+" :Exception caused because of no response from MOOLDA URL:"+url+" Request:"+request+" output:"+output);
								//throw new RuntimeException("Failed : HTTP error code : " + connection.getResponseCode());
								return output;
						 	 }
						 	iLogger.info("MDAReports report status: SUCCESS for setServiceCloserDetails Service Report ::Response Code:"+connection.getResponseCode());	
						 	
						 	 br = new BufferedReader(new InputStreamReader((connection.getInputStream())));
						 	 while ((result = br.readLine()) != null) {
						 		 output = result.toUpperCase();
						 	 }
						 	 iLogger.info("setServiceCloserDetails:setServiceCloserDetails:AssetEventID :"+assetEventId+" MoolDA Report response :"+output);
						 	 
						
						
			}
			catch(Exception e)
			{
				output="FAILURE";
				fLogger.fatal("setServiceCloserDetails:setServiceCloserDetails:AssetEventID :"+assetEventId+":Exception"+e.getMessage());
				return output;
			}
			finally
			{
				if(os!=null)
					try {
						os.close();
					} catch (IOException e1) {
						e1.printStackTrace();
					}
				if(br!=null)
					try {
						br.close();
					} catch (IOException e1) {
						e1.printStackTrace();
					}
				
			}
				return output;
}


	/*	 public String setServiceDetails(String serialNumber, String dealerCode, String jobCardNumber,String dbmsPartCode, String servicedDate, String messageId)
	 {
		 String status ="SUCCESS-Record Processed";

		 //Logger fatalError = Logger.getLogger("fatalErrorLogger");
		 //Logger businessError = Logger.getLogger("businessErrorLogger");

	    Logger fLogger = FatalLoggerClass.logger;

	    Logger bLogger = BusinessErrorLoggerClass.logger; 
		Session session = HibernateUtil.getSessionFactory().getCurrentSession();
		 Logger iLogger = InfoLoggerClass.logger;
		//DF20150603 - Rajani Nagaraju - WISE going down issue - Open a new session when the getCurrentSession returns a dirty session(txns which is not yet committed exists)
		if(session.getTransaction().isActive() && session.isDirty())
		{
		   	iLogger.info("Opening a new session");
		   	session = HibernateUtil.getSessionFactory().openSession();
		}
		 session.beginTransaction();

		 try
		 {
			 //Validate the serialNumber
			 DomainServiceImpl domainService = new DomainServiceImpl();
			 AssetEntity assetEntity = domainService.getAssetEntity(serialNumber);

			 //DF20150608 - Rajani Nagaraju - Session Closed Exception on processing service history record
			 AssetEntity assetEntity=null;

			 Query serialNumQ = session.createQuery(" from AssetEntity where serial_number='"+serialNumber+"'");
			 Iterator serialNumItr = serialNumQ.list().iterator();
			 while(serialNumItr.hasNext())
			 {
				 assetEntity = (AssetEntity)serialNumItr.next();
			 }

			 if(assetEntity==null || assetEntity.getSerial_number()==null)
			 {
				if(serialNumber.trim().length() >7)
				{
							serialNumber = serialNumber.substring(serialNumber.length()-7 , serialNumber.length());
				}



				//DF20140715 - Rajani Nagaraju - Remove Preceeding zeros in Machine Number
				serialNumber=serialNumber.replaceFirst("^0+(?!$)", "");
				Query qryMacNo =session.createQuery("from AssetEntity a where a.machineNumber='"+serialNumber+"'");
				Iterator itrMacNo=qryMacNo.list().iterator();
				while(itrMacNo.hasNext())
				{
					assetEntity = (AssetEntity) itrMacNo.next();		

					//DF20140805 - Rajani Nagaraju - Updating Serial Number from Machine Number
					serialNumber=assetEntity.getSerial_number().getSerialNumber();
				}

			 }

			 if(assetEntity==null || assetEntity.getSerial_number()==null)
			 {
					AssetControlUnitEntity assetControl=null;
					Query assetControlQ = session.createQuery(" from AssetControlUnitEntity where serialNumber like '%"+serialNumber+"%'");
					Iterator assetControlItr = assetControlQ.list().iterator();
					while(assetControlItr.hasNext())
					{
						assetControl= (AssetControlUnitEntity)assetControlItr.next();
					}

					if(assetControl==null)
					{
						status = "FAILURE-PIN Registration Data not received";
						bLogger.error("EA Processing: AssetServiceDetails: "+messageId+" : PIN Registration Data not received");
						return status;
					}
					else
					{
						status = "FAILURE-Roll off Data not received";
						bLogger.error("EA Processing: AssetServiceDetails: "+messageId+" : Roll off Data not received");
						return status;
					}

			 }

			 //Validate DealerCode - Get the dealer Entity for the given dealerCode
			 Query dealerQuery = session.createQuery("from AccountEntity where status=true and accountCode='"+dealerCode+"'");
			 Iterator itr = dealerQuery.list().iterator();
			 AccountEntity dealerEntity = null;
			 while(itr.hasNext())
			 {
				 dealerEntity = (AccountEntity) itr.next();
			 }

			 if(dealerEntity==null)
			 {
				 throw new CustomFault("Dealer Master data is not received for the Dealer:"+dealerCode);
			 }


			 //Parse the serviced date
			 SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
			 Timestamp vinServicedDate =null;
			 try
			 {
				 vinServicedDate = new Timestamp(dateFormat.parse(servicedDate).getTime());
			 }
			 catch(Exception e)
			 {
				 status = "FAILURE-"+e.getMessage();
				 bLogger.error("EA Processing: AssetServiceDetails: "+messageId+" : Date Parse Exception for Serviced Date"+e);
				 return status;
			 }

			 //Check if there are any Active Service Alert for the VIN
			 int ServiceEventTypeId = 0;
			 Properties prop = new Properties();
			 prop.load(getClass().getClassLoader().getResourceAsStream("remote/wise/resource/properties/configuration.properties"));
			 ServiceEventTypeId= Integer.parseInt(prop.getProperty("ServiceEventTypeId"));
			 //int flag =0;

			 //DF20150923 - Rajani Nagaraju - JCB0321,JCB0339 Service Alert Completion should close all the active service alerts for previous scehdules (if any) as well
			 //Also there was a problem in wrong serviceNames getting updated in ServiceHistory record
			 //-----------------STEP 1: Get the List of service schedules for which the active alert has to be closed
			 Query serviceListQ = session.createQuery("select b from AssetServiceScheduleEntity a, ServiceScheduleEntity b" +
			 		" where a.serviceScheduleId=b.serviceScheduleId and a.serialNumber='"+serialNumber+"'" +
			 		" order by b.engineHoursSchedule desc ");
			 Iterator serviceListItr = serviceListQ.list().iterator();
			 List<String> scheduleIdList = new LinkedList<String>();
			 String serviceName = null;
			 String scheduleName =null;

			 int addRec=0;
			 while(serviceListItr.hasNext())
			 {
				 ServiceScheduleEntity serviceSch = (ServiceScheduleEntity)serviceListItr.next();
				 if(serviceSch.getDbmsPartCode().equalsIgnoreCase(dbmsPartCode))
				 {
					 addRec=1;
				//	 scheduleIdList.add(String.valueOf(serviceSch.getServiceScheduleId()));

					 serviceName = serviceSch.getServiceName();
					 scheduleName = serviceSch.getScheduleName();
				 }

				 if(addRec==1)
					 scheduleIdList.add(String.valueOf(serviceSch.getServiceScheduleId()));

			 }

			 if(scheduleIdList.isEmpty())
			 {
				 fLogger.fatal("No service schedule defined for the VIN with the given DBMS part Code");
				 status = "FAILURE-No service schedule defined for the VIN with the given DBMS part Code";
				 return status;

				 throw new CustomFault("No service schedule defined for the VIN with the given DBMS part Code and the CallTypeId");
			 }


			//-----------------STEP 2: Close any active service alert on the machine for the schedules <= current received schedule
			ListToStringConversion conversionObj = new  ListToStringConversion();
			String scheduleIdListAsString = conversionObj.getStringList(scheduleIdList).toString();
			Query alertClosureQ = session.createQuery(" from AssetEventEntity where serialNumber='"+serialNumber+"' and eventTypeId="+ServiceEventTypeId +
					" and activeStatus=1 and serviceScheduleId in ("+scheduleIdListAsString+")");
			Iterator alertClosureItr = alertClosureQ.list().iterator();
			while(alertClosureItr.hasNext())
			{
				AssetEventEntity assetEvent = (AssetEventEntity)alertClosureItr.next();
				assetEvent.setActiveStatus(0);
				assetEvent.setEventClosedTime(new Timestamp(new Date().getTime()));
				session.save(assetEvent);
			}

			Properties prop1 = new Properties();
			Properties prop2 = new Properties();
			int engineHoursId = 0;
			try {
				prop1.load(getClass().getClassLoader().getResourceAsStream("remote/wise/resource/properties/configuration.properties"));
				IndustryBO industryBoObj = new IndustryBO();
				clientId = industryBoObj.getClientEntity(prop1.getProperty("ClientName")).getClient_id();

				prop2.load(getClass().getClassLoader().getResourceAsStream("remote/wise/resource/properties/configuration.properties"));

				engineHours= prop2.getProperty("TotalEngineHours");
				if(session == null || !session.isOpen()){
					session = new HibernateUtil().getSessionFactory().openSession();
					session.beginTransaction();
				}
				itr = session.createQuery("select max(a.parameterId), a.parameterName " +
						" from MonitoringParameters a " +
						" where parameterName in " +
							"( '"
							+ engineHours
							+ "')"
							+ " group by a.parameterName"
							+ " order by a.parameterId").list().iterator();

				Object[] resultObj = null;

				while (itr.hasNext()) {
					resultObj = (Object[]) itr.next();

					if ( ((String)resultObj[1]).equalsIgnoreCase(engineHours) ) {
						engineHoursId = (Integer) resultObj[0]; 
					}

				} // End of itr
			//	engineON= prop2.getProperty("EngineON");
			}catch(Exception e){
					e.printStackTrace();
				}
			finally {
				if(session!=null || session.isOpen())
				session.close();
			}
			//using DAL Layer to get the amh from dynamic amh table 
			 Calendar cal = Calendar.getInstance();
			 cal.setTime(dateStr.parse(servicedDate));

			 Timestamp txnTimestamp = new Timestamp(cal.getTimeInMillis());
			List parametreIDList = new LinkedList();
			parametreIDList.add(engineHoursId);
			DynamicAMH_DAL dalObj = new DynamicAMH_DAL();
			String cmh = dalObj.getLatestCMH(serialNumber, txnTimestamp,segmentID, parametreIDList);

			//-----------------STEP 3: Insert/Update the record for Service Completion into ServiceHistory tables

			if(session == null || !session.isOpen()){
				session = new HibernateUtil().getSessionFactory().openSession();
				session.beginTransaction();
			}

			//-----------------STEP 3: Insert/Update the record for Service Completion into ServiceHistory tables
			 Query serviceCompletionQ = session.createQuery("from ServiceHistoryEntity where serviceTicketNumber='"+jobCardNumber+"'");
			 Iterator serviceCompletionItr = serviceCompletionQ.list().iterator();

			 int update=0;
			 while(serviceCompletionItr.hasNext())
			 {
				 update=1;

				 ServiceHistoryEntity serviceHistoryObj = (ServiceHistoryEntity)serviceCompletionItr.next();
				 if( ! (serviceHistoryObj.getSerialNumber().getSerial_number().getSerialNumber().equalsIgnoreCase(serialNumber)) )
				 {
					 throw new CustomFault("Same JobCardNumber Details exists for different VIN");
				 }
				 serviceHistoryObj.setDealerId(dealerEntity);
				 serviceHistoryObj.setServiceDate(vinServicedDate);
				 serviceHistoryObj.setDbmsPartCode(dbmsPartCode);
				 serviceHistoryObj.setServiceName(serviceName);
				 serviceHistoryObj.setScheduleName(scheduleName);

				 session.update(serviceHistoryObj);
			 }


			 if(update==0)
			 {
				 ServiceHistoryEntity newServiceRecord = new ServiceHistoryEntity();
				 newServiceRecord.setSerialNumber(assetEntity);
				 newServiceRecord.setServiceTicketNumber(jobCardNumber);
				 newServiceRecord.setDealerId(dealerEntity);
				 newServiceRecord.setServiceDate(vinServicedDate);
				 newServiceRecord.setDbmsPartCode(dbmsPartCode);
				 newServiceRecord.setServiceName(serviceName);
				 newServiceRecord.setScheduleName(scheduleName);

				 session.save(newServiceRecord);
			 }






			 Query q = session.createQuery(" from AssetEventEntity where serialNumber='"+serialNumber+"' and eventTypeId="+ServiceEventTypeId+" " +
			 		" and activeStatus=1 ");
			 Iterator it = q.list().iterator();
			 while(it.hasNext())
			 {
				 assetEvt = (AssetEventEntity)it.next();
				 String serviceName = null;
				 String scheduleName =null;
				 flag =1;

				 //Check for the valid service history record received
				 if(assetEvt!=null)
				 {
					 String dbmsPartCodeDef = null;
					 Query serviceSchQuery = session.createQuery("from ServiceScheduleEntity where serviceScheduleId="+assetEvt.getServiceScheduleId());
					 Iterator serviceSchItr = serviceSchQuery.list().iterator();
					 while(serviceSchItr.hasNext())
					 {
						 ServiceScheduleEntity serSch = (ServiceScheduleEntity)serviceSchItr.next();
						 dbmsPartCodeDef = serSch.getDbmsPartCode();
						 serviceName = serSch.getServiceName();
						 scheduleName = serSch.getScheduleName();
					 }

					 //DF20150116 - Rajani Nagaraju - Remove the condition of Ignoring the service details record if service record is received for previous service alerts but different alert is raised in LL
					 if( (dbmsPartCodeDef==null) || (!(dbmsPartCodeDef.equalsIgnoreCase(dbmsPartCode))) )
					 {
						 throw new CustomFault("Invalid Service Details received, Service Alert is raised in LL for different DBMS part code");
					 }

					 //Nullify the assetEvent
					 else
					 if((dbmsPartCodeDef!=null) && (dbmsPartCodeDef.equalsIgnoreCase(dbmsPartCode)))
					 {
						 assetEvt.setActiveStatus(0);
						 assetEvt.setEventClosedTime(new Timestamp(new Date().getTime()));
						 session.save(assetEvt);
					 }


				 }


				 else
				 {
					 if(assetEntity.getProductId()==null || assetEntity.getProductId().getAssetGroupId()==null || assetEntity.getProductId().getAssetTypeId()==null
							 || assetEntity.getProductId().getEngineTypeId()==null)
					 {
						 throw new CustomFault("Product details not available for the VIN");
					 }
					 //get the service name and schedule Name
					 Query masterServSchQuery = session.createQuery("from ServiceScheduleEntity where dbmsPartCode='"+dbmsPartCode+"'" +
					 		" and assetGroupId="+assetEntity.getProductId().getAssetGroupId().getAsset_group_id()+" and " +
					 				" assetTypeId="+assetEntity.getProductId().getAssetTypeId().getAsset_type_id()+" and " +
					 						" engineTypeId="+assetEntity.getProductId().getEngineTypeId().getEngineTypeId());
					 Iterator masterServSchItr = masterServSchQuery.list().iterator();
					 int present =0;

					 while(masterServSchItr.hasNext())
					 {
						 present=1;
						 ServiceScheduleEntity serviceSchedule = (ServiceScheduleEntity)masterServSchItr.next();
						 serviceName = serviceSchedule.getServiceName();
						 scheduleName = serviceSchedule.getScheduleName();
					 }

					 //No service schedule defined for the specific product
					 if(present==0)
					 {
						 throw new CustomFault("No service schedule defined for the product with the given DBMS part Code");
					 }
				 } 

				//Insert/update the service history record
				 Query query = session.createQuery("from ServiceHistoryEntity where serviceTicketNumber='"+jobCardNumber+"'");
				 Iterator itrtr = query.list().iterator();

				 int update=0;

				 while(itrtr.hasNext())
				 {
					 update=1;

					 ServiceHistoryEntity serviceHistoryObj = (ServiceHistoryEntity)itrtr.next();
					 if( ! (serviceHistoryObj.getSerialNumber().getSerial_number().getSerialNumber().equalsIgnoreCase(serialNumber)) )
					 {
						 throw new CustomFault("Same JobCardNumber Details exists for different VIN");
					 }
					 serviceHistoryObj.setDealerId(dealerEntity);
					 serviceHistoryObj.setServiceDate(vinServicedDate);
					 serviceHistoryObj.setDbmsPartCode(dbmsPartCode);
					 serviceHistoryObj.setServiceName(serviceName);
					 serviceHistoryObj.setScheduleName(scheduleName);

					 session.update(serviceHistoryObj);
				 }


				 if(update==0)
				 {
					 ServiceHistoryEntity newServiceRecord = new ServiceHistoryEntity();
					 newServiceRecord.setSerialNumber(assetEntity);
					 newServiceRecord.setServiceTicketNumber(jobCardNumber);
					 newServiceRecord.setDealerId(dealerEntity);
					 newServiceRecord.setServiceDate(vinServicedDate);
					 newServiceRecord.setDbmsPartCode(dbmsPartCode);
					 newServiceRecord.setServiceName(serviceName);
					 newServiceRecord.setScheduleName(scheduleName);

					 session.save(newServiceRecord);
				 }
			 }

			 //DefectId:20150805 @Suprava Insert/update serviceHistory Details when assetEvent has no Entry 
			 if(assetEvt==null && flag ==0){
				 String serviceName = null;
				 String scheduleName =null;
				 iLogger.info("Insert/update serviceHistory Details when assetEvent has no Entry");
				 if(assetEntity.getProductId()==null || assetEntity.getProductId().getAssetGroupId()==null || assetEntity.getProductId().getAssetTypeId()==null
							 || assetEntity.getProductId().getEngineTypeId()==null)
					 {
						 throw new CustomFault("Product details not available for the VIN");
					 }
					 //get the service name and schedule Name
					 Query masterServSchQuery = session.createQuery("from ServiceScheduleEntity where dbmsPartCode='"+dbmsPartCode+"'" +
					 		" and assetGroupId="+assetEntity.getProductId().getAssetGroupId().getAsset_group_id()+" and " +
					 				" assetTypeId="+assetEntity.getProductId().getAssetTypeId().getAsset_type_id()+" and " +
					 						" engineTypeId="+assetEntity.getProductId().getEngineTypeId().getEngineTypeId());
					 Iterator masterServSchItr = masterServSchQuery.list().iterator();
					 int present =0;

					 while(masterServSchItr.hasNext())
					 {
						 present=1;
						 ServiceScheduleEntity serviceSchedule = (ServiceScheduleEntity)masterServSchItr.next();
						 serviceName = serviceSchedule.getServiceName();
						 scheduleName = serviceSchedule.getScheduleName();
					 }

					 //No service schedule defined for the specific product
					 if(present==0)
					 {
						 throw new CustomFault("No service schedule defined for the product with the given DBMS part Code");
					 }
					 iLogger.info("serviceName & scheduleName:"+serviceName+"+"+scheduleName); 
				//Insert/update the service history record
				 Query query = session.createQuery("from ServiceHistoryEntity where serviceTicketNumber='"+jobCardNumber+"'");
				 Iterator itrtr = query.list().iterator();

				 int update=0;

				 while(itrtr.hasNext())
				 {
					 update=1;

					 ServiceHistoryEntity serviceHistoryObj = (ServiceHistoryEntity)itrtr.next();
					 if( ! (serviceHistoryObj.getSerialNumber().getSerial_number().getSerialNumber().equalsIgnoreCase(serialNumber)) )
					 {
						 throw new CustomFault("Same JobCardNumber Details exists for different VIN");
					 }
					 serviceHistoryObj.setDealerId(dealerEntity);
					 serviceHistoryObj.setServiceDate(vinServicedDate);
					 serviceHistoryObj.setDbmsPartCode(dbmsPartCode);
					 serviceHistoryObj.setServiceName(serviceName);
					 serviceHistoryObj.setScheduleName(scheduleName);

					 session.update(serviceHistoryObj);
				 }


				 if(update==0)
				 {
					 ServiceHistoryEntity newServiceRecord = new ServiceHistoryEntity();
					 newServiceRecord.setSerialNumber(assetEntity);
					 newServiceRecord.setServiceTicketNumber(jobCardNumber);
					 newServiceRecord.setDealerId(dealerEntity);
					 newServiceRecord.setServiceDate(vinServicedDate);
					 newServiceRecord.setDbmsPartCode(dbmsPartCode);
					 newServiceRecord.setServiceName(serviceName);
					 newServiceRecord.setScheduleName(scheduleName);

					 session.save(newServiceRecord);
				 }

			 }

			 String serviceName = null;
			 String scheduleName =null;

			 //Check for the valid service history record received
			 if(assetEvt!=null)
			 {
				 String dbmsPartCodeDef = null;
				 Query serviceSchQuery = session.createQuery("from ServiceScheduleEntity where serviceScheduleId="+assetEvt.getServiceScheduleId());
				 Iterator serviceSchItr = serviceSchQuery.list().iterator();
				 while(serviceSchItr.hasNext())
				 {
					 ServiceScheduleEntity serSch = (ServiceScheduleEntity)serviceSchItr.next();
					 dbmsPartCodeDef = serSch.getDbmsPartCode();
					 serviceName = serSch.getServiceName();
					 scheduleName = serSch.getScheduleName();
				 }

				 //DF20150116 - Rajani Nagaraju - Remove the condition of Ignoring the service details record if service record is received for previous service alerts but different alert is raised in LL
				 if( (dbmsPartCodeDef==null) || (!(dbmsPartCodeDef.equalsIgnoreCase(dbmsPartCode))) )
				 {
					 throw new CustomFault("Invalid Service Details received, Service Alert is raised in LL for different DBMS part code");
				 }

				 //Nullify the assetEvent
				 else
				 if((dbmsPartCodeDef!=null) && (dbmsPartCodeDef.equalsIgnoreCase(dbmsPartCode)))
				 {
					 assetEvt.setActiveStatus(0);
					 assetEvt.setEventClosedTime(new Timestamp(new Date().getTime()));
					 session.save(assetEvt);
				 }


			 }


			 else
			 {
				 if(assetEntity.getProductId()==null || assetEntity.getProductId().getAssetGroupId()==null || assetEntity.getProductId().getAssetTypeId()==null
						 || assetEntity.getProductId().getEngineTypeId()==null)
				 {
					 throw new CustomFault("Product details not available for the VIN");
				 }
				 //get the service name and schedule Name
				 Query masterServSchQuery = session.createQuery("from ServiceScheduleEntity where dbmsPartCode='"+dbmsPartCode+"'" +
				 		" and assetGroupId="+assetEntity.getProductId().getAssetGroupId().getAsset_group_id()+" and " +
				 				" assetTypeId="+assetEntity.getProductId().getAssetTypeId().getAsset_type_id()+" and " +
				 						" engineTypeId="+assetEntity.getProductId().getEngineTypeId().getEngineTypeId());
				 Iterator masterServSchItr = masterServSchQuery.list().iterator();
				 int present =0;

				 while(masterServSchItr.hasNext())
				 {
					 present=1;
					 ServiceScheduleEntity serviceSchedule = (ServiceScheduleEntity)masterServSchItr.next();
					 serviceName = serviceSchedule.getServiceName();
					 scheduleName = serviceSchedule.getScheduleName();
				 }

				 //No service schedule defined for the specific product
				 if(present==0)
				 {
					 throw new CustomFault("No service schedule defined for the product with the given DBMS part Code");
				 }
			 } 

			 //Insert/update the service history record
			 Query query = session.createQuery("from ServiceHistoryEntity where serviceTicketNumber='"+jobCardNumber+"'");
			 Iterator itrtr = query.list().iterator();

			 int update=0;

			 while(itrtr.hasNext())
			 {
				 update=1;

				 ServiceHistoryEntity serviceHistoryObj = (ServiceHistoryEntity)itrtr.next();
				 if( ! (serviceHistoryObj.getSerialNumber().getSerial_number().getSerialNumber().equalsIgnoreCase(serialNumber)) )
				 {
					 throw new CustomFault("Same JobCardNumber Details exists for different VIN");
				 }
				 serviceHistoryObj.setDealerId(dealerEntity);
				 serviceHistoryObj.setServiceDate(vinServicedDate);
				 serviceHistoryObj.setDbmsPartCode(dbmsPartCode);
				 serviceHistoryObj.setServiceName(serviceName);
				 serviceHistoryObj.setScheduleName(scheduleName);

				 session.update(serviceHistoryObj);
			 }


			 if(update==0)
			 {
				 ServiceHistoryEntity newServiceRecord = new ServiceHistoryEntity();
				 newServiceRecord.setSerialNumber(assetEntity);
				 newServiceRecord.setServiceTicketNumber(jobCardNumber);
				 newServiceRecord.setDealerId(dealerEntity);
				 newServiceRecord.setServiceDate(vinServicedDate);
				 newServiceRecord.setDbmsPartCode(dbmsPartCode);
				 newServiceRecord.setServiceName(serviceName);
				 newServiceRecord.setScheduleName(scheduleName);

				 session.save(newServiceRecord);
			 }

			 if(session.isOpen())
				 if(session.getTransaction().isActive())
				 {
					 session.getTransaction().commit();
				 }

		 } 			 

		 catch(CustomFault e)
		 {

			 try
			 {
				 if(session.isOpen())
					 if(session.getTransaction().isActive())
			         {
			        	 session.getTransaction().rollback();
			         }
			 }
			 catch(Exception e1)
			 {
				//DF20150603 - Rajani Nagaraju - WISE going down issue - Adding try catch against commit
				 fLogger.fatal("Exception in Rolling back the transaction:"+e1);
			 }

			 status = "FAILURE-"+e.getFaultInfo();
			  bLogger.error("EA Processing: AssetServiceDetails: "+messageId+" : "+e.getFaultInfo());
		 }

		 catch(Exception e)
		 {
			try{
			 if(session.isOpen())
				if(session.getTransaction().isActive())
	            {
	                 session.getTransaction().rollback();
	            }
			}
			catch(Exception e1)
			 {
				//DF20150603 - Rajani Nagaraju - WISE going down issue - Adding try catch against commit
				 fLogger.fatal("Exception in Rolling back the transaction:"+e1);
			 }


			status = "FAILURE-"+e.getMessage();
			fLogger.fatal("EA Processing: AssetServiceDetails: "+messageId+ " Fatal Exception :"+e);
		 }	 

		 finally
        {
              if(session.isOpen())
              {
                    session.flush();
                    session.close();
              }

        }

		//DF20160513 - Rajani Nagaraju - Update Service Completion details to close the Alert in OrientAppDB - TAlertTxn (Graph Model)
		 iLogger.info("EA Processing: ServiceCompletion: "+messageId+ ": Update Alert details in OrientAppDB");
		 String messageString = serialNumber+"|"+dealerCode+"|"+jobCardNumber+"|"+dbmsPartCode+"|"+servicedDate;
		 String orientdbStatus = new EADataPopulationBO().ServiceCompletion(messageId, messageId, messageString);
		 iLogger.info("EA Processing: ServiceCompletion:  "+messageId+ ": Update Alert details in OrientAppDB OrientAppDB Status:"+orientdbStatus);

		 return status;

	}*/
	//**********************************************END of Set Service Details for a machine *************************************************************

	/*
	@SuppressWarnings({ "rawtypes", "unused" })
	public String setServiceDetails(String JobCardNumber, String ScheduleName,
			String ServiceName, String ServiceDate, String SerialNumber)
			throws CustomFault {

		Session session = HibernateUtil.getSessionFactory().openSession();
		session.beginTransaction();

		DomainServiceImpl domainService = new DomainServiceImpl();
		AssetEntity assetEntity = domainService.getAssetEntity(SerialNumber);

		Query q = session
				.createQuery("from ServiceHistoryEntity where serialNumber ='"
						+ SerialNumber + "'");
		Iterator itr = q.list().iterator();
		int updatenext = 0;
		while (itr.hasNext()) {
			ServiceHistoryEntity entityObj = (ServiceHistoryEntity) itr.next();
			if (entityObj.getServiceTicketNumber().equals(JobCardNumber))
				throw new CustomFault("Job card number already exists!! ");
			if ((entityObj.getServiceName().equals(ServiceName))
					&& (entityObj.getScheduleName().equals(ScheduleName)))
				throw new CustomFault(
						"Service Name and schedule name already exists!! ");

		}
		SimpleDateFormat dateFormat = new SimpleDateFormat(
				"yyyy-MM-dd hh:mm:ss.SSS");
		java.util.Date parsedDate;
		try {
			parsedDate = dateFormat.parse(ServiceDate);

			java.sql.Timestamp timestamp = new java.sql.Timestamp(
					parsedDate.getTime());

			ServiceHistoryEntity serviceObj = new ServiceHistoryEntity();
			serviceObj.setServiceTicketNumber(JobCardNumber);
			serviceObj.setServiceName(ServiceName);
			serviceObj.setScheduleName(ScheduleName);

			serviceObj.setServiceDate(timestamp);
			serviceObj.setSerialNumber(assetEntity);

			serviceObj.save();
		} catch (ParseException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return "SUCCESS";
	}  */


	//updating asset service schedule whenever the services are extended in service schedules per product
	public String updateAssetServiceSchedules(List<ProductEntity> products) {
		// TODO Auto-generated method stub
		Logger fLogger = FatalLoggerClass.logger;
		Logger iLogger = InfoLoggerClass.logger;
		String status = "";
		Logger bLogger = BusinessErrorLoggerClass.logger;
		boolean flag = true;
		Session session = HibernateUtil.getSessionFactory().getCurrentSession();
		try{
			session.beginTransaction();
			for(int i=0;i<products.size();i++)
			{
				//get the Service Schedule defined for the product to which the machine belongs to
				LinkedHashMap<ServiceScheduleEntity, Integer> servSchDurationMap = new LinkedHashMap<ServiceScheduleEntity, Integer>();
				//-- Key - Service Schedule Entity, Value - Duration Schedule defined (In Days)
				HashMap<Integer, ServiceScheduleEntity> servSchIDEntityMap = new HashMap<Integer, ServiceScheduleEntity>();
				//-- Key - Service Schedule Id, Value - Service Schedule Entity
				Query q = session.createQuery(" from ServiceScheduleEntity where assetGroupId="+products.get(i).getAssetGroupId().getAsset_group_id()+" and " +
						" assetTypeId="+products.get(i).getAssetTypeId().getAsset_type_id()+" and engineTypeId="+products.get(i).getEngineTypeId().getEngineTypeId()+" " +
						" order by durationSchedule");
				List<Integer> ServicesIdsList = new LinkedList<Integer>();
				Iterator itrtr = q.list().iterator();
				while(itrtr.hasNext())
				{
					ServiceScheduleEntity serviceSchedule = (ServiceScheduleEntity)itrtr.next();
					servSchDurationMap.put(serviceSchedule, serviceSchedule.getDurationSchedule());
					servSchIDEntityMap.put(serviceSchedule.getServiceScheduleId(), serviceSchedule);
					ServicesIdsList.add(serviceSchedule.getServiceScheduleId());
				}



				if(servSchDurationMap.isEmpty())
				{
					status = "FAILURE-Service Schedule not defined for the product";
					throw new CustomFault("Service Schedule not defined for the product");
				}
				StringBuilder ServicesIdsListString = new ListToStringConversion().getIntegerListString(ServicesIdsList);
				Query existingVINQuery = session.createQuery("select assc.serialNumber" +
						" from AssetServiceScheduleEntity assc " +
						"where assc.serviceScheduleId in ("+ServicesIdsListString+") group by assc.serialNumber");

				Iterator itr = existingVINQuery.list().iterator();
				Object[] result = null;
				while(itr.hasNext())
				{

					AssetEntity SerialNumber = (AssetEntity) itr.next();
					//System.out.println(SerialNumber.getSerial_number().getSerialNumber());
					Query assetServSch = session.createQuery(" from AssetServiceScheduleEntity where serialNumber ='"+SerialNumber.getSerial_number().getSerialNumber()+"'");
					Iterator assetServSchItr = assetServSch.list().iterator();
					//System.out.println(SerialNumber.getSerial_number().getSerialNumber()+" size:"+assetServSch.list().size());
					//System.out.println("servSchDurationMap.size():"+servSchDurationMap.size());
					if(servSchDurationMap.size() == assetServSch.list().size())
					{
						continue;
					}
					Date VinInstallationDate = SerialNumber.getInstall_date();
					AccountEntity dealerEntity = null;
					LinkedHashMap<ServiceScheduleEntity, Integer> servSchDurationMapReplica = new LinkedHashMap<ServiceScheduleEntity, Integer>();
					servSchDurationMapReplica = servSchDurationMap;
					//System.out.println("servSchDurationMapReplica:"+servSchDurationMapReplica.size());
					while(assetServSchItr.hasNext())
					{	
						AssetServiceScheduleEntity assetService = (AssetServiceScheduleEntity) assetServSchItr.next();
						//System.out.println("id:"+assetService.getServiceScheduleId().getServiceScheduleId()+" size:"+servSchDurationMapReplica.size());
						dealerEntity = assetService.getDealerId();
						//Remove the record from servSchDurationMap - Since the data in AssetServiceSchedule is already updated
						if(servSchDurationMapReplica.containsKey(servSchIDEntityMap.get(assetService.getServiceScheduleId().getServiceScheduleId())))
						{
							servSchDurationMapReplica.remove(servSchIDEntityMap.get(assetService.getServiceScheduleId().getServiceScheduleId()));
						}
					}

					if(VinInstallationDate!=null){
						//Insert the records into AssetService Schedule
						for(int j=0; j<servSchDurationMapReplica.size(); j++)
						{
							flag = false;
							ServiceScheduleEntity servSch = (ServiceScheduleEntity)servSchDurationMapReplica.keySet().toArray()[j];
							int duration = (Integer)servSchDurationMapReplica.values().toArray()[j];
							//System.out.println("duration:"+duration+" vin date:"+VinInstallationDate);
							//get the scheduledDate
							Calendar c = Calendar.getInstance();
							c.setTime(VinInstallationDate);
							c.add(Calendar.DATE, duration);
							Timestamp scheduledDate = new Timestamp(c.getTime().getTime());
							if(dealerEntity!=null)
							{
								AssetServiceScheduleEntity assetServSchEnt = new AssetServiceScheduleEntity();
								assetServSchEnt.setDealerId(dealerEntity);
								assetServSchEnt.setScheduledDate(scheduledDate);
								assetServSchEnt.setSerialNumber(SerialNumber);		        			
								assetServSchEnt.setServiceScheduleId(servSch);
								assetServSchEnt.setEngineHoursSchedule(servSch.getEngineHoursSchedule());
								session.save(assetServSchEnt);
								status = "success";
							}

						}
					}
				}
			}
			if(flag)
				status = "SUCCESS";

		}catch(CustomFault ce){
			status = "FAILURE";

			try
			{
				if(session.isOpen())
					if(session.getTransaction().isActive())
					{
						session.getTransaction().rollback();
					}
			}
			catch(Exception e1)
			{
				fLogger.fatal("exception in rolling back the data "+e1.getMessage());
			}
			ce.printStackTrace();
		}
		catch(Exception e){
			status = "FAILURE";
			try
			{
				if(session.isOpen())
					if(session.getTransaction().isActive())
					{
						session.getTransaction().rollback();
					}
			}
			catch(Exception e1)
			{
				fLogger.fatal("fatal message:"+e1.getMessage());
			}
			e.printStackTrace();
		}
		finally
		{
			if(session.isOpen())
			{
				session.getTransaction().commit();
			}
			if(session.isOpen())
			{
				session.flush();
				session.close();
			}

		}
		return status;
	}


	//updating asset service schedule whenever the services are extended in service schedules
	//defectId 20151015 s suresh 
	public String updateAssetServiceSchedule(){
		String response = "FAILURE";
		Logger fLogger = FatalLoggerClass.logger;
		Logger iLogger = InfoLoggerClass.logger;
		String status = "";
		Logger bLogger = BusinessErrorLoggerClass.logger;
		Session session = HibernateUtil.getSessionFactory().getCurrentSession();
		List<ProductEntity> products = new LinkedList<ProductEntity>();
		try{
			session.beginTransaction();
			Query productsQuery = session.createQuery("select p from ServiceScheduleEntity s,ProductEntity p " +
					"where s.assetGroupId = p.assetGroupId and s.assetTypeId = p.assetTypeId " +
					"and s.engineTypeId = p.engineTypeId " +
					"group by p.assetGroupId,p.assetTypeId,p.engineTypeId");
			Iterator itr = productsQuery.list().iterator();
			while(itr.hasNext())
			{
				ProductEntity entity = (ProductEntity) itr.next();
				products.add(entity);
			}
			response = updateAssetServiceSchedules(products);
		}catch(Exception e){
			fLogger.fatal("fatal message:"+e.getMessage());
		}
		finally
		{
			if(session.isOpen())
			{
				session.flush();
				session.close();
			}

		}

		return response;
	}

	public String closeOutdatedServiceAlerts() {
		// TODO Auto-generated method stub
		Logger fLogger = FatalLoggerClass.logger;
		Logger iLogger = InfoLoggerClass.logger;
		SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd hh:MM:ss");
		String response = "FAILURE";
		Session session = HibernateUtil.getSessionFactory().openSession();
		String alertClosureTime = sdf.format(Calendar.getInstance().getTime());

		Session session1 = HibernateUtil.getSessionFactory().openSession();
		session1.beginTransaction();
		//Transaction tx = null;
		try{
			//Statement statement = connection.createStatement();
			session.beginTransaction();

			//boolean flagContinue = true;
			//while(flagContinue){
				if(session ==null || !session.isOpen())
				{
					session = HibernateUtil.getSessionFactory().getCurrentSession();
					session.beginTransaction();
				}
				if(session1 ==null || !session1.isOpen())
				{
					session1 = HibernateUtil.getSessionFactory().getCurrentSession();
					session1.beginTransaction();
				}
				String outdatedVINsQuery =" SELECT ae.serialNumber,ae,DATEDIFF(NOW(),convert_tz(ae.eventGeneratedTime,'+00:00','+05:30'))as alertAge," +
						"ae.serviceScheduleId,ss.serviceName,ss.scheduleName,ss.dbmsPartCode"+  
						" FROM AssetEventEntity ae,ServiceScheduleEntity ss where ae.eventTypeId=1 and ae.activeStatus=1 and "+ 
						"DATEDIFF(NOW(),convert_tz(ae.eventGeneratedTime,'+00:00','+05:30'))>7 and ss.serviceScheduleId = ae.serviceScheduleId and ss.serviceName = 'Beyond Warranty' and ae.serialNumber is not null";
				//outdatedVINsQuery = "select count(*) as count from asset_event";
				Query query = session.createQuery(outdatedVINsQuery);
				//query.setMaxResults(100);
				List list = query.list();
				int noOfRecords = list.size();
				iLogger.info("ServiceDetailsBO : closeOutdatedServiceAlerts outdated number of records "+list.size());
				Iterator rs = list.iterator();

				/*if(!rs.hasNext())
				{
					flagContinue = false;
				}*/
				Object[] result = null;
				int rows = 1;
				while(rs.hasNext())
				{
					result = (Object[]) rs.next();
					AssetEntity entity = (AssetEntity) result[0];

					String serialNumber = entity.getSerial_number().getSerialNumber();
					int serviceScheduleID = (Integer)result[3];
					AccountEntity accountId = null;
					String serviceName = (String) result[4];
					String scheduleName = (String) result[5];
					String DBMS_partCode = (String) result[6];
					//System.out.println(serialNumber);
					/*if(!session.isOpen())
					{
						session = HibernateUtil.getSessionFactory().getCurrentSession();
						session.beginTransaction();
					}

					AssetEventEntity closureOfEvent = session.load(AssetEventEntity.class, entity,new Integer(serviceScheduleID));*/
					AssetEventEntity closureOfEvent = (AssetEventEntity)result[1];
					int asset_event_id = closureOfEvent.getAssetEventId();
					//System.out.println(closureOfEvent.getSerialNumber().getSerial_number().getSerialNumber()+" Schedule ID "+closureOfEvent.getServiceScheduleId());
					Timestamp currentTime = new Timestamp(new Date().getTime());
					/*closureOfEvent.setCreated_timestamp(currentTime);
					closureOfEvent.setEventClosedTime(new Timestamp(Calendar.getInstance().getTime().getTime()));
					iLogger.info("ServiceDetailsBO : closeOutdatedServiceAlerts record no: "+rows+" asset_event_id :"+asset_event_id+" service ScheduleID : "+closureOfEvent.getServiceScheduleId());
					closureOfEvent.setActiveStatus(0);
					
					//DF20190110- Updating partition key and source.
					closureOfEvent.setUpdateSource("WISE");
					closureOfEvent.setAutoClosure(1);
					if(closureOfEvent.getEventGeneratedTime() != null){
						Date date = new Date();
						date.setTime(closureOfEvent.getEventGeneratedTime().getTime());
						String partitionKey = new SimpleDateFormat("yyyyMM").format(date);
						closureOfEvent.setPartitionKey(Integer.parseInt(partitionKey));
					}

					if(session1 ==null || !session1.isOpen())
					{
						session1 = HibernateUtil.getSessionFactory().getCurrentSession();
						session1.beginTransaction();
					}


					session1.update(closureOfEvent);
					iLogger.info("ServiceDetailsBO : closeOutdatedServiceAlerts record no: "+rows+" asset_event_id :"+asset_event_id+"asset_event update done ");

					if(rows == noOfRecords){
						iLogger.info("ServiceDetailsBO : closeOutdatedServiceAlerts record no: "+rows+" first flushing block ");
						session1.flush();
						//session.clear();
						session1.getTransaction().commit();
						if(session1 !=null && session1.isOpen()){
							session1.close();
						}
					}*/
					/*if(session ==null || !session.isOpen())
					{
						session = HibernateUtil.getSessionFactory().getCurrentSession();
						tx = session.beginTransaction();
					}*/
					if(session ==null || !session.isOpen())
					{
						session = HibernateUtil.getSessionFactory().getCurrentSession();
						session.beginTransaction();
					}
					Query dealerQuery = session.createQuery("select accountId from AssetOwnerSnapshotEntity where Serial_Number = '"+serialNumber
							+"' and Account_Type = 'Dealer'");
					Iterator dealerItr = dealerQuery.list().iterator();
					Object[] dealer = null;
					if(dealerItr.hasNext()){
						//dealer = (Object[]) dealerItr.next();
						accountId = (AccountEntity)dealerItr.next();
					}


					//----------------- get the CMH when the machine got services (service alert closure)

					String txnKey = "ServiceDetailsBO:closeOutdatedServiceAlerts";

					List<AmsDAO> snapshotObj=new ArrayList<AmsDAO> ();

					DynamicAMS_DAL amsDaoObj=new DynamicAMS_DAL();

					snapshotObj=amsDaoObj.getAMSData(txnKey, serialNumber);

					//iLogger.debug(txnKey+"::"+"AMS:persistDetailsToDynamicMySql::AMS DAL::getAMSData Size:"+snapshotObj.size());
					//	String cummOpHours = null;
					String cmh = null;
					if(snapshotObj.size()>0){

						//parameters format in AMS
						//String currParam= LAT|LONG|Enginestatus|Machinehours|ExternalBatteryVoltage|HCT|LOP|InternalBatteryLow
						//temp = false;
						String parameters=snapshotObj.get(0).getParameters();
						if(parameters!=null){
							String [] currParamList=parameters.split("\\|", -1);
							//DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

							//CMH

							if(currParamList.length>2)
								cmh = currParamList[3];
						}
					}
					/*String cmhQueryString = "select amd.parameterValue " +
							"from AssetMonitoringSnapshotEntity ams,AssetMonitoringDetailEntity amd " +
							"where ams.serialNumber = '"+serialNumber+"' and " +
									" amd.transactionNumber = ams.latestEventTxn and " +
									"amd.parameterId = 4 ";



					Query cmhQuery = session.createQuery(cmhQueryString);
					Iterator cmhIterator = cmhQuery.list().iterator();
					while(cmhIterator.hasNext()){
						cmh = (String) cmhIterator.next();
					}*/

					//Auto Closure Entry For machines with service alert age of more than 30 days only for extended warranty service alerts
					/*ServiceHistoryEntity newServiceHistoryEntry = new ServiceHistoryEntity();

					newServiceHistoryEntry.setSerialNumber(entity);
					if(accountId!=null)
						newServiceHistoryEntry.setDealerId(accountId);

					newServiceHistoryEntry.setServiceDate(new Timestamp(Calendar.getInstance().getTime().getTime()));
					newServiceHistoryEntry.setServiceName(serviceName);
					newServiceHistoryEntry.setScheduleName(scheduleName);
					newServiceHistoryEntry.setServiceTicketNumber(asset_event_id+"");
					newServiceHistoryEntry.setDbmsPartCode(asset_event_id+"");
					newServiceHistoryEntry.setServiceScheduleId(serviceScheduleID);
					if(cmh!=null)
						newServiceHistoryEntry.setCMH(cmh);

					if(session ==null && !session.isOpen())
					{
						session = HibernateUtil.getSessionFactory().openSession();
						session.beginTransaction();
					}

					session.save(newServiceHistoryEntry);*/
					
					//DF20190320:Abhishek Deshmukh:: to close the service through Kafka Q.  
					iLogger.info("closeOutdatedServiceAlerts():ServiceDetailsBO.java - Before Calling ServiceHistoryQueue Handler");
					ServiceHistoryInputContract inputObject = new ServiceHistoryInputContract();
					inputObject.setSerialNumber(serialNumber);
					inputObject.setDealerCode(accountId.getAccountCode());
					inputObject.setJobCardNumber(Integer.toString(asset_event_id));
					inputObject.setDbmsPartCode(DBMS_partCode);
					String currentTimeInString = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(currentTime);
					inputObject.setServicedDate(currentTimeInString);
					inputObject.setProcess("ServiceHistory");
					inputObject.setReprocessJobCode("RServiceHistory");
					
					iLogger.info("closeOutdatedServiceAlerts():ServiceDetailsBO.java :: Service Clouser History- Input to the Q::"+inputObject.getSerialNumber()+","+inputObject.getDealerCode()+","+inputObject.getJobCardNumber()+","+"" +
							inputObject.getDbmsPartCode()+","+inputObject.getServicedDate()+"," +
							inputObject.getFileRef()+","+"" +
							inputObject.getMessageId()+","+inputObject.getProcess()+","+inputObject.getReprocessJobCode());
					
					ServiceHistoryQHandler queueObj = new ServiceHistoryQHandler();

					String output = queueObj.handleServiceHistoryDetailsToKafkaQueue("ServiceHistoryQueue",inputObject);
					
					if(output.equalsIgnoreCase("FAILURE")||output.contains("FAILURE")||output==null){
						
						fLogger.fatal("ServiceDetailsBO.java:closeOutdatedServiceAlerts():: ERROR while inserting data in Kafka Q hence unable to close service for Beyond Warranty VIN'S ");
						fLogger.fatal("closeOutdatedServiceAlerts():ServiceDetailsBO.java :: Service Clouser History- Input to the Q::"+inputObject.getSerialNumber()+","+inputObject.getDealerCode()+","+inputObject.getJobCardNumber()+","+"" +
								inputObject.getDbmsPartCode()+","+inputObject.getServicedDate()+"," +
								inputObject.getFileRef()+","+"" +
								inputObject.getMessageId()+","+inputObject.getProcess()+","+inputObject.getReprocessJobCode());
						
					}
					else if(output.equalsIgnoreCase("SUCCESS")){
						iLogger.info("Service Clouser History- Input to the Q: Success Data: ");
					}
					
					
					iLogger.info("ServiceDetailsBO : closeOutdatedServiceAlerts record no: "+rows+" asset_event_id :"+asset_event_id+"service history done ");
					/*if(rows == noOfRecords){
						iLogger.info("ServiceDetailsBO : closeOutdatedServiceAlerts record no: "+rows+" first flushing block ");
						//session.flush();
						//session.clear();
						//session.getTransaction().commit();
						if(session !=null && session.isOpen()){
							session.close();
						}

					}*/
					rows++;
				}
			//}

			/*if(session1!=null && session1.isOpen()){
					iLogger.info("ServiceDetailsBO : closeOutdatedServiceAlerts last flushing block ");
					session1.flush();
					//session.clear();
					session1.getTransaction().commit();
				}
				if(session!=null && session.isOpen()){
					iLogger.info("ServiceDetailsBO : closeOutdatedServiceAlerts last flushing block ");
					session.flush();
					//session.clear();
					session.getTransaction().commit();
				}*/

			response = "SUCCESS";
		}catch(Exception e)
		{
			fLogger.fatal("ServiceDetailsBO.java:closeOutdatedServiceAlerts():: EXCEPTION while inserting data in Kafka Q hence unable to close service for Beyond Warranty VIN'S :"+e);
			/*if(session !=null && session.isOpen())
			{
				if(session.getTransaction().isActive())
				{
					session.getTransaction().rollback();
				}
			}
			if(session1 !=null && session1.isOpen())
			{
				if(session1.getTransaction().isActive())
				{
					session1.getTransaction().rollback();
				}
			}
			e.printStackTrace();*/

		}
		finally{
			/*if(session1 !=null && session1.isOpen()){
				if(session1.getTransaction().isActive())
				{
					session1.flush();
					session1.getTransaction().commit();
				}
			}
			if(session !=null && session.isOpen()){
				if(session.getTransaction().isActive())
				{
					session.flush();
					session.getTransaction().commit();
				}

			}*/
			if(session !=null && session.isOpen()){
				session.close();
			}
			if(session1 !=null && session1.isOpen()){
				session1.close();
			}
		}
		return response;
	}


}