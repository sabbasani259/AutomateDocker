package remote.wise.businessobject;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.sql.BatchUpdateException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.text.DateFormat;
import java.text.DecimalFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.TimeZone;
import java.util.TreeMap;
import java.util.concurrent.Callable;
import java.util.concurrent.CompletionService;
import java.util.concurrent.ExecutorCompletionService;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

//import javax.persistence.criteria.CriteriaBuilder.In;

import jxl.Workbook;
import jxl.WorkbookSettings;
import jxl.format.UnderlineStyle;
import jxl.format.VerticalAlignment;
import jxl.write.WritableCellFormat;
import jxl.write.WritableFont;
import jxl.write.WritableSheet;
import jxl.write.WritableWorkbook;

import org.hibernate.Query;
import org.hibernate.SQLQuery;
import org.hibernate.Session;
import org.hibernate.Transaction;

import remote.wise.businessentity.AccountEntity;
import remote.wise.businessentity.AccountTenancyMapping;
import remote.wise.businessentity.AssetControlUnitEntity;
import remote.wise.businessentity.AssetCustomGroupMapping;
import remote.wise.businessentity.AssetEntity;
import remote.wise.businessentity.AssetEventEntity;
import remote.wise.businessentity.AssetMonitoringDetailEntity;
import remote.wise.businessentity.CatalogValuesEntity;
import remote.wise.businessentity.ContactEntity;
import remote.wise.businessentity.CustomAssetGroupEntity;
import remote.wise.businessentity.EventEntity;
import remote.wise.businessentity.GroupUserMapping;
import remote.wise.businessentity.MonitoringParameters;
import remote.wise.businessentity.PreferenceCatalogEntity;
import remote.wise.businessentity.PreferenceEntity;
import remote.wise.businessentity.ReportMasterListEntity;
import remote.wise.businessentity.RpmBands;
import remote.wise.businessentity.SavedReportEntity;
import remote.wise.businessentity.ServiceDetailsReportEntity;
import remote.wise.businessentity.ServiceHistoryEntity;
import remote.wise.businessentity.TenancyEntity;
import remote.wise.dal.DynamicAMH_DAL;
import remote.wise.dal.DynamicAMS_DAL;
import remote.wise.exception.CustomFault;
import remote.wise.handler.EmailHandler;
import remote.wise.handler.EmailTemplate;
import remote.wise.log.BusinessErrorLogging.BusinessErrorLoggerClass;
import remote.wise.log.FatalErrorLogging.FatalLoggerClass;
import remote.wise.log.InfoLogging.InfoLoggerClass;
import remote.wise.pojo.AmsDAO;
import remote.wise.pojo.AssetMonitoringParametersDAO;
import remote.wise.pojo.CommunicationMachinesDAO;
import remote.wise.service.datacontract.DealersUnderZoneReqContract;
import remote.wise.service.datacontract.DealersUnderZoneRespContract;
import remote.wise.service.datacontract.DueOverDueReportReqContract;
import remote.wise.service.datacontract.DueOverDueReportRespContract;
import remote.wise.service.datacontract.FleetSummaryReportReqContract;
import remote.wise.service.datacontract.FleetSummaryReportRespContract;
import remote.wise.service.datacontract.LandmarkActivityReportReqContract;
import remote.wise.service.datacontract.LandmarkActivityReportRespContract;
import remote.wise.service.datacontract.MachineActivityReportReqContract;
import remote.wise.service.datacontract.MachineActivityReportRespContract;
import remote.wise.service.datacontract.MachineAlertsTrendDataReqContract;
import remote.wise.service.datacontract.MachineAlertsTrendDataRespContract;
import remote.wise.service.datacontract.MachineCommReportRespContract;
import remote.wise.service.datacontract.MachineHourMeterTrendDataReportReqContract;
import remote.wise.service.datacontract.MachineHourMeterTrendDataReportRespContract;
import remote.wise.service.datacontract.MachineHoursReportReqContract;
import remote.wise.service.datacontract.MachineHoursReportRespContract;
import remote.wise.service.datacontract.MachineHoursServiceReportReqContract;
import remote.wise.service.datacontract.MachineHoursServiceReportRespContract;
import remote.wise.service.datacontract.MachinePerformanceReportReqContract;
import remote.wise.service.datacontract.MachinePerformanceReportRespContract;
import remote.wise.service.datacontract.MachineRPMBandDataReportReqContract;
import remote.wise.service.datacontract.MachineRPMBandDataReportRespContract;
import remote.wise.service.datacontract.MachineServiceDueOverDueReqContract;
import remote.wise.service.datacontract.MachineServiceDueOverDueRespContract;
import remote.wise.service.datacontract.NotificationSummaryReportReqContract;
import remote.wise.service.datacontract.NotificationSummaryReportRespContract;
import remote.wise.service.datacontract.ReportMailSubscriptionListRespContract;
import remote.wise.service.datacontract.ReportSubscriptionRespContract;
import remote.wise.service.datacontract.UtilizationSummaryReportReqContract;
import remote.wise.service.datacontract.UtilizationSummaryReportRespContract;
import remote.wise.service.implementation.AssetServiceScheduleImpl;
import remote.wise.service.implementation.DealersUnderZoneImpl;
import remote.wise.service.implementation.DomainServiceImpl;
import remote.wise.service.implementation.DueOverDueReportImpl;
import remote.wise.service.implementation.FleetSummaryReporImpl;
import remote.wise.service.implementation.LandmarkActivityReportImpl;
import remote.wise.service.implementation.MachineActivityReportImpl;
import remote.wise.service.implementation.MachineAlertsTrendDataImpl;
import remote.wise.service.implementation.MachineHourMeterTrendDataReportImpl;
import remote.wise.service.implementation.MachineHoursReportImpl;
import remote.wise.service.implementation.MachineHoursServiceReportImpl;
import remote.wise.service.implementation.MachinePerformanceReportImpl;
import remote.wise.service.implementation.MachineRPMBandDataImpl;
import remote.wise.service.implementation.MachineServiceDueOverDueImpl;
import remote.wise.service.implementation.NotificationReportDetailsImpl;
import remote.wise.service.implementation.NotificationSummaryReportImpl;
import remote.wise.service.implementation.ReportMasterListImpl;
import remote.wise.service.implementation.ReportSubscriptionImpl;
import remote.wise.service.implementation.SavedReportImpl;
import remote.wise.service.implementation.UnderUtilizedMachinesImpl;
import remote.wise.service.implementation.UtilizationDetailReportImpl;
import remote.wise.service.implementation.UtilizationDetailServiceImpl;
import remote.wise.service.implementation.UtilizationSummaryReportImpl;
import remote.wise.util.ConnectMySQL;
import remote.wise.util.DateUtil;
import remote.wise.util.HibernateUtil;
import remote.wise.util.IstGmtTimeConversion;
import remote.wise.util.ListToStringConversion;
//import remote.wise.util.WiseLogger;
import org.apache.logging.log4j.Logger;
public class ReportDetailsBO implements Callable<String> 
{
	//DF:2013:12:13 : Converision from Long to Double for all the required fields : Suprava
	//the machines which didnt communicated
	HashMap<Integer, String>TenancyData = new HashMap<Integer, String>();
	HashMap<Integer, String>GroupData = new HashMap<Integer, String>();
	HashMap<String, Integer>serGroupID = new HashMap<String, Integer>();
	
	public int segementID_Thread;
	public ReportDetailsBO(int segementID) {
		// TODO Auto-generated constructor stub
		this.segementID_Thread=segementID;
	}

	//DefectId:1337 - Rajani Nagaraju - 20130923 - Log4j Changes - Using static logger object all throughout the application
	/*public static WiseLogger businessError = WiseLogger.getLogger("ReportDetailsBO:","businessError");
	public static WiseLogger fatalError = WiseLogger.getLogger("ReportDetailsBO:","fatalError");
	public static WiseLogger infoLogger = WiseLogger.getLogger("ReportDetailsBO:","info");
*/
	//DF20191021 - Rajani Nagaraju - Extended Warranty Changes - START
		public String serialNumber;
		public ReportDetailsBO(int segementID, String serialNumber) {
			// TODO Auto-generated constructor stub
			this.segementID_Thread=segementID;
			this.serialNumber = serialNumber;
		}
		//DF20191021 - Rajani Nagaraju - Extended Warranty Changes - END


	public ReportDetailsBO() {
		// TODO Auto-generated constructor stub
	}

	public static long toDate1(java.sql.Timestamp timestamp) {
		long milliseconds=0L;
		if(timestamp!=null)
		{
			milliseconds = timestamp.getTime() + (timestamp.getNanos() / 1000000);            	        
		}
		return milliseconds;

	}

	private String Serial_no;
	private double Engine_Off_Hours_Perct;
	private long Working_Time;
	private double WorkingTimePercentage;

	public String getSerial_no() {
		return Serial_no;
	}

	public void setSerial_no(String serial_no) {
		Serial_no = serial_no;
	}

	public double getEngine_Off_Hours_Perct() {
		return Engine_Off_Hours_Perct;
	}

	public void setEngine_Off_Hours_Perct(double engine_Off_Hours_Perct) {
		Engine_Off_Hours_Perct = engine_Off_Hours_Perct;
	}

	public long getWorking_Time() {
		return Working_Time;
	}

	public void setWorking_Time(long working_Time) {
		Working_Time = working_Time;
	}

	public double getWorkingTimePercentage() {
		return WorkingTimePercentage;
	}

	public void setWorkingTimePercentage(double workingTimePercentage) {
		WorkingTimePercentage = workingTimePercentage;
	}

	String currentDateFinal = null;
	String time = null;

	// //************************************************ Machine Utilization
	// Summary Report *************************************************
	/**
	 * This method returns the Utilization summary for the given period for the
	 * serialNumberList accessible to login user and for the given filter
	 * criteria
	 * 
	 * @param loginId
	 *            userLoginId
	 * @param period
	 *            period-Either one of the following:
	 *            Today,Week,Month,Quarter,Year
	 * @param tenancyIdList
	 *            list of tenancyId
	 * @param customAssetGroupIdList
	 *            list of customAssetGroupId
	 * @param assetGroupIdList
	 *            list of assetGroupId
	 * @param modelIdList
	 *            list of modelId
	 * @return Returns the Utilization Summary for the List of machines
	 */

//S Suresh DefectId 20151102 new implementation for Utilization Summary Report
	
	public List<UtilizationSummaryReportImpl> machineUtilizationSummaryReport(String fromDate,String toDate,
			String loginId, String period, List<Integer> tenancyIdList,
			List<Integer> customAssetGroupIdList,
			List<Integer> assetGroupIdList, List<Integer> modelIdList,
			boolean isGroupingOnAssetGroup, List<Integer> loginTenancyIdList) {

        List<UtilizationSummaryReportImpl> responseList = new LinkedList<UtilizationSummaryReportImpl>();

        HashMap<String, Integer> calledSerNumMapUtilization = new HashMap<String, Integer>();

        List<String>  tempSerNumListUtilization = new ArrayList<String>();

        List<String>  AllSerNumListUtilization = new ArrayList<String>();

        String tempSerialNumberUtilization=null;

        UtilizationSummaryReportImpl impObj =null;

        //Logger businessError = Logger.getLogger("businessErrorLogger");

        //Logger fatalError = Logger.getLogger("fatalErrorLogger");

        Logger fLogger = FatalLoggerClass.logger;

        Logger bLogger = BusinessErrorLoggerClass.logger;

        Logger iLogger = InfoLoggerClass.logger;

        Session session = HibernateUtil.getSessionFactory().openSession();

        session.beginTransaction();

        String fromdateFormatted= null,                              todateFormatted = null;

        try {

                        DecimalFormat df2 = new DecimalFormat("###.#");

                        // get the current Year

                        Calendar c = Calendar.getInstance();

                        int currentYear = c.get(Calendar.YEAR);

                        //infoLogger.info("currentYear   "+currentYear);

                        // Period can be 'Today','Week','Month', 'Quarter', 'Year'

                        String basicFromQuery = null;

                        String basicSelectQuery = null;

                        String basicWhereQuery = null;

                        String finalQuery = null;

                        String basicGroupByQuery = " ";



                        double engineRunDuration=(long) 0;

                        //                                            Keerthi : 10/12/13 : taking off hours  as int from Long

                        double engineOffHours=0.0D;

                        double engineOffHours1=0.0D;

                        double EngineWorkingDurationInMin=0.0D;

                        //Suresh df20151102 new implementation for utilisation summary report

                        String periodType = null;

                       

                        //DefectId: DF20131218 - Juhi Gupta - To display the VINs that has not communicated for the given time period

                        ListToStringConversion conversionObj = new ListToStringConversion();

                        String loginTenIdListString = conversionObj.getIntegerListString(loginTenancyIdList).toString();;

                        SimpleDateFormat dateFrmt = new SimpleDateFormat("yyyy-MM-dd");

                        String lastDateInPeriod=null;

                        String startDateInPeriod=null;

                        //int currentDayofPeriod = 0;

                        //DefectID:1406 Suprava -2013/10/30 To return Report Totals

                        double totalengineRunDurationInMinsumm=0.0D;

                        double totalengineWorkingDurationInMinsumm=0.0D;

                        double totalmachineUtilizationPercentagesumm=0.0D;

                        double totalengineOffDurationInMin=0.0D;



                       

                        //added by smitha on oct 14th 2013[to display the machines which have not communicated.... Internal Defect 20131014]

                        boolean querySelected = false;

                        String selectQueryCustomDates=null;

                        calledSerNumMapUtilization=getserialNumberList(tenancyIdList,customAssetGroupIdList,assetGroupIdList,modelIdList);

                        //ended on oct 14th 2013[to display the machines which have not communicated.... Internal Defect 20131014]

                        List<Integer> tenancyIdList1 = tenancyIdList;

        //            tenancyIdList = getSubTenancyIds(tenancyIdList,session);

                        String childTenancyIdStringList = conversionObj.getIntegerListString(

                                                        tenancyIdList).toString();

                        //Changes Done by Juhi On 6 May 2013 Added engineWorkingDurationInMin

                        //DefectID:1406 Suprava 2013/10/30

                        /*basicSelectQuery = "select b.tenancyId, b.tenancyName, a.machineName, a.serialNumber, " +

                        " (a.EngineRunningBand1+a.EngineRunningBand2+a.EngineRunningBand3+a.EngineRunningBand4+a.EngineRunningBand5+a.EngineRunningBand6+a.EngineRunningBand7+a.EngineRunningBand8) as engineRunDurationInMin,"

                        +"a.engineOffHours as engineOffDurationInMin , (a.EngineRunningBand3+a.EngineRunningBand4+a.EngineRunningBand5+a.EngineRunningBand6+a.EngineRunningBand7+a.EngineRunningBand8) as engineWorkingDurationInMin, c.group_id as machineGroupId, c.group_name as machineGroupName,"

                        +" ten.tenancy_id as mgTenancy,b.parentTenancyName,b.tenancyTypeId ";*/

                       

                        //Suresh 2015/11/03 new Query implementation via Asset Owner Snapshot

                        basicSelectQuery = "select a_t1.tenancy_id,acc.account_name as TenancyName,a1.machineName, a1.serialNumber," +

                                                        "(a1.machineHours - max(a2.machineHours) ) as workingHours" +

                                                        ",acc1.account_name as DealerName,aos1.accountType";



                       

                        //Defect ID:1406 Suprava 2013/10/29 machine grouping

                        /*basicFromQuery = "from AssetCustomGroupMapping h RIGHT OUTER JOIN h.serial_number x  LEFT OUTER JOIN h.group_id c "+

                        " LEFT OUTER JOIN c.tenancy_id ten ,TenancyEntity ten1, " ;*/

                       

                        basicFromQuery = " from AccountTenancyMapping a_t,AccountEntity acc, AssetOwnerSnapshotEntity aos, AssetOwnerSnapshotEntity aos1," +

                                                        "AssetEntity vin,AccountEntity acc1,AccountTenancyMapping a_t1,";

                       

                        /*//changes Juhi

                        basicWhereQuery = " where ten1.tenancy_id = b.tenancyId and a.tenancyId = b.tenacy_Dimension_Id and b.tenancyId in ("

                                        + childTenancyIdStringList + " ) and x.serial_number = a.serialNumber ";

                                        //DefectId:20150216 @ Suprava Dealer As a new parameter Added

                                        //" and b.parentTenancyId=ten1.parent_tenancy_id ";

*/

                       

                        //Suresh df20151102 new implementation for utilisation summary report

                        basicWhereQuery = " where a_t.tenancy_id in ('"+childTenancyIdStringList+"')"+

                                " and aos.accountId = a_t.account_id "+

                                "and a1.serialNumber = aos.serialNumber "+

                                                        "and a2.serialNumber = aos.serialNumber "+

                                "and vin.serial_number = a1.serialNumber "+

                                "and acc.account_id = vin.primary_owner_id "+

                                "and a_t1.account_id = acc.account_id "+

                                                        "and acc1.account_id = acc.parent_account_id "+

                                "and aos1.serialNumber = vin.serial_number "+

                                "and aos1.accountId = vin.primary_owner_id "+

                                                        "and a1.tenancyId in (select b.tenacy_Dimension_Id  from TenancyBridgeEntity a , TenancyDimensionEntity b  where a.parentId in ('"+childTenancyIdStringList+"') and a.childId = a_t1.tenancy_id and b.tenancyId = a.childId) ";

                       

                        //Logic for Custom Dates (fromDate,toDate) added by Juhi on 14-August-2013

                        if(fromDate == null && toDate==null)

                        {

                                        if ((period.equalsIgnoreCase("Week"))||(period.equalsIgnoreCase("Last Week"))) {

                                                        Date currentDate = new Date();

                                                        DateUtil dateUtilObj = new DateUtil();

                                                        DateUtil dateUtilObj1 = new DateUtil();

                                                        //periodType = "week";

                                                        if (period.equalsIgnoreCase("Week"))

                                                        {

                                                                        dateUtilObj  = dateUtilObj. getCurrentDateUtility(currentDate);



                                                                        int week = dateUtilObj. getWeek();

                                                                        int year = dateUtilObj. getYear();



                                                                        //Suresh df20151102 new implementation for utilisation summary report

                                                                        basicSelectQuery += ",a1.timeCount as cuurentTimeKey,a2.timeCount as lastCommTimeKey ";

                                                                        basicFromQuery = basicFromQuery + " AssetMonitoringFactDataWeekAgg a1,AssetMonitoringFactDataWeekAgg a2";

                                                                        //end Defect ID:1406

                                                                        basicWhereQuery = basicWhereQuery

                                                                        + "and a1.timeCount = "+week

                                                +" and a1.year ="+ year

                                                                        +" and a2.timeCount= (select max(a.timeCount) "+

                                                                        "from AssetMonitoringFactDataWeekAgg a "+

                                                                        "where a.serialNumber = aos.serialNumber and a.timeCount<"+week +" and a.year = "+year+") ";

                                               

                                                                       

                                                                        //Defect ID:1406 (Smitha oct 4th 2013) machine grouping

                                                                        /*basicWhereQuery = basicWhereQuery

                                                                        + " and a.timeCount = "+week+" and a.year = "+year+"";*/

                                                                        //DefectId: DF20131218 -Juhi- To display the VINs that has not communicated for the given time period

                                                                        //get the Last Day

                                                                        Calendar cal = Calendar.getInstance();

                                                                        lastDateInPeriod = dateFrmt.format(cal.getTime());

                                                                        //get the first day of the week

                                                                        cal.set(Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek());

                                                                        startDateInPeriod=  dateFrmt.format(cal.getTime());

                                                        }

                                                        if((period.equalsIgnoreCase("Last Week")))

                                                        {

                                                                        dateUtilObj  = dateUtilObj. getPreviousDateUtility(currentDate);

                                                                        dateUtilObj1  = dateUtilObj1. getCurrentDateUtility(currentDate);

                                                                        int week = dateUtilObj. getWeek();

                                                                        int year=0;

                                                                        if(week==1)

                                                                                        year = dateUtilObj.getYear();

                                                                        else

                                                                                        year = dateUtilObj.getCurrentYear();



                                                                       

                                                                        //Suresh df20151102 new implementation for utilisation summary report

                                                                       
                                                                        basicSelectQuery += ",a1.timeCount as cuurentTimeKey,a2.timeCount as lastCommTimeKey ";
                                                                        
                                                                        basicFromQuery = basicFromQuery + " AssetMonitoringFactDataWeekAgg a1,AssetMonitoringFactDataWeekAgg a2";

                                                                        //end Defect ID:1406

                                                                        basicWhereQuery = basicWhereQuery

                                                                        + "and a1.timeCount = "+week

                                                +" and a1.year ="+ year

                                                                        +" and a2.timeCount= (select max(a.timeCount) "+

                                                                        "from AssetMonitoringFactDataWeekAgg a "+

                                                                        "where a.serialNumber = aos.serialNumber and a.timeCount<"+week +" and a.year = "+year+") ";



                                                                       

                                                                        /*//Defect ID:1406 (Smitha oct 4th 2013) machine grouping

                                                                        basicFromQuery = basicFromQuery + " AssetMonitoringFactDataWeekAgg a ";

                                                                        //end Defect ID:1406

                                                                        basicWhereQuery = basicWhereQuery

                                                                        + " and a.timeCount = "+week+" and a.year = "+year+"";*/



                                                                        //DefectId: DF20131218 - Juhi- To display the VINs that has not communicated for the given time period

                                                                        //get the Last Day of Previous Week

                                                                        Calendar cal = Calendar.getInstance();

                                                                        int i = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();

                                                                        cal.add(Calendar.DATE, -i - 7);

                                                                        cal.add(Calendar.DATE, 6);

                                                                        lastDateInPeriod = dateFrmt.format(cal.getTime());

                                                                        //get the First Day of Previous Week

                                                                        cal = Calendar.getInstance();

                                                                        int j = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();

                                                                        cal.add(Calendar.DATE, -j - 7);

                                                                        cal.set(Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek());

                                                                        startDateInPeriod=  dateFrmt.format(cal.getTime());

                                                        }



                                        }



                                        else if ((period.equalsIgnoreCase("Month"))||(period.equalsIgnoreCase("Last Month"))) {

                                                        periodType = "month";

                                                        Date currentDate = new Date();

                                                        DateUtil dateUtilObj = new DateUtil();

                                                        DateUtil dateUtilObj1 = new DateUtil();

                                                        DateUtil dateUtilObj2 = new DateUtil();

                                                        if((period.equalsIgnoreCase("Month")))

                                                        {

                                                                        dateUtilObj  = dateUtilObj. getCurrentDateUtility(currentDate);

                                                                        int month = dateUtilObj. getMonth ();

                                                                        int year = dateUtilObj. getYear();





                                                                        //Suresh df20151102 new implementation for utilisation summary report

                                                                        basicSelectQuery += ",a1.timeCount as cuurentTimeKey,a2.timeCount as lastCommTimeKey ";

                                                                        basicFromQuery = basicFromQuery + " AssetMonitoringFactDataMonthAgg a1,AssetMonitoringFactDataMonthAgg a2";

                                                                        //end Defect ID:1406

                                                                        basicWhereQuery = basicWhereQuery

                                                                        + "and a1.timeCount = "+month

                                                +" and a1.year ="+ year

                                                                        +" and a2.timeCount= (select max(a.timeCount) "+

                                                                        "from AssetMonitoringFactDataMonthAgg a "+

                                                                        "where a.serialNumber = aos.serialNumber and a.timeCount<"+month +" and a.year = "+year+") ";

                                                                       

                                                                       

                                                                        /*//Defect ID:1406 (Smitha oct 4th 2013) machine grouping

                                                                        basicFromQuery = basicFromQuery + " AssetMonitoringFactDataMonthAgg a ";

                                                                        //end Defect ID:1406

                                                                        basicWhereQuery = basicWhereQuery

                                                                        + " and a.timeCount = "+month+" and a.year= " + year+"";*/

                                                                        //DefectId: DF20131218 -Juhi - To display the VINs that has not communicated for the given time period

                                                                        //get the Last Day

                                                                        Calendar cal = Calendar.getInstance();

                                                                        lastDateInPeriod = dateFrmt.format(cal.getTime());

                                                                        //get the First Day of current Month

                                                                        String mon = month+"";

                                                                        if(mon.length()<2)

                                                                                        mon="0"+mon;

                                                                        startDateInPeriod=year+"-"+mon+"-"+"01";

                                                        }

                                                        if(period.equalsIgnoreCase("Last Month"))

                                                        {

                                                                        dateUtilObj1  = dateUtilObj1. getCurrentDateUtility(currentDate);

                                                                        dateUtilObj  = dateUtilObj. getPreviousDateUtility (currentDate);

                                                                        int month = dateUtilObj. getMonth ();

                                                                        int year=0;

                                                                        int prevMonth = 0;

                                                                        int preYear = 0;

                                                                        String prevMonthInString = null;

                                                                        if(dateUtilObj1.getMonth() ==1)

                                                                                        year = dateUtilObj.getYear();

                                                                        else

                                                                                        year = dateUtilObj.getCurrentYear();



                                                                        if(dateUtilObj.getMonth() ==1){ //if report for previous month falls in january

                                                                                        Calendar preCal = Calendar.getInstance();

                                                                                        preCal.set(dateUtilObj1.getCurrentYear(), dateUtilObj.getMonth(),Calendar.DAY_OF_MONTH);

                                                                                        preCal.add(Calendar.MONTH, -1);

                                                                                        dateUtilObj2 =  dateUtilObj2.getPreviousDateUtility(preCal.getTime());

                                                                                        //prevMonth = preCal.get(Calendar.MONTH)+1;

                                                                                        prevMonth=dateUtilObj2.getMonth();

                                                                                        prevMonthInString = "="+prevMonth;

                                                                                        preYear = dateUtilObj.getYear();

                                                                        }

                                                                        else

                                                                        {

                                                                                        prevMonthInString = month+"";

                                                                                        preYear = year;

                                                                        }

                                                                                        //Suresh df20151102 new implementation for utilisation summary report
                                                                        basicSelectQuery += ",a1.timeCount as cuurentTimeKey,a2.timeCount as lastCommTimeKey ";
                                                                       

                                                                        basicFromQuery = basicFromQuery + " AssetMonitoringFactDataMonthAgg a1,AssetMonitoringFactDataMonthAgg a2";

                                                                        //end Defect ID:1406

                                                                        basicWhereQuery = basicWhereQuery

                                                                        + "and a1.timeCount = "+month

                                                +" and a1.year ="+ year

                                                                        +" and a2.timeCount= (select max(a.timeCount) "+

                                                                        "from AssetMonitoringFactDataMonthAgg a "+

                                                                        "where a.serialNumber = aos.serialNumber and a.timeCount<"+prevMonthInString +" and a.year = "+preYear+") ";

                                                                        /*//Defect ID:1406 (Smitha oct 4th 2013) machine grouping

                                                                        basicFromQuery = basicFromQuery + " AssetMonitoringFactDataMonthAgg a ";

                                                                        //end Defect ID:1406

                                                                        basicWhereQuery = basicWhereQuery

                                                                        + " and a.timeCount = "+month+" and a.year= " + year+"";*/

                                                                        //DefectId: DF20131218 -Juhi- To display the VINs that has not communicated for the given time period

                                                                        //Get the Last Day of previous Month

                                                                        Calendar cal = Calendar.getInstance();

                                                                        cal.set(Calendar.DATE, 1);

                                                                        cal.add(Calendar.DAY_OF_MONTH, -1);

                                                                        lastDateInPeriod = dateFrmt.format(cal.getTime());

                                                                        //get the First Day of Previous Month

                                                                        String mon = month+"";

                                                                        if(mon.length()<2)

                                                                                        mon="0"+mon;

                                                                        startDateInPeriod=year+"-"+mon+"-"+"01";

                                                        }

                                        }



                                        else if ((period.equalsIgnoreCase("Quarter"))||(period.equalsIgnoreCase("Last Quarter"))) {

                                                        //periodType = "quarter";

                                                        Date currentDate = new Date();

                                                        DateUtil dateUtilObj = new DateUtil();

                                                        DateUtil dateUtilObj1 = new DateUtil();

                                                        if(period.equalsIgnoreCase("Quarter"))

                                                        {

                                                                        dateUtilObj  = dateUtilObj. getCurrentDateUtility(currentDate);

                                                                        int quarter = dateUtilObj. getQuarter ();

                                                                        int year = dateUtilObj. getYear();



                                                                                       

                                                                        //Suresh df20151102 new implementation for utilisation summary report

                                                                        basicSelectQuery += ",a1.timeCount as cuurentTimeKey,a2.timeCount as lastCommTimeKey ";

                                                                        basicFromQuery = basicFromQuery + " AssetMonitoringFactDataQuarterAgg a1,AssetMonitoringFactDataQuarterAgg a2";

                                                                        //end Defect ID:1406

                                                                        basicWhereQuery = basicWhereQuery

                                                                        + "and a1.timeCount = "+quarter

                                                +" and a1.year ="+ year

                                                                        +" and a2.timeCount= (select max(a.timeCount) "+

                                                                        "from AssetMonitoringFactDataQuarterAgg a "+

                                                                        "where a.serialNumber = aos.serialNumber and a.timeCount<"+quarter +" and a.year = "+year+") ";

                                                                       

                                                                        /*//Defect ID:1406 (Smitha oct 4th 2013) machine grouping

                                                                        basicFromQuery = basicFromQuery + " AssetMonitoringFactDataQuarterAgg a ";

                                                                        //end Defect ID:1406

                                                                        basicWhereQuery = basicWhereQuery

                                                                        + " and a.timeCount = "+quarter+" and a.year="+year+"";*/



                                                                        //DefectId: DF20131218 - Juhi - To display the VINs that has not communicated for the given time period

                                                                        //get the Last Day

                                                                        Calendar cal = Calendar.getInstance();

                                                                        lastDateInPeriod = dateFrmt.format(cal.getTime());

                                                                        //get the first Date of current quarter

                                                                        switch(quarter)

                                                                        {

                                                                        case 3 :

                                                                                        startDateInPeriod = year+"-07-01";

                                                                                        break;

                                                                                        // return July 01

                                                                        case 2 :

                                                                                        startDateInPeriod = year+"-04-01";

                                                                                        break;

                                                                                        // return April 01

                                                                        case 1 :

                                                                                        startDateInPeriod = year+"-01-01";

                                                                                        break;

                                                                                        // return Jan 01

                                                                        case 4 :

                                                                                        startDateInPeriod = year+"-10-01";

                                                                                        break;

                                                                                        // return Oct 01

                                                                        }

                                                        }

                                                        if(period.equalsIgnoreCase("Last Quarter"))

                                                        {

                                                                        dateUtilObj1  = dateUtilObj1. getCurrentDateUtility(currentDate);

                                                                        dateUtilObj  = dateUtilObj. getPreviousDateUtility(currentDate);

                                                                        int quarter = dateUtilObj. getQuarter ();

                                                                        int year=0;

                                                                        if(dateUtilObj1.getQuarter() ==1)

                                                                                        year = dateUtilObj.getYear();

                                                                        else

                                                                                        year = dateUtilObj.getCurrentYear();



                                                                        //Suresh df20151102 new implementation for utilisation summary report

                                                                        basicSelectQuery += ",a1.timeCount as cuurentTimeKey,a2.timeCount as lastCommTimeKey ";

                                                                        basicFromQuery = basicFromQuery + " AssetMonitoringFactDataQuarterAgg a1,AssetMonitoringFactDataQuarterAgg a2";

                                                                        //end Defect ID:1406

                                                                        basicWhereQuery = basicWhereQuery

                                                                        + "and a1.timeCount = "+quarter

                                                +" and a1.year ="+ year

                                                                        +" and a2.timeCount= (select max(a.timeCount) "+

                                                                        "from AssetMonitoringFactDataQuarterAgg a "+

                                                                        "where a.serialNumber = aos.serialNumber and a.timeCount<"+quarter +" and a.year = "+year+") ";

                                                                       

/*

                                                                        //Defect ID:1406 (Smitha oct 4th 2013) machine grouping

                                                                        basicFromQuery = basicFromQuery + " AssetMonitoringFactDataQuarterAgg a ";

                                                                        //end Defect ID:1406

                                                                        basicWhereQuery = basicWhereQuery

                                                                        + " and a.timeCount = "+quarter+" and a.year="+year+"";*/

                                                                        //DefectId: DF20131218  -Juhi - To display the VINs that has not communicated for the given time period

                                                                        //get the last day of previous quarter

                                                                        switch(quarter)

                                                                        {

                                                                        case 3 :

                                                                                        lastDateInPeriod = year+"-09-30";

                                                                                        break;

                                                                                        // return September 30

                                                                        case 2 :

                                                                                        lastDateInPeriod = year+"-06-30";

                                                                                        break;

                                                                                        // return June 30

                                                                        case 1 :

                                                                                        lastDateInPeriod = year+"-03-31";

                                                                                        break;

                                                                                        // return March 31

                                                                        case 4 :

                                                                                        lastDateInPeriod = year+"-12-31";

                                                                                        break;

                                                                                        // return December 31

                                                                        }

                                                                        //get the first Date of Previous quarter

                                                                        switch(quarter)

                                                                        {

                                                                        case 3 :

                                                                                        startDateInPeriod = year+"-07-01";

                                                                                        break;

                                                                                        // return July 01

                                                                        case 2 :

                                                                                        startDateInPeriod = year+"-04-01";

                                                                                        break;

                                                                                        // return April 01

                                                                        case 1 :

                                                                                        startDateInPeriod = year+"-01-01";

                                                                                        break;

                                                                                        // return Jan 01

                                                                        case 4 :

                                                                                        startDateInPeriod = year+"-10-01";

                                                                                        break;

                                                                                        // return Oct 01

                                                                        }

                                                        }                                                             

                                        }                             

                                        else if ((period.equalsIgnoreCase("Year"))||(period.equalsIgnoreCase("Last Year"))) {

                                                        periodType = "year";

                                                        Date currentDate = new Date();

                                                        DateUtil dateUtilObj = new DateUtil();

                                                        if(period.equalsIgnoreCase("Year"))

                                                        {

                                                                        dateUtilObj  = dateUtilObj. getCurrentDateUtility(currentDate);

                                                                        int year = dateUtilObj. getYear();





                                                                        //Suresh df20151102 new implementation for utilisation summary report

                                                                        basicSelectQuery += ",a1.year as cuurentTimeKey,a2.year as lastCommTimeKey ";

                                                                        basicFromQuery = basicFromQuery + " AssetMonitoringFactDataYearAgg a1,AssetMonitoringFactDataYearAgg a2";

                                                                        //end Defect ID:1406

                                                                        basicWhereQuery = basicWhereQuery

                                                +" and a1.year ="+ year

                                                                        +" and a2.year= (select max(a.year) "+

                                                                        "from AssetMonitoringFactDataYearAgg a "+

                                                                        "where a.serialNumber = aos.serialNumber and a.year<"+year+")";

                                                                       

                                                        /*           //Defect ID:1406 (Smitha oct 4th 2013) machine grouping

                                                                        basicFromQuery = basicFromQuery + " AssetMonitoringFactDataYearAgg a ";

                                                                        //end Defect ID:1406

                                                                        basicWhereQuery = basicWhereQuery

                                                                        + " and a.year = "+year+" ";*/

                                                                        //DefectId: DF20131218 - Juhi - To display the VINs that has not communicated for the given time period

                                                                        //get the Last Day

                                                                        Calendar cal = Calendar.getInstance();

                                                                        lastDateInPeriod = dateFrmt.format(cal.getTime());

                                                                        //get the First day of current Year

                                                                        startDateInPeriod=year+"-01"+"-01";

                                                        }

                                                        if(period.equalsIgnoreCase("Last Year"))

                                                        {

                                                                        dateUtilObj  = dateUtilObj. getPreviousDateUtility(currentDate);

                                                                        int year = dateUtilObj. getYear();



                                                                       

                                                                        //Suresh df20151102 new implementation for utilisation summary report

                                                                        basicSelectQuery += ",a1.year as cuurentTimeKey,a2.year as lastCommTimeKey ";

                                                                        basicFromQuery = basicFromQuery + " AssetMonitoringFactDataYearAgg a1,AssetMonitoringFactDataYearAgg a2";

                                                                        //end Defect ID:1406

                                                                        basicWhereQuery = basicWhereQuery

                                                +" and a1.year ="+ year

                                                                        +" and a2.year= (select max(a.year) "+

                                                                        "from AssetMonitoringFactDataYearAgg a "+

                                                                        "where a.serialNumber = aos.serialNumber and a.year<"+year+")";



                                                                        /*//Defect ID:1406 (Smitha oct 4th 2013) machine grouping

                                                                        basicFromQuery = basicFromQuery + " AssetMonitoringFactDataYearAgg a ";

                                                                        //end Defect ID:1406

                                                                        basicWhereQuery = basicWhereQuery

                                                                        + " and a.year = "+year+" ";*/

                                                                        //DefectId: DF20131218 -Juhi - To display the VINs that has not communicated for the given time period

                                                                        //get the Last day of previous Year

                                                                        lastDateInPeriod=year+"-12-31";

                                                                        //get the First day of Previous Year

                                                                        startDateInPeriod=year+"-01"+"-01";

                                                        }                                                             

                                        }

                                        if(!(isGroupingOnAssetGroup) )

                                                        basicGroupByQuery = " group by a1.serialNumber ";

                        }

                        //Logic for Custom Dates (fromDate,toDate) added by Juhi on 14-August-2013

                        else

                        {



                                        /*if(period==null)

                                        {

                                                        Date newerDate = dateFrmt.parse(todateFormatted);

                                                        Date olderDate = dateFrmt.parse(fromdateFormatted);

                                                        double diffInDays = (double)( (newerDate.getTime() - olderDate.getTime())

                                        / (1000 * 60 * 60 * 24) );

                                                        diffInDays= diffInDays+1;

                                                        double engineOffLong = (24*diffInDays)-engineOn;

                                                        engineOffInt = (double)engineOffLong;

                                        //            implObj.setEngineOff(engineOffInt);

                                                        implObj.setEngineOff(Double.valueOf(df2.format((Double)engineOffInt)));

                                        }*/

                                        //added by smitha on oct 15th 2013[custom dates aggregation for a VIN query change.... Internal Defect 20131014]

                                        //querySelected=true;

                        /*           basicSelectQuery = " select b.tenancyId, b.tenancyName, a.machineName, a.serialNumber, " +

                                        " sum((a.EngineRunningBand1+a.EngineRunningBand2+a.EngineRunningBand3+a.EngineRunningBand4+a.EngineRunningBand5+a.EngineRunningBand6+a.EngineRunningBand7+a.EngineRunningBand8)) as engineRunDurationInMin,"

                                        +"sum(a.engineOffHours) as engineOffDurationInMin , sum((a.EngineRunningBand3+a.EngineRunningBand4+a.EngineRunningBand5+a.EngineRunningBand6+a.EngineRunningBand7+a.EngineRunningBand8)) as engineWorkingDurationInMin, c.group_id as machineGroupId, c.group_name as machineGroupName, ten.tenancy_id as mgTenancy," +

                                        //DefectId:20150220 @ Suprava Delaer As a new parameter Added

                                        "b.parentTenancyName,b.tenancyTypeId ";*/

                                       

                                        //Suresh df20151102 new Query implementation for utilisation summary report

                                        basicSelectQuery = "select a_t1.tenancy_id,acc.account_name as TenancyName,a1.machineName, a1.serialNumber,(a1.machineHours -"+

                                                                        "max(a2.machineHours) ) as engineRunHours,a1.timeKey as cuurentTimeKey,a2.timeKey as lastCommTimeKey" +

                                                                        ",acc1.account_name as DealerName,aos1.accountType";

                                       

                                        //ended on oct 15th 2013[custom dates aggregation for a VIN query change.... Internal Defect 20131014]



                                        DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");

                                        DateFormat dateFormat1 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

                                        Date fromdate1=null;

                                        String fromdate2=null;

                                        String todate2=null;

                                        String fromdate=null;

                                        String todate=null;

                                        try {       



                                                        fromdate1 = (Date)dateFormat.parse(fromDate);                           

                                                        fromdate=          dateFormat.format(fromdate1);

                                                        fromdate2=dateFormat1.format(fromdate1);



                                                        Date todate1=(Date)dateFormat.parse(toDate);



                                                        todate=dateFormat.format(todate1);

                                                        todate2=dateFormat1.format(todate1);





                                        } catch (ParseException e) {

                                                        // TODO Auto-generated catch block

                                                        e.printStackTrace();

                                        }

                                        //DefectId: DF20131018 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period

                                        startDateInPeriod = fromdate;

                                        lastDateInPeriod = todate;



                                        List<String> dateList= new LinkedList<String>();                                                                               

                                        Calendar calendar = Calendar.getInstance();                                                                      

                                        /*do

                                                        {

                                                                        dateList.add(fromdate2);

                                                                        calendar.setTime(fromdate1);

                                                                        calendar.add(Calendar.DAY_OF_YEAR, 1);

                                                                        fromdate1 = calendar.getTime();                                             

                                                                        fromdate2 = dateFormat1.format(fromdate1);





                                                        } while ((fromdate2.compareTo(todate2)) <=0);*/

                                        String dateStringList=conversionObj.getStringList(dateList).toString();





                                        //Suresh df20151102 new implementation for utilisation summary report

                                       

                                        basicFromQuery = basicFromQuery + " AssetMonitoringFactDataDayAgg a1,AssetMonitoringFactDataDayAgg a2";

                                        //end Defect ID:1406

                                        basicWhereQuery = basicWhereQuery

                                        + " and a1.timeKey <= '"+fromdate2+"' and a1.timeKey > '"+todate2+"' "

                                        +" and a2.timeKey= (select max(a.timeKey) "+

                                        "from AssetMonitoringFactDataDayAgg a "+

                                        "where a.serialNumber = aos.serialNumber and a.timeKey<'"+todate2 +"') ";

                                       

                                       

                                        /*//Defect ID:1406 (Smitha oct 4th 2013) machine grouping

                                        basicFromQuery = basicFromQuery + " AssetMonitoringFactDataDayAgg a";

                                        //end Defect ID:1406

                                        basicWhereQuery = basicWhereQuery+ " and a.timeKey between '"+fromdate2+"' and '"+todate2+"' ";*/

                                       

                                        //Suresh df20151102 new implementation for utilisation summary report

                                       

                                        if(basicGroupByQuery.length()>2)

                                        {

                                                        //                                                                                            basicGroupByQuery =basicGroupByQuery+ " ,a.timeKey,a.tenancyId";

                                                        //added by smitha on oct 15th 2013[custom dates aggregation for a VIN query change.... Internal Defect 20131014]

                                                        basicGroupByQuery ="a1.serialNumber ,a1.tenancyId ";

                                                        //ended on oct 15th 2013[custom dates aggregation for a VIN query change.... Internal Defect 20131014]

                                        }

                                        else

                                        {

                                                        //                                                                                            basicGroupByQuery = " group by a.serialNumber,a.timeKey,a.tenancyId";

                                                        //added by smitha on oct 15th 2013[custom dates aggregation for a VIN query change.... Internal Defect 20131014]

                                                        basicGroupByQuery = " group by a1.serialNumber,a1.tenancyId  ";

                                                        //ended on oct 15th 2013[custom dates aggregation for a VIN query change.... Internal Defect 20131014]

                                        }

                                       

                                        /*if(basicGroupByQuery.length()>2)

                                        {

                                                        //                                                                                            basicGroupByQuery =basicGroupByQuery+ " ,a.timeKey,a.tenancyId";

                                                        //added by smitha on oct 15th 2013[custom dates aggregation for a VIN query change.... Internal Defect 20131014]

                                                        basicGroupByQuery ="a.serialNumber ,a.tenancyId,c.group_id , ten1.tenancy_id ";

                                                        //ended on oct 15th 2013[custom dates aggregation for a VIN query change.... Internal Defect 20131014]

                                        }

                                        else

                                        {

                                                        //                                                                                            basicGroupByQuery = " group by a.serialNumber,a.timeKey,a.tenancyId";

                                                        //added by smitha on oct 15th 2013[custom dates aggregation for a VIN query change.... Internal Defect 20131014]

                                                        basicGroupByQuery = " group by a.serialNumber,a.tenancyId,c.group_id, ten1.tenancy_id  ";

                                                        //ended on oct 15th 2013[custom dates aggregation for a VIN query change.... Internal Defect 20131014]

                                        }*/

                                        fromdateFormatted= dateFormat.format(dateFormat.parse(fromDate));           

                                        todateFormatted = dateFormat.format(dateFormat.parse(toDate));

                        }

                        //Logic for Custom Dates (fromDate,toDate) added by Juhi on 14-August-2013

                        //Suresh df20151102 new implementation for utilisation summary report

                        //basicFromQuery = basicFromQuery + ",TenancyDimensionEntity b ";

                        boolean machineGroup = false;

                        boolean machineProfile = false;

                        boolean model = false;

                        machineGroup=true;

                        /*if (!(customAssetGroupIdList == null || customAssetGroupIdList

                                                        .isEmpty())) {

                                        String customAssetGroupStringList = conversionObj

                                        .getIntegerListString(customAssetGroupIdList)

                                        .toString();

                                        basicSelectQuery = basicSelectQuery

                                        + ", c.group_id as machineGroupId, c.group_name as machineGroupName ";

                                        basicFromQuery = basicFromQuery

                                        + " , CustomAssetGroupEntity c, AssetCustomGroupMapping h ";

                                        basicWhereQuery = basicWhereQuery

                                        + " and c.group_id = h.group_id and c.group_id in ("

                                        + customAssetGroupStringList + ") and "

                                        + " h.serial_number = a.serialNumber ";

                                        basicWhereQuery = basicWhereQuery

                                        + " and c.group_id in ("

                                        + customAssetGroupStringList + ")";

                                        //                                                            machineGroup=true;

                        }*/

/*

                        if ((!(assetGroupIdList == null || assetGroupIdList.isEmpty()))

                                                        || (!(modelIdList == null || modelIdList.isEmpty()))) {

                                        basicFromQuery = basicFromQuery

                                        + " , AssetClassDimensionEntity d ";

                                        basicWhereQuery = basicWhereQuery

                                        + " and a.assetClassDimensionId = d.assetClassDimensionId";



                        }



                        if (!(assetGroupIdList == null || assetGroupIdList.isEmpty())) {

                                        String assetGroupStringList = conversionObj

                                        .getIntegerListString(assetGroupIdList).toString();

                                        basicSelectQuery = basicSelectQuery

                                        + " ,d.assetGroupId as profileId, d.assetGroupName as profileName ";

                                        basicWhereQuery = basicWhereQuery + " and d.assetGroupId in ( "

                                        + assetGroupStringList + " )";

                                        machineProfile = true;

                        }



                        if (!(modelIdList == null || modelIdList.isEmpty())) {

                                        String modelIdStringList = conversionObj.getIntegerListString(

                                                                        modelIdList).toString();



                                        basicSelectQuery = basicSelectQuery

                                        + " , d.assetTypeId as modelId, d.assetTypeName as modelName ";

                                        basicWhereQuery = basicWhereQuery + " and d.assetTypeId in ( "

                                        + modelIdStringList + " )";

                                        model = true;

                        }*/

                        //added by smitha on oct 15th 2013[custom dates aggregation for a VIN query change.... Internal Defect 20131014]

                        /*if(querySelected==false){

                                        finalQuery = basicSelectQuery + basicFromQuery + basicWhereQuery + basicGroupByQuery + " order by a.serialNumber, ten.tenancy_id ";

                                        }

                                        else{

                        */                          finalQuery = basicSelectQuery + basicFromQuery + basicWhereQuery + basicGroupByQuery + " order by a1.serialNumber, a1.tenancyId ";



                        //ended on oct 15th 2013[custom dates aggregation for a VIN query change.... Internal Defect 20131014]

                        //                                           finalQuery = basicSelectQuery + basicFromQuery + basicWhereQuery + basicGroupByQuery;

                        //DefectID:1406 Suprava 2013/10/30

                        List<String> otherMachineGroupVins = new LinkedList<String>();
                    //    System.out
					//			.println("finalQuery----"+finalQuery);
                        iLogger.info("stmt2-----------"+finalQuery);
                        
                       

                        Query query = session.createQuery(finalQuery);

                        Iterator itr = query.list().iterator();

                        Object[] result = null;

                        iLogger.info("stmt3-----------");

                        while (itr.hasNext()) {

                                        impObj = new UtilizationSummaryReportImpl();

                                        result = (Object[]) itr.next();

                                        impObj.setTenancyId(((TenancyEntity) result[0]).getTenancy_id());

                                        if (result[1] != null)         {

                                                        impObj.setTenancyName(result[1].toString());

                                        }

                                        if (result[2] != null){

                                                        impObj.setMachineName(result[2].toString());

                                        }

                                        if(result[3]!=null)

                                        {

                                                        tempSerialNumberUtilization=result[3].toString();



                                        }



                                        if( (!isGroupingOnAssetGroup) && (tempSerNumListUtilization.contains(tempSerialNumberUtilization)))

                                         {

                                                        continue;

                                        }

                                        impObj.setSerialNumber(result[3].toString());

                                        //System.out.println(result[3].toString());



                                        /*if (result[4] != null){

                                                        EngineWorkingDurationInMin=(Integer) result[4];

                                        }*/

                                        if (result[4] != null){

                                                        //                                           DefectId:1632 @ suprava

                                                        engineRunDuration=Math.round(Double.valueOf(df2.format((Double)result[4])));

                                                        impObj.setEngineRunDurationInMin(engineRunDuration);

                                                        // System.out.println("engineRunDuration"+engineRunDuration);

                                        }

                                        impObj.setEngineRunDurationInMin(engineRunDuration);

                                        /* if (result[6] != null){

                                                        if(period == null){

                                                                        Timestamp currentTimeStamp = (Timestamp) result[6];

                                                                        Date lastCommDate = new Date(currentTimeStamp.getTime());

                                                                        Calendar cal = Calendar.getInstance();

                                                                        cal.setTime(lastCommDate);

                                                                        int firstDay = cal.get(Calendar.DAY_OF_YEAR);

                                                                        cal.setTime(dateFrmt.parse(toDate));

                                                                        int lastDay = cal.get(Calendar.DAY_OF_YEAR);

                                                                        engineOffHours = ((firstDay - lastDay)*24 - engineRunDuration);

                                                        }

                                                        else if(period!=null)

                                                        {

                                                                       

                                                                         int durationPeriod = 0;

                                                                        int currentPeriod = 0;

                                                                        int lastCommunicatedPeriod = (Integer) result[6];

                                                                        currentPeriod = (Integer) result[5];

                                                                        switch(periodType.charAt(0))

                                                                        {

                                                                        case 'w' :

                                                                                        durationPeriod = (currentPeriod-lastCommunicatedPeriod)*7;    

                                                                                        break;

                                                                        case 'm' :

                                                                                         durationPeriod = (currentPeriod-lastCommunicatedPeriod)*30;

                                                                                        break;

                                                                        case 'q' :

                                                                                        durationPeriod = (currentPeriod-lastCommunicatedPeriod)*90;

                                                                                        break;

                                                                        case 'y' :

                                                                                        durationPeriod = (currentPeriod-lastCommunicatedPeriod)*365;

                                                                                        break;

                                                                        }

                                                                        engineOffHours              = Double.valueOf(df2.format(((currentDayofPeriod + (durationPeriod*24)) - engineRunDuration)));

                                                        }*/

                                                       

                                                         

                                                         //Done by Juhi on DF:20131209 Integer to Long Cast

                                                         //                                                                           if(querySelected==false){

                                                        //                                                                           Keerthi : 10/12/13 : taking off hours  as int instead of Long

                                                        // engineOffHours=Double.valueOf(df2.format((Double)result[5]));

                                                        //                                                                           }else{

                                                        //                                                                           engineOffHours1=(Long) result[5];

                                                        //                                                                           }

                                                        //System.out.println("engineOffHours"+engineOffHours);



                                        /*double workingTime1 = (Double)result[4];*/



                        /*           if(period==null)

                                        {

                                                        Date newerDate = dateFrmt.parse(todateFormatted);

                                                        Date olderDate = dateFrmt.parse(fromdateFormatted);

                                                        double diffInDays = (double)( (newerDate.getTime() - olderDate.getTime())

                                                                                         / (1000 * 60 * 60 * 24) );

                                                        diffInDays= diffInDays+1;

                                                        double engineOffLong = (24*diffInDays)-engineRunDuration;

                                                        //engineOffInt = (double)engineOffLong;

                                                        //           implObj.setEngineOff(engineOffInt);

                                                        impObj.setEngineOffDurationInMin(Double.valueOf(df2.format((Double)engineOffLong)));

                                                        //                                                                           Keerthi : 27/12/2013 : calculating engine off hours for custom dates

                                                        engineOffHours = engineOffLong;

                                        }else{*/



                                                        Date newerDate = dateFrmt.parse(lastDateInPeriod);

                                                        Date olderDate = dateFrmt.parse(startDateInPeriod);

                                                        //System.out.println(newerDate+":"+olderDate);

                                                        double diffInDays = (double)( (newerDate.getTime() - olderDate.getTime())

                                                                                         / (1000 * 60 * 60 * 24) );

                                                        diffInDays= diffInDays+1;

                                                        double engineOffLong = (24*diffInDays)-engineRunDuration;

                                                        // System.out.println("dissInDays"+diffInDays+"engineOffLong"+engineOffLong);

                                                        //engineOffInt = (double)engineOffLong;

                                                        //           implObj.setEngineOff(engineOffInt);

                                                        //impObj.setEngineOffDurationInMin(Double.valueOf(df2.format((Double)engineOffLong)));

                                                        //                                                                           Keerthi : 27/12/2013 : calculating engine off hours for custom dates

                                                        engineOffHours = Double.valueOf(df2.format((Double)engineOffLong));

                                        impObj.setEngineOffDurationInMin(engineOffHours);

                                        //Changes done by Juhi on 6 May2013

                                        /* if (result[6] != null){

                                                        impObj.setEngineWorkingDurationInMin(Double.valueOf(df2.format((Double)result[6])));

                                        }*/

                                        DecimalFormat df3 = new DecimalFormat("###.##");

                                        Double machineUtilization=0.0;

                                        if(!(engineRunDuration+engineOffHours ==0)){

                                        machineUtilization=(Double.valueOf(df3.format((Double) ((engineRunDuration/(engineRunDuration+engineOffHours))*100))));

                                        }

                                        else

                                        {

                                                        machineUtilization=0.0;

                                         }

                                        if(machineUtilization!=null){

                                                        impObj.setMachineUtilizationPercentage(machineUtilization);

                                        }

                                        //DefectId:20150225 @ Suprava Delaer As a new parameter Added

                                        TenancyEntity tenancyEntity =null;

                                                        if(result[6]!=null)

                                                                                        {

                                                                                                        //int tenancyTypeId =(Integer) result[11];

                                                                                                        String accountType = (String)result[6];

                                                                                                        //If the Machine is with customer Get the parentTeancyId

                                                                                                        if(accountType.equalsIgnoreCase("Customer"))

                                                                                                        {

                                                                                                                        //tenancyEntity =(TenancyEntity)result[10];

                                                                                                                        impObj.setDealerName(result[5].toString());

                                                                                                        }

                                                                                                        //If the Machine is with Dealer

                                                                                                        else if(accountType.equalsIgnoreCase("Dealer"))

                                                                                                        {

                                                                                                                        if(result[1]!=null)

                                                                                                                        {

                                                                                                                        //String Dealername =(String)result[1];

                                                                                                                        impObj.setDealerName(result[1].toString());

                                                                                                        }

                                                                                                        }

                                                                                                        else

                                                                                                        {

                                                                                                                        impObj.setDealerName("No Dealer Tagging");

                                                                                                        }

                                                                                       

                                                                                        }

                                                        //End of DefectId:20150225



                                        /*if (machineGroup == true) {

                                                        //null check by smitha on 7th oct 2013

                                                        if(result[7]!=null){

                                                        impObj.setMachineGroupId((Integer) result[7]);

                                                        }

                                                        //end on 7th 0ct 2013

                                                        if (result[8] != null){

//                                                                            infoLogger.info("MachineGroupName   "+(result[8].toString()));

                                                                        impObj.setMachineGroupName(result[8].toString());

                                                        }

                                        }*/

                                        //DefectID:1406 - Suprava - 2013-October-30 - To return Report Totals

                                        if(!(tempSerNumListUtilization.contains(tempSerialNumberUtilization)))

                                        {



                                                        totalengineOffDurationInMin = totalengineOffDurationInMin+engineOffHours;

                                                        //totalengineWorkingDurationInMinsumm = totalengineWorkingDurationInMinsumm+(Double.valueOf(df2.format((Double)result[6])));

                                                        totalmachineUtilizationPercentagesumm = totalmachineUtilizationPercentagesumm+(machineUtilization);

                                                        totalengineRunDurationInMinsumm = totalengineRunDurationInMinsumm+(engineRunDuration);

                                        }



                                        //DefectID: 1406 Suprava

                                        int otherMachineGroup =0;

                                        /*if(result[9]!=null)

                                        {

                                                        int mgTenancy = (Integer) result[9];

                                                        if(! (loginTenancyIdList.contains(mgTenancy)) )

                                                         {

                                                                        otherMachineGroup=1;

                                                        }

                                        }*/



                                        if(( (otherMachineGroupVins.contains(tempSerialNumberUtilization)) || (tempSerNumListUtilization.contains(tempSerialNumberUtilization)) ) )

                                        {

                                                        continue;

                                        }

                                        //DefectId:1406 End

                                        //DefectID:1406 - Suprava Nayak - 20131028 - MachineGrouping issue in Reports and sending Report Totals information

                                        /*if (machineGroup == true){

                                                        if(result[9]!=null)

                                                        {

                                                                        int mgTenancy = (Integer) result[9];

                                                                        if(loginTenancyIdList.contains(mgTenancy))

                                                                         {

                                                                                        if(result[7]!=null)

                                                                                                        impObj.setMachineGroupId((Integer)result[7]);



                                                                                        if(result[8]!=null)

                                                                                                        impObj.setMachineGroupName(result[8].toString());

                                                                        }

                                                                        else

                                                                        {

                                                                                        otherMachineGroupVins.add(tempSerialNumberUtilization);

                                                                        }



                                                        }

                                        }*/

                                        /* if (machineProfile == true) {

                                                        if (machineGroup == true) {

                                                                        impObj.setMachineProfileId((Integer) result[10]);

                                                                        if (result[11] != null){

                                                                                        impObj.setMachineProfileName(result[11].toString());

                                                                        }

                                                        } else {

                                                                        impObj.setMachineProfileId((Integer) result[7]);

                                                                        if (result[8] != null){

                                                                                        impObj.setMachineProfileName(result[8].toString());

                                                                        }

                                                        }

                                        }*/

                                     /*   if (machineProfile == true) {

                                                        if (machineGroup == true) {

                                                                        impObj.setMachineProfileId((Integer) result[9]);

                                                                        if (result[10] != null){

                                                                                        impObj.setMachineProfileName(result[10].toString());

                                                                        }

                                                        }

                                                         }*/

                                        /*if (model == true) {

                                                        if (machineProfile == true) {

                                                                        if (machineGroup == true) {

                                                                                        impObj.setModelId((Integer) result[12]);

                                                                                        if (result[13] != null){

                                                                                                        impObj.setModelName(result[13].toString());

                                                                                        }

                                                                        } else {

                                                                                        impObj.setModelId((Integer) result[10]);

                                                                                        if (result[11] != null){

                                                                                                        impObj.setModelName(result[11].toString());

                                                                                        }

                                                                        }

                                                        } else {

                                                                        if (machineGroup == true) {

                                                                                        impObj.setModelId((Integer) result[10]);

                                                                                        if (result[11] != null){

                                                                                                        impObj.setModelName(result[11].toString());

                                                                                        }

                                                                        } else {

                                                                                        impObj.setModelId((Integer) result[7]);

                                                                                        if (result[8] != null){

                                                                                                        impObj.setModelName(result[8].toString());

                                                                                        }

                                                                        }                                                                            

                                                        }



                                        }*/

                                        /*if (model == true) {

                                                        if (machineProfile == true) {

                                                                        if (machineGroup == true) {

                                                                                        impObj.setModelId((Integer) result[11]);

                                                                                        if (result[12] != null){

                                                                                                        impObj.setModelName(result[12].toString());

                                                                                        }

                                                                        } else {

                                                                                        impObj.setModelId((Integer) result[9]);

                                                                                        if (result[11] != null){

                                                                                                        impObj.setModelName(result[11].toString());

                                                                                        }

                                                                        }

                                                        } else {

                                                                        if (machineGroup == true) {

                                                                                        impObj.setModelId((Integer) result[9]);

                                                                                        if (result[10] != null){

                                                                                                        impObj.setModelName(result[10].toString());

                                                                                        }

                                                                        }                                            

                                                        }



                                        }
*/
                                        tempSerNumListUtilization.add(tempSerialNumberUtilization);

                                        responseList.add(impObj);

                                        //System.out.println(responseList.size());

                        }
                        iLogger.info("stmt 4---------------");

                        //-------------------------------------------------------------------------------------------------------------------

                        //DefectId: DF20131218 - Juhi To display the VINs that has not communicated for the given time period

                        /* Query ownerListQuery = session.createQuery(" select distinct c.serialNumber " +

                                                        " from TenancyBridgeEntity a, AccountTenancyMapping b, AssetAccountMapping c " +

                                                        " where a.childId= b.tenancy_id " +

                                                        " and b.account_id= c.accountId " +

                                                        " and a.parentId in ("+childTenancyIdStringList+") and" +

                                                        " ( (c.ownershipStartDate between '"+startDateInPeriod+"' and '"+lastDateInPeriod+"') OR " +

                                                        "   (c.ownershipStartDate = ( select max(y.ownershipStartDate) from AssetAccountMapping y " +

                                                        " where y.serialNumber= c.serialNumber" +

                                                        " and y.ownershipStartDate <='"+startDateInPeriod+"')" +

                                                        "    )" +

                        " )");*/

                       

                         //S Suresh new query implementation for utilisation summary report

                        String TenancyIdStringList = conversionObj.getIntegerListString(

                                                                        tenancyIdList1).toString();

                        //System.out.println("Hiii");
                        if(!(session.isOpen()))   // seesion open 2016-02-24
                        {
                        	session = HibernateUtil.getSessionFactory().getCurrentSession();
                        	session.beginTransaction();
                        }

                        String vinListquery = "select distinct a.serialNumber " +

                                                        "from AssetOwnerSnapshotEntity a, AccountTenancyMapping b " +

                                                        "where b.tenancy_id in ("+TenancyIdStringList+") "+

                                                        "and a.accountId  = b.account_id and"+

                                                        " ((a.assetOwnershipDate between '"+startDateInPeriod+"' and '"+lastDateInPeriod+"') OR " +

                                                        "   (a.assetOwnershipDate = ( select max(y.assetOwnershipDate) from AssetOwnerSnapshotEntity y " +

                                                        " where y.serialNumber= a.serialNumber" +

                                                        " and y.assetOwnershipDate <='"+startDateInPeriod+"')" +

                                                        "    )" +

                        " )";

                        //System.out.println(vinListquery);
                        
                        iLogger.info("stmt 5---------------"+vinListquery);
                        Query ownerListQuery = session.createQuery(vinListquery);

                        Iterator ownerListItr = ownerListQuery.list().iterator();

                        List<String> actualOwnerVINList = new LinkedList<String>();
                        iLogger.info("stmt 6---------------");
                        while(ownerListItr.hasNext())

                        {

                                        String VinNumber = (String)ownerListItr.next();

                                        actualOwnerVINList.add(VinNumber);

                        }
                        iLogger.info("stmt 7---------------");
                        //System.out.println("actualOwnerVINList.size()"+actualOwnerVINList.size());

                        //Get only the List of VINs which has not communicated for the Given period

                        actualOwnerVINList.removeAll(tempSerNumListUtilization);

                        String actualOwnerVinListString = conversionObj.getStringList(actualOwnerVINList).toString();
                        iLogger.info("stmt 7.1---------------");

                        /*basicSelectQuery = "select b.tenancyId, b.tenancyName, a.machineName, a.serialNumber, " +

                        //                                           " (a.EngineRunningBand1+a.EngineRunningBand2+a.EngineRunningBand3+a.EngineRunningBand4+a.EngineRunningBand5+a.EngineRunningBand6+a.EngineRunningBand7+a.EngineRunningBand8) as engineRunDurationInMin,"

                        //                                           +"a.engineOffHours as engineOffDurationInMin , (a.EngineRunningBand3+a.EngineRunningBand4+a.EngineRunningBand5+a.EngineRunningBand6+a.EngineRunningBand7+a.EngineRunningBand8) as engineWorkingDurationInMin,

                        " c.group_id as machineGroupId, c.group_name as machineGroupName,"+

                        " ten.tenancy_id as mgTenancy, ten1.parent_tenancy_id,b.tenancyTypeId";





                        basicFromQuery = "from AssetCustomGroupMapping h RIGHT OUTER JOIN h.serial_number x  LEFT OUTER JOIN h.group_id c "+

                        " LEFT OUTER JOIN c.tenancy_id ten ,TenancyEntity ten1,TenancyDimensionEntity b, AssetMonitoringFactDataDayAgg a " ;



                        basicWhereQuery = " where ten1.tenancy_id = b.tenancyId and a.tenancyId = b.tenacy_Dimension_Id and b.tenancyId in ("+ childTenancyIdStringList + " )" +

                        " and  a.serialNumber =x.serial_number  and a.serialNumber in ("+actualOwnerVinListString+") " +

                        " and a.timeKey = ( select max(p.timeKey) from AssetMonitoringFactDataDayAgg p where p.serialNumber = a.serialNumber " +

                        " and p.timeKey <= '"+startDateInPeriod+"' )" +

                        //DefectId:20150216 @ Suprava Dealer As a new parameter Added

                                        " and b.parentTenancyId=ten1.parent_tenancy_id ";*/

                       

                         

                         //S Suresh new Query implementation for utilization summary report

                       

                         basicSelectQuery = "select a_t1.tenancy_id,acc.account_name as TenancyName,a1.machineName, a1.serialNumber" +

                                                                        ",acc1.account_name as DealerName,aos1.accountType";





                                       

                                        basicFromQuery = " from AccountTenancyMapping a_t,AccountEntity acc, AssetOwnerSnapshotEntity aos, AssetOwnerSnapshotEntity aos1," +

                                                                        "AssetEntity vin,AccountEntity acc1,AccountTenancyMapping a_t1,AssetMonitoringFactDataDayAgg a1 ";

                                       

                                        //Suresh df20151102 new implementation for utilisation summary report

                                        basicWhereQuery = " where a_t.tenancy_id in ("+TenancyIdStringList+")"+

                                                " and aos.accountId = a_t.account_id "+

                                                "and a1.serialNumber = aos.serialNumber "+

                                                "and a1.serialNumber in ("+actualOwnerVinListString+") "+

                                                "and vin.serial_number = a1.serialNumber "+

                                                "and acc.account_id = vin.primary_owner_id "+

                                                "and a_t1.account_id = acc.account_id "+

                                                                        "and acc1.account_id = acc.parent_account_id "+

                                                "and aos1.serialNumber = vin.serial_number "+

                                                "and aos1.accountId = vin.primary_owner_id "+

                                                                        " and a1.timeKey = " +

                                                                        "( select max(p.timeKey) from AssetMonitoringFactDataDayAgg p " +

                                                                        "where p.serialNumber = a1.serialNumber and p.timeKey <= '"+startDateInPeriod+"' )";





                        basicGroupByQuery = " group by a1.serialNumber,a_t1.tenancy_id";

                        /*if (!(customAssetGroupIdList == null || customAssetGroupIdList

                                                        .isEmpty())) {

                                        String customAssetGroupStringList = conversionObj

                                        .getIntegerListString(customAssetGroupIdList)

                                        .toString();



                                        basicWhereQuery = basicWhereQuery

                                        + " and c.group_id in ("

                                        + customAssetGroupStringList + ")";



                        }



                        if ((!(assetGroupIdList == null || assetGroupIdList.isEmpty()))

                                                        || (!(modelIdList == null || modelIdList.isEmpty()))) {

                                        basicFromQuery = basicFromQuery

                                        + " , AssetClassDimensionEntity d ";

                                        basicWhereQuery = basicWhereQuery

                                        + " and a.assetClassDimensionId = d.assetClassDimensionId";



                        }



                        if (!(assetGroupIdList == null || assetGroupIdList.isEmpty())) {

                                        String assetGroupStringList = conversionObj

                                        .getIntegerListString(assetGroupIdList).toString();

                                        basicSelectQuery = basicSelectQuery

                                        + " ,d.assetGroupId as profileId, d.assetGroupName as profileName ";

                                        basicWhereQuery = basicWhereQuery + " and d.assetGroupId in ( "

                                        + assetGroupStringList + " )";

                                        machineProfile = true;

                        }



                        if (!(modelIdList == null || modelIdList.isEmpty())) {

                                        String modelIdStringList = conversionObj.getIntegerListString(

                                                                        modelIdList).toString();



                                        basicSelectQuery = basicSelectQuery

                                        + " , d.assetTypeId as modelId, d.assetTypeName as modelName ";

                                        basicWhereQuery = basicWhereQuery + " and d.assetTypeId in ( "

                                        + modelIdStringList + " )";

                                        model = true;

                        }*/
                        if(!(session.isOpen()))
                        {
                        	session = HibernateUtil.getSessionFactory().getCurrentSession();
                        	session.beginTransaction();
                        	iLogger.info("stmt-------session created again");
                        }

                        if(! (actualOwnerVINList==null || actualOwnerVINList.isEmpty()))

                        {
                        	iLogger.info("stmt 7.2---------------");
                                        finalQuery = basicSelectQuery + basicFromQuery + basicWhereQuery + basicGroupByQuery + " order by a1.serialNumber, a1.lastReported desc  ";

                                        Iterator vinListItr = session.createQuery(finalQuery).list().iterator();

                                        tempSerNumListUtilization= new ArrayList<String>();

                                        result =null;

                                        //                           Keerthi : 09/01/2014 : using proper iterator for non communicated pins.
                                        iLogger.info("stmt-------vinListItr");
                                        while (vinListItr.hasNext()) {

                                                        impObj = new UtilizationSummaryReportImpl();

                                                        result = (Object[]) vinListItr.next();

                                                        impObj.setTenancyId(((TenancyEntity) result[0]).getTenancy_id());

                                                        if (result[1] != null)         {

                                                                        impObj.setTenancyName(result[1].toString());

                                                        }

                                                        if (result[2] != null){

                                                                        impObj.setMachineName(result[2].toString());

                                                        }

                                                        if(result[3]!=null)

                                                        {

                                                                        tempSerialNumberUtilization=result[3].toString();



                                                        }





                                                        if( (!isGroupingOnAssetGroup) && (tempSerNumListUtilization.contains(tempSerialNumberUtilization)))

                                                         {

                                                                        continue;

                                                        }

                                                        impObj.setSerialNumber(result[3].toString());

                                                        impObj.setEngineRunDurationInMin(0d);

                                                        //                                           Keerthi : 13/01/14 : taking diff in days

                                                        Date newerDate = dateFrmt.parse(lastDateInPeriod);

                                                        Date olderDate = dateFrmt.parse(startDateInPeriod);

                                                        double diffInDays = (double)( (newerDate.getTime() - olderDate.getTime())

                                                                                         / (1000 * 60 * 60 * 24) );

                                                        diffInDays= diffInDays+1;

                                                        double engineOff = (24*diffInDays);//engine on 0 for non-communicated period

                                                        //                                           engineOffInt = (double)engineOffLong;

                                                        impObj.setEngineOffDurationInMin(engineOff);

                                                        impObj.setMachineUtilizationPercentage(0d);

                                                        /*if (result[4] != null){

                                        EngineWorkingDurationInMin=(Integer) result[4];

                        }*/

                                                        /*if (result[4] != null){

//    DefectId:1632 @ suprava

                                        engineRunDuration=Math.round(Double.valueOf(df2.format((Double)result[4])));

                                        impObj.setEngineRunDurationInMin(engineRunDuration);

                        }

                        impObj.setEngineRunDurationInMin(engineRunDuration);

                        if (result[5] != null){

                                        //Done by Juhi on DF:20131209 Integer to Long Cast

//                                    if(querySelected==false){

//                                    Keerthi : 10/12/13 : taking off hours  as int instead of Long

                                        engineOffHours=Double.valueOf(df2.format((Double)result[5]));

//                                    }else{

//                                    engineOffHours1=(Long) result[5];

//                                    }

                        }

                        if (result[5] != null)

                        {

                                        impObj.setEngineOffDurationInMin(Double.valueOf(df2.format((Double)result[5])));

                        }

                        //Changes done by Juhi on 6 May2013

                        if (result[6] != null){

                                        impObj.setEngineWorkingDurationInMin(Double.valueOf(df2.format((Double)result[6])));

                        }*/

                                                        /*DecimalFormat df4 = new DecimalFormat("###.##");

                        Double machineUtilization=(Double.valueOf(df4.format((Double) ((engineRunDuration/(engineRunDuration+engineOffHours))*100))));

                        if(machineUtilization!=null){

                                        impObj.setMachineUtilizationPercentage(machineUtilization); 

                        }*/





                                                        /*if (machineGroup == true) {

                                        //null check by smitha on 7th oct 2013

                                        if(result[7]!=null){

                                        impObj.setMachineGroupId((Integer) result[7]);

                                        }

                                        //end on 7th 0ct 2013

                                        if (result[8] != null){

                                                        impObj.setMachineGroupName(result[8].toString());

                                        }

                        }*/

                                                        //DefectID:1406 - Suprava - 2013-October-30 - To return Report Totals

                                                        if(!(tempSerNumListUtilization.contains(tempSerialNumberUtilization)))

                                                        {



                                                                        totalengineOffDurationInMin = totalengineOffDurationInMin+Double.valueOf(df2.format(engineOff));

                                                                        //                                                           totalengineWorkingDurationInMinsumm = totalengineWorkingDurationInMinsumm+(Double.valueOf(df2.format((Double)result[6])));

                                                                        //                                                           totalmachineUtilizationPercentagesumm = totalmachineUtilizationPercentagesumm+(machineUtilization);

                                                                        //                                                           totalengineRunDurationInMinsumm = totalengineRunDurationInMinsumm+(engineRunDuration);

                                                        }



                                                        //DefectID: 1406 Suprava

                                                        /*/

                                                        //DefectId:20150220 @ Suprava Delaer As a new parameter Added

                                                        TenancyEntity tenancyEntity =null;        

                                                        if(result[5]!=null)

                                                                        {

                                                                                        //int tenancyTypeId =(Integer) result[11];

                                                                                        String accountType = (String)result[5];

                                                                                        //If the Machine is with customer Get the parentTeancyId

                                                                                        if(accountType.equalsIgnoreCase("Customer"))

                                                                                        {

                                                                                                        //tenancyEntity =(TenancyEntity)result[10];

                                                                                                        impObj.setDealerName(result[4].toString());

                                                                                        }

                                                                                        //If the Machine is with Dealer

                                                                                        else if(accountType.equalsIgnoreCase("Dealer"))

                                                                                        {

                                                                                                        if(result[1]!=null)

                                                                                                        {

                                                                                                        //String Dealername =(String)result[1];

                                                                                                        impObj.setDealerName(result[1].toString());

                                                                                        }

                                                                                        }

                                                                                        else

                                                                                        {

                                                                                                        impObj.setDealerName("No Dealer Tagging");

                                                                                        }

                                                                                                       

                                                                                                        }

                                                        //DefectId:20150225 End

                                                        if( (otherMachineGroup==1)&& ( (otherMachineGroupVins.contains(tempSerialNumberUtilization)) || (tempSerNumListUtilization.contains(tempSerialNumberUtilization)) ) )

                                                        {

                                                                        continue;

                                                        }

                                                        //DefectId:1406 End

                                                        //DefectID:1406 - Suprava Nayak - 20131028 - MachineGrouping issue in Reports and sending Report Totals information

                                                        /* if (machineGroup == true){

                                                                        if(result[6]!=null)

                                                                        {

                                                                                        int mgTenancy = (Integer) result[6];

                                                                                        if(loginTenancyIdList.contains(mgTenancy))

                                                                                         {

                                                                                                        if(result[4]!=null)

                                                                                                                        impObj.setMachineGroupId((Integer)result[4]);



                                                                                                        if(result[5]!=null)

                                                                                                                        impObj.setMachineGroupName(result[5].toString());

                                                                                        }

                                                                                        else

                                                                                        {

                                                                                                        otherMachineGroupVins.add(tempSerialNumberUtilization);

                                                                                        }



                                                                        }

                                                        }*/

                                                        /*if (machineProfile == true) {

                                                                        if (machineGroup == true) {

                                                                                        if( result[4]!=null){

                                                                                                        impObj.setMachineProfileId((Integer) result[4]);

                                                                                        }                                                                            

                                                                                        if (result[8] != null){

                                                                                                        impObj.setMachineProfileName(result[8].toString());

                                                                                        }

                                                                        } else {

                                                                                        if( result[4]!=null){

                                                                                                        impObj.setMachineProfileId((Integer) result[4]);

                                                                                        }

                                                                                        if (result[5] != null){

                                                                                                        impObj.setMachineProfileName(result[5].toString());

                                                                                        }

                                                                        }

                                                        }*/

                                                        if (machineProfile == true) {

                                                                        if (machineGroup == true) {

                                                                                        if( result[4]!=null){

                                                                                                        impObj.setMachineProfileId((Integer) result[4]);

                                                                                        }                                                                            

                                                                                        if (result[10] != null){

                                                                                                        impObj.setMachineProfileName(result[10].toString());

                                                                                        }

                                                                        } else {

                                                                                        if( result[4]!=null){

                                                                                                        impObj.setMachineProfileId((Integer) result[4]);

                                                                                        }

                                                                                        if (result[5] != null){

                                                                                                        impObj.setMachineProfileName(result[5].toString());

                                                                                        }

                                                                        }

                                                        }

                                                        /*if (model == true) {

                                                                        if (machineProfile == true) {

                                                                                        if (machineGroup == true) {

                                                                                                        if( result[9]!=null){

                                                                                                                        impObj.setModelId((Integer) result[9]);

                                                                                                        }

                                                                                                        if (result[10] != null){

                                                                                                                        impObj.setModelName(result[10].toString());

                                                                                                        }

                                                                                        } else {

                                                                                                        if( result[7]!=null){

                                                                                                                        impObj.setModelId((Integer) result[7]);

                                                                                                        }

                                                                                                        if (result[8] != null){

                                                                                                                        impObj.setModelName(result[8].toString());

                                                                                                        }

                                                                                        }

                                                                        } else {

                                                                                        if (machineGroup == true) {

                                                                                                        if( result[7]!=null){

                                                                                                                        impObj.setModelId((Integer) result[7]);

                                                                                                        }

                                                                                                        if (result[8] != null){

                                                                                                                        impObj.setModelName(result[8].toString());

                                                                                                        }

                                                                                        } else {

                                                                                                        if( result[4]!=null){

                                                                                                                        impObj.setModelId((Integer) result[4]);

                                                                                                        }

                                                                                                        if (result[5] != null){

                                                                                                                        impObj.setModelName(result[5].toString());

                                                                                                        }

                                                                                        }                                                                            

                                                                        }



                                                        }*/

                                                        if (model == true) {

                                                                        if (machineProfile == true) {

                                                                                        if (machineGroup == true) {

                                                                                                        if( result[11]!=null){

                                                                                                                        impObj.setModelId((Integer) result[11]);

                                                                                                        }

                                                                                                        if (result[12] != null){

                                                                                                                        impObj.setModelName(result[12].toString());

                                                                                                        }

                                                                                        } else {

                                                                                                        if( result[9]!=null){

                                                                                                                        impObj.setModelId((Integer) result[9]);

                                                                                                        }

                                                                                                        if (result[10] != null){

                                                                                                                        impObj.setModelName(result[10].toString());

                                                                                                        }

                                                                                        }

                                                                        } else {

                                                                                        if (machineGroup == true) {

                                                                                                        if( result[9]!=null){

                                                                                                                        impObj.setModelId((Integer) result[9]);

                                                                                                        }

                                                                                                        if (result[10] != null){

                                                                                                                        impObj.setModelName(result[10].toString());

                                                                                                        }

                                                                                        } else {

                                                                                                        if( result[4]!=null){

                                                                                                                        impObj.setModelId((Integer) result[4]);

                                                                                                        }

                                                                                                        if (result[5] != null){

                                                                                                                        impObj.setModelName(result[5].toString());

                                                                                                        }

                                                                                        }                                                                            

                                                                        }



                                                        }

                                                       

                                                         tempSerNumListUtilization.add(tempSerialNumberUtilization);

                                                        responseList.add(impObj);

                                        }
                                        iLogger.info("stmt-------");

                        }

                        //-------------------------------------------------------------------------------------------------------------------

                        //DefectId: DF20131218 - Juhi To display the VINs that has not communicated for the given time period

                         //added by smitha on oct 14th 2013[to display the machines which have not communicated .... Internal Defect 20131014]

                        /*          commented by Juhi on 10-12-2013---start

                          * Set mapSet = (Set) calledSerNumMapUtilization.entrySet();

                        Iterator mapIterator = mapSet.iterator();            

                        while (mapIterator.hasNext()) {

                                        Map.Entry mapEntry = (Map.Entry) mapIterator.next();

                                        String keyValue = (String) mapEntry.getKey();

                                        int value = (Integer)mapEntry.getValue();

                                        AllSerNumListUtilization.add(keyValue);



        }             



                        int tenancyId=0;

                        String tenancyName2=null;

                        Integer groupID1=0;

                        String groupName2=null;

                        Iterator iterSerialNoList = AllSerNumListUtilization.iterator();

                        for (String serialNo : AllSerNumListUtilization) {

                        if(!tempSerNumListUtilization.contains(serialNo))           {

                                        impObj = new UtilizationSummaryReportImpl();

                                        impObj.setEngineOffDurationInMin(0l);

                                        impObj.setEngineRunDurationInMin(0.0d);

                                        impObj.setEngineWorkingDurationInMin(0l);

                                        groupID1=serGroupID.get(serialNo);

                                        if(groupID1!=0){

                                                        impObj.setMachineGroupId(groupID1);

                                        }else{

                                                        impObj.setMachineGroupId(0);

                                        }



                                        groupName2=GroupData.get(groupID1);

                                        if(groupName2!="" || groupName2!=null){

                                                        impObj.setMachineGroupName(groupName2);

                                        }else {

                                                        impObj.setMachineGroupName(null);

                                        }



                                        impObj.setMachineProfileId(0);

                                        impObj.setMachineProfileName(null); 

                                        impObj.setMachineUtilizationPercentage(0.0d);

                                        impObj.setModelId(0);

                                        impObj.setModelName(null);                                                   

                                        impObj.setSerialNumber(serialNo);

                                        tenancyId=calledSerNumMapUtilization.get(serialNo);

                                        impObj.setTenancyId(tenancyId);

                                        tenancyName2=TenancyData.get(tenancyId);

                                        impObj.setTenancyName(tenancyName2);

                                        responseList.add(impObj);

                        }

                        }              commented by Juhi on 10-12-2013---end

                          */                                            //DefectId:1406 Suprava 2013/10/30

                        impObj = new UtilizationSummaryReportImpl();

                        impObj.setSerialNumber("Summary");

                        //System.out.println("totalengineRunDurationInMinsumm:"+totalengineRunDurationInMinsumm);

                        impObj.setEngineRunDurationInMin(totalengineRunDurationInMinsumm);

                        // System.out.println("totalengineWorkingDurationInMinsumm:"+totalengineWorkingDurationInMinsumm);

                        impObj.setEngineWorkingDurationInMin(totalengineWorkingDurationInMinsumm);

                        //Defect_id:2014-01-08 @suprava

                         if(!(totalengineRunDurationInMinsumm==0))

                        {

                                        DecimalFormat df3 = new DecimalFormat("###.##");

                                        totalmachineUtilizationPercentagesumm=(Double.valueOf(df3.format((Double)((totalengineRunDurationInMinsumm/(totalengineRunDurationInMinsumm+totalengineOffDurationInMin))*100))));

                                        impObj.setMachineUtilizationPercentage(totalmachineUtilizationPercentagesumm);

                                        // System.out.println("totalmachineUtilizationPercentagesumm:"+totalmachineUtilizationPercentagesumm);

                        }

                        else

                         {

                                        impObj.setMachineUtilizationPercentage(0.0);

                        }

                        // System.out.println("totalengineOffDurationInMin:"+totalengineOffDurationInMin);

                        impObj.setEngineOffDurationInMin(Double.valueOf(df2.format((Double)(totalengineOffDurationInMin))));

                        responseList.add(impObj);

                         //ended on oct 14th 2013[to display the machines which have not communicated .... Internal Defect 20131014]

        }



        catch (Exception e) {

                        e.printStackTrace();
                        iLogger.info("stmt exception ---------------"+e);
                        fLogger.fatal("Exception :" + e);

        }



        finally {

                        if (session.getTransaction().isActive()) {

                                        session.getTransaction().commit();

                        }



                        if (session.isOpen()) {

                                        session.flush();

                                        session.close();

                        }



        }



        return responseList;

}
	
	/*public List<UtilizationSummaryReportImpl> machineUtilizationSummaryReport(String fromDate,String toDate,
			String loginId, String period, List<Integer> tenancyIdList,
			List<Integer> customAssetGroupIdList,
			List<Integer> assetGroupIdList, List<Integer> modelIdList,
			boolean isGroupingOnAssetGroup, List<Integer> loginTenancyIdList) {
		List<UtilizationSummaryReportImpl> responseList = new LinkedList<UtilizationSummaryReportImpl>();
		HashMap<String, Integer> calledSerNumMapUtilization = new HashMap<String, Integer>();
		List<String>  tempSerNumListUtilization = new ArrayList<String>();
		List<String>  distinctSerNumList = new ArrayList<String>();
		List<String>  AllSerNumListUtilization = new ArrayList<String>();
		String tempSerialNumberUtilization=null;
		UtilizationSummaryReportImpl impObj =null;
		//Logger businessError = Logger.getLogger("businessErrorLogger");
		//Logger fatalError = Logger.getLogger("fatalErrorLogger");

		Session session = HibernateUtil.getSessionFactory().openSession();
		session.beginTransaction();
        String fromdateFormatted= null,		todateFormatted = null;
		try {
			DecimalFormat df2 = new DecimalFormat("###.#");
			// get the current Year
			Calendar c = Calendar.getInstance();
			int currentYear = c.get(Calendar.YEAR);
			//infoLogger.info("currentYear   "+currentYear);
			// Period can be 'Today','Week','Month', 'Quarter', 'Year'
			String basicFromQuery = null;
			String basicSelectQuery = null;
			String basicWhereQuery = null;
			String finalQuery = null;
			String basicGroupByQuery = " ";

			double engineRunDuration=(long) 0;
//			Keerthi : 10/12/13 : taking off hours  as int from Long
			double engineOffHours=0.0D;
			double engineOffHours1=0.0D;
			double EngineWorkingDurationInMin=0.0D;

			//DefectId: DF20131218 - Juhi Gupta - To display the VINs that has not communicated for the given time period 
			ListToStringConversion conversionObj = new ListToStringConversion();
			String loginTenIdListString = conversionObj.getIntegerListString(loginTenancyIdList).toString();;
			SimpleDateFormat dateFrmt = new SimpleDateFormat("yyyy-MM-dd");
			String lastDateInPeriod=null;
			String startDateInPeriod=null;

			//DefectID:1406 Suprava -2013/10/30 To return Report Totals
			double totalengineRunDurationInMinsumm=0.0D;
			double totalengineWorkingDurationInMinsumm=0.0D;
			double totalmachineUtilizationPercentagesumm=0.0D;
			double totalengineOffDurationInMin=0.0D;


			//added by smitha on oct 14th 2013[to display the machines which have not communicated.... Internal Defect 20131014]
			boolean querySelected = false;
			String selectQueryCustomDates=null;
			calledSerNumMapUtilization=getserialNumberList(tenancyIdList,customAssetGroupIdList,assetGroupIdList,modelIdList);
			//ended on oct 14th 2013[to display the machines which have not communicated.... Internal Defect 20131014]

			tenancyIdList = getSubTenancyIds(tenancyIdList); 
			String childTenancyIdStringList = conversionObj.getIntegerListString(
					tenancyIdList).toString();
			//Changes Done by Juhi On 6 May 2013 Added engineWorkingDurationInMin
			//DefectID:1406 Suprava 2013/10/30
			basicSelectQuery = "select b.tenancyId, b.tenancyName, a.machineName, a.serialNumber, " +
			" (a.EngineRunningBand1+a.EngineRunningBand2+a.EngineRunningBand3+a.EngineRunningBand4+a.EngineRunningBand5+a.EngineRunningBand6+a.EngineRunningBand7+a.EngineRunningBand8) as engineRunDurationInMin,"
			+"a.engineOffHours as engineOffDurationInMin , (a.EngineRunningBand3+a.EngineRunningBand4+a.EngineRunningBand5+a.EngineRunningBand6+a.EngineRunningBand7+a.EngineRunningBand8) as engineWorkingDurationInMin, c.group_id as machineGroupId, c.group_name as machineGroupName,"
			+" ten.tenancy_id as mgTenancy ";


			//Defect ID:1406 Suprava 2013/10/29 machine grouping
			basicFromQuery = "from AssetCustomGroupMapping h RIGHT OUTER JOIN h.serial_number x  LEFT OUTER JOIN h.group_id c "+
				" LEFT OUTER JOIN c.tenancy_id ten ,TenancyEntity ten1, " ;
			//changes Juhi
			basicWhereQuery = " where ten1.tenancy_id = b.tenancyId and a.tenancyId = b.tenacy_Dimension_Id and b.tenancyId in ("
				+ childTenancyIdStringList + " ) and x.serial_number = a.serialNumber ";

			//Logic for Custom Dates (fromDate,toDate) added by Juhi on 14-August-2013 
			if(fromDate == null && toDate==null)
			{
			if ((period.equalsIgnoreCase("Week"))||(period.equalsIgnoreCase("Last Week"))) {
				Date currentDate = new Date();
				DateUtil dateUtilObj = new DateUtil();
				DateUtil dateUtilObj1 = new DateUtil();
				if (period.equalsIgnoreCase("Week"))
				{
					dateUtilObj  = dateUtilObj. getCurrentDateUtility(currentDate);

					int week = dateUtilObj. getWeek();
					int year = dateUtilObj. getYear();


					//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
					basicFromQuery = basicFromQuery + " AssetMonitoringFactDataWeekAgg a ";
					//end Defect ID:1406
					basicWhereQuery = basicWhereQuery
					+ " and a.timeCount = "+week+" and a.year = "+year+"";
					//DefectId: DF20131218 -Juhi- To display the VINs that has not communicated for the given time period 
					//get the Last Day 
					Calendar cal = Calendar.getInstance();
					lastDateInPeriod = dateFrmt.format(cal.getTime());
					//get the first day of the week
					cal.set(Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek());
					startDateInPeriod=  dateFrmt.format(cal.getTime());
				}
				if((period.equalsIgnoreCase("Last Week")))
				{
					dateUtilObj  = dateUtilObj. getPreviousDateUtility(currentDate);
					dateUtilObj1  = dateUtilObj1. getCurrentDateUtility(currentDate);
					int week = dateUtilObj. getWeek();
					int year=0;
					if(week==1)
						year = dateUtilObj.getYear();
					else
						year = dateUtilObj.getCurrentYear();


					//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
					basicFromQuery = basicFromQuery + " AssetMonitoringFactDataWeekAgg a ";
					//end Defect ID:1406
					basicWhereQuery = basicWhereQuery
					+ " and a.timeCount = "+week+" and a.year = "+year+"";

					//DefectId: DF20131218 - Juhi- To display the VINs that has not communicated for the given time period 
					//get the Last Day of Previous Week
					Calendar cal = Calendar.getInstance();
				    int i = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
				    cal.add(Calendar.DATE, -i - 7);
				    cal.add(Calendar.DATE, 6);
				    lastDateInPeriod = dateFrmt.format(cal.getTime());
				    //get the First Day of Previous Week
				    cal = Calendar.getInstance();
				    int j = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
				    cal.add(Calendar.DATE, -j - 7);
					cal.set(Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek());
					startDateInPeriod=  dateFrmt.format(cal.getTime());
				}

			} 

			else if ((period.equalsIgnoreCase("Month"))||(period.equalsIgnoreCase("Last Month"))) {
				Date currentDate = new Date();
				DateUtil dateUtilObj = new DateUtil();
				DateUtil dateUtilObj1 = new DateUtil();
				if((period.equalsIgnoreCase("Month")))
				{
					dateUtilObj  = dateUtilObj. getCurrentDateUtility(currentDate);
					int month = dateUtilObj. getMonth ();
					int year = dateUtilObj. getYear();


					//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
					basicFromQuery = basicFromQuery + " AssetMonitoringFactDataMonthAgg a ";
					//end Defect ID:1406
					basicWhereQuery = basicWhereQuery
					+ " and a.timeCount = "+month+" and a.year= " + year+"";
					//DefectId: DF20131218 -Juhi - To display the VINs that has not communicated for the given time period 
					//get the Last Day 
					Calendar cal = Calendar.getInstance();
					lastDateInPeriod = dateFrmt.format(cal.getTime());
					//get the First Day of current Month
					String mon = month+"";
					if(mon.length()<2)
						mon="0"+mon;
					startDateInPeriod=year+"-"+mon+"-"+"01";
				}
				if(period.equalsIgnoreCase("Last Month"))
				{
					dateUtilObj1  = dateUtilObj1. getCurrentDateUtility(currentDate);
					dateUtilObj  = dateUtilObj. getPreviousDateUtility (currentDate);
					int month = dateUtilObj. getMonth ();
					int year=0;
					if(dateUtilObj1.getMonth() ==1)
						year = dateUtilObj.getYear();
					else
						year = dateUtilObj.getCurrentYear();


					//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
					basicFromQuery = basicFromQuery + " AssetMonitoringFactDataMonthAgg a ";
					//end Defect ID:1406
					basicWhereQuery = basicWhereQuery
					+ " and a.timeCount = "+month+" and a.year= " + year+"";
					//DefectId: DF20131218 -Juhi- To display the VINs that has not communicated for the given time period 
					//Get the Last Day of previous Month
					Calendar cal = Calendar.getInstance();
					cal.set(Calendar.DATE, 1);
				    cal.add(Calendar.DAY_OF_MONTH, -1);
				    lastDateInPeriod = dateFrmt.format(cal.getTime());
				   //get the First Day of Previous Month
				    String mon = month+"";
					if(mon.length()<2)
						mon="0"+mon;
					startDateInPeriod=year+"-"+mon+"-"+"01";
				}
			} 

			else if ((period.equalsIgnoreCase("Quarter"))||(period.equalsIgnoreCase("Last Quarter"))) {
				Date currentDate = new Date();
				DateUtil dateUtilObj = new DateUtil();
				DateUtil dateUtilObj1 = new DateUtil();
				if(period.equalsIgnoreCase("Quarter"))
				{
					dateUtilObj  = dateUtilObj. getCurrentDateUtility(currentDate);
					int quarter = dateUtilObj. getQuarter ();
					int year = dateUtilObj. getYear();


					//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
					basicFromQuery = basicFromQuery + " AssetMonitoringFactDataQuarterAgg a ";
					//end Defect ID:1406
					basicWhereQuery = basicWhereQuery
					+ " and a.timeCount = "+quarter+" and a.year="+year+"";

					//DefectId: DF20131218 - Juhi - To display the VINs that has not communicated for the given time period 
					//get the Last Day 
					Calendar cal = Calendar.getInstance();
					lastDateInPeriod = dateFrmt.format(cal.getTime());
					//get the first Date of current quarter
					switch(quarter) 
					{
					    case 3 : 
					    	startDateInPeriod = year+"-07-01";
					    	break;
					    	// return July 01
					    case 2 :
					    	startDateInPeriod = year+"-04-01";
					    	break;
					        // return April 01
					    case 1 :
					    	startDateInPeriod = year+"-01-01";
					    	break;
					        // return Jan 01
					    case 4 : 
					    	startDateInPeriod = year+"-10-01";
					    	break;
					        // return Oct 01
					}
				}
				if(period.equalsIgnoreCase("Last Quarter"))
				{
					dateUtilObj1  = dateUtilObj1. getCurrentDateUtility(currentDate);
					dateUtilObj  = dateUtilObj. getPreviousDateUtility(currentDate);
					int quarter = dateUtilObj. getQuarter ();
					int year=0;
					if(dateUtilObj1.getQuarter() ==1)
						year = dateUtilObj.getYear();
					else
						year = dateUtilObj.getCurrentYear();


					//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
					basicFromQuery = basicFromQuery + " AssetMonitoringFactDataQuarterAgg a ";
					//end Defect ID:1406
					basicWhereQuery = basicWhereQuery
					+ " and a.timeCount = "+quarter+" and a.year="+year+"";
					//DefectId: DF20131218  -Juhi - To display the VINs that has not communicated for the given time period 
					//get the last day of previous quarter
					switch(quarter) 
					{
					    case 3 : 
					    	lastDateInPeriod = year+"-09-30";
					    	break;
					        // return September 30
					    case 2 :
					    	lastDateInPeriod = year+"-06-30";
					    	break;
					        // return June 30
					    case 1 :
					    	lastDateInPeriod = year+"-03-31";
					    	break;
					        // return March 31
					    case 4 : 
					    	lastDateInPeriod = year+"-12-31";
					    	break;
					        // return December 31
					}
					//get the first Date of Previous quarter
					switch(quarter) 
					{
					    case 3 : 
					    	startDateInPeriod = year+"-07-01";
					    	break;
					        // return July 01
					    case 2 :
					    	startDateInPeriod = year+"-04-01";
					    	break;
					        // return April 01
					    case 1 :
					    	startDateInPeriod = year+"-01-01";
					    	break;
					        // return Jan 01
					    case 4 : 
					    	startDateInPeriod = year+"-10-01";
					    	break;
					        // return Oct 01
					}
				}				
			} 		
			else if ((period.equalsIgnoreCase("Year"))||(period.equalsIgnoreCase("Last Year"))) {
				Date currentDate = new Date();
				DateUtil dateUtilObj = new DateUtil();
				if(period.equalsIgnoreCase("Year"))
				{
					dateUtilObj  = dateUtilObj. getCurrentDateUtility(currentDate);
					int year = dateUtilObj. getYear();


					//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
					basicFromQuery = basicFromQuery + " AssetMonitoringFactDataYearAgg a ";
					//end Defect ID:1406
					basicWhereQuery = basicWhereQuery
					+ " and a.year = "+year+" ";
					//DefectId: DF20131218 - Juhi - To display the VINs that has not communicated for the given time period 
					//get the Last Day 
					Calendar cal = Calendar.getInstance();
					lastDateInPeriod = dateFrmt.format(cal.getTime());
					//get the First day of current Year
					startDateInPeriod=year+"-01"+"-01";
				}
				if(period.equalsIgnoreCase("Last Year"))
				{
					dateUtilObj  = dateUtilObj. getPreviousDateUtility(currentDate);
					int year = dateUtilObj. getYear();


					//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
					basicFromQuery = basicFromQuery + " AssetMonitoringFactDataYearAgg a ";
					//end Defect ID:1406
					basicWhereQuery = basicWhereQuery
					+ " and a.year = "+year+" ";
					//DefectId: DF20131218 -Juhi - To display the VINs that has not communicated for the given time period 
					//get the Last day of previous Year
					lastDateInPeriod=year+"-12-31";
					//get the First day of Previous Year 
					startDateInPeriod=year+"-01"+"-01";
				}				
			}
			if(!(isGroupingOnAssetGroup) )
				basicGroupByQuery = " group by a.serialNumber,ten1.tenancy_id ";
			}
			//Logic for Custom Dates (fromDate,toDate) added by Juhi on 14-August-2013 
			else
			{

				if(period==null)
				{
					Date newerDate = dateFrmt.parse(todateFormatted);
					Date olderDate = dateFrmt.parse(fromdateFormatted);
					double diffInDays = (double)( (newerDate.getTime() - olderDate.getTime()) 
			                / (1000 * 60 * 60 * 24) );
					diffInDays= diffInDays+1;
					double engineOffLong = (24*diffInDays)-engineOn;
					engineOffInt = (double)engineOffLong;
				//	implObj.setEngineOff(engineOffInt);
					implObj.setEngineOff(Double.valueOf(df2.format((Double)engineOffInt)));
				}
				//added by smitha on oct 15th 2013[custom dates aggregation for a VIN query change.... Internal Defect 20131014]
				//querySelected=true;
				basicSelectQuery = " select b.tenancyId, b.tenancyName, a.machineName, a.serialNumber, " +
			" sum((a.EngineRunningBand1+a.EngineRunningBand2+a.EngineRunningBand3+a.EngineRunningBand4+a.EngineRunningBand5+a.EngineRunningBand6+a.EngineRunningBand7+a.EngineRunningBand8)) as engineRunDurationInMin,"
			+"sum(a.engineOffHours) as engineOffDurationInMin , sum((a.EngineRunningBand3+a.EngineRunningBand4+a.EngineRunningBand5+a.EngineRunningBand6+a.EngineRunningBand7+a.EngineRunningBand8)) as engineWorkingDurationInMin, c.group_id as machineGroupId, c.group_name as machineGroupName, ten.tenancy_id as mgTenancy ";
				//ended on oct 15th 2013[custom dates aggregation for a VIN query change.... Internal Defect 20131014]

				DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat dateFormat1 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
				Date fromdate1=null;
				String fromdate2=null;
				String todate2=null;
				String fromdate=null;
				String todate=null;
					try {	

						fromdate1 = (Date)dateFormat.parse(fromDate);		
						 fromdate=	dateFormat.format(fromdate1);
					fromdate2=dateFormat1.format(fromdate1);

					Date todate1=(Date)dateFormat.parse(toDate);

					 todate=dateFormat.format(todate1);
					todate2=dateFormat1.format(todate1);


					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					//DefectId: DF20131018 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period 
					startDateInPeriod = fromdate;
					lastDateInPeriod = todate;

					List<String> dateList= new LinkedList<String>();					
					Calendar calendar = Calendar.getInstance();					
					do
					{
						dateList.add(fromdate2);
						calendar.setTime(fromdate1);
						calendar.add(Calendar.DAY_OF_YEAR, 1);
						fromdate1 = calendar.getTime();			
						fromdate2 = dateFormat1.format(fromdate1);


					} while ((fromdate2.compareTo(todate2)) <=0);
					String dateStringList=conversionObj.getStringList(dateList).toString();


					//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
					basicFromQuery = basicFromQuery + " AssetMonitoringFactDataDayAgg a";
					//end Defect ID:1406
					basicWhereQuery = basicWhereQuery+ " and a.timeKey between '"+fromdate2+"' and '"+todate2+"' ";
					if(basicGroupByQuery.length()>2)
					{
//						basicGroupByQuery =basicGroupByQuery+ " ,a.timeKey,a.tenancyId";
						//added by smitha on oct 15th 2013[custom dates aggregation for a VIN query change.... Internal Defect 20131014]
						basicGroupByQuery ="a.serialNumber ,a.tenancyId,c.group_id , ten1.tenancy_id ";
						//ended on oct 15th 2013[custom dates aggregation for a VIN query change.... Internal Defect 20131014]
					}
					else
					{
//						basicGroupByQuery = " group by a.serialNumber,a.timeKey,a.tenancyId";
						//added by smitha on oct 15th 2013[custom dates aggregation for a VIN query change.... Internal Defect 20131014]
						basicGroupByQuery = " group by a.serialNumber,a.tenancyId,c.group_id, ten1.tenancy_id  ";
						//ended on oct 15th 2013[custom dates aggregation for a VIN query change.... Internal Defect 20131014]
					}
					fromdateFormatted= dateFormat.format(dateFormat.parse(fromDate));	
					todateFormatted = dateFormat.format(dateFormat.parse(toDate));
			}
			//Logic for Custom Dates (fromDate,toDate) added by Juhi on 14-August-2013 
			basicFromQuery = basicFromQuery + ",TenancyDimensionEntity b ";
			boolean machineGroup = false;
			boolean machineProfile = false;
			boolean model = false;
			machineGroup=true;
			if (!(customAssetGroupIdList == null || customAssetGroupIdList
					.isEmpty())) {
				String customAssetGroupStringList = conversionObj
				.getIntegerListString(customAssetGroupIdList)
				.toString();
				basicSelectQuery = basicSelectQuery
				+ ", c.group_id as machineGroupId, c.group_name as machineGroupName ";
				basicFromQuery = basicFromQuery
				+ " , CustomAssetGroupEntity c, AssetCustomGroupMapping h ";*/
	/*basicWhereQuery = basicWhereQuery
				+ " and c.group_id = h.group_id and c.group_id in ("
				+ customAssetGroupStringList + ") and "
				+ " h.serial_number = a.serialNumber ";
				basicWhereQuery = basicWhereQuery
				+ " and c.group_id in ("
				+ customAssetGroupStringList + ")";
//				machineGroup=true;
			}

			if ((!(assetGroupIdList == null || assetGroupIdList.isEmpty()))
					|| (!(modelIdList == null || modelIdList.isEmpty()))) {
				basicFromQuery = basicFromQuery
				+ " , AssetClassDimensionEntity d ";
				basicWhereQuery = basicWhereQuery
				+ " and a.assetClassDimensionId = d.assetClassDimensionId";

			}

			if (!(assetGroupIdList == null || assetGroupIdList.isEmpty())) {
				String assetGroupStringList = conversionObj
				.getIntegerListString(assetGroupIdList).toString();
				basicSelectQuery = basicSelectQuery
				+ " ,d.assetGroupId as profileId, d.assetGroupName as profileName ";
				basicWhereQuery = basicWhereQuery + " and d.assetGroupId in ( "
				+ assetGroupStringList + " )";
				machineProfile = true;
			}

			if (!(modelIdList == null || modelIdList.isEmpty())) {
				String modelIdStringList = conversionObj.getIntegerListString(
						modelIdList).toString();

				basicSelectQuery = basicSelectQuery
				+ " , d.assetTypeId as modelId, d.assetTypeName as modelName ";
				basicWhereQuery = basicWhereQuery + " and d.assetTypeId in ( "
				+ modelIdStringList + " )";
				model = true;
			}
			//added by smitha on oct 15th 2013[custom dates aggregation for a VIN query change.... Internal Defect 20131014]
			/*if(querySelected==false){
				finalQuery = basicSelectQuery + basicFromQuery + basicWhereQuery + basicGroupByQuery + " order by a.serialNumber, ten.tenancy_id ";
				}
				else{
					finalQuery = basicSelectQuery + basicFromQuery + basicWhereQuery + basicGroupByQuery + " order by a.serialNumber, ten.tenancy_id ";

			//ended on oct 15th 2013[custom dates aggregation for a VIN query change.... Internal Defect 20131014]
//			finalQuery = basicSelectQuery + basicFromQuery + basicWhereQuery + basicGroupByQuery;
			//DefectID:1406 Suprava 2013/10/30
			List<String> otherMachineGroupVins = new LinkedList<String>();
			Query query = session.createQuery(finalQuery);
			Iterator itr = query.list().iterator();
			Object[] result = null;

			while (itr.hasNext()) {
				impObj = new UtilizationSummaryReportImpl();
				result = (Object[]) itr.next();
				impObj.setTenancyId((Integer) result[0]);
				if (result[1] != null)	{
					impObj.setTenancyName(result[1].toString());
				}
				if (result[2] != null){
					impObj.setMachineName(result[2].toString());
				}
				if(result[3]!=null)
				{
					tempSerialNumberUtilization=result[3].toString();

				}

				if( (!isGroupingOnAssetGroup) && (tempSerNumListUtilization.contains(tempSerialNumberUtilization))) 
				{
					continue;
				}
				impObj.setSerialNumber(result[3].toString());

				if (result[4] != null){
					EngineWorkingDurationInMin=(Integer) result[4];
				}
				if (result[4] != null){
//			DefectId:1632 @ suprava
					engineRunDuration=Math.round(Double.valueOf(df2.format((Double)result[4])));
					impObj.setEngineRunDurationInMin(engineRunDuration);
				}
				impObj.setEngineRunDurationInMin(engineRunDuration);
				if (result[5] != null){
					//Done by Juhi on DF:20131209 Integer to Long Cast 
//					if(querySelected==false){
//					Keerthi : 10/12/13 : taking off hours  as int instead of Long
					engineOffHours=Double.valueOf(df2.format((Double)result[5]));
//					}else{
//					engineOffHours1=(Long) result[5];
//					}
				}

				double workingTime1 = (Double)result[4];

				double engineOn = (double) (workingTime1 );
				if(period==null)
				{
					Date newerDate = dateFrmt.parse(todateFormatted);
					Date olderDate = dateFrmt.parse(fromdateFormatted);
					double diffInDays = (double)( (newerDate.getTime() - olderDate.getTime()) 
			                / (1000 * 60 * 60 * 24) );
					diffInDays= diffInDays+1;
					double engineOffLong = (24*diffInDays)-engineOn;
					//engineOffInt = (double)engineOffLong;
				//	implObj.setEngineOff(engineOffInt);
					impObj.setEngineOffDurationInMin(Double.valueOf(df2.format((Double)engineOffLong)));
//					Keerthi : 27/12/2013 : calculating engine off hours for custom dates
					engineOffHours = engineOffLong;
				}else{


				if (result[5] != null)
				{
					impObj.setEngineOffDurationInMin(Double.valueOf(df2.format((Double)result[5])));
				}
				}
				//Changes done by Juhi on 6 May2013
				if (result[6] != null){
					impObj.setEngineWorkingDurationInMin(Double.valueOf(df2.format((Double)result[6])));
				}
				//
				Double machineUtilization=(Double.valueOf(df2.format((Double) ((engineRunDuration/(engineRunDuration+engineOffHours))*100))));
			//	infoLogger.info("machineUtilization   "+machineUtilization);
				if(machineUtilization!=null){
					impObj.setMachineUtilizationPercentage(machineUtilization);	
				}


				if (machineGroup == true) {
			//		infoLogger.info("MachineGroupId   "+(Integer) result[7]);
					//null check by smitha on 7th oct 2013
					if(result[7]!=null){
					impObj.setMachineGroupId((Integer) result[7]);
					}
					//end on 7th 0ct 2013
					if (result[8] != null){
	//					infoLogger.info("MachineGroupName   "+(result[8].toString()));
						impObj.setMachineGroupName(result[8].toString());
					}
				}
				//DefectID:1406 - Suprava - 2013-October-30 - To return Report Totals
				if(!(tempSerNumListUtilization.contains(tempSerialNumberUtilization)))
				{

					totalengineOffDurationInMin = totalengineOffDurationInMin+(Double.valueOf(df2.format((Double)result[5])));
					totalengineWorkingDurationInMinsumm = totalengineWorkingDurationInMinsumm+(Double.valueOf(df2.format((Double)result[6])));
					totalmachineUtilizationPercentagesumm = totalmachineUtilizationPercentagesumm+(machineUtilization);
					totalengineRunDurationInMinsumm = totalengineRunDurationInMinsumm+(engineRunDuration);
				}

				//DefectID: 1406 Suprava
				int otherMachineGroup =0;
				if(result[9]!=null)
				{
					int mgTenancy = (Integer) result[9];
					if(! (loginTenancyIdList.contains(mgTenancy)) ) 
					{
						otherMachineGroup=1;
					}
				}

				if( (otherMachineGroup==1)&& ( (otherMachineGroupVins.contains(tempSerialNumberUtilization)) || (tempSerNumListUtilization.contains(tempSerialNumberUtilization)) ) )
				{
					continue;
				}
				//DefectId:1406 End
				//DefectID:1406 - Suprava Nayak - 20131028 - MachineGrouping issue in Reports and sending Report Totals information
				if (machineGroup == true){
				 if(result[9]!=null)
				 {
					int mgTenancy = (Integer) result[9];
					if(loginTenancyIdList.contains(mgTenancy)) 
					{
						if(result[7]!=null)
							impObj.setMachineGroupId((Integer)result[7]);

						if(result[8]!=null)
							impObj.setMachineGroupName(result[8].toString());
					}
					else
					{
						otherMachineGroupVins.add(tempSerialNumberUtilization);
					}

				  }
				}
				if (machineProfile == true) {
					if (machineGroup == true) {
						impObj.setMachineProfileId((Integer) result[10]);
						if (result[11] != null){
							impObj.setMachineProfileName(result[11].toString());
						}
					} else {
						impObj.setMachineProfileId((Integer) result[7]);
						if (result[8] != null){
							impObj.setMachineProfileName(result[8].toString());
						}
					}
				}
				if (model == true) {
					if (machineProfile == true) {
						if (machineGroup == true) {
							impObj.setModelId((Integer) result[12]);
							if (result[13] != null){
								impObj.setModelName(result[13].toString());
							}
						} else {
							impObj.setModelId((Integer) result[10]);
							if (result[11] != null){
								impObj.setModelName(result[11].toString());
							}
						}
					} else {
						if (machineGroup == true) {
							impObj.setModelId((Integer) result[10]);
							if (result[11] != null){
								impObj.setModelName(result[11].toString());
							}
						} else {
							impObj.setModelId((Integer) result[7]);
							if (result[8] != null){
								impObj.setModelName(result[8].toString());
							}
						}					
					}

				}
				tempSerNumListUtilization.add(tempSerialNumberUtilization);
				responseList.add(impObj);
			}
			//-------------------------------------------------------------------------------------------------------------------
			//DefectId: DF20131218 - Juhi To display the VINs that has not communicated for the given time period 
			Query ownerListQuery = session.createQuery(" select distinct c.serialNumber " +
														" from TenancyBridgeEntity a, AccountTenancyMapping b, AssetAccountMapping c " +
														" where a.childId= b.tenancy_id " +
														" and b.account_id= c.accountId " +
														" and a.parentId in ("+childTenancyIdStringList+") and" +
														" ( (c.ownershipStartDate between '"+startDateInPeriod+"' and '"+lastDateInPeriod+"') OR " +
														"   (c.ownershipStartDate = ( select max(y.ownershipStartDate) from AssetAccountMapping y " +
																					" where y.serialNumber= c.serialNumber" +
																					" and y.ownershipStartDate <='"+startDateInPeriod+"')" +
														"    )" +
														" )");
			Iterator ownerListItr = ownerListQuery.list().iterator();
			List<String> actualOwnerVINList = new LinkedList<String>();
			while(ownerListItr.hasNext())
			{
				AssetEntity assetList = (AssetEntity)ownerListItr.next();
				actualOwnerVINList.add(assetList.getSerial_number().getSerialNumber());
			}

			//Get only the List of VINs which has not communicated for the Given period
			actualOwnerVINList.removeAll(tempSerNumListUtilization);
			String actualOwnerVinListString = conversionObj.getStringList(actualOwnerVINList).toString();
			basicSelectQuery = "select b.tenancyId, b.tenancyName, a.machineName, a.serialNumber, " +
			" (a.EngineRunningBand1+a.EngineRunningBand2+a.EngineRunningBand3+a.EngineRunningBand4+a.EngineRunningBand5+a.EngineRunningBand6+a.EngineRunningBand7+a.EngineRunningBand8) as engineRunDurationInMin,"
			+"a.engineOffHours as engineOffDurationInMin , (a.EngineRunningBand3+a.EngineRunningBand4+a.EngineRunningBand5+a.EngineRunningBand6+a.EngineRunningBand7+a.EngineRunningBand8) as engineWorkingDurationInMin, c.group_id as machineGroupId, c.group_name as machineGroupName,"
			+" ten.tenancy_id as mgTenancy ";


		basicFromQuery = "from AssetCustomGroupMapping h RIGHT OUTER JOIN h.serial_number x  LEFT OUTER JOIN h.group_id c "+
				" LEFT OUTER JOIN c.tenancy_id ten ,TenancyEntity ten1,TenancyDimensionEntity b, AssetMonitoringFactDataDayAgg a " ;

			basicWhereQuery = " where ten1.tenancy_id = b.tenancyId and a.tenancyId = b.tenacy_Dimension_Id and b.tenancyId in ("+ childTenancyIdStringList + " )" +
					" and  a.serialNumber =x.serial_number  and a.serialNumber in ("+actualOwnerVinListString+") " +
	                  				" and a.timeKey = ( select max(p.timeKey) from AssetMonitoringFactDataDayAgg p where p.serialNumber = a.serialNumber " +
	                  				" and p.timeKey <= '"+startDateInPeriod+"' )";



		basicGroupByQuery = " group by a.serialNumber,ten1.tenancy_id";
		if (!(customAssetGroupIdList == null || customAssetGroupIdList
				.isEmpty())) {
			String customAssetGroupStringList = conversionObj
			.getIntegerListString(customAssetGroupIdList)
			.toString();

			basicWhereQuery = basicWhereQuery
			+ " and c.group_id in ("
			+ customAssetGroupStringList + ")";

		}

		if ((!(assetGroupIdList == null || assetGroupIdList.isEmpty()))
				|| (!(modelIdList == null || modelIdList.isEmpty()))) {
			basicFromQuery = basicFromQuery
			+ " , AssetClassDimensionEntity d ";
			basicWhereQuery = basicWhereQuery
			+ " and a.assetClassDimensionId = d.assetClassDimensionId";

		}

		if (!(assetGroupIdList == null || assetGroupIdList.isEmpty())) {
			String assetGroupStringList = conversionObj
			.getIntegerListString(assetGroupIdList).toString();
			basicSelectQuery = basicSelectQuery
			+ " ,d.assetGroupId as profileId, d.assetGroupName as profileName ";
			basicWhereQuery = basicWhereQuery + " and d.assetGroupId in ( "
			+ assetGroupStringList + " )";
			machineProfile = true;
		}

		if (!(modelIdList == null || modelIdList.isEmpty())) {
			String modelIdStringList = conversionObj.getIntegerListString(
					modelIdList).toString();

			basicSelectQuery = basicSelectQuery
			+ " , d.assetTypeId as modelId, d.assetTypeName as modelName ";
			basicWhereQuery = basicWhereQuery + " and d.assetTypeId in ( "
			+ modelIdStringList + " )";
			model = true;
		}
				if(! (actualOwnerVINList==null || actualOwnerVINList.isEmpty()))
		{
		finalQuery = basicSelectQuery + basicFromQuery + basicWhereQuery + basicGroupByQuery + " order by x.serial_number, a.lastReported desc  ";
		Iterator vinListItr = session.createQuery(finalQuery).list().iterator();
		tempSerNumListUtilization=null;
		result =null;
		while (itr.hasNext()) {
			impObj = new UtilizationSummaryReportImpl();
			result = (Object[]) itr.next();
			impObj.setTenancyId((Integer) result[0]);
			if (result[1] != null)	{
				impObj.setTenancyName(result[1].toString());
			}
			if (result[2] != null){
				impObj.setMachineName(result[2].toString());
			}
			if(result[3]!=null)
			{
				tempSerialNumberUtilization=result[3].toString();

			}

			if( (!isGroupingOnAssetGroup) && (tempSerNumListUtilization.contains(tempSerialNumberUtilization))) 
			{
				continue;
			}
			impObj.setSerialNumber(result[3].toString());

			if (result[4] != null){
				EngineWorkingDurationInMin=(Integer) result[4];
			}
			if (result[4] != null){
//		DefectId:1632 @ suprava
				engineRunDuration=Math.round(Double.valueOf(df2.format((Double)result[4])));
				impObj.setEngineRunDurationInMin(engineRunDuration);
			}
			impObj.setEngineRunDurationInMin(engineRunDuration);
			if (result[5] != null){
				//Done by Juhi on DF:20131209 Integer to Long Cast 
//				if(querySelected==false){
//				Keerthi : 10/12/13 : taking off hours  as int instead of Long
				engineOffHours=Double.valueOf(df2.format((Double)result[5]));
//				}else{
//				engineOffHours1=(Long) result[5];
//				}
			}
			if (result[5] != null)
			{
				impObj.setEngineOffDurationInMin(Double.valueOf(df2.format((Double)result[5])));
			}
			//Changes done by Juhi on 6 May2013
			if (result[6] != null){
				impObj.setEngineWorkingDurationInMin(Double.valueOf(df2.format((Double)result[6])));
			}
			//
			Double machineUtilization=(Double.valueOf(df2.format((Double) ((engineRunDuration/(engineRunDuration+engineOffHours))*100))));
			if(machineUtilization!=null){
				impObj.setMachineUtilizationPercentage(machineUtilization);	
			}


			if (machineGroup == true) {
				//null check by smitha on 7th oct 2013
				if(result[7]!=null){
				impObj.setMachineGroupId((Integer) result[7]);
				}
				//end on 7th 0ct 2013
				if (result[8] != null){
					impObj.setMachineGroupName(result[8].toString());
				}
			}
			//DefectID:1406 - Suprava - 2013-October-30 - To return Report Totals
			if(!(tempSerNumListUtilization.contains(tempSerialNumberUtilization)))
			{

				totalengineOffDurationInMin = totalengineOffDurationInMin+(Double.valueOf(df2.format((Double)result[5])));
				totalengineWorkingDurationInMinsumm = totalengineWorkingDurationInMinsumm+(Double.valueOf(df2.format((Double)result[6])));
				totalmachineUtilizationPercentagesumm = totalmachineUtilizationPercentagesumm+(machineUtilization);
				totalengineRunDurationInMinsumm = totalengineRunDurationInMinsumm+(engineRunDuration);
			}

			//DefectID: 1406 Suprava
			int otherMachineGroup =0;
			if(result[9]!=null)
			{
				int mgTenancy = (Integer) result[9];
				if(! (loginTenancyIdList.contains(mgTenancy)) ) 
				{
					otherMachineGroup=1;
				}
			}

			if( (otherMachineGroup==1)&& ( (otherMachineGroupVins.contains(tempSerialNumberUtilization)) || (tempSerNumListUtilization.contains(tempSerialNumberUtilization)) ) )
			{
				continue;
			}
			//DefectId:1406 End
			//DefectID:1406 - Suprava Nayak - 20131028 - MachineGrouping issue in Reports and sending Report Totals information
			if (machineGroup == true){
			 if(result[9]!=null)
			 {
				int mgTenancy = (Integer) result[9];
				if(loginTenancyIdList.contains(mgTenancy)) 
				{
					if(result[7]!=null)
						impObj.setMachineGroupId((Integer)result[7]);

					if(result[8]!=null)
						impObj.setMachineGroupName(result[8].toString());
				}
				else
				{
					otherMachineGroupVins.add(tempSerialNumberUtilization);
				}

			  }
			}
			if (machineProfile == true) {
				if (machineGroup == true) {
					impObj.setMachineProfileId((Integer) result[10]);
					if (result[11] != null){
						impObj.setMachineProfileName(result[11].toString());
					}
				} else {
					impObj.setMachineProfileId((Integer) result[7]);
					if (result[8] != null){
						impObj.setMachineProfileName(result[8].toString());
					}
				}
			}
			if (model == true) {
				if (machineProfile == true) {
					if (machineGroup == true) {
						impObj.setModelId((Integer) result[12]);
						if (result[13] != null){
							impObj.setModelName(result[13].toString());
						}
					} else {
						impObj.setModelId((Integer) result[10]);
						if (result[11] != null){
							impObj.setModelName(result[11].toString());
						}
					}
				} else {
					if (machineGroup == true) {
						impObj.setModelId((Integer) result[10]);
						if (result[11] != null){
							impObj.setModelName(result[11].toString());
						}
					} else {
						impObj.setModelId((Integer) result[7]);
						if (result[8] != null){
							impObj.setModelName(result[8].toString());
						}
					}					
				}

			}
			tempSerNumListUtilization.add(tempSerialNumberUtilization);
			responseList.add(impObj);
		}
		}
			//-------------------------------------------------------------------------------------------------------------------
			//DefectId: DF20131218 - Juhi To display the VINs that has not communicated for the given time period 
			//added by smitha on oct 14th 2013[to display the machines which have not communicated .... Internal Defect 20131014]
		commented by Juhi on 10-12-2013---start
	 * Set mapSet = (Set) calledSerNumMapUtilization.entrySet();
			Iterator mapIterator = mapSet.iterator();	
			while (mapIterator.hasNext()) {
				Map.Entry mapEntry = (Map.Entry) mapIterator.next(); 
				String keyValue = (String) mapEntry.getKey(); 
				int value = (Integer)mapEntry.getValue();
				AllSerNumListUtilization.add(keyValue);

		}	

			int tenancyId=0;
			String tenancyName2=null;
			Integer groupID1=0;
			String groupName2=null;
			 Iterator iterSerialNoList = AllSerNumListUtilization.iterator();
			 for (String serialNo : AllSerNumListUtilization) {
			if(!tempSerNumListUtilization.contains(serialNo))	{
				impObj = new UtilizationSummaryReportImpl();
				impObj.setEngineOffDurationInMin(0l);
				impObj.setEngineRunDurationInMin(0.0d);
				impObj.setEngineWorkingDurationInMin(0l);
				groupID1=serGroupID.get(serialNo);
				if(groupID1!=0){
					impObj.setMachineGroupId(groupID1);
				}else{
					impObj.setMachineGroupId(0);
				}

				groupName2=GroupData.get(groupID1);
				if(groupName2!="" || groupName2!=null){
					impObj.setMachineGroupName(groupName2);
				}else {
					impObj.setMachineGroupName(null);
				}

				impObj.setMachineProfileId(0);
				impObj.setMachineProfileName(null);	
				impObj.setMachineUtilizationPercentage(0.0d);
				impObj.setModelId(0);
				impObj.setModelName(null);				
				impObj.setSerialNumber(serialNo);
				tenancyId=calledSerNumMapUtilization.get(serialNo);
				impObj.setTenancyId(tenancyId);
				tenancyName2=TenancyData.get(tenancyId);
				impObj.setTenancyName(tenancyName2);
				responseList.add(impObj);
			}
			}	commented by Juhi on 10-12-2013---end
			   //DefectId:1406 Suprava 2013/10/30

			//DefectID:1732-----Smitha-----to display the correct average value in the header
				Iterator iterResult = responseList.iterator();
				UtilizationSummaryReportImpl resultlist = null;
				String serNum=null;
				int sizeOfDistinctSerNumList=0;
				while (iterResult.hasNext()) {
					if (iterResult != null) {
						resultlist = (UtilizationSummaryReportImpl) iterResult.next();
						serNum=resultlist.getSerialNumber();
						if(!distinctSerNumList.contains(serNum)){
							distinctSerNumList.add(serNum);
						}
					}
				}
				sizeOfDistinctSerNumList=distinctSerNumList.size();
		        impObj = new UtilizationSummaryReportImpl();
				impObj.setSerialNumber("Summary");
				impObj.setEngineRunDurationInMin(totalengineRunDurationInMinsumm);
				impObj.setEngineWorkingDurationInMin(totalengineWorkingDurationInMinsumm);
				impObj.setMachineUtilizationPercentage(totalmachineUtilizationPercentagesumm/sizeOfDistinctSerNumList);
				impObj.setEngineOffDurationInMin(totalengineOffDurationInMin);
				//ended......DefectID:1732
				responseList.add(impObj); 
			//ended on oct 14th 2013[to display the machines which have not communicated .... Internal Defect 20131014]
		}

		catch (Exception e) {
			e.printStackTrace();
			fatalError.fatal("Exception :" + e);
		}

		finally {
			if (session.getTransaction().isActive()) {
				session.getTransaction().commit();
			}

			if (session.isOpen()) {
				session.flush();
				session.close();
			}

		}

		return responseList;
	}

	// ************************************************ END of Machine
	// Utilization Summary Report
	// *************************************************
	 */

	/*public List<UtilizationSummaryReportImpl> machineUtilizationSummaryReport(String fromDate,String toDate,
			String loginId, String period, List<Integer> tenancyIdList,
			List<Integer> customAssetGroupIdList,
			List<Integer> assetGroupIdList, List<Integer> modelIdList,
			boolean isGroupingOnAssetGroup, List<Integer> loginTenancyIdList) {
		List<UtilizationSummaryReportImpl> responseList = new LinkedList<UtilizationSummaryReportImpl>();
		HashMap<String, Integer> calledSerNumMapUtilization = new HashMap<String, Integer>();
		List<String>  tempSerNumListUtilization = new ArrayList<String>();
		List<String>  AllSerNumListUtilization = new ArrayList<String>();
		String tempSerialNumberUtilization=null;
		UtilizationSummaryReportImpl impObj =null;
		//Logger businessError = Logger.getLogger("businessErrorLogger");
		//Logger fatalError = Logger.getLogger("fatalErrorLogger");
		Logger fLogger = FatalLoggerClass.logger;
		Logger bLogger = BusinessErrorLoggerClass.logger;
		Logger iLogger = InfoLoggerClass.logger;
		Session session = HibernateUtil.getSessionFactory().openSession();
		session.beginTransaction();
		String fromdateFormatted= null,		todateFormatted = null;
		try {
			DecimalFormat df2 = new DecimalFormat("###.#");
			// get the current Year
			Calendar c = Calendar.getInstance();
			int currentYear = c.get(Calendar.YEAR);
			//infoLogger.info("currentYear   "+currentYear);
			// Period can be 'Today','Week','Month', 'Quarter', 'Year'
			String basicFromQuery = null;
			String basicSelectQuery = null;
			String basicWhereQuery = null;
			String finalQuery = null;
			String basicGroupByQuery = " ";

			double engineRunDuration=(long) 0;
			//			Keerthi : 10/12/13 : taking off hours  as int from Long
			double engineOffHours=0.0D;
			double engineOffHours1=0.0D;
			double EngineWorkingDurationInMin=0.0D;

			//DefectId: DF20131218 - Juhi Gupta - To display the VINs that has not communicated for the given time period 
			ListToStringConversion conversionObj = new ListToStringConversion();
			String loginTenIdListString = conversionObj.getIntegerListString(loginTenancyIdList).toString();;
			SimpleDateFormat dateFrmt = new SimpleDateFormat("yyyy-MM-dd");
			String lastDateInPeriod=null;
			String startDateInPeriod=null;

			//DefectID:1406 Suprava -2013/10/30 To return Report Totals
			double totalengineRunDurationInMinsumm=0.0D;
			double totalengineWorkingDurationInMinsumm=0.0D;
			double totalmachineUtilizationPercentagesumm=0.0D;
			double totalengineOffDurationInMin=0.0D;


			//added by smitha on oct 14th 2013[to display the machines which have not communicated.... Internal Defect 20131014]
			boolean querySelected = false;
			String selectQueryCustomDates=null;
			
			calledSerNumMapUtilization=getserialNumberList(tenancyIdList,customAssetGroupIdList,assetGroupIdList,modelIdList);
			//ended on oct 14th 2013[to display the machines which have not communicated.... Internal Defect 20131014]
            
			tenancyIdList = getSubTenancyIds(tenancyIdList,session); 
			String childTenancyIdStringList = conversionObj.getIntegerListString(
					tenancyIdList).toString();
			//Changes Done by Juhi On 6 May 2013 Added engineWorkingDurationInMin
			//DefectID:1406 Suprava 2013/10/30
			basicSelectQuery = "select b.tenancyId, b.tenancyName, a.machineName, a.serialNumber, " +
			" (a.EngineRunningBand1+a.EngineRunningBand2+a.EngineRunningBand3+a.EngineRunningBand4+a.EngineRunningBand5+a.EngineRunningBand6+a.EngineRunningBand7+a.EngineRunningBand8) as engineRunDurationInMin,"
			+"a.engineOffHours as engineOffDurationInMin , (a.EngineRunningBand3+a.EngineRunningBand4+a.EngineRunningBand5+a.EngineRunningBand6+a.EngineRunningBand7+a.EngineRunningBand8) as engineWorkingDurationInMin, c.group_id as machineGroupId, c.group_name as machineGroupName,"
			+" ten.tenancy_id as mgTenancy,b.parentTenancyName,b.tenancyTypeId ";


			//Defect ID:1406 Suprava 2013/10/29 machine grouping
			basicFromQuery = "from AssetCustomGroupMapping h RIGHT OUTER JOIN h.serial_number x  LEFT OUTER JOIN h.group_id c "+
			" LEFT OUTER JOIN c.tenancy_id ten ,TenancyEntity ten1, " ;
			//changes Juhi
			basicWhereQuery = " where ten1.tenancy_id = b.tenancyId and a.tenancyId = b.tenacy_Dimension_Id and b.tenancyId in ("
				+ childTenancyIdStringList + " ) and x.serial_number = a.serialNumber ";
				//DefectId:20150216 @ Suprava Dealer As a new parameter Added
				//" and b.parentTenancyId=ten1.parent_tenancy_id ";

			//Logic for Custom Dates (fromDate,toDate) added by Juhi on 14-August-2013 
			if(fromDate == null && toDate==null)
			{
				if ((period.equalsIgnoreCase("Week"))||(period.equalsIgnoreCase("Last Week"))) {
					Date currentDate = new Date();
					DateUtil dateUtilObj = new DateUtil();
					DateUtil dateUtilObj1 = new DateUtil();
					if (period.equalsIgnoreCase("Week"))
					{
						dateUtilObj  = dateUtilObj. getCurrentDateUtility(currentDate);

						int week = dateUtilObj. getWeek();
						int year = dateUtilObj. getYear();


						//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
						basicFromQuery = basicFromQuery + " AssetMonitoringFactDataWeekAgg a ";
						//end Defect ID:1406
						basicWhereQuery = basicWhereQuery
						+ " and a.timeCount = "+week+" and a.year = "+year+"";
						//DefectId: DF20131218 -Juhi- To display the VINs that has not communicated for the given time period 
						//get the Last Day 
						Calendar cal = Calendar.getInstance();
						lastDateInPeriod = dateFrmt.format(cal.getTime());
						//get the first day of the week
						cal.set(Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek());
						startDateInPeriod=  dateFrmt.format(cal.getTime());
					}
					if((period.equalsIgnoreCase("Last Week")))
					{
						dateUtilObj  = dateUtilObj. getPreviousDateUtility(currentDate);
						dateUtilObj1  = dateUtilObj1. getCurrentDateUtility(currentDate);
						int week = dateUtilObj. getWeek();
						int year=0;
						if(week==1)
							year = dateUtilObj.getYear();
						else
							year = dateUtilObj.getCurrentYear();


						//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
						basicFromQuery = basicFromQuery + " AssetMonitoringFactDataWeekAgg a ";
						//end Defect ID:1406
						basicWhereQuery = basicWhereQuery
						+ " and a.timeCount = "+week+" and a.year = "+year+"";

						//DefectId: DF20131218 - Juhi- To display the VINs that has not communicated for the given time period 
						//get the Last Day of Previous Week
						Calendar cal = Calendar.getInstance();
						int i = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
						cal.add(Calendar.DATE, -i - 7);
						cal.add(Calendar.DATE, 6);
						lastDateInPeriod = dateFrmt.format(cal.getTime());
						//get the First Day of Previous Week
						cal = Calendar.getInstance();
						int j = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
						cal.add(Calendar.DATE, -j - 7);
						cal.set(Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek());
						startDateInPeriod=  dateFrmt.format(cal.getTime());
					}

				} 

				else if ((period.equalsIgnoreCase("Month"))||(period.equalsIgnoreCase("Last Month"))) {
					Date currentDate = new Date();
					DateUtil dateUtilObj = new DateUtil();
					DateUtil dateUtilObj1 = new DateUtil();
					if((period.equalsIgnoreCase("Month")))
					{
						dateUtilObj  = dateUtilObj. getCurrentDateUtility(currentDate);
						int month = dateUtilObj. getMonth ();
						int year = dateUtilObj. getYear();


						//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
						basicFromQuery = basicFromQuery + " AssetMonitoringFactDataMonthAgg a ";
						//end Defect ID:1406
						basicWhereQuery = basicWhereQuery
						+ " and a.timeCount = "+month+" and a.year= " + year+"";
						//DefectId: DF20131218 -Juhi - To display the VINs that has not communicated for the given time period 
						//get the Last Day 
						Calendar cal = Calendar.getInstance();
						lastDateInPeriod = dateFrmt.format(cal.getTime());
						//get the First Day of current Month
						String mon = month+"";
						if(mon.length()<2)
							mon="0"+mon;
						startDateInPeriod=year+"-"+mon+"-"+"01";
					}
					if(period.equalsIgnoreCase("Last Month"))
					{
						dateUtilObj1  = dateUtilObj1. getCurrentDateUtility(currentDate);
						dateUtilObj  = dateUtilObj. getPreviousDateUtility (currentDate);
						int month = dateUtilObj. getMonth ();
						int year=0;
						if(dateUtilObj1.getMonth() ==1)
							year = dateUtilObj.getYear();
						else
							year = dateUtilObj.getCurrentYear();


						//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
						basicFromQuery = basicFromQuery + " AssetMonitoringFactDataMonthAgg a ";
						//end Defect ID:1406
						basicWhereQuery = basicWhereQuery
						+ " and a.timeCount = "+month+" and a.year= " + year+"";
						//DefectId: DF20131218 -Juhi- To display the VINs that has not communicated for the given time period 
						//Get the Last Day of previous Month
						Calendar cal = Calendar.getInstance();
						cal.set(Calendar.DATE, 1);
						cal.add(Calendar.DAY_OF_MONTH, -1);
						lastDateInPeriod = dateFrmt.format(cal.getTime());
						//get the First Day of Previous Month
						String mon = month+"";
						if(mon.length()<2)
							mon="0"+mon;
						startDateInPeriod=year+"-"+mon+"-"+"01";
					}
				} 

				else if ((period.equalsIgnoreCase("Quarter"))||(period.equalsIgnoreCase("Last Quarter"))) {
					Date currentDate = new Date();
					DateUtil dateUtilObj = new DateUtil();
					DateUtil dateUtilObj1 = new DateUtil();
					if(period.equalsIgnoreCase("Quarter"))
					{
						dateUtilObj  = dateUtilObj. getCurrentDateUtility(currentDate);
						int quarter = dateUtilObj. getQuarter ();
						int year = dateUtilObj. getYear();


						//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
						basicFromQuery = basicFromQuery + " AssetMonitoringFactDataQuarterAgg a ";
						//end Defect ID:1406
						basicWhereQuery = basicWhereQuery
						+ " and a.timeCount = "+quarter+" and a.year="+year+"";

						//DefectId: DF20131218 - Juhi - To display the VINs that has not communicated for the given time period 
						//get the Last Day 
						Calendar cal = Calendar.getInstance();
						lastDateInPeriod = dateFrmt.format(cal.getTime());
						//get the first Date of current quarter
						switch(quarter) 
						{
						case 3 : 
							startDateInPeriod = year+"-07-01";
							break;
							// return July 01
						case 2 :
							startDateInPeriod = year+"-04-01";
							break;
							// return April 01
						case 1 :
							startDateInPeriod = year+"-01-01";
							break;
							// return Jan 01
						case 4 : 
							startDateInPeriod = year+"-10-01";
							break;
							// return Oct 01
						}
					}
					if(period.equalsIgnoreCase("Last Quarter"))
					{
						dateUtilObj1  = dateUtilObj1. getCurrentDateUtility(currentDate);
						dateUtilObj  = dateUtilObj. getPreviousDateUtility(currentDate);
						int quarter = dateUtilObj. getQuarter ();
						int year=0;
						if(dateUtilObj1.getQuarter() ==1)
							year = dateUtilObj.getYear();
						else
							year = dateUtilObj.getCurrentYear();


						//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
						basicFromQuery = basicFromQuery + " AssetMonitoringFactDataQuarterAgg a ";
						//end Defect ID:1406
						basicWhereQuery = basicWhereQuery
						+ " and a.timeCount = "+quarter+" and a.year="+year+"";
						//DefectId: DF20131218  -Juhi - To display the VINs that has not communicated for the given time period 
						//get the last day of previous quarter
						switch(quarter) 
						{
						case 3 : 
							lastDateInPeriod = year+"-09-30";
							break;
							// return September 30
						case 2 :
							lastDateInPeriod = year+"-06-30";
							break;
							// return June 30
						case 1 :
							lastDateInPeriod = year+"-03-31";
							break;
							// return March 31
						case 4 : 
							lastDateInPeriod = year+"-12-31";
							break;
							// return December 31
						}
						//get the first Date of Previous quarter
						switch(quarter) 
						{
						case 3 : 
							startDateInPeriod = year+"-07-01";
							break;
							// return July 01
						case 2 :
							startDateInPeriod = year+"-04-01";
							break;
							// return April 01
						case 1 :
							startDateInPeriod = year+"-01-01";
							break;
							// return Jan 01
						case 4 : 
							startDateInPeriod = year+"-10-01";
							break;
							// return Oct 01
						}
					}				
				} 		
				else if ((period.equalsIgnoreCase("Year"))||(period.equalsIgnoreCase("Last Year"))) {
					Date currentDate = new Date();
					DateUtil dateUtilObj = new DateUtil();
					if(period.equalsIgnoreCase("Year"))
					{
						dateUtilObj  = dateUtilObj. getCurrentDateUtility(currentDate);
						int year = dateUtilObj. getYear();


						//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
						basicFromQuery = basicFromQuery + " AssetMonitoringFactDataYearAgg a ";
						//end Defect ID:1406
						basicWhereQuery = basicWhereQuery
						+ " and a.year = "+year+" ";
						//DefectId: DF20131218 - Juhi - To display the VINs that has not communicated for the given time period 
						//get the Last Day 
						Calendar cal = Calendar.getInstance();
						lastDateInPeriod = dateFrmt.format(cal.getTime());
						//get the First day of current Year
						startDateInPeriod=year+"-01"+"-01";
					}
					if(period.equalsIgnoreCase("Last Year"))
					{
						dateUtilObj  = dateUtilObj. getPreviousDateUtility(currentDate);
						int year = dateUtilObj. getYear();


						//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
						basicFromQuery = basicFromQuery + " AssetMonitoringFactDataYearAgg a ";
						//end Defect ID:1406
						basicWhereQuery = basicWhereQuery
						+ " and a.year = "+year+" ";
						//DefectId: DF20131218 -Juhi - To display the VINs that has not communicated for the given time period 
						//get the Last day of previous Year
						lastDateInPeriod=year+"-12-31";
						//get the First day of Previous Year 
						startDateInPeriod=year+"-01"+"-01";
					}				
				}
				if(!(isGroupingOnAssetGroup) )
					basicGroupByQuery = " group by a.serialNumber,ten1.tenancy_id ";
			}
			//Logic for Custom Dates (fromDate,toDate) added by Juhi on 14-August-2013 
			else
			{

				if(period==null)
				{
					Date newerDate = dateFrmt.parse(todateFormatted);
					Date olderDate = dateFrmt.parse(fromdateFormatted);
					double diffInDays = (double)( (newerDate.getTime() - olderDate.getTime()) 
			                / (1000 * 60 * 60 * 24) );
					diffInDays= diffInDays+1;
					double engineOffLong = (24*diffInDays)-engineOn;
					engineOffInt = (double)engineOffLong;
				//	implObj.setEngineOff(engineOffInt);
					implObj.setEngineOff(Double.valueOf(df2.format((Double)engineOffInt)));
				}
				//added by smitha on oct 15th 2013[custom dates aggregation for a VIN query change.... Internal Defect 20131014]
				//querySelected=true;
				basicSelectQuery = " select b.tenancyId, b.tenancyName, a.machineName, a.serialNumber, " +
				" sum((a.EngineRunningBand1+a.EngineRunningBand2+a.EngineRunningBand3+a.EngineRunningBand4+a.EngineRunningBand5+a.EngineRunningBand6+a.EngineRunningBand7+a.EngineRunningBand8)) as engineRunDurationInMin,"
				+"sum(a.engineOffHours) as engineOffDurationInMin , sum((a.EngineRunningBand3+a.EngineRunningBand4+a.EngineRunningBand5+a.EngineRunningBand6+a.EngineRunningBand7+a.EngineRunningBand8)) as engineWorkingDurationInMin, c.group_id as machineGroupId, c.group_name as machineGroupName, ten.tenancy_id as mgTenancy," +
				//DefectId:20150220 @ Suprava Delaer As a new parameter Added
				"b.parentTenancyName,b.tenancyTypeId ";
				//ended on oct 15th 2013[custom dates aggregation for a VIN query change.... Internal Defect 20131014]

				DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat dateFormat1 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
				Date fromdate1=null;
				String fromdate2=null;
				String todate2=null;
				String fromdate=null;
				String todate=null;
				try {	

					fromdate1 = (Date)dateFormat.parse(fromDate);		
					fromdate=	dateFormat.format(fromdate1);
					fromdate2=dateFormat1.format(fromdate1);

					Date todate1=(Date)dateFormat.parse(toDate);

					todate=dateFormat.format(todate1);
					todate2=dateFormat1.format(todate1);


				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				//DefectId: DF20131018 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period 
				startDateInPeriod = fromdate;
				lastDateInPeriod = todate;

				List<String> dateList= new LinkedList<String>();					
				Calendar calendar = Calendar.getInstance();					
				do
					{
						dateList.add(fromdate2);
						calendar.setTime(fromdate1);
						calendar.add(Calendar.DAY_OF_YEAR, 1);
						fromdate1 = calendar.getTime();			
						fromdate2 = dateFormat1.format(fromdate1);


					} while ((fromdate2.compareTo(todate2)) <=0);
				String dateStringList=conversionObj.getStringList(dateList).toString();


				//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
				basicFromQuery = basicFromQuery + " AssetMonitoringFactDataDayAgg a";
				//end Defect ID:1406
				basicWhereQuery = basicWhereQuery+ " and a.timeKey between '"+fromdate2+"' and '"+todate2+"' ";
				if(basicGroupByQuery.length()>2)
				{
					//						basicGroupByQuery =basicGroupByQuery+ " ,a.timeKey,a.tenancyId";
					//added by smitha on oct 15th 2013[custom dates aggregation for a VIN query change.... Internal Defect 20131014]
					basicGroupByQuery ="a.serialNumber ,a.tenancyId,c.group_id , ten1.tenancy_id ";
					//ended on oct 15th 2013[custom dates aggregation for a VIN query change.... Internal Defect 20131014]
				}
				else
				{
					//						basicGroupByQuery = " group by a.serialNumber,a.timeKey,a.tenancyId";
					//added by smitha on oct 15th 2013[custom dates aggregation for a VIN query change.... Internal Defect 20131014]
					basicGroupByQuery = " group by a.serialNumber,a.tenancyId,c.group_id, ten1.tenancy_id  ";
					//ended on oct 15th 2013[custom dates aggregation for a VIN query change.... Internal Defect 20131014]
				}
				fromdateFormatted= dateFormat.format(dateFormat.parse(fromDate));	
				todateFormatted = dateFormat.format(dateFormat.parse(toDate));
			}
			//Logic for Custom Dates (fromDate,toDate) added by Juhi on 14-August-2013 
			basicFromQuery = basicFromQuery + ",TenancyDimensionEntity b ";
			boolean machineGroup = false;
			boolean machineProfile = false;
			boolean model = false;
			machineGroup=true;
			if (!(customAssetGroupIdList == null || customAssetGroupIdList
					.isEmpty())) {
				String customAssetGroupStringList = conversionObj
				.getIntegerListString(customAssetGroupIdList)
				.toString();
				basicSelectQuery = basicSelectQuery
				+ ", c.group_id as machineGroupId, c.group_name as machineGroupName ";
				basicFromQuery = basicFromQuery
				+ " , CustomAssetGroupEntity c, AssetCustomGroupMapping h ";
				basicWhereQuery = basicWhereQuery
				+ " and c.group_id = h.group_id and c.group_id in ("
				+ customAssetGroupStringList + ") and "
				+ " h.serial_number = a.serialNumber ";
				basicWhereQuery = basicWhereQuery
				+ " and c.group_id in ("
				+ customAssetGroupStringList + ")";
				//				machineGroup=true;
			}

			if ((!(assetGroupIdList == null || assetGroupIdList.isEmpty()))
					|| (!(modelIdList == null || modelIdList.isEmpty()))) {
				basicFromQuery = basicFromQuery
				+ " , AssetClassDimensionEntity d ";
				basicWhereQuery = basicWhereQuery
				+ " and a.assetClassDimensionId = d.assetClassDimensionId";

			}

			if (!(assetGroupIdList == null || assetGroupIdList.isEmpty())) {
				String assetGroupStringList = conversionObj
				.getIntegerListString(assetGroupIdList).toString();
				basicSelectQuery = basicSelectQuery
				+ " ,d.assetGroupId as profileId, d.assetGroupName as profileName ";
				basicWhereQuery = basicWhereQuery + " and d.assetGroupId in ( "
				+ assetGroupStringList + " )";
				machineProfile = true;
			}

			if (!(modelIdList == null || modelIdList.isEmpty())) {
				String modelIdStringList = conversionObj.getIntegerListString(
						modelIdList).toString();

				basicSelectQuery = basicSelectQuery
				+ " , d.assetTypeId as modelId, d.assetTypeName as modelName ";
				basicWhereQuery = basicWhereQuery + " and d.assetTypeId in ( "
				+ modelIdStringList + " )";
				model = true;
			}
			//added by smitha on oct 15th 2013[custom dates aggregation for a VIN query change.... Internal Defect 20131014]
			if(querySelected==false){
				finalQuery = basicSelectQuery + basicFromQuery + basicWhereQuery + basicGroupByQuery + " order by a.serialNumber, ten.tenancy_id ";
				}
				else{
			 		finalQuery = basicSelectQuery + basicFromQuery + basicWhereQuery + basicGroupByQuery + " order by a.serialNumber, ten.tenancy_id ";

			 //ended on oct 15th 2013[custom dates aggregation for a VIN query change.... Internal Defect 20131014]
			 //			finalQuery = basicSelectQuery + basicFromQuery + basicWhereQuery + basicGroupByQuery;
			 //DefectID:1406 Suprava 2013/10/30
			 List<String> otherMachineGroupVins = new LinkedList<String>();
			 Query query = session.createQuery(finalQuery);
			 Iterator itr = query.list().iterator();
			 Object[] result = null;

			 while (itr.hasNext()) {
				 impObj = new UtilizationSummaryReportImpl();
				 result = (Object[]) itr.next();
				 impObj.setTenancyId((Integer) result[0]);
				 if (result[1] != null)	{
					 impObj.setTenancyName(result[1].toString());
				 }
				 if (result[2] != null){
					 impObj.setMachineName(result[2].toString());
				 }
				 if(result[3]!=null)
				 {
					 tempSerialNumberUtilization=result[3].toString();

				 }

				 if( (!isGroupingOnAssetGroup) && (tempSerNumListUtilization.contains(tempSerialNumberUtilization))) 
				 {
					 continue;
				 }
				 impObj.setSerialNumber(result[3].toString());

				 if (result[4] != null){
					EngineWorkingDurationInMin=(Integer) result[4];
				}
				 if (result[4] != null){
					 //			DefectId:1632 @ suprava
					 engineRunDuration=Math.round(Double.valueOf(df2.format((Double)result[4])));
					 impObj.setEngineRunDurationInMin(engineRunDuration);
					// System.out.println("engineRunDuration"+engineRunDuration);
				 }
				 impObj.setEngineRunDurationInMin(engineRunDuration);
				 if (result[5] != null){
					 //Done by Juhi on DF:20131209 Integer to Long Cast 
					 //					if(querySelected==false){
					 //					Keerthi : 10/12/13 : taking off hours  as int instead of Long
					 engineOffHours=Double.valueOf(df2.format((Double)result[5]));
					 //					}else{
					 //					engineOffHours1=(Long) result[5];
					 //					}
					 //System.out.println("engineOffHours"+engineOffHours);
				 }

				 double workingTime1 = (Double)result[4];

				 double engineOn = (double) (workingTime1 );
				 if(period==null)
				 {
					 Date newerDate = dateFrmt.parse(todateFormatted);
					 Date olderDate = dateFrmt.parse(fromdateFormatted);
					 double diffInDays = (double)( (newerDate.getTime() - olderDate.getTime()) 
							 / (1000 * 60 * 60 * 24) );
					 diffInDays= diffInDays+1;
					 double engineOffLong = (24*diffInDays)-engineOn;
					 //engineOffInt = (double)engineOffLong;
					 //	implObj.setEngineOff(engineOffInt);
					 impObj.setEngineOffDurationInMin(Double.valueOf(df2.format((Double)engineOffLong)));
					 //					Keerthi : 27/12/2013 : calculating engine off hours for custom dates
					 engineOffHours = engineOffLong;
				 }else{


					 if (result[5] != null)
					 {
						 impObj.setEngineOffDurationInMin(Double.valueOf(df2.format((Double)result[5])));
					 }
				 }
				 //Changes done by Juhi on 6 May2013
				 if (result[6] != null){
					 impObj.setEngineWorkingDurationInMin(Double.valueOf(df2.format((Double)result[6])));
				 }
				 //
				 DecimalFormat df3 = new DecimalFormat("###.##");
				 Double machineUtilization=0.0;
				 if(!(engineRunDuration+engineOffHours ==0)){
				 machineUtilization=(Double.valueOf(df3.format((Double) ((engineRunDuration/(engineRunDuration+engineOffHours))*100))));
				 }
				 else
				 {
					 machineUtilization=0.0; 
				 }
				 if(machineUtilization!=null){
					 impObj.setMachineUtilizationPercentage(machineUtilization);	
				 }
				//DefectId:20150225 @ Suprava Delaer As a new parameter Added
				 TenancyEntity tenancyEntity =null;
					if(result[11]!=null)
							{
								int tenancyTypeId =(Integer) result[11];
								//If the Machine is with customer Get the parentTeancyId
								if(tenancyTypeId==4)
								{
									//tenancyEntity =(TenancyEntity)result[10];
									impObj.setDealerName(result[10].toString());
								}
								//If the Machine is with Dealer
								else if(tenancyTypeId==3) 
								{
									if(result[1]!=null)
									{
									//String Dealername =(String)result[1];
									impObj.setDealerName(result[1].toString());
								}
								}
								else
								{
									impObj.setDealerName("No Dealer Tagging");
								}
							
							}
					//End of DefectId:20150225

				 if (machineGroup == true) {
					//null check by smitha on 7th oct 2013
					if(result[7]!=null){
					impObj.setMachineGroupId((Integer) result[7]);
					}
					//end on 7th 0ct 2013
					if (result[8] != null){
	//					infoLogger.info("MachineGroupName   "+(result[8].toString()));
						impObj.setMachineGroupName(result[8].toString());
					}
				}
				 //DefectID:1406 - Suprava - 2013-October-30 - To return Report Totals
				 if(!(tempSerNumListUtilization.contains(tempSerialNumberUtilization)))
				 {

					 totalengineOffDurationInMin = totalengineOffDurationInMin+engineOffHours;
					 totalengineWorkingDurationInMinsumm = totalengineWorkingDurationInMinsumm+(Double.valueOf(df2.format((Double)result[6])));
					 totalmachineUtilizationPercentagesumm = totalmachineUtilizationPercentagesumm+(machineUtilization);
					 totalengineRunDurationInMinsumm = totalengineRunDurationInMinsumm+(engineRunDuration);
				 }

				 //DefectID: 1406 Suprava
				 int otherMachineGroup =0;
				 if(result[9]!=null)
				 {
					 int mgTenancy = (Integer) result[9];
					 if(! (loginTenancyIdList.contains(mgTenancy)) ) 
					 {
						 otherMachineGroup=1;
					 }
				 }

				 if( (otherMachineGroup==1)&& ( (otherMachineGroupVins.contains(tempSerialNumberUtilization)) || (tempSerNumListUtilization.contains(tempSerialNumberUtilization)) ) )
				 {
					 continue;
				 }
				 //DefectId:1406 End
				 //DefectID:1406 - Suprava Nayak - 20131028 - MachineGrouping issue in Reports and sending Report Totals information
				 if (machineGroup == true){
					 if(result[9]!=null)
					 {
						 int mgTenancy = (Integer) result[9];
						 if(loginTenancyIdList.contains(mgTenancy)) 
						 {
							 if(result[7]!=null)
								 impObj.setMachineGroupId((Integer)result[7]);

							 if(result[8]!=null)
								 impObj.setMachineGroupName(result[8].toString());
						 }
						 else
						 {
							 otherMachineGroupVins.add(tempSerialNumberUtilization);
						 }

					 }
				 }
				 if (machineProfile == true) {
					 if (machineGroup == true) {
						 impObj.setMachineProfileId((Integer) result[10]);
						 if (result[11] != null){
							 impObj.setMachineProfileName(result[11].toString());
						 }
					 } else {
						 impObj.setMachineProfileId((Integer) result[7]);
						 if (result[8] != null){
							 impObj.setMachineProfileName(result[8].toString());
						 }
					 }
				 }
				 if (machineProfile == true) {
					 if (machineGroup == true) {
						 impObj.setMachineProfileId((Integer) result[12]);
						 if (result[13] != null){
							 impObj.setMachineProfileName(result[13].toString());
						 }
					 } else {
						 impObj.setMachineProfileId((Integer) result[7]);
						 if (result[8] != null){
							 impObj.setMachineProfileName(result[8].toString());
						 }
					 }
				 }
				 if (model == true) {
					 if (machineProfile == true) {
						 if (machineGroup == true) {
							 impObj.setModelId((Integer) result[12]);
							 if (result[13] != null){
								 impObj.setModelName(result[13].toString());
							 }
						 } else {
							 impObj.setModelId((Integer) result[10]);
							 if (result[11] != null){
								 impObj.setModelName(result[11].toString());
							 }
						 }
					 } else {
						 if (machineGroup == true) {
							 impObj.setModelId((Integer) result[10]);
							 if (result[11] != null){
								 impObj.setModelName(result[11].toString());
							 }
						 } else {
							 impObj.setModelId((Integer) result[7]);
							 if (result[8] != null){
								 impObj.setModelName(result[8].toString());
							 }
						 }					
					 }

				 }
				 if (model == true) {
					 if (machineProfile == true) {
						 if (machineGroup == true) {
							 impObj.setModelId((Integer) result[14]);
							 if (result[15] != null){
								 impObj.setModelName(result[15].toString());
							 }
						 } else {
							 impObj.setModelId((Integer) result[12]);
							 if (result[13] != null){
								 impObj.setModelName(result[13].toString());
							 }
						 }
					 } else {
						 if (machineGroup == true) {
							 impObj.setModelId((Integer) result[12]);
							 if (result[13] != null){
								 impObj.setModelName(result[13].toString());
							 }
						 } else {
							 impObj.setModelId((Integer) result[7]);
							 if (result[8] != null){
								 impObj.setModelName(result[8].toString());
							 }
						 }					
					 }

				 }
				 tempSerNumListUtilization.add(tempSerialNumberUtilization);
				 responseList.add(impObj);
			 }
			 //-------------------------------------------------------------------------------------------------------------------
			 //DefectId: DF20131218 - Juhi To display the VINs that has not communicated for the given time period 
			 Query ownerListQuery = session.createQuery(" select distinct c.serialNumber " +
					 " from TenancyBridgeEntity a, AccountTenancyMapping b, AssetAccountMapping c " +
					 " where a.childId= b.tenancy_id " +
					 " and b.account_id= c.accountId " +
					 " and a.parentId in ("+childTenancyIdStringList+") and" +
					 " ( (c.ownershipStartDate between '"+startDateInPeriod+"' and '"+lastDateInPeriod+"') OR " +
					 "   (c.ownershipStartDate = ( select max(y.ownershipStartDate) from AssetAccountMapping y " +
					 " where y.serialNumber= c.serialNumber" +
					 " and y.ownershipStartDate <='"+startDateInPeriod+"')" +
					 "    )" +
			 " )");
			 Iterator ownerListItr = ownerListQuery.list().iterator();
			 List<String> actualOwnerVINList = new LinkedList<String>();
			 while(ownerListItr.hasNext())
			 {
				 AssetEntity assetList = (AssetEntity)ownerListItr.next();
				 actualOwnerVINList.add(assetList.getSerial_number().getSerialNumber());
			 }

			 //Get only the List of VINs which has not communicated for the Given period
			 actualOwnerVINList.removeAll(tempSerNumListUtilization);
			 String actualOwnerVinListString = conversionObj.getStringList(actualOwnerVINList).toString();
			 basicSelectQuery = "select b.tenancyId, b.tenancyName, a.machineName, a.serialNumber, " +
			 //			" (a.EngineRunningBand1+a.EngineRunningBand2+a.EngineRunningBand3+a.EngineRunningBand4+a.EngineRunningBand5+a.EngineRunningBand6+a.EngineRunningBand7+a.EngineRunningBand8) as engineRunDurationInMin,"
			 //			+"a.engineOffHours as engineOffDurationInMin , (a.EngineRunningBand3+a.EngineRunningBand4+a.EngineRunningBand5+a.EngineRunningBand6+a.EngineRunningBand7+a.EngineRunningBand8) as engineWorkingDurationInMin,
			 " c.group_id as machineGroupId, c.group_name as machineGroupName,"+
			 " ten.tenancy_id as mgTenancy, ten1.parent_tenancy_id,b.tenancyTypeId";


			 basicFromQuery = "from AssetCustomGroupMapping h RIGHT OUTER JOIN h.serial_number x  LEFT OUTER JOIN h.group_id c "+
			 " LEFT OUTER JOIN c.tenancy_id ten ,TenancyEntity ten1,TenancyDimensionEntity b, AssetMonitoringFactDataDayAgg a " ;

			 basicWhereQuery = " where ten1.tenancy_id = b.tenancyId and a.tenancyId = b.tenacy_Dimension_Id and b.tenancyId in ("+ childTenancyIdStringList + " )" +
			 " and  a.serialNumber =x.serial_number  and a.serialNumber in ("+actualOwnerVinListString+") " +
			 " and a.timeKey = ( select max(p.timeKey) from AssetMonitoringFactDataDayAgg p where p.serialNumber = a.serialNumber " +
			 " and p.timeKey <= '"+startDateInPeriod+"' )" +
			//DefectId:20150216 @ Suprava Dealer As a new parameter Added
				" and b.parentTenancyId=ten1.parent_tenancy_id ";


			 basicGroupByQuery = " group by a.serialNumber,ten1.tenancy_id";
			 if (!(customAssetGroupIdList == null || customAssetGroupIdList
					 .isEmpty())) {
				 String customAssetGroupStringList = conversionObj
				 .getIntegerListString(customAssetGroupIdList)
				 .toString();

				 basicWhereQuery = basicWhereQuery
				 + " and c.group_id in ("
				 + customAssetGroupStringList + ")";

			 }

			 if ((!(assetGroupIdList == null || assetGroupIdList.isEmpty()))
					 || (!(modelIdList == null || modelIdList.isEmpty()))) {
				 basicFromQuery = basicFromQuery
				 + " , AssetClassDimensionEntity d ";
				 basicWhereQuery = basicWhereQuery
				 + " and a.assetClassDimensionId = d.assetClassDimensionId";

			 }

			 if (!(assetGroupIdList == null || assetGroupIdList.isEmpty())) {
				 String assetGroupStringList = conversionObj
				 .getIntegerListString(assetGroupIdList).toString();
				 basicSelectQuery = basicSelectQuery
				 + " ,d.assetGroupId as profileId, d.assetGroupName as profileName ";
				 basicWhereQuery = basicWhereQuery + " and d.assetGroupId in ( "
				 + assetGroupStringList + " )";
				 machineProfile = true;
			 }

			 if (!(modelIdList == null || modelIdList.isEmpty())) {
				 String modelIdStringList = conversionObj.getIntegerListString(
						 modelIdList).toString();

				 basicSelectQuery = basicSelectQuery
				 + " , d.assetTypeId as modelId, d.assetTypeName as modelName ";
				 basicWhereQuery = basicWhereQuery + " and d.assetTypeId in ( "
				 + modelIdStringList + " )";
				 model = true;
			 }
			 if(! (actualOwnerVINList==null || actualOwnerVINList.isEmpty()))
			 {
				 finalQuery = basicSelectQuery + basicFromQuery + basicWhereQuery + basicGroupByQuery + " order by x.serial_number, a.lastReported desc  ";
				 Iterator vinListItr = session.createQuery(finalQuery).list().iterator();
				 tempSerNumListUtilization= new ArrayList<String>();
				 result =null;
				 //		Keerthi : 09/01/2014 : using proper iterator for non communicated pins.
				 while (vinListItr.hasNext()) {
					 impObj = new UtilizationSummaryReportImpl();
					 result = (Object[]) vinListItr.next();
					 impObj.setTenancyId((Integer) result[0]);
					 if (result[1] != null)	{
						 impObj.setTenancyName(result[1].toString());
					 }
					 if (result[2] != null){
						 impObj.setMachineName(result[2].toString());
					 }
					 if(result[3]!=null)
					 {
						 tempSerialNumberUtilization=result[3].toString();

					 }

					 if( (!isGroupingOnAssetGroup) && (tempSerNumListUtilization.contains(tempSerialNumberUtilization))) 
					 {
						 continue;
					 }
					 impObj.setSerialNumber(result[3].toString());
					 impObj.setEngineRunDurationInMin(0d);
					 //			Keerthi : 13/01/14 : taking diff in days
					 Date newerDate = dateFrmt.parse(lastDateInPeriod);
					 Date olderDate = dateFrmt.parse(startDateInPeriod);
					 double diffInDays = (double)( (newerDate.getTime() - olderDate.getTime()) 
							 / (1000 * 60 * 60 * 24) );
					 diffInDays= diffInDays+1;
					 double engineOff = (24*diffInDays);//engine on 0 for non-communicated period
					 //			engineOffInt = (double)engineOffLong;
					 impObj.setEngineOffDurationInMin(engineOff);
					 impObj.setMachineUtilizationPercentage(0d);	
					 if (result[4] != null){
				EngineWorkingDurationInMin=(Integer) result[4];
			}
					 if (result[4] != null){
//		DefectId:1632 @ suprava
				engineRunDuration=Math.round(Double.valueOf(df2.format((Double)result[4])));
				impObj.setEngineRunDurationInMin(engineRunDuration);
			}
			impObj.setEngineRunDurationInMin(engineRunDuration);
			if (result[5] != null){
				//Done by Juhi on DF:20131209 Integer to Long Cast 
//				if(querySelected==false){
//				Keerthi : 10/12/13 : taking off hours  as int instead of Long
				engineOffHours=Double.valueOf(df2.format((Double)result[5]));
//				}else{
//				engineOffHours1=(Long) result[5];
//				}
			}
			if (result[5] != null)
			{
				impObj.setEngineOffDurationInMin(Double.valueOf(df2.format((Double)result[5])));
			}
			//Changes done by Juhi on 6 May2013
			if (result[6] != null){
				impObj.setEngineWorkingDurationInMin(Double.valueOf(df2.format((Double)result[6])));
			}
					 DecimalFormat df4 = new DecimalFormat("###.##");
			Double machineUtilization=(Double.valueOf(df4.format((Double) ((engineRunDuration/(engineRunDuration+engineOffHours))*100))));
			if(machineUtilization!=null){
				impObj.setMachineUtilizationPercentage(machineUtilization);	
			}


					 if (machineGroup == true) {
				//null check by smitha on 7th oct 2013
				if(result[7]!=null){
				impObj.setMachineGroupId((Integer) result[7]);
				}
				//end on 7th 0ct 2013
				if (result[8] != null){
					impObj.setMachineGroupName(result[8].toString());
				}
			}
					 //DefectID:1406 - Suprava - 2013-October-30 - To return Report Totals
					 if(!(tempSerNumListUtilization.contains(tempSerialNumberUtilization)))
					 {

						 totalengineOffDurationInMin = totalengineOffDurationInMin+Double.valueOf(df2.format(engineOff));
						 //				totalengineWorkingDurationInMinsumm = totalengineWorkingDurationInMinsumm+(Double.valueOf(df2.format((Double)result[6])));
						 //				totalmachineUtilizationPercentagesumm = totalmachineUtilizationPercentagesumm+(machineUtilization);
						 //				totalengineRunDurationInMinsumm = totalengineRunDurationInMinsumm+(engineRunDuration);
					 }

					 //DefectID: 1406 Suprava
					 int otherMachineGroup =0;
					 if(result[6]!=null)
					 {
						 int mgTenancy = (Integer) result[6];
						 if(! (loginTenancyIdList.contains(mgTenancy)) ) 
						 {
							 otherMachineGroup=1;
						 }
					 }
					//DefectId:20150220 @ Suprava Delaer As a new parameter Added
					 TenancyEntity tenancyEntity =null;	
					 if(result[8]!=null)
								{
									int tenancyTypeId =(Integer) result[8];
									//If the Machine is with customer Get the parentTeancyId
									if(tenancyTypeId==4)
									{
										tenancyEntity =(TenancyEntity)result[7];
										impObj.setDealerName(tenancyEntity.getTenancy_name());
									}
									//If the Machine is with Dealer
									else if(tenancyTypeId==3) 
									{
										if(result[1]!=null)
										{
										String Dealername =(String)result[1];
										impObj.setDealerName(Dealername);
									}
									}
									else
									{
										impObj.setDealerName("No Dealer Tagging");
									}
								
								}
					 //DefectId:20150225 End
					 if( (otherMachineGroup==1)&& ( (otherMachineGroupVins.contains(tempSerialNumberUtilization)) || (tempSerNumListUtilization.contains(tempSerialNumberUtilization)) ) )
					 {
						 continue;
					 }
					 //DefectId:1406 End
					 //DefectID:1406 - Suprava Nayak - 20131028 - MachineGrouping issue in Reports and sending Report Totals information
					 if (machineGroup == true){
						 if(result[6]!=null)
						 {
							 int mgTenancy = (Integer) result[6];
							 if(loginTenancyIdList.contains(mgTenancy)) 
							 {
								 if(result[4]!=null)
									 impObj.setMachineGroupId((Integer)result[4]);

								 if(result[5]!=null)
									 impObj.setMachineGroupName(result[5].toString());
							 }
							 else
							 {
								 otherMachineGroupVins.add(tempSerialNumberUtilization);
							 }

						 }
					 }
					 if (machineProfile == true) {
						 if (machineGroup == true) {
							 if( result[4]!=null){
								 impObj.setMachineProfileId((Integer) result[4]);
							 }					
							 if (result[8] != null){
								 impObj.setMachineProfileName(result[8].toString());
							 }
						 } else {
							 if( result[4]!=null){
								 impObj.setMachineProfileId((Integer) result[4]);
							 }
							 if (result[5] != null){
								 impObj.setMachineProfileName(result[5].toString());
							 }
						 }
					 }
					 if (machineProfile == true) {
						 if (machineGroup == true) {
							 if( result[4]!=null){
								 impObj.setMachineProfileId((Integer) result[4]);
							 }					
							 if (result[10] != null){
								 impObj.setMachineProfileName(result[10].toString());
							 }
						 } else {
							 if( result[4]!=null){
								 impObj.setMachineProfileId((Integer) result[4]);
							 }
							 if (result[5] != null){
								 impObj.setMachineProfileName(result[5].toString());
							 }
						 }
					 }
					 if (model == true) {
						 if (machineProfile == true) {
							 if (machineGroup == true) {
								 if( result[9]!=null){
									 impObj.setModelId((Integer) result[9]);
								 }
								 if (result[10] != null){
									 impObj.setModelName(result[10].toString());
								 }
							 } else {
								 if( result[7]!=null){
									 impObj.setModelId((Integer) result[7]);
								 }
								 if (result[8] != null){
									 impObj.setModelName(result[8].toString());
								 }
							 }
						 } else {
							 if (machineGroup == true) {
								 if( result[7]!=null){
									 impObj.setModelId((Integer) result[7]);
								 }
								 if (result[8] != null){
									 impObj.setModelName(result[8].toString());
								 }
							 } else {
								 if( result[4]!=null){
									 impObj.setModelId((Integer) result[4]);
								 }
								 if (result[5] != null){
									 impObj.setModelName(result[5].toString());
								 }
							 }					
						 }

					 }
					 if (model == true) {
						 if (machineProfile == true) {
							 if (machineGroup == true) {
								 if( result[11]!=null){
									 impObj.setModelId((Integer) result[11]);
								 }
								 if (result[12] != null){
									 impObj.setModelName(result[12].toString());
								 }
							 } else {
								 if( result[9]!=null){
									 impObj.setModelId((Integer) result[9]);
								 }
								 if (result[10] != null){
									 impObj.setModelName(result[10].toString());
								 }
							 }
						 } else {
							 if (machineGroup == true) {
								 if( result[9]!=null){
									 impObj.setModelId((Integer) result[9]);
								 }
								 if (result[10] != null){
									 impObj.setModelName(result[10].toString());
								 }
							 } else {
								 if( result[4]!=null){
									 impObj.setModelId((Integer) result[4]);
								 }
								 if (result[5] != null){
									 impObj.setModelName(result[5].toString());
								 }
							 }					
						 }

					 }
					 
					 tempSerNumListUtilization.add(tempSerialNumberUtilization);
					 responseList.add(impObj);
				 }
			 }
			 //-------------------------------------------------------------------------------------------------------------------
			 //DefectId: DF20131218 - Juhi To display the VINs that has not communicated for the given time period 
			 //added by smitha on oct 14th 2013[to display the machines which have not communicated .... Internal Defect 20131014]
			 	commented by Juhi on 10-12-2013---start
			  * Set mapSet = (Set) calledSerNumMapUtilization.entrySet();
			Iterator mapIterator = mapSet.iterator();	
			while (mapIterator.hasNext()) {
				Map.Entry mapEntry = (Map.Entry) mapIterator.next(); 
				String keyValue = (String) mapEntry.getKey(); 
				int value = (Integer)mapEntry.getValue();
				AllSerNumListUtilization.add(keyValue);

		}	

			int tenancyId=0;
			String tenancyName2=null;
			Integer groupID1=0;
			String groupName2=null;
			 Iterator iterSerialNoList = AllSerNumListUtilization.iterator();
			 for (String serialNo : AllSerNumListUtilization) {
			if(!tempSerNumListUtilization.contains(serialNo))	{
				impObj = new UtilizationSummaryReportImpl();
				impObj.setEngineOffDurationInMin(0l);
				impObj.setEngineRunDurationInMin(0.0d);
				impObj.setEngineWorkingDurationInMin(0l);
				groupID1=serGroupID.get(serialNo);
				if(groupID1!=0){
					impObj.setMachineGroupId(groupID1);
				}else{
					impObj.setMachineGroupId(0);
				}

				groupName2=GroupData.get(groupID1);
				if(groupName2!="" || groupName2!=null){
					impObj.setMachineGroupName(groupName2);
				}else {
					impObj.setMachineGroupName(null);
				}

				impObj.setMachineProfileId(0);
				impObj.setMachineProfileName(null);	
				impObj.setMachineUtilizationPercentage(0.0d);
				impObj.setModelId(0);
				impObj.setModelName(null);				
				impObj.setSerialNumber(serialNo);
				tenancyId=calledSerNumMapUtilization.get(serialNo);
				impObj.setTenancyId(tenancyId);
				tenancyName2=TenancyData.get(tenancyId);
				impObj.setTenancyName(tenancyName2);
				responseList.add(impObj);
			}
			}	commented by Juhi on 10-12-2013---end
			  			   //DefectId:1406 Suprava 2013/10/30
			 impObj = new UtilizationSummaryReportImpl();
			 impObj.setSerialNumber("Summary");
			 //System.out.println("totalengineRunDurationInMinsumm:"+totalengineRunDurationInMinsumm);
			 impObj.setEngineRunDurationInMin(totalengineRunDurationInMinsumm);
			// System.out.println("totalengineWorkingDurationInMinsumm:"+totalengineWorkingDurationInMinsumm);
			 impObj.setEngineWorkingDurationInMin(totalengineWorkingDurationInMinsumm);
			 //Defect_id:2014-01-08 @suprava 
			 if(!(totalengineRunDurationInMinsumm==0))
			 {
				 DecimalFormat df3 = new DecimalFormat("###.##");
				 totalmachineUtilizationPercentagesumm=(Double.valueOf(df3.format((Double)((totalengineRunDurationInMinsumm/(totalengineRunDurationInMinsumm+totalengineOffDurationInMin))*100))));
				 impObj.setMachineUtilizationPercentage(totalmachineUtilizationPercentagesumm);
				// System.out.println("totalmachineUtilizationPercentagesumm:"+totalmachineUtilizationPercentagesumm);
			 }
			 else 
			 {
				 impObj.setMachineUtilizationPercentage(0.0);	
			 }
			// System.out.println("totalengineOffDurationInMin:"+totalengineOffDurationInMin);
			 impObj.setEngineOffDurationInMin(Double.valueOf(df2.format((Double)(totalengineOffDurationInMin))));
			 responseList.add(impObj); 
			 //ended on oct 14th 2013[to display the machines which have not communicated .... Internal Defect 20131014]
		}

		catch (Exception e) {
			e.printStackTrace();
			fLogger.fatal("Exception :" + e);
		}

		finally {
			if (session.getTransaction().isActive()) {
				session.getTransaction().commit();
			}

			if (session.isOpen()) {
				session.flush();
				session.close();
			}

		}

		return responseList;
	}*/



	// ************************************************************* Machine Due OverDue Report *****************************************************
	/** This method returns the List of machines under service due/overdue 
	 * @param loginId user LoginId
	 * @param tenancyIdList List of tenancy Id
	 * @param machineGroupIdList List of machine group Id
	 * @param machineProfileIdList List of machine profile Id
	 * @param modelIdList List of modelId
	 * @param isOverdueReport is due/overdue details required
	 * @return
	 * @throws ParseException 
	 *//*
	@SuppressWarnings("unused")
	public List<DueOverDueReportImpl> getDueOverdueMachines(String loginId,	List<Integer> tenancyIdList, List<Integer> machineGroupIdList,
			List<Integer> machineProfileIdList,	List<Integer> modelIdList,boolean isOverdueReport) 

			{            List<DueOverDueReportImpl> implList = new LinkedList<DueOverDueReportImpl>();
			//Logger fatalError = Logger.getLogger("fatalErrorLogger");
			//Logger businessError = Logger.getLogger("businessErrorLogger");
			Logger fLogger = FatalLoggerClass.logger;
			Logger bLogger = BusinessErrorLoggerClass.logger;
			Logger iLogger = InfoLoggerClass.logger;
			Session session = HibernateUtil.getSessionFactory().getCurrentSession();
			session.beginTransaction();

			try
			{
				DecimalFormat df2 = new DecimalFormat("###.#");
				String severity;

				if(isOverdueReport)
				{
					severity ="RED";
				}
				else
					severity = "YELLOW";

				String basicFromQuery = null;
				String basicSelectQuery = null;
				String basicWhereQuery = null;
				String finalQuery = null;

				boolean machineGroup = false;
				boolean machineProfile = false;
				boolean model = false;
				machineGroup=true;
				//        Keerthi : Defect ID : 1393 :Only customer machines
				// tenancyIdList=getCustomerTenancyIds(tenancyIdList);
				iLogger.info("child id list size tenancyIdList: "+tenancyIdList.size());
				//DefectId:20140910 To Display the customer machine
				ListToStringConversion conversion = new ListToStringConversion();
				String loggedInTenancyId = conversion.getIntegerListString(tenancyIdList).toString();
				List<Integer> subTenancyIdList = new ArrayList<Integer>();
				String tenancyQuery = "select t1.childId,t.parent_tenancy_id FROM  TenancyBridgeEntity  t1 ,TenancyEntity t WHERE t1.parentId in("+loggedInTenancyId+") and t1.childId=t.tenancy_id and t.tenancy_type_id=4";
				Query queryy = session.createQuery(tenancyQuery);
				Iterator itr1 = queryy.list().iterator();
				Object[] resultTenancy = null;
				while(itr1.hasNext()){	
					resultTenancy = (Object[]) itr1.next();
					int childId=(Integer) resultTenancy[0];
					if (resultTenancy[0] != null) {
						subTenancyIdList.add((Integer) resultTenancy[0]);
						//System.out.println("subTenancyIdList"+subTenancyIdList);
					}
					//					infoLogger.info("childId");
				}	
				iLogger.info("child id list size from subTenancyIdList: "+subTenancyIdList.size());
				if(subTenancyIdList!=null && subTenancyIdList.size()>0){
					ListToStringConversion conversionObj = new ListToStringConversion();
					String tenancyIdStringList = conversionObj.getIntegerListString(subTenancyIdList).toString();
					iLogger.info("tenancyIdStringList  "+ tenancyIdStringList);
					Date currentDate1 = new Date();
					DateUtil dateUtilObj = new DateUtil();
					dateUtilObj  = dateUtilObj. getCurrentDateUtility(currentDate1);
					int year = dateUtilObj. getYear();

					String parameterName =null;

					Properties prop = new Properties();
					prop.load(getClass().getClassLoader().getResourceAsStream("remote/wise/resource/properties/configuration.properties"));
					parameterName= prop.getProperty("ServiceAlerts");
					String accountType ="Dealer";					 

					          
                basicSelectQuery = "select distinct a.SerialNumber as serialNumber, b.tenancyId as tenancyId,b.tenancyName as tenancyName, " +
                            "a.Account_Id as customerAccountId,h.account_name as customerName, h.mobile_no as customerMobileNo, h.parent_account_id as dealerAccount," +
                            " i.serial_number as AssetEntity, i.DriverName as driverName, i.DriverContactNumber as driverContactNo, " +
                            " j.machineHours, f.eventId, c.group_id as machineGroupId, c.group_name as machineGroupName,f.serviceScheduleId ";
					    
                basicFromQuery = " from notification_fact_Yearagg a JOIN a.Tenancy_Id b , AssetEventEntity f, EventTypeEntity g, AccountEntity h, " +
                            "AssetExtendedDetailsEntity i ,AssetMonitoringFactDataYearAgg j , AccountDimensionEntity u , CustomAssetGroupEntity c, AssetCustomGroupMapping w " ;
					 
					//Code change done by Juhi 4-October-2013 for CustomAssetGroupEntity
					//DefectId:20150408 @Suprava Max Machine Hour Query change 
					basicSelectQuery = "select distinct a.SerialNumber as serialNumber, b.tenancyId as tenancyId,b.tenancyName as tenancyName, " +
					"a.Account_Id as customerAccountId,h.account_name as customerName, h.mobile_no as customerMobileNo, h.parent_account_id as dealerAccount," +
					" i.serial_number as AssetEntity, i.DriverName as driverName, i.DriverContactNumber as driverContactNo, " +
					" max(j.machineHours), f.eventId, c.group_id as machineGroupId, c.group_name as machineGroupName,f.serviceScheduleId ";

					basicFromQuery =" from AssetCustomGroupMapping w RIGHT OUTER JOIN w.serial_number x  LEFT OUTER JOIN w.group_id c," +
					" TenancyDimensionEntity b, notification_fact_Yearagg a ,AssetEventEntity f, EventTypeEntity g, AccountEntity h," +
					"AssetExtendedDetailsEntity i ,AssetMonitoringFactDataYearAgg j , AccountDimensionEntity u ";

					basicWhereQuery = " where h.status=true and a.Tenancy_Id = b.tenacy_Dimension_Id and x.serial_number = a.SerialNumber and " +
					" a.Account_Id = u.accountDimensionId and u.accountId = h.account_id and b.tenancyId in ( " + tenancyIdStringList +" )" +
					" and f.serialNumber = a.SerialNumber and f.activeStatus = 1 and f.eventSeverity = '" +severity+ "' "+
					" and g.eventTypeId = f.eventTypeId and g.eventTypeName ='" +parameterName+"' "+
					" and a.SerialNumber = i.serial_number " +
					" and a.SerialNumber = j.serialNumber" +
					//DfectId: 1925 @ Suprava
					" and j.year ="+year+"" +
					" and f.serviceScheduleId!=0" +
					" and b.tenacy_Dimension_Id = j.tenancyId" ;
					
					basicSelectQuery = "select distinct a.SerialNumber as serialNumber, b.tenancyId as tenancyId,b.tenancyName as tenancyName, " +
					"a.Account_Id as customerAccountId,h.account_name as customerName, h.mobile_no as customerMobileNo, acc.account_name as dealerAccount," +
					" i.serial_number as AssetEntity, i.DriverName as driverName, i.DriverContactNumber as driverContactNo, " +
					" max(j.machineHours), f.eventId, c.group_id as machineGroupId, c.group_name as machineGroupName,f.serviceScheduleId,acc.mobile_no ";

					basicFromQuery =" from AssetCustomGroupMapping w RIGHT OUTER JOIN w.serial_number x  LEFT OUTER JOIN w.group_id c," +
					" TenancyDimensionEntity b, notification_fact_Yearagg a ,AssetEventEntity f, EventTypeEntity g, AccountEntity h," +
					"AssetExtendedDetailsEntity i ,AssetMonitoringFactDataYearAgg j , AccountDimensionEntity u , AssetOwnerSnapshotEntity aos,AccountEntity acc ";

					basicWhereQuery = " where h.status=true and a.Tenancy_Id = b.tenacy_Dimension_Id and x.serial_number = a.SerialNumber and " +
					" a.Account_Id = u.accountDimensionId and u.accountId = h.account_id and b.tenancyId in ( " + tenancyIdStringList +" )" +
					" and f.serialNumber = a.SerialNumber and f.activeStatus = 1 and f.eventSeverity = '" +severity+ "' "+
					" and g.eventTypeId = f.eventTypeId and g.eventTypeName ='" +parameterName+"' "+
					" and a.SerialNumber = i.serial_number " +
					" and a.SerialNumber = j.serialNumber" +
					" and a.SerialNumber = aos.serialNumber" +
					" and aos.accountType = '"+accountType+"' " +
					//DfectId: 1925 @ Suprava
					//" and j.year ="+year+"" +
					" and f.serviceScheduleId!=0" +					
					" and aos.accountId=acc.account_id " +					
					" and b.tenacy_Dimension_Id = j.tenancyId" +
					" and h.parent_account_id = aos.accountId";


					basicWhereQuery = " where a.Account_Id = u.accountDimensionId and u.accountId = h.account_id and b.tenancyId in ( " + tenancyIdStringList +" )" +
                                              " and f.serialNumber = a.SerialNumber and f.activeStatus = 1 and f.eventSeverity = '" +severity+ "' "+
                                              " and g.eventTypeId = f.eventTypeId and g.eventTypeName ='" +parameterName+"' "+
                                              " and a.SerialNumber = i.serial_number " +
                                              " and a.SerialNumber = j.serialNumber" +
                                              " and c.group_id = w.group_id and w.serial_number = a.SerialNumber" +
                                              " and j.year ="+year+" and f.serviceScheduleId!=0";
					 
					String basicGroupByQuery = " group by a.SerialNumber ";

					if(! (machineGroupIdList==null || machineGroupIdList.isEmpty()) )
					{
						String customAssetGroupStringList = conversionObj.getIntegerListString(machineGroupIdList).toString();
						basicSelectQuery = basicSelectQuery+", c.group_id as machineGroupId, c.group_name as machineGroupName ";
                      basicFromQuery = basicFromQuery + " , CustomAssetGroupEntity c, AssetCustomGroupMapping w ";
						basicWhereQuery = basicWhereQuery + " and c.group_id = w.group_id and c.group_id in ("+customAssetGroupStringList+") and " +
                                  " w.serial_number = a.SerialNumber ";
						basicWhereQuery = basicWhereQuery + "  and c.group_id in ("+customAssetGroupStringList+")";                    
						//                    machineGroup = true;
					}


					if( (! (machineProfileIdList==null || machineProfileIdList.isEmpty()) ) || ( ! (modelIdList==null || modelIdList.isEmpty())) )
					{
						basicFromQuery = basicFromQuery + " , AssetClassDimensionEntity d ";
						basicWhereQuery = basicWhereQuery + " and a.AssetClass_Id = d.assetClassDimensionId";

					}     


					if(! (machineProfileIdList==null || machineProfileIdList.isEmpty()))
					{
						String machineProfileIdStringList = conversionObj.getIntegerListString(machineProfileIdList).toString();

						basicSelectQuery = basicSelectQuery + " ,d.assetGroupId as profileId, d.assetGroupName as profileName ";
						basicWhereQuery = basicWhereQuery + " and d.assetGroupId in ( "+machineProfileIdStringList+") ";
						machineProfile = true;
					}

					if ( ! (modelIdList==null || modelIdList.isEmpty()) ) 
					{
						String modelIdStringList = conversionObj.getIntegerListString(modelIdList).toString();

						basicSelectQuery = basicSelectQuery+ " , d.assetTypeId as modelId, d.assetTypeName as modelName ";
						basicWhereQuery = basicWhereQuery +" and d.assetTypeId in ( "+ modelIdStringList +" )";
						model = true;
					}

					finalQuery =  basicSelectQuery + basicFromQuery + basicWhereQuery + basicGroupByQuery ;


					Query query = session.createQuery(finalQuery);
					Iterator itr = query.list().iterator();
					Object[] result=null,result2=null;
					int serviceScheduleId = 0;
					while(itr.hasNext())
					{
						double totalMachineHours =0.0D;

						result = (Object[]) itr.next();
						DueOverDueReportImpl impObj = new DueOverDueReportImpl();
						String obtainedSerialNum =null;
						//DefectId:20150408 @Suprava To handle Null pointer exception
						if(result[0]!=null){
						obtainedSerialNum = result[0].toString();
						impObj.setSerialNumber(obtainedSerialNum);
						}
						if(result[1]!=null)
						impObj.setTenancyId((Integer)result[1]);
						if(result[2]!=null)
						impObj.setTenancyName(result[2].toString());
						if(result[4]!=null)
							impObj.setCustomerName(result[4].toString());
						if(result[5]!=null)
							impObj.setCustomerContactNumber(result[5].toString());
						if(result[6]!=null)
						{
							AccountEntity dealerAccount = (AccountEntity) result[6];
							impObj.setDealerName(dealerAccount.getAccount_name());
							impObj.setDealerContactNumber(dealerAccount.getMobile_no());
							impObj.setDealerName(result[6].toString());
						}
						AssetEntity assetEntity = (AssetEntity)result[7];
						impObj.setMachineName(assetEntity.getNick_name());
						if(result[8]!=null)
							impObj.setOperatorName(result[8].toString());
						if(result[9]!=null)
							impObj.setOperatorContactNumber(result[9].toString());

						if(result[10]!=null)
						{     
							double machineHours = Double.valueOf(df2.format((Double)result[10]));
							double machineHourString = machineHours;
							totalMachineHours = machineHourString;
							impObj.setTotalMachineHours(totalMachineHours);
						}
						if(result[15]!=null){
							impObj.setDealerContactNumber(result[15].toString());
						}


						EventEntity eventEntity = (EventEntity) result[11];
						int frequency = eventEntity.getFrequency();

						if(machineGroup)
						{

							// null check by smitha on 7th oct 2013
							if(result[12]!=null){
								impObj.setMachineGroupId((Integer)result[12]);
							}
							if(result[13]!=null){
								impObj.setMachineGroupName(result[13].toString());
							}
							if(result[14]!=null){
								impObj.setServiceScheduleId((Integer)result[14]);
								serviceScheduleId = (Integer)result[14];
							}
							//end on 7th oct 2013
						}
						if(machineProfile)
						{
							if(machineGroup)
							{
								impObj.setServiceScheduleId((Integer)result[14]);
								serviceScheduleId = (Integer)result[14];
								impObj.setMachineProfileId((Integer)result[15]);
								impObj.setMachineProfileName(result[16].toString());
								impObj.setMachineProfileId((Integer)result[16]);
								impObj.setMachineProfileName(result[17].toString());
							}
							else
							{                                  
								impObj.setMachineProfileId((Integer)result[12]);
								impObj.setMachineProfileName(result[13].toString());
								impObj.setServiceScheduleId((Integer)result[14]);
								serviceScheduleId = (Integer)result[14];
							}
						}
						if(model)
						{
							if(machineProfile)
							{
								if(machineGroup)
								{
									impObj.setServiceScheduleId((Integer)result[14]);
									serviceScheduleId = (Integer)result[14];
									impObj.setModelId((Integer)result[17]);
									impObj.setModelName(result[18].toString());
									impObj.setModelId((Integer)result[18]);
									impObj.setModelName(result[19].toString());
								}
								else
								{
									impObj.setServiceScheduleId((Integer)result[14]);
									serviceScheduleId = (Integer)result[14];
									impObj.setModelId((Integer)result[15]);
									impObj.setModelName(result[16].toString());
									impObj.setModelId((Integer)result[16]);
									impObj.setModelName(result[17].toString());
								}
							}
							else
							{
								if(machineGroup)
								{
									impObj.setServiceScheduleId((Integer)result[14]);
									serviceScheduleId = (Integer)result[14];
									impObj.setModelId((Integer)result[15]);
									impObj.setModelName(result[16].toString());
									impObj.setModelId((Integer)result[16]);
									impObj.setModelName(result[17].toString());
								}
								else
								{
									impObj.setServiceScheduleId((Integer)result[14]);
									serviceScheduleId = (Integer)result[14];
									impObj.setModelId((Integer)result[15]);
									impObj.setModelName(result[16].toString());
									impObj.setModelId((Integer)result[16]);
									impObj.setModelName(result[17].toString());
								}
							}
						}


						//get planned service date, service name and schedule name
						//Timestamp plannedServiceDate = null;
						double plannedEngineHours =0.0D;
						SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
						String currentDate = dateFormat.format(new Date());
						String plannedService = null;


						Date curDate = dateFormat.parse(currentDate);
						Date plannedDate = null;

						 ServiceDetailsBO2 serviceDetails = new ServiceDetailsBO2();
                      List<AssetServiceScheduleImpl> serviceImpl = serviceDetails.getAssetServiceScheduleBO(obtainedSerialNum);


                        if(! (session.isOpen() ))
                    {
                                        session = HibernateUtil.getSessionFactory().getCurrentSession();
                                        session.getTransaction().begin();
                    }

						 for(int k=0; k<serviceImpl.size(); k++)
                      {
                            if(serviceImpl.get(k).getHoursToNextService()!=null)
                            {
						 plannedService = serviceImpl.get(k).getScheduledDate();
                                  plannedDate = dateFormat.parse(plannedService);

                                   int serviceScheduleId = serviceImpl.get(k).getServiceScheduleId();

						//Keerthi : 03/10/13 : Defect ID : 1393 : taking schedule id from asset event
						// serialNumber in where clause Added by Juhi on 2-december-2013
						Query query3 = session.createQuery("select a.serviceName,a.scheduleName,a.engineHoursSchedule,b.scheduledDate from ServiceScheduleEntity a, AssetServiceScheduleEntity b where a.serviceScheduleId=b.serviceScheduleId and b.serialNumber='"+obtainedSerialNum+"'and b.serviceScheduleId ="+serviceScheduleId);
						Iterator itr3= query3.list().iterator();
						while(itr3.hasNext())
						{
							result2 = (Object[]) itr3.next();
							impObj.setServiceName(result2[0].toString());
							impObj.setScheduleName(result2[1].toString());
							impObj.setPlannedServiceHours(Double.valueOf(df2.format((Long)result2[2])));
							impObj.setPlannedServiceDate(result2[3].toString());


							plannedEngineHours = Double.valueOf(df2.format((Long)result2[2]));
							plannedDate = (Date)result2[3];
						}


						    }
                      }

						if(! (session.isOpen() ))
						{
							session = HibernateUtil.getSessionFactory().getCurrentSession();
							session.getTransaction().begin();
						}

						if(severity=="RED")
						{
							if(totalMachineHours>= plannedEngineHours)
							{
								//  impObj.setDueOrOverDueHours(plannedEngineHours-totalMachineHours);  
								impObj.setDueOrOverDueHours(Double.valueOf(df2.format(plannedEngineHours-totalMachineHours)));
							}

							if ( (curDate!=null) && (plannedDate!=null) && (curDate.after(plannedDate)))
							{ 
								impObj.setDueOrOverDueDays((int)( (curDate.getTime() - plannedDate.getTime()) / (1000 * 60 * 60 * 24) ));
							}
						}

						else if (severity=="YELLOW")
						{
							long DAY_IN_MS = 1000 * 60 * 60 * 24;
							if(totalMachineHours > (plannedEngineHours - frequency))
							{
								//  impObj.setDueOrOverDueHours(plannedEngineHours-totalMachineHours);
								impObj.setDueOrOverDueHours(Double.valueOf(df2.format(plannedEngineHours-totalMachineHours)));
							}

							if(plannedDate!=null)
							{
								if ((curDate.getTime()) > (plannedDate.getTime()- (7 * DAY_IN_MS) ) )
								{
									//impObj.setDueOrOverDueDays(plannedDate.getDate() - curDate.getDate());
									impObj.setDueOrOverDueDays((int)( (plannedDate.getTime() - curDate.getTime()) / (1000 * 60 * 60 * 24) ));
								}                                  
							}
						}


						implList.add(impObj);
					}
				}
				else{
					iLogger.info("no customers for this parent tenancy id ");
					iLogger.info("returning empty impl list !!!");
				}

			}

			    catch(CustomFault e)
    {
          businessError.error("Custom Fault: "+ e.getFaultInfo());
    }

			catch(Exception e1)
			{
				e1.printStackTrace();
				fLogger.fatal("Exception :"+e1);
			}


			finally
			{
				if(session.getTransaction().isActive())
				{
					session.getTransaction().commit();
				}

				if(session.isOpen())
				{
					session.flush();
					session.close();
				}

			}


			return implList;


			}

*/	

    //20151123 - S Suresh new Query changes for Machine Due OverDue 
    // ************************************************************* Machine Due OverDue Report *****************************************************
                    /** This method returns the List of machines under service due/overdue 
                     * @param loginId user LoginId
                    * @param tenancyIdList List of tenancy Id
                    * @param machineGroupIdList List of machine group Id
                    * @param machineProfileIdList List of machine profile Id
                    * @param modelIdList List of modelId
                    * @param isOverdueReport is due/overdue details required
                    * @return
                    * @throws ParseException 
                     */
                    @SuppressWarnings("unused")
                    public List<DueOverDueReportImpl> getDueOverdueMachines(String loginId,  List<Integer> tenancyIdList, List<Integer> machineGroupIdList,
                                                    List<Integer> machineProfileIdList,         List<Integer> modelIdList,boolean isOverdueReport) 

                                                    {            List<DueOverDueReportImpl> implList = new LinkedList<DueOverDueReportImpl>();
                                                    //Logger fatalError = Logger.getLogger("fatalErrorLogger");
                                                    //Logger businessError = Logger.getLogger("businessErrorLogger");
                                                    Logger fLogger = FatalLoggerClass.logger;
                                                    Logger bLogger = BusinessErrorLoggerClass.logger;
                                                    Logger iLogger = InfoLoggerClass.logger;
                                                    Session session = HibernateUtil.getSessionFactory().getCurrentSession();
                                                    session.beginTransaction();

                                                    try
                                                    {
                                                                    DecimalFormat df2 = new DecimalFormat("###.#");
                                                                    String severity;

                                                                    if(isOverdueReport)
                                                                    {
                                                                                    severity ="RED";
                                                                    }
                                                                    else
                                                                                    severity = "YELLOW";

                                                                    String basicFromQuery = null;
                                                                    String basicSelectQuery = null;
                                                                    String basicWhereQuery = null;
                                                                    String finalQuery = null;

                                                                    boolean machineGroup = false;
                                                                    boolean machineProfile = false;
                                                                    boolean model = false;
                                                                    machineGroup=true;
                                                                    //        Keerthi : Defect ID : 1393 :Only customer machines
                                                                    // tenancyIdList=getCustomerTenancyIds(tenancyIdList);
                                                                    iLogger.info("child id list size tenancyIdList: "+tenancyIdList.size());
                                                                    //DefectId:20140910 To Display the customer machine
                                                                    ListToStringConversion conversion = new ListToStringConversion();
                                                                    String loggedInTenancyId = conversion.getIntegerListString(tenancyIdList).toString();
                                                                    List<Integer> subTenancyIdList = new ArrayList<Integer>();
                                                                    /*String tenancyQuery = "select t1.childId,t.parent_tenancy_id FROM  TenancyBridgeEntity  t1 ,TenancyEntity t WHERE t1.parentId in("+loggedInTenancyId+") and t1.childId=t.tenancy_id and t.tenancy_type_id=4";
                                                                    Query queryy = session.createQuery(tenancyQuery);
                                                                    Iterator itr1 = queryy.list().iterator();
                                                                    Object[] resultTenancy = null;
                                                                    while(itr1.hasNext()){    
                                                                                    resultTenancy = (Object[]) itr1.next();
                                                                                    int childId=(Integer) resultTenancy[0];
                                                                                    if (resultTenancy[0] != null) {
                                                                                                    subTenancyIdList.add((Integer) resultTenancy[0]);
                                                                                                    //System.out.println("subTenancyIdList"+subTenancyIdList);
                                                                                    }
                                                                                    //                                                                            infoLogger.info("childId");
                                                                    }              
                                                                    iLogger.info("child id list size from subTenancyIdList: "+subTenancyIdList.size());*/
                                                                    if(tenancyIdList!=null && tenancyIdList.size()>0){
                                                                                    ListToStringConversion conversionObj = new ListToStringConversion();
                                                                                    //String tenancyIdStringList = conversionObj.getIntegerListString(subTenancyIdList).toString();
                                                                                    iLogger.info("tenancyIdStringList  "+ loggedInTenancyId);
                                                                                    Date currentDate1 = new Date();
                                                                                    DateUtil dateUtilObj = new DateUtil();
                                                                                    dateUtilObj  = dateUtilObj. getCurrentDateUtility(currentDate1);
                                                                                    int year = dateUtilObj. getYear();

                                                                                    String parameterName =null;

                                                                                    Properties prop = new Properties();
                                                                                    prop.load(getClass().getClassLoader().getResourceAsStream("remote/wise/resource/properties/configuration.properties"));
                                                                                    parameterName= prop.getProperty("ServiceAlerts");
                                                                                    String accountType ="Customer";                                                                            

                                                                                    /*          
                    basicSelectQuery = "select distinct a.SerialNumber as serialNumber, b.tenancyId as tenancyId,b.tenancyName as tenancyName, " +
                                "a.Account_Id as customerAccountId,h.account_name as customerName, h.mobile_no as customerMobileNo, h.parent_account_id as dealerAccount," +
                                " i.serial_number as AssetEntity, i.DriverName as driverName, i.DriverContactNumber as driverContactNo, " +
                                " j.machineHours, f.eventId, c.group_id as machineGroupId, c.group_name as machineGroupName,f.serviceScheduleId ";*/
                                                                                    /*    
                    basicFromQuery = " from notification_fact_Yearagg a JOIN a.Tenancy_Id b , AssetEventEntity f, EventTypeEntity g, AccountEntity h, " +
                                "AssetExtendedDetailsEntity i ,AssetMonitoringFactDataYearAgg j , AccountDimensionEntity u , CustomAssetGroupEntity c, AssetCustomGroupMapping w " ;
                                                                                    */
                                                                                    //Code change done by Juhi 4-October-2013 for CustomAssetGroupEntity
                                                                                    //DefectId:20150408 @Suprava Max Machine Hour Query change 
                                                                                    /*basicSelectQuery = "select distinct a.SerialNumber as serialNumber, b.tenancyId as tenancyId,b.tenancyName as tenancyName, " +
                                                                                    "a.Account_Id as customerAccountId,h.account_name as customerName, h.mobile_no as customerMobileNo, h.parent_account_id as dealerAccount," +
                                                                                    " i.serial_number as AssetEntity, i.DriverName as driverName, i.DriverContactNumber as driverContactNo, " +
                                                                                    " max(j.machineHours), f.eventId, c.group_id as machineGroupId, c.group_name as machineGroupName,f.serviceScheduleId ";

                                                                                    basicFromQuery =" from AssetCustomGroupMapping w RIGHT OUTER JOIN w.serial_number x  LEFT OUTER JOIN w.group_id c," +
                                                                                    " TenancyDimensionEntity b, notification_fact_Yearagg a ,AssetEventEntity f, EventTypeEntity g, AccountEntity h," +
                                                                                    "AssetExtendedDetailsEntity i ,AssetMonitoringFactDataYearAgg j , AccountDimensionEntity u ";

                                                                                    basicWhereQuery = " where h.status=true and a.Tenancy_Id = b.tenacy_Dimension_Id and x.serial_number = a.SerialNumber and " +
                                                                                    " a.Account_Id = u.accountDimensionId and u.accountId = h.account_id and b.tenancyId in ( " + tenancyIdStringList +" )" +
                                                                                    " and f.serialNumber = a.SerialNumber and f.activeStatus = 1 and f.eventSeverity = '" +severity+ "' "+
                                                                                    " and g.eventTypeId = f.eventTypeId and g.eventTypeName ='" +parameterName+"' "+
                                                                                    " and a.SerialNumber = i.serial_number " +
                                                                                    " and a.SerialNumber = j.serialNumber" +
                                                                                    //DfectId: 1925 @ Suprava
                                                                                    " and j.year ="+year+"" +
                                                                                    " and f.serviceScheduleId!=0" +
                                                                                    " and b.tenacy_Dimension_Id = j.tenancyId" ;*/
                                                                                    
                                                                                    
                                                                                    
                                                                                    basicSelectQuery = "select distinct aos1.serialNumber,td.tenancyId,td.tenancyName" +
                                                                                                                    ",a.account_id,a.account_name,a.mobile_no,pa.account_name,ap.serial_number as AssetEntity,ap.DriverName," +
                                                                                                                    "ap.DriverContactNumber,yearagg.machineHours,svc.lastServiceName,svc.lastServiceDate," +
                                                                                                                    "svc.serviceScheduleName,svc.nextServiceName,svc.nextServiceDate,svc.nextServiceHours,ae.eventId ";
                                                                                    
                                                                                       
                                                                                    basicFromQuery = "from AssetOwnerSnapshotEntity aos,AssetOwnerSnapshotEntity aos1," +
                                                                                                                    "AssetEventEntity ae,AssetMonitoringFactDataYearAgg yearagg,AccountTenancyMapping a_t," +
                                                                                                                    "AccountTenancyMapping a_t1,TenancyDimensionEntity td,ServiceDetailsReportEntity svc," +
                                                                                                                    "AccountEntity a,AccountEntity pa,AssetExtendedDetailsEntity ap ";
                                                                                    
                                                                                    
                                                                                    basicWhereQuery = "where a_t1.tenancy_id in ("+loggedInTenancyId+") and " +
                                                                                                                                                      "aos.accountId = a_t1.account_id and " +
                                                                                                                                                      "aos1.serialNumber = aos.serialNumber and " +
                                                                                                                                                      "aos1.accountType = '"+accountType+"' and " +
                                                                                                                                                      "a.account_id = aos1.accountId and " +
                                                                                                                                                      "pa.account_id = a.parent_account_id and " +
                                                                                                                                                      "ap.serial_number = aos1.serialNumber and " +
                                                                                                                                                      "a_t.account_id = aos1.accountId and " +
                                                                                                                                                      "ae.serialNumber = aos1.serialNumber and " +
                                                                                                                                                      "ae.eventSeverity = '"+severity+"' and " +
                                                                                                                                                      "ae.activeStatus =1 and " +
                                                                                                                                                      "ae.eventTypeId= 1 and " +
                                                                                                                                                      "td.tenancyId = a_t.tenancy_id and " +
                                                                                                                                                      "yearagg.serialNumber = aos1.serialNumber and " +
                                                                                                                                                      "yearagg.tenancyId = td.tenacy_Dimension_Id and " +
                                                                                                                                                      "yearagg.year="+year+" and " +
                                                                                                                                                      "svc.serialNumber = aos1.serialNumber and " +
                                                                                                                                                      "yearagg.machineHours = (select max(yearagg1.machineHours) from " +
                                                                                                                                                      "AssetMonitoringFactDataYearAgg yearagg1 where " +
                                                                                                                                                      "yearagg1.serialNumber = aos1.serialNumber and " +
                                                                                                                                                      "yearagg1.tenancyId = td.tenacy_Dimension_Id and " +
                                                                                                                                                      "yearagg1.year="+year+" ))";

                                                                                    /*basicWhereQuery = " where a.Account_Id = u.accountDimensionId and u.accountId = h.account_id and b.tenancyId in ( " + tenancyIdStringList +" )" +
                                                  " and f.serialNumber = a.SerialNumber and f.activeStatus = 1 and f.eventSeverity = '" +severity+ "' "+
                                                  " and g.eventTypeId = f.eventTypeId and g.eventTypeName ='" +parameterName+"' "+
                                                  " and a.SerialNumber = i.serial_number " +
                                                  " and a.SerialNumber = j.serialNumber" +
                                                  " and c.group_id = w.group_id and w.serial_number = a.SerialNumber" +
                                                  " and j.year ="+year+" and f.serviceScheduleId!=0";
                                                                                    */
                                                                                    //String basicGroupByQuery = " group by a.SerialNumber ";

                                                                                    /*if(! (machineGroupIdList==null || machineGroupIdList.isEmpty()) )
                                                                                    {
                                                                                                    String customAssetGroupStringList = conversionObj.getIntegerListString(machineGroupIdList).toString();
                                                                                                    basicSelectQuery = basicSelectQuery+", c.group_id as machineGroupId, c.group_name as machineGroupName ";
                          basicFromQuery = basicFromQuery + " , CustomAssetGroupEntity c, AssetCustomGroupMapping w ";
                                                                                                    basicWhereQuery = basicWhereQuery + " and c.group_id = w.group_id and c.group_id in ("+customAssetGroupStringList+") and " +
                                      " w.serial_number = a.SerialNumber ";
                                                                                                    basicWhereQuery = basicWhereQuery + "  and c.group_id in ("+customAssetGroupStringList+")";                    
                                                                                                    //                    machineGroup = true;
                                                                                    }
*/

                                                                                    /*if( (! (machineProfileIdList==null || machineProfileIdList.isEmpty()) ) || ( ! (modelIdList==null || modelIdList.isEmpty())) )
                                                                                    {
                                                                                                    basicFromQuery = basicFromQuery + " , AssetClassDimensionEntity d ";
                                                                                                    basicWhereQuery = basicWhereQuery + " and a.AssetClass_Id = d.assetClassDimensionId";

                                                                                    }     


                                                                                    if(! (machineProfileIdList==null || machineProfileIdList.isEmpty()))
                                                                                    {
                                                                                                    String machineProfileIdStringList = conversionObj.getIntegerListString(machineProfileIdList).toString();

                                                                                                    basicSelectQuery = basicSelectQuery + " ,d.assetGroupId as profileId, d.assetGroupName as profileName ";
                                                                                                    basicWhereQuery = basicWhereQuery + " and d.assetGroupId in ( "+machineProfileIdStringList+") ";
                                                                                                    machineProfile = true;
                                                                                    }

                                                                                    if ( ! (modelIdList==null || modelIdList.isEmpty()) ) 
                                                                                    {
                                                                                                    String modelIdStringList = conversionObj.getIntegerListString(modelIdList).toString();

                                                                                                    basicSelectQuery = basicSelectQuery+ " , d.assetTypeId as modelId, d.assetTypeName as modelName ";
                                                                                                    basicWhereQuery = basicWhereQuery +" and d.assetTypeId in ( "+ modelIdStringList +" )";
                                                                                                    model = true;
                                                                                    }*/

                                                                                    finalQuery =  basicSelectQuery + basicFromQuery + basicWhereQuery ;


                                                                                    Query query = session.createQuery(finalQuery);
                                                                                    Iterator itr = query.list().iterator();
                                                                                    Object[] result=null,result2=null;
                                                                                    int serviceScheduleId = 0;
                                                                                    while(itr.hasNext())
                                                                                    {
                                                                                                    double totalMachineHours =0.0D;

                                                                                                    result = (Object[]) itr.next();
                                                                                                    DueOverDueReportImpl impObj = new DueOverDueReportImpl();
                                                                                                    String obtainedSerialNum =null;
                                                                                                    //DefectId:20150408 @Suprava To handle Null pointer exception
                                                                                                    if(result[0]!=null){
                                                                                                    obtainedSerialNum = result[0].toString();
                                                                                                    impObj.setSerialNumber(obtainedSerialNum);
                                                                                                    }
                                                                                                    if(result[1]!=null)
                                                                                                    impObj.setTenancyId((Integer)result[1]);
                                                                                                    if(result[2]!=null)
                                                                                                    impObj.setTenancyName(result[2].toString());
                                                                                                    if(result[4]!=null)
                                                                                                                    impObj.setCustomerName(result[4].toString());
                                                                                                    if(result[5]!=null)
                                                                                                                    impObj.setCustomerContactNumber(result[5].toString());
                                                                                                    if(result[6]!=null)
                                                                                                    {
                                                                                                                    /*AccountEntity dealerAccount = (AccountEntity) result[6];
                                                                                                                    impObj.setDealerName(dealerAccount.getAccount_name());
                                                                                                                    impObj.setDealerContactNumber(dealerAccount.getMobile_no());*/
                                                                                                                    impObj.setDealerName(result[6].toString());
                                                                                                    }
                                                                                                    AssetEntity assetEntity = (AssetEntity)result[7];
                                                                                                    impObj.setMachineName(assetEntity.getNick_name());
                                                                                                    if(result[8]!=null)
                                                                                                                    impObj.setOperatorName(result[8].toString());
                                                                                                    if(result[9]!=null)
                                                                                                                    impObj.setOperatorContactNumber(result[9].toString());

                                                                                                    if(result[10]!=null)
                                                                                                    {     
                                                                                                                    double machineHours = Double.valueOf(df2.format((Double)result[10]));
                                                                                                                    double machineHourString = machineHours;
                                                                                                                    totalMachineHours = machineHourString;
                                                                                                                    impObj.setTotalMachineHours(totalMachineHours);
                                                                                                    }
                                                                                                    EventEntity eventEntity = (EventEntity) result[17];
                                                                                                    int frequency = eventEntity.getFrequency();
                                                                                                    double plannedEngineHours =0.0D;
                                                                                                    SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
                                                                                                    String currentDate = dateFormat.format(new Date());
                                                                                                    String plannedService = null;


                                                                                                    Date curDate = dateFormat.parse(currentDate);
                                                                                                    Date plannedDate = null;

                                                                                                    impObj.setServiceName(result[14].toString());
                                                                                                    impObj.setScheduleName(result[13].toString());
                                                                                                    impObj.setPlannedServiceHours(Double.valueOf(df2.format(Long.parseLong((String)result[16]))));
                                                                                                    impObj.setPlannedServiceDate(result[15].toString());
                                                                                                    
                                                                                                    
                                                                                                    plannedEngineHours = Double.valueOf(df2.format(Long.parseLong((String)result[16])));
                                                                                                    plannedDate = (Date)result[15];
                                                                                                    /*if(result[15]!=null){
                                                                                                                    impObj.setDealerContactNumber(result[15].toString());
                                                                                                    }


                                                                                                    EventEntity eventEntity = (EventEntity) result[11];
                                                                                                    int frequency = eventEntity.getFrequency();

                                                                                                    if(machineGroup)
                                                                                                    {

                                                                                                                    // null check by smitha on 7th oct 2013
                                                                                                                    if(result[12]!=null){
                                                                                                                                    impObj.setMachineGroupId((Integer)result[12]);
                                                                                                                    }
                                                                                                                    if(result[13]!=null){
                                                                                                                                    impObj.setMachineGroupName(result[13].toString());
                                                                                                                    }
                                                                                                                    if(result[14]!=null){
                                                                                                                                    impObj.setServiceScheduleId((Integer)result[14]);
                                                                                                                                    serviceScheduleId = (Integer)result[14];
                                                                                                                    }
                                                                                                                    //end on 7th oct 2013
                                                                                                    }
                                                                                                    if(machineProfile)
                                                                                                    {
                                                                                                                    if(machineGroup)
                                                                                                                    {
                                                                                                                                    impObj.setServiceScheduleId((Integer)result[14]);
                                                                                                                                    serviceScheduleId = (Integer)result[14];
                                                                                                                                    impObj.setMachineProfileId((Integer)result[15]);
                                                                                                                                    impObj.setMachineProfileName(result[16].toString());
                                                                                                                                    impObj.setMachineProfileId((Integer)result[16]);
                                                                                                                                    impObj.setMachineProfileName(result[17].toString());
                                                                                                                    }
                                                                                                                    else
                                                                                                                    {                                  
                                                                                                                                    impObj.setMachineProfileId((Integer)result[12]);
                                                                                                                                    impObj.setMachineProfileName(result[13].toString());
                                                                                                                                    impObj.setServiceScheduleId((Integer)result[14]);
                                                                                                                                    serviceScheduleId = (Integer)result[14];
                                                                                                                    }
                                                                                                    }
                                                                                                    if(model)
                                                                                                    {
                                                                                                                    if(machineProfile)
                                                                                                                    {
                                                                                                                                    if(machineGroup)
                                                                                                                                    {
                                                                                                                                                    impObj.setServiceScheduleId((Integer)result[14]);
                                                                                                                                                    serviceScheduleId = (Integer)result[14];
                                                                                                                                                    impObj.setModelId((Integer)result[17]);
                                                                                                                                                    impObj.setModelName(result[18].toString());
                                                                                                                                                    impObj.setModelId((Integer)result[18]);
                                                                                                                                                    impObj.setModelName(result[19].toString());
                                                                                                                                    }
                                                                                                                                    else
                                                                                                                                    {
                                                                                                                                                    impObj.setServiceScheduleId((Integer)result[14]);
                                                                                                                                                    serviceScheduleId = (Integer)result[14];
                                                                                                                                                    impObj.setModelId((Integer)result[15]);
                                                                                                                                                    impObj.setModelName(result[16].toString());
                                                                                                                                                    impObj.setModelId((Integer)result[16]);
                                                                                                                                                    impObj.setModelName(result[17].toString());
                                                                                                                                    }
                                                                                                                    }
                                                                                                                    else
                                                                                                                    {
                                                                                                                                    if(machineGroup)
                                                                                                                                    {
                                                                                                                                                    impObj.setServiceScheduleId((Integer)result[14]);
                                                                                                                                                    serviceScheduleId = (Integer)result[14];
                                                                                                                                                    impObj.setModelId((Integer)result[15]);
                                                                                                                                                    impObj.setModelName(result[16].toString());
                                                                                                                                                    impObj.setModelId((Integer)result[16]);
                                                                                                                                                    impObj.setModelName(result[17].toString());
                                                                                                                                    }
                                                                                                                                    else
                                                                                                                                    {
                                                                                                                                                    impObj.setServiceScheduleId((Integer)result[14]);
                                                                                                                                                    serviceScheduleId = (Integer)result[14];
                                                                                                                                                    impObj.setModelId((Integer)result[15]);
                                                                                                                                                    impObj.setModelName(result[16].toString());
                                                                                                                                                    impObj.setModelId((Integer)result[16]);
                                                                                                                                                    impObj.setModelName(result[17].toString());
                                                                                                                                    }
                                                                                                                    }
                                                                                                    }


                                                                                                    //get planned service date, service name and schedule name
                                                                                                    //Timestamp plannedServiceDate = null;
                                                                                                    double plannedEngineHours =0.0D;
                                                                                                    SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
                                                                                                    String currentDate = dateFormat.format(new Date());
                                                                                                    String plannedService = null;


                                                                                                    Date curDate = dateFormat.parse(currentDate);
                                                                                                    Date plannedDate = null;

                                                                                                    ServiceDetailsBO2 serviceDetails = new ServiceDetailsBO2();
                          List<AssetServiceScheduleImpl> serviceImpl = serviceDetails.getAssetServiceScheduleBO(obtainedSerialNum);


                            if(! (session.isOpen() ))
                        {
                                            session = HibernateUtil.getSessionFactory().getCurrentSession();
                                            session.getTransaction().begin();
                        }

                                                                                                    for(int k=0; k<serviceImpl.size(); k++)
                          {
                                if(serviceImpl.get(k).getHoursToNextService()!=null)
                                {
                                                                                                    plannedService = serviceImpl.get(k).getScheduledDate();
                                      plannedDate = dateFormat.parse(plannedService);

                                       int serviceScheduleId = serviceImpl.get(k).getServiceScheduleId();

                                                                                                    //Keerthi : 03/10/13 : Defect ID : 1393 : taking schedule id from asset event
                                                                                                    // serialNumber in where clause Added by Juhi on 2-december-2013
                                                                                                    Query query3 = session.createQuery("select a.serviceName,a.scheduleName,a.engineHoursSchedule,b.scheduledDate from ServiceScheduleEntity a, AssetServiceScheduleEntity b where a.serviceScheduleId=b.serviceScheduleId and b.serialNumber='"+obtainedSerialNum+"'and b.serviceScheduleId ="+serviceScheduleId);
                                                                                                    Iterator itr3= query3.list().iterator();
                                                                                                    while(itr3.hasNext())
                                                                                                    {
                                                                                                                    result2 = (Object[]) itr3.next();
                                                                                                                    impObj.setServiceName(result2[0].toString());
                                                                                                                    impObj.setScheduleName(result2[1].toString());
                                                                                                                    impObj.setPlannedServiceHours(Double.valueOf(df2.format((Long)result2[2])));
                                                                                                                    impObj.setPlannedServiceDate(result2[3].toString());


                                                                                                                    plannedEngineHours = Double.valueOf(df2.format((Long)result2[2]));
                                                                                                                    plannedDate = (Date)result2[3];
                                                                                                    }
*/

                                                                                                    /*    }
                          }*/

                                                                                                    /*if(! (session.isOpen() ))
                                                                                                    {
                                                                                                                    session = HibernateUtil.getSessionFactory().getCurrentSession();
                                                                                                                    session.getTransaction().begin();
                                                                                                    }*/

                                                                                                    if(severity=="RED")
                                                                                                    {
                                                                                                                    if(totalMachineHours>= plannedEngineHours)
                                                                                                                    {
                                                                                                                                    //  impObj.setDueOrOverDueHours(plannedEngineHours-totalMachineHours);  
                                                                                                                                    impObj.setDueOrOverDueHours(Double.valueOf(df2.format(plannedEngineHours-totalMachineHours)));
                                                                                                                    }

                                                                                                                    if ( (curDate!=null) && (plannedDate!=null) && (curDate.after(plannedDate)))
                                                                                                                    { 
                                                                                                                                    impObj.setDueOrOverDueDays((int)( (curDate.getTime() - plannedDate.getTime()) / (1000 * 60 * 60 * 24) ));
                                                                                                                    }
                                                                                                    }

                                                                                                    else if (severity=="YELLOW")
                                                                                                    {
                                                                                                                    long DAY_IN_MS = 1000 * 60 * 60 * 24;
                                                                                                                    if(totalMachineHours > (plannedEngineHours - frequency))
                                                                                                                    {
                                                                                                                                    //  impObj.setDueOrOverDueHours(plannedEngineHours-totalMachineHours);
                                                                                                                                    impObj.setDueOrOverDueHours(Double.valueOf(df2.format(plannedEngineHours-totalMachineHours)));
                                                                                                                    }

                                                                                                                    if(plannedDate!=null)
                                                                                                                    {
                                                                                                                                    if ((curDate.getTime()) > (plannedDate.getTime()- (7 * DAY_IN_MS) ) )
                                                                                                                                    {
                                                                                                                                                    //impObj.setDueOrOverDueDays(plannedDate.getDate() - curDate.getDate());
                                                                                                                                                    impObj.setDueOrOverDueDays((int)( (plannedDate.getTime() - curDate.getTime()) / (1000 * 60 * 60 * 24) ));
                                                                                                                                    }                                  
                                                                                                                    }
                                                                                                    }


                                                                                                    implList.add(impObj);
                                                                                    }
                                                                    }
                                                                    else{
                                                                                    iLogger.info("no customers for this parent tenancy id ");
                                                                                    iLogger.info("returning empty impl list !!!");
                                                                    }

                                                    }

                                                    /*    catch(CustomFault e)
        {
              businessError.error("Custom Fault: "+ e.getFaultInfo());
        }*/

                                                    catch(Exception e1)
                                                    {
                                                                    e1.printStackTrace();
                                                                    fLogger.fatal("Exception :"+e1);
                                                    }


                                                    finally
                                                    {
                                                                    if(session.getTransaction().isActive())
                                                                    {
                                                                                    session.getTransaction().commit();
                                                                    }

                                                                    if(session.isOpen())
                                                                    {
                                                                                    session.flush();
                                                                                    session.close();
                                                                    }

                                                    }


                                                    return implList;

                                                    }

      
	
	
	// *******************************************************END of Machine Due OverDue Report *****************************************************
	/**
	 * This method returns the Utilization Details for the given period for the
	 * serialNumberList accessible to login user and for the given filter
	 * criteria
	 * 
	 * @param loginId
	 *            userLoginId
	 * @param tenancyIdList
	 *            list of tenancyId
	 * @param machineGroupIdList
	 *            list of customAssetGroupId
	 * @param machineProfileIdList
	 *            list of assetGroupId
	 * @param modelIdList
	 *            list of modelId
	 * @param period
	 *            period-Either one of the following: Today,Week
	 * @param serialNumList
	 *            List of VINs for which utilization details has to be returned
	 * @return Returns the Utilization Details for the List of machines
	 */
	//Logic for Custom Dates (fromDate,toDate) added by Juhi on 19-August-2013
	public List<UtilizationDetailReportImpl> getUtilizationDetailReportOld
	(
			String loginId, List<Integer> tenancyIdList,
			List<Integer> machineGroupIdList,
			List<Integer> machineProfileIdList, List<Integer> modelIdList,
			String period, List<String> serialNumList) {

		List<UtilizationDetailReportImpl> implRespList = new LinkedList<UtilizationDetailReportImpl>();
		UtilizationDetailReportImpl implObj = null;
		List<String> serialNumberList = new LinkedList<String>();
		String startDateTime=null;
		HashMap<String, HashMap<String, String>> serialNoMap = null;

		//Logger businessError = Logger.getLogger("businessErrorLogger");
		//Logger fatalError = Logger.getLogger("fatalErrorLogger");
		Logger fLogger = FatalLoggerClass.logger;
	
		Session session = HibernateUtil.getSessionFactory().openSession();
		session.beginTransaction();

		try {
			// get List of user accessible serial numbers as per the filter
			// criteria
			if (serialNumList == null) 
			{

				ListToStringConversion conversionObj = new ListToStringConversion();
				Date currentDate = new Date();
				DateUtil dateUtilObj = new DateUtil();
				dateUtilObj  = dateUtilObj. getCurrentDateUtility(currentDate);
				int year = dateUtilObj. getYear();
				tenancyIdList = getSubTenancyIds(tenancyIdList,session); 
				String tenancyIdStringList = conversionObj.getIntegerListString(tenancyIdList).toString();

				String basicQueryString = "select a.serialNumber,a.year from AssetMonitoringFactDataYearAgg a , TenancyDimensionEntity b ";

				String basicWhereQuery = " where a.year = "+year+" "
				+ "  and a.tenancyId = b.tenacy_Dimension_Id and b.tenancyId in ( " + tenancyIdStringList + ") ";

				if ((!(machineProfileIdList == null || machineProfileIdList
						.isEmpty()))
						|| (!(modelIdList == null || modelIdList.isEmpty()))) {
					basicQueryString = basicQueryString
					+ " JOIN a.assetClassDimensionId d ";

					if (!(machineProfileIdList == null || machineProfileIdList
							.isEmpty())) {
						String machineProfileIdStringList = conversionObj
						.getIntegerListString(machineProfileIdList)
						.toString();
						basicWhereQuery = basicWhereQuery
						+ " and d.assetGroupId in ( "
						+ machineProfileIdStringList + " )";
					}

					if (!(modelIdList == null || modelIdList.isEmpty())) {
						String modelIdStringList = conversionObj
						.getIntegerListString(modelIdList).toString();
						basicWhereQuery = basicWhereQuery
						+ " and d.assetTypeId in ( "
						+ modelIdStringList + " )";
					}
				}

				if (!(machineGroupIdList == null || machineGroupIdList
						.isEmpty())) {
					String machineGroupIdStringList = conversionObj
					.getIntegerListString(machineGroupIdList)
					.toString();
					basicQueryString = basicQueryString
					+ " , CustomAssetGroupEntity c, AssetCustomGroupMapping h ";
					basicWhereQuery = basicWhereQuery
					+ " and c.group_id = h.group_id and c.group_id in ("
					+ machineGroupIdStringList + ") and "
					+ " h.serial_number = a.serialNumber ";
				}

				basicQueryString = basicQueryString + basicWhereQuery;
				Query query = session.createQuery(basicQueryString);
				Iterator itr = query.list().iterator();
				Object[] result = null;

				while (itr.hasNext()) 
				{
					result = (Object[]) itr.next();
					serialNumberList.add(result[0].toString());
				}
			}

			else {
				serialNumberList.addAll(serialNumList);
			}

			// --------------------------------get the parameter id of
			// 'EngineON' parameter
			int parameterId = 0; // Parameter Id for EngineON - that would be
			// received on-event
			String parameterName = null;

			Properties prop = new Properties();
			try {
				prop.load(getClass().getClassLoader().getResourceAsStream(
				"remote/wise/resource/properties/configuration.properties"));
			} catch (IOException e) {
				// TODO Austo-generated catch block
				e.printStackTrace();
			}
			parameterName = prop.getProperty("EngineON");

			Query query = session
			.createQuery("select parameterId from MonitoringParameters where parameterName ='"
					+ parameterName + "' order by parameterId desc");
			query.setMaxResults(1);
			Iterator itr = query.list().iterator();

			while (itr.hasNext()) {
				parameterId = (Integer) itr.next();
			}

			// -------------------- Calculate the start date based on input
			// period
			//String startDate = null;
			SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
			SimpleDateFormat timestampFormat = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
			DateFormat dayFormat = new SimpleDateFormat("EEEE");
			if (period.equalsIgnoreCase("Week")) {
				Date currentDate = new Date();
				DateUtil dateUtilObj = new DateUtil();
				dateUtilObj  = dateUtilObj. getCurrentDateUtility(currentDate);
				int week = dateUtilObj. getWeek();				
				Calendar cal = Calendar.getInstance();
				cal.setTime(new Date());
				cal.set(Calendar.WEEK_OF_YEAR, week);
				SimpleDateFormat formatter = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
				cal.set(Calendar.DAY_OF_WEEK, Calendar.SUNDAY);
				startDateTime=formatter.format(cal.getTime());
			}

			// get the timeStamp and the corresponding Machine status
			ListToStringConversion conversionObj = new ListToStringConversion();
			String serialNumberAsStringList = conversionObj.getStringList(
					serialNumberList).toString();

			Query query1 = session
			.createQuery("select b.transactionTime, a.parameterValue, b.serialNumber,"
					+ " c.engineOffHours,c.EngineRunningBand1,c.EngineRunningBand2,c.EngineRunningBand3,c.EngineRunningBand4,c.EngineRunningBand5,c.EngineRunningBand6,c.EngineRunningBand7,c.EngineRunningBand8 "
					+ "  from "
					+ "AssetMonitoringDetailEntity a JOIN a.transactionNumber b, AssetMonitoringFactDataDayAgg c"
					//b=assetMonitoringHeader
					+ " where b.transactionTime >= '"+ startDateTime+ "' and "
					+ " b.serialNumber in ("
					+ serialNumberAsStringList
					+ ") and a.parameterId ="
					+ parameterId
					+ " "
					+ " and b.serialNumber = c. serialNumber and substring(c.timeKey,1,10) = substring(b.transactionTime,1,10) order by b.transactionTime ASC "
					+ " GROUP BY b.serialNumber");
			List resultList = query1.list();
			Iterator itr1 = resultList.iterator();
			double EngineRunningBand1=0.0;
			double EngineRunningBand2=0.0;
			double EngineRunningBand3=0.0;
			double EngineRunningBand4=0.0;
			double EngineRunningBand5=0.0;
			double EngineRunningBand6=0.0;
			double EngineRunningBand7=0.0;
			double EngineRunningBand8=0.0;
			double workingTime=0.0;
			double idleTime=0.0;
			double EngineRunDuration=0.0;
			double machineUtilizationPerct1=0.0;

			String parameterValue = null;
			String transactionDate = null;
			String transactionDay=null;
			String presentStatus=null;
			String pastStatus=null;
			String reqKey=null;
			String serialNumber =null;

			Object[] result1 = null;			
			String previousDate = null;String prevSerialNumber=null;HashMap <String, String> timeStatusMap=null;
			HashMap <String, ArrayList<String>> otherValuesMap=new HashMap<String, ArrayList<String>>();

			List<String> ListOfSerialNumber =new ArrayList<String>();int index=0;
			serialNoMap = new HashMap<String, HashMap<String, String>>();
			while (itr1.hasNext()) {				
				result1 = (Object[]) itr1.next();

				Timestamp transactionTimeStamp = (Timestamp) result1[0];
				transactionDate = dateFormat.format(transactionTimeStamp);
				transactionDay=dayFormat.format(transactionTimeStamp);
				presentStatus = result1[1].toString();
				AssetEntity assetEntity = (AssetEntity) result1[2];
				serialNumber  = assetEntity.getSerial_number().getSerialNumber() ;

				if(!ListOfSerialNumber.contains(serialNumber)){
					ListOfSerialNumber.add(serialNumber);
					pastStatus = null;
				}


				if (!presentStatus.equals(pastStatus)) {

					timeStatusMap = new HashMap<String, String>();
					timeStatusMap.put(timestampFormat.format(transactionTimeStamp), presentStatus);
					if(!serialNoMap.containsKey(serialNumber)){
						serialNoMap.put(serialNumber,timeStatusMap);
					}
					else{

						timeStatusMap = serialNoMap.get(serialNumber);

						timeStatusMap.put(timestampFormat.format(transactionTimeStamp), presentStatus);
						serialNoMap.remove(serialNumber);
						serialNoMap.put(serialNumber, timeStatusMap);
					}

					pastStatus = presentStatus;

				}	
				if(otherValuesMap!=null && !otherValuesMap.containsKey(serialNumber)){

					index =0;
					ArrayList<String> otherValuesList = new ArrayList<String>();
					otherValuesList.add(index++,transactionDate);
					otherValuesList.add(index++,dayFormat.format(transactionTimeStamp));
					serialNumber  = assetEntity.getSerial_number().getSerialNumber() ;
					//implObj.setSerialNumber(assetEntity.getSerial_number().getSerialNumber());
					otherValuesList.add(index++,assetEntity.getNick_name());

					if (result1[3] != null)
					{
						int a = (Integer)result1[3];
						String b = String.valueOf(a);
						otherValuesList.add(index++,b);
					}
					EngineRunningBand1=(Double) result1[4];
					EngineRunningBand2=(Double) result1[5];
					EngineRunningBand3=(Double) result1[6];
					EngineRunningBand4=(Double) result1[7];
					EngineRunningBand5=(Double) result1[8];
					EngineRunningBand6=(Double) result1[9];
					EngineRunningBand7=(Double) result1[10];
					EngineRunningBand8=(Double) result1[11];

					workingTime=(EngineRunningBand3+EngineRunningBand4+EngineRunningBand5+EngineRunningBand6+EngineRunningBand7+EngineRunningBand8);
					idleTime=(EngineRunningBand1+EngineRunningBand2);
					EngineRunDuration=(workingTime+idleTime);
					otherValuesList.add(index++,String.valueOf(EngineRunDuration));
					otherValuesList.add(index++,String.valueOf(workingTime));
					machineUtilizationPerct1=(workingTime/24)*100;
					otherValuesList.add(index++,String.valueOf(machineUtilizationPerct1));
					otherValuesMap.put(serialNumber, otherValuesList);
				}

			}
			ArrayList<String> otherValuesList	=null;
			for (String entry : otherValuesMap.keySet()) {
				otherValuesList = otherValuesMap.get(entry);
				implObj = new UtilizationDetailReportImpl();

				implObj.setSerialNumber(entry);
				implObj.setDateInString(otherValuesList.get(0));
				implObj.setDayInString(otherValuesList.get(1));
				implObj.setNickName(otherValuesList.get(2));
				implObj.setEngineRunDuration(Double.parseDouble(otherValuesList.get(3)));
				implObj.setEngineWorkingDuration(Double.parseDouble(otherValuesList.get(4)));
				implObj.setMachineUtilizationPerct(Double.parseDouble(otherValuesList.get(5)));
				//			implObj.setTimeMachineStatusMap(serialNoMap.get(entry));

				String engineOffDur = otherValuesList.get(3);
				Long engineOffDuration = Long.parseLong(engineOffDur);
				implObj.setEngineOffDuration(engineOffDuration);

				implRespList.add(implObj);
			}			
		}


		catch (Exception e) {
			e.printStackTrace();
			fLogger.fatal("Exception :" + e);

		}


		finally {
			if (session.getTransaction().isActive()) {
				session.getTransaction().commit();
			}

			if (session.isOpen()) {
				session.flush();
				session.close();
			}

		}

		return implRespList;
	}

	// ******************************************* END of Machine Utilization
	// Detail Report *************************************************

	// ********************************************************* Machine
	// Utilization Detail Service *******************************************
	/**
	 * This method returns the details of Machine Utilization over a given
	 * period of time
	 * 
	 * @param loginId
	 *            userLoginId
	 * @param serialNumber
	 *            VIN as input String
	 * @param period
	 *            Period for the machine utilization details has to be returned
	 * @return
	 */
	public List<UtilizationDetailServiceImpl> getUtilizationDetailService(
			String loginId, String serialNumber, String period) {
		List<UtilizationDetailServiceImpl> implResponseList = new LinkedList<UtilizationDetailServiceImpl>();
		Logger fLogger = FatalLoggerClass.logger;
		
		try {
			List<String> serNumList = new LinkedList<String>();
			serNumList.add(serialNumber);

			List<UtilizationDetailReportImpl> implList = getFleetUtilizationDetails(
					loginId, null, null, null, null, period, serNumList);

			for (int i = 0; i < implList.size(); i++) {
				UtilizationDetailServiceImpl response = new UtilizationDetailServiceImpl();
				response.setSerialNumber(implList.get(i).getSerialNumber());
				response.setTimeMachineStatusMap(implList.get(i)
						.getTimeMachineStatusMap());
				response.setTimeDuration(implList.get(i).getDateInString());					

				implResponseList.add(response);
			}
		}	
		catch (Exception e) {
			fLogger.fatal("Exception :" + e);
		}



		return implResponseList;
	}

	/*// ********************************************************* END of Machine
	// Utilization Detail Service *******************************************

	//************************************************** Get the Usage Details of the Machine ****************************************
	*//** DefectID:1383 - Rajani Nagaraju - 20130930 - Query modification to return correct resultset 
	 *  DefectId: - Rajani Nagaraju - 20131011 - CustomDate Implementation 
	 *  DefectId: - 1406 - 20131028 - Rajani Nagaraju - Resolution to MachineGrouping Issue(Machine belonging to a machine Group of other tenancies 
	 *  							should be shown as no Machine Grouping) and ReportTotalsIssue ( To return Report totals at summary from service)
	 *  DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
	 * 	method to get the machine hours report
	 *  @param period,customAssetGroupIdList,machineProfileIdList,tenancyIdList,modelList
	 *  @return list
	 **//*
	//Added custom Dates by Juhi on 13-August-2013
	public List<MachineHoursReportImpl> getMachineHoursReportService(String fromDate,String toDate,String period, 
			List<Integer> customAssetGroupIdList,List<Integer> machineProfileIdList, 
			List<Integer> tenancyIdList,List<Integer> modelList, 
			boolean isGroupingOnAssetGroup, List<Integer> loginTenancyIdList,
			int minThreshold, int maxThreshold)
			{
		//DefectId:20141011 @Suprava New Logic sn
		MachineHoursReportImpl implObj = null;
		List<MachineHoursReportImpl> listImplObj = new LinkedList<MachineHoursReportImpl>();
		Logger fLogger = FatalLoggerClass.logger;
		//Logger bLogger = BusinessErrorLoggerClass.logger;
		Logger iLogger = InfoLoggerClass.logger;
		Session session4 = HibernateUtil.getSessionFactory().openSession();
		session4.beginTransaction();

		try 
		{
			String selectQuery = null;
			String fromQuery = null;
			String whereQuery = null;
			String finalQuery = null;
			String serialNumber=null;
			String status=null;
			String currentStatus=null;
			Timestamp transactionTime2=null;
			long Duration_In_Current_Status=(long)0;
			String Query=null;

			//DefectID:1406 - Rajani Nagaraju - 20131029 - To return Report Totals
			double totalMachineHoursSumm =0.0D;
			double machineHoursSumm=0.0D;
			int totalMachinesOperational=0;
			int totalMachinesDormant=0;
			int totalMachineswithMinThr =0;
			int totalMachineswithMaxThr =0;

			DecimalFormat df2 = new DecimalFormat("###.#");
			SimpleDateFormat dateFrmt = new SimpleDateFormat("yyyy-MM-dd");
			String lastDateInPeriod=null;
			String lastDateInPeriod1=null;
			String startDateInPeriod=null;
			Date startDateInPeriod1=null;
			String startDateInPeriod2=null;
			String fromdateFormatted1=null;
			Date todateFormatted1=null;

			SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
			sdf.setTimeZone(TimeZone.getTimeZone("GMT"));
			String timeStamp = sdf.format(Calendar.getInstance().getTime());
			Timestamp sysDate=Timestamp.valueOf(timeStamp);


			Calendar c = Calendar.getInstance();
			int currentYear = c.get(Calendar.YEAR);
			int year =0;int week = 0; int quarter = 0;int month =0;
			DateUtil dateUtil1 = new DateUtil();
			DateUtil thisDate =dateUtil1.getCurrentDateUtility(new Date());
			DateUtil dateUtil2 = new DateUtil();
			DateUtil prevDate = dateUtil2.getPreviousDateUtility(new Date());
			if(period!=null){
				if (period.equalsIgnoreCase("Week")) 
				{
					week = thisDate.getWeek();
					year = thisDate.getYear();
					//To display the VINs that has not communicated for the given time period 
					//get the Last Day 
					Calendar cal = Calendar.getInstance();
					lastDateInPeriod = dateFrmt.format(cal.getTime());
					lastDateInPeriod1 = lastDateInPeriod +" 23:59:59";
					//System.out.println("lastDateInPeriod ***"+lastDateInPeriod1);
					//get the first day of the week
					cal.set(Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek());
					startDateInPeriod=  dateFrmt.format(cal.getTime());
					startDateInPeriod=startDateInPeriod+" 00:00:00";
					//System.out.println("startDateInPeriod ***"+startDateInPeriod);

				}

				else if (period.equalsIgnoreCase("Last Week")) 
				{
					week =  prevDate.getWeek();
					if(thisDate.getWeek()==1)
					{
						year = prevDate.getYear();
					}
					else
					{
						year = prevDate.getCurrentYear();
					}
					//get the Last Day of Previous Week
					Calendar cal = Calendar.getInstance();
					int i = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
					cal.add(Calendar.DATE, -i - 7);
					cal.add(Calendar.DATE, 6);
					lastDateInPeriod = dateFrmt.format(cal.getTime());
					lastDateInPeriod1 = lastDateInPeriod +" 23:59:59";
					//System.out.println("lastDateInPeriod ***"+lastDateInPeriod1);
					//get the First Day of Previous Week
					cal = Calendar.getInstance();
					int j = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
					cal.add(Calendar.DATE, -j - 7);
					cal.set(Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek());
					startDateInPeriod=  dateFrmt.format(cal.getTime());
					startDateInPeriod=startDateInPeriod+" 00:00:00";
					//System.out.println("startDateInPeriod ***"+startDateInPeriod);
				}

				else if (period.equalsIgnoreCase("Month")) 
				{
					month =  thisDate.getMonth();
					year = thisDate.getYear();
					//get the Last Day 
					Calendar cal = Calendar.getInstance();
					lastDateInPeriod = dateFrmt.format(cal.getTime());
					lastDateInPeriod1 = lastDateInPeriod +" 23:59:59";
					//System.out.println("lastDateInPeriod ***"+lastDateInPeriod1);
					//get the First Day of current Month
					String mon = month+"";
					if(mon.length()<2)
						mon="0"+mon;
					startDateInPeriod=year+"-"+mon+"-"+"01";
					startDateInPeriod=startDateInPeriod+" 00:00:00";
					//System.out.println("startDateInPeriod ***"+startDateInPeriod);
				}

				else if (period.equalsIgnoreCase("Last Month")) 
				{
					month =  prevDate.getMonth();
					if(thisDate.getMonth()==1)
					{
						year = prevDate.getYear();
					}
					else
					{
						year = prevDate.getCurrentYear();
					}
					//Get the Last Day of previous Month
					Calendar cal = Calendar.getInstance();
					cal.set(Calendar.DATE, 1);
					cal.add(Calendar.DAY_OF_MONTH, -1);
					lastDateInPeriod = dateFrmt.format(cal.getTime());
					lastDateInPeriod1 = lastDateInPeriod +" 23:59:59";
					//System.out.println("lastDateInPeriod ***"+lastDateInPeriod1);
					//get the First Day of Previous Month
					String mon = month+"";
					if(mon.length()<2)
						mon="0"+mon;
					startDateInPeriod=year+"-"+mon+"-"+"01";
					startDateInPeriod=startDateInPeriod+" 00:00:00";
					//System.out.println("startDateInPeriod2 ***"+startDateInPeriod);
				}

				else if (period.equalsIgnoreCase("Quarter")) 
				{
					quarter =  thisDate.getQuarter();
					year = thisDate.getYear();
					//get the Last Day 
					Calendar cal = Calendar.getInstance();
					lastDateInPeriod = dateFrmt.format(cal.getTime());
					lastDateInPeriod1 = lastDateInPeriod +" 23:59:59";
					//System.out.println("lastDateInPeriod ***"+lastDateInPeriod1);
					//get the first Date of current quarter
					switch(quarter) 
					{
					case 3 : 
						startDateInPeriod = year+"-07-01";
						startDateInPeriod=startDateInPeriod+" 00:00:00";
						//System.out.println("startDateInPeriod ***"+startDateInPeriod);
						break;
						// return July 01
					case 2 :
						startDateInPeriod = year+"-04-01";
						startDateInPeriod=startDateInPeriod+" 00:00:00";
						//System.out.println("startDateInPeriod ***"+startDateInPeriod);
						break;
						// return April 01
					case 1 :
						startDateInPeriod = year+"-01-01";
						startDateInPeriod=startDateInPeriod+" 00:00:00";
						//System.out.println("startDateInPeriod ***"+startDateInPeriod);
						break;
						// return Jan 01
					case 4 : 
						startDateInPeriod = year+"-10-01";
						startDateInPeriod=startDateInPeriod+" 00:00:00";
						//System.out.println("startDateInPeriod ***"+startDateInPeriod);
						break;
						// return Oct 01
					}
				}

				else if (period.equalsIgnoreCase("Last Quarter")) 
				{
					Calendar cal = Calendar.getInstance();
					quarter = prevDate.getQuarter();
					if(thisDate.getQuarter()==1)
					{
						year = prevDate.getYear();
					}
					else
					{
						year = prevDate.getCurrentYear();
					}
					//get the last day of previous quarter
					switch(quarter) 
					{
					case 3 : 
						lastDateInPeriod = year+"-09-30";
						lastDateInPeriod1 = lastDateInPeriod +" 23:59:59";
						//System.out.println("lastDateInPeriod ***"+lastDateInPeriod1);
						break;
						// return September 30
					case 2 :
						lastDateInPeriod = year+"-06-30";
						lastDateInPeriod1 = lastDateInPeriod +" 23:59:59";
						//System.out.println("lastDateInPeriod ***"+lastDateInPeriod1);
						break;
						// return June 30
					case 1 :
						lastDateInPeriod = year+"-03-31";
						lastDateInPeriod1 = lastDateInPeriod +" 23:59:59";
						//System.out.println("lastDateInPeriod ***"+lastDateInPeriod1);
						break;
						// return March 31
					case 4 : 
						lastDateInPeriod = year+"-12-31";
						lastDateInPeriod1 = lastDateInPeriod +" 23:59:59";
						//System.out.println("lastDateInPeriod ***"+lastDateInPeriod1);
						break;
						// return December 31
					}
					//get the first Date of Previous quarter
					switch(quarter) 
					{
					case 3 : 
						startDateInPeriod = year+"-07-01";
						startDateInPeriod=startDateInPeriod+" 00:00:00";
						//System.out.println("startDateInPeriod2 ***"+startDateInPeriod2);
						break;
						// return July 01
					case 2 :
						startDateInPeriod = year+"-04-01";
						startDateInPeriod=startDateInPeriod+" 00:00:00";
						//System.out.println("startDateInPeriod2 ***"+startDateInPeriod2);
						break;
						// return April 01
					case 1 :
						startDateInPeriod = year+"-01-01";
						startDateInPeriod=startDateInPeriod+" 00:00:00";
						//System.out.println("startDateInPeriod2 ***"+startDateInPeriod2);
						break;
						// return Jan 01
					case 4 : 
						startDateInPeriod = year+"-10-01";
						startDateInPeriod=startDateInPeriod+" 00:00:00";
						//System.out.println("startDateInPeriod ***"+startDateInPeriod);
						break;
						// return Oct 01
					}
				}

				else if (period.equalsIgnoreCase("Year")) 
				{
					year = thisDate.getYear();
					//get the Last Day 
					Calendar cal = Calendar.getInstance();
					lastDateInPeriod = dateFrmt.format(cal.getTime());
					lastDateInPeriod1 = lastDateInPeriod +" 23:59:59";
					//System.out.println("lastDateInPeriod ***"+lastDateInPeriod1);
					//get the First day of current Year
					startDateInPeriod=year+"-01"+"-01";
					startDateInPeriod=startDateInPeriod+" 00:00:00";
					//System.out.println("startDateInPeriod ***"+startDateInPeriod);
				}

				else if (period.equalsIgnoreCase("Last Year")) 
				{
					Calendar cal = Calendar.getInstance();
					year = prevDate.getYear();
					//get the Last day of previous Year
					lastDateInPeriod=year+"-12-31";
					//lastDateInPeriod1 = lastDateInPeriod +" 18:30:00";
					//System.out.println("lastDateInPeriod ***"+lastDateInPeriod1);
					//get the First day of Previous Year 
					startDateInPeriod=year+"-01"+"-01";
					startDateInPeriod=startDateInPeriod+" 00:00:00";
					//System.out.println("startDateInPeriod ***"+startDateInPeriod);
				}
			}
			else
			{
				    Calendar cal = Calendar.getInstance();	
				    startDateInPeriod1 = (Date)dateFrmt.parse(fromDate);
				    startDateInPeriod = dateFrmt.format(startDateInPeriod1);
					cal.setTime(startDateInPeriod1);
					cal.add(Calendar.DAY_OF_YEAR, -1);
					startDateInPeriod2 = dateFrmt.format(cal.getTime());
				    startDateInPeriod = startDateInPeriod + " 00:00:00";
					//System.out.println("startDateInPeriod ***"+startDateInPeriod);
					todateFormatted1 = (Date)dateFrmt.parse(toDate);
					lastDateInPeriod=dateFrmt.format(todateFormatted1);
					lastDateInPeriod=lastDateInPeriod+ " 23:59:59"; 
					//System.out.println("lastDateInPeriod ***"+lastDateInPeriod);
			
			}
			//Get the Status of the machine
			List<Integer> transactionNumberList = new LinkedList<Integer>();
			int transactionNumber =0;
			String serial_num = null;
			Query query3 = session4
			.createQuery("select max(a.transactionNumber),a.serialNumber from AssetMonitoringHeaderEntity a where a.createdTimestamp >= '"+startDateInPeriod+"' and  a.createdTimestamp<='"+lastDateInPeriod+"' group by a.serialNumber");
			Iterator transactionNumItr = query3.list().iterator();
			while (transactionNumItr.hasNext())
			{
				AssetEntity asset =null;
				Object[] result = (Object[]) transactionNumItr.next();
				if (result[0] != null) {
					transactionNumber = (Integer)result[0];
					transactionNumberList.add(transactionNumber);
					//infoLogger.info("transactionNumberList"+transactionNumberList);
				}
			}
			ListToStringConversion conversionObj = new ListToStringConversion();
			String transactionNumberAsStringList = conversionObj.getIntegerListString(transactionNumberList).toString();
			infoLogger.info("transactionNumberAsStringList ***"+transactionNumberAsStringList);
			if(transactionNumberAsStringList==null ||transactionNumberAsStringList.equalsIgnoreCase(null) || transactionNumberAsStringList.isEmpty())
			{
				transactionNumberAsStringList ="0";
			}
			//get the List of tenancies accessible to the logged in user tenancy level
			ListToStringConversion conversionObj = new ListToStringConversion();
			tenancyIdList = getSubTenancyIds(tenancyIdList,session4);
			String tenancyIDList = conversionObj.getIntegerListString(tenancyIdList).toString();
			String loginTenIdListString = conversionObj.getIntegerListString(loginTenancyIdList).toString();
			String groupByQuery =" group by z.serialNumber, ten1.tenancy_id ";
			String orderByQuery = "";
			if(period !=null){

				selectQuery = "select z.machineHours as totalMachineLifeHours," +
				" (z.EngineRunningBand1+z.EngineRunningBand2+z.EngineRunningBand3+z.EngineRunningBand4+z.EngineRunningBand5+z.EngineRunningBand6+z.EngineRunningBand7+z.EngineRunningBand8) as machineHours,"+
				"z.lastEngineRun,z.Address,d.nick_name,c.tenancyName,z.lastReported, d , c.tenancyId, cu.group_id as machineGroupId, " +
				" cu.group_name as machineGroupName, ten.tenancy_name as mgTenancyNname, ten.tenancy_id as mgTenancy ,z.engineStatus as status," +
				//DefectId:20150220 @ Suprava Delaer As a new parameter Added
				"c.parentTenancyName,c.tenancyTypeId ";

				fromQuery =" from AssetCustomGroupMapping h RIGHT OUTER JOIN h.serial_number d  LEFT OUTER JOIN h.group_id cu" +
				" LEFT OUTER JOIN cu.tenancy_id ten ," +
				" TenancyEntity ten1 , " +
				" TenancyDimensionEntity c, " ;
				//DefectId:20141111 @Suprava Read Time out Exception
				//" AssetMonitoringDetailEntity e JOIN e.transactionNumber amh ,";
				//DefectId:20141111 en
				
				whereQuery = " where ten1.tenancy_id = c.tenancyId and " +
				" z.tenancyId = c.tenacy_Dimension_Id and c.tenancyId in ("+ tenancyIDList + " ) " +
				//DefectId:20141111 @Suprava Read Time out Exception
				" and amh.transactionNumber in("+transactionNumberAsStringList+")"+
				" and e.parameterId=18 "+
				" and amh.transactionNumber=e.transactionNumber " +
				" and z.serialNumber = amh.serialNumber " +
				//DefectId:20141111 en
				" and z.serialNumber = d.serial_number " ;
				//DefectId:20150216 @ Suprava Delaer As a new parameter Added
				//" and c.parentTenancyId=ten1.parent_tenancy_id ";

				if (period.equalsIgnoreCase("Week")) 
				{
					week = thisDate.getWeek();
					year = thisDate.getYear();
					fromQuery = fromQuery+" AssetMonitoringFactDataWeekAgg z ";
					whereQuery = whereQuery	+ " and z.timeCount = "+week +" and z.year="+year;

					//To display the VINs that has not communicated for the given time period 
					//get the Last Day 
					Calendar cal = Calendar.getInstance();
					lastDateInPeriod = dateFrmt.format(cal.getTime());
					//get the first day of the week
					cal.set(Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek());
					startDateInPeriod=  dateFrmt.format(cal.getTime());

				}

				else if (period.equalsIgnoreCase("Last Week")) 
				{
					week =  prevDate.getWeek();
					if(thisDate.getWeek()==1)
					{
						year = prevDate.getYear();
					}
					else
					{
						year = prevDate.getCurrentYear();
					}

					fromQuery = fromQuery+" AssetMonitoringFactDataWeekAgg z ";

					whereQuery = whereQuery	+ " and z.timeCount = "+week+" and z.year="+year;

					//To display the VINs that has not communicated for the given time period 
					//get the Last Day of Previous Week
					Calendar cal = Calendar.getInstance();
					int i = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
					cal.add(Calendar.DATE, -i - 7);
					cal.add(Calendar.DATE, 6);
					lastDateInPeriod = dateFrmt.format(cal.getTime());
					//get the First Day of Previous Week
					cal = Calendar.getInstance();
					int j = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
					cal.add(Calendar.DATE, -j - 7);
					cal.set(Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek());
					startDateInPeriod=  dateFrmt.format(cal.getTime());
				}

				else if (period.equalsIgnoreCase("Month")) 
				{
					month =  thisDate.getMonth();
					year = thisDate.getYear();
					fromQuery = fromQuery+" AssetMonitoringFactDataMonthAgg z ";
					whereQuery = whereQuery	+ " and z.timeCount = "	+ month+" and z.year="+year;

					// To display the VINs that has not communicated for the given time period 
					//get the Last Day 
					Calendar cal = Calendar.getInstance();
					lastDateInPeriod = dateFrmt.format(cal.getTime());
					//get the First Day of current Month
					String mon = month+"";
					if(mon.length()<2)
						mon="0"+mon;
					startDateInPeriod=year+"-"+mon+"-"+"01";
				}

				else if (period.equalsIgnoreCase("Last Month")) 
				{
					month =  prevDate.getMonth();
					if(thisDate.getMonth()==1)
					{
						year = prevDate.getYear();
					}
					else
					{
						year = prevDate.getCurrentYear();
					}
					fromQuery = fromQuery+" AssetMonitoringFactDataMonthAgg z ";
					whereQuery = whereQuery	+ " and z.timeCount = "	+ month+" and z.year="+year;

					// To display the VINs that has not communicated for the given time period 
					//Get the Last Day of previous Month
					Calendar cal = Calendar.getInstance();
					cal.set(Calendar.DATE, 1);
					cal.add(Calendar.DAY_OF_MONTH, -1);
					lastDateInPeriod = dateFrmt.format(cal.getTime());
					//get the First Day of Previous Month
					String mon = month+"";
					if(mon.length()<2)
						mon="0"+mon;
					startDateInPeriod=year+"-"+mon+"-"+"01";
				}

				else if (period.equalsIgnoreCase("Quarter")) 
				{
					quarter =  thisDate.getQuarter();
					year = thisDate.getYear();
					fromQuery = fromQuery+" AssetMonitoringFactDataQuarterAgg z ";
					whereQuery = whereQuery	+ " and z.timeCount  = " +quarter+" and z.year="+year;

					// To display the VINs that has not communicated for the given time period 
					//get the Last Day 
					Calendar cal = Calendar.getInstance();
					lastDateInPeriod = dateFrmt.format(cal.getTime());
					//get the first Date of current quarter
					switch(quarter) 
					{
					case 3 : 
						startDateInPeriod = year+"-07-01";
						break;
						// return July 01
					case 2 :
						startDateInPeriod = year+"-04-01";
						break;
						// return April 01
					case 1 :
						startDateInPeriod = year+"-01-01";
						break;
						// return Jan 01
					case 4 : 
						startDateInPeriod = year+"-10-01";
						break;
						// return Oct 01
					}
				}

				else if (period.equalsIgnoreCase("Last Quarter")) 
				{
					quarter = prevDate.getQuarter();
					if(thisDate.getQuarter()==1)
					{
						year = prevDate.getYear();
					}
					else
					{
						year = prevDate.getCurrentYear();
					}
					fromQuery = fromQuery+" AssetMonitoringFactDataQuarterAgg z ";
					whereQuery = whereQuery	+ " and z.timeCount  = " +quarter+" and z.year="+year;

					// To display the VINs that has not communicated for the given time period 
					//get the last day of previous quarter
					switch(quarter) 
					{
					case 3 : 
						lastDateInPeriod = year+"-09-30";
						break;
						// return September 30
					case 2 :
						lastDateInPeriod = year+"-06-30";
						break;
						// return June 30
					case 1 :
						lastDateInPeriod = year+"-03-31";
						break;
						// return March 31
					case 4 : 
						lastDateInPeriod = year+"-12-31";
						break;
						// return December 31
					}
					//get the first Date of Previous quarter
					switch(quarter) 
					{
					case 3 : 
						startDateInPeriod = year+"-07-01";
						break;
						// return July 01
					case 2 :
						startDateInPeriod = year+"-04-01";
						break;
						// return April 01
					case 1 :
						startDateInPeriod = year+"-01-01";
						break;
						// return Jan 01
					case 4 : 
						startDateInPeriod = year+"-10-01";
						break;
						// return Oct 01
					}
				}

				else if (period.equalsIgnoreCase("Year")) 
				{
					year = thisDate.getYear();
					fromQuery = fromQuery+" AssetMonitoringFactDataYearAgg z ";
					whereQuery = whereQuery	+ " and z.year= "+year;

					// To display the VINs that has not communicated for the given time period 
					//get the Last Day 
					Calendar cal = Calendar.getInstance();
					lastDateInPeriod = dateFrmt.format(cal.getTime());
					//get the First day of current Year
					startDateInPeriod=year+"-01"+"-01";
				}

				else if (period.equalsIgnoreCase("Last Year")) 
				{
					year = prevDate.getYear();
					fromQuery = fromQuery+" AssetMonitoringFactDataYearAgg z ";
					whereQuery = whereQuery	+ " and z.year= "+year;

					// To display the VINs that has not communicated for the given time period 
					//get the Last day of previous Year
					lastDateInPeriod=year+"-12-31";
					//get the First day of Previous Year 
					startDateInPeriod=year+"-01"+"-01";
				}

				// Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
				orderByQuery = orderByQuery + " order by d.serial_number, z.lastReported desc ";

			}
			else{

				DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
				String fromdateFormatted=null;
				String todateFormatted=null;

				try 
				{	
					fromdateFormatted= dateFormat.format(dateFormat.parse(fromDate));	
					todateFormatted = dateFormat.format(dateFormat.parse(toDate));	
				} 

				catch (ParseException e) 
				{
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				if(fromdateFormatted==null || todateFormatted==null)
				{
					throw new CustomFault("Unparsable Date input for Custom dates");
				}

				// To display the VINs that has not communicated for the given time period 
				startDateInPeriod = fromdateFormatted;
				lastDateInPeriod = todateFormatted;

				groupByQuery =" group by z.serialNumber, ten1.tenancy_id ";

				selectQuery = "select z.machineHours as totalMachineLifeHours," +
				" sum(u.EngineRunningBand1+u.EngineRunningBand2+u.EngineRunningBand3+u.EngineRunningBand4+u.EngineRunningBand5+u.EngineRunningBand6+u.EngineRunningBand7+u.EngineRunningBand8) as machineHours,"+
				"z.lastEngineRun,z.Address,d.nick_name,c.tenancyName,z.lastReported, d , c.tenancyId, cu.group_id as machineGroupId, " +
				" cu.group_name as machineGroupName, ten.tenancy_name as mgTenancyName, ten.tenancy_id as mgTenancy, z.engineStatus as status," +
				//DefectId:20150216 @ Suprava Delaer As a new parameter Added
				"c.parentTenancyName,c.tenancyTypeId ";

				fromQuery =" from AssetCustomGroupMapping h RIGHT OUTER JOIN h.serial_number d  LEFT OUTER JOIN h.group_id cu" +
				" LEFT OUTER JOIN cu.tenancy_id ten , TenancyEntity ten1, " +
				" TenancyDimensionEntity c, AssetMonitoringFactDataDayAgg z, AssetMonitoringFactDataDayAgg u ";
				//DefectId:20141111 @Suprava Read Time out Exception
			//	" AssetMonitoringDetailEntity e JOIN e.transactionNumber amh ";
				//DefectId:20141111 @Suprava Read Time out Exception

				whereQuery = " where ten1.tenancy_id = c.tenancyId and " +
				" z.tenancyId = c.tenacy_Dimension_Id and c.tenancyId in ("+ tenancyIDList + " ) " +
				" and z.serialNumber = d.serial_number " +
				//	" and d.primary_owner_id = v.account_id " +
				" and z.serialNumber = u.serialNumber " +
				" and u.tenancyId=z.tenancyId " +
				" and z.timeKey = (select max(o.timeKey) from AssetMonitoringFactDataDayAgg o, TenancyDimensionEntity yt" +
				" where o.serialNumber=z.serialNumber and o.tenancyId = yt.tenacy_Dimension_Id and yt.tenancyId in ("+ tenancyIDList + " ) " +
				" and o.timeKey >='"+fromdateFormatted+"' and o.timeKey <= '"+todateFormatted+"')" +
				//DefectId:20141111 @Suprava Read Time out Exception
				" and amh.transactionNumber in("+transactionNumberAsStringList+")"+
				" and e.parameterId=18 "+
				" and amh.transactionNumber=e.transactionNumber " +
				" and z.serialNumber = amh.serialNumber " +
				//DefectId:20141111
				" and u.timeKey between '"+fromdateFormatted+"' and '"+todateFormatted+"'" ;
				//DefectId:20150216 @ Suprava Delaer As a new parameter Added
				//" and c.parentTenancyId=ten1.parent_tenancy_id ";

				groupByQuery = groupByQuery +" , cu.group_id ";

				// To take the latest/Last reported row from factAgg tables
				orderByQuery = orderByQuery +  " order by d.serial_number , z.lastReported desc";


			}
			if (!(customAssetGroupIdList == null || customAssetGroupIdList.isEmpty())) 
			{
				String customAssetGroupStringList = conversionObj.getIntegerListString(customAssetGroupIdList).toString();
				whereQuery = whereQuery+ " and cu.group_id in ("+ customAssetGroupStringList + ")";
			}

			if ((!(machineProfileIdList == null || machineProfileIdList.isEmpty()))	|| (!(modelList == null || modelList.isEmpty()))) 
			{
				fromQuery = fromQuery+ " , AssetClassDimensionEntity b ";
				whereQuery = whereQuery	+ " and z.assetClassDimensionId = b.assetClassDimensionId";
			}

			if (!(machineProfileIdList == null || machineProfileIdList.isEmpty())) 
			{
				String machineProfileIdStringList = conversionObj.getIntegerListString(machineProfileIdList).toString();
				whereQuery = whereQuery + " and b.assetGroupId in ( "+ machineProfileIdStringList + ") ";

			}			

			if (!((modelList == null) || (modelList.isEmpty()))) 
			{
				String modelIdListStringList = conversionObj.getIntegerListString(modelList).toString();
				whereQuery = whereQuery + " and b.assetTypeId in ( "+ modelIdListStringList + " )";

			}

			finalQuery = selectQuery + fromQuery + whereQuery + groupByQuery + orderByQuery ;

			Query qury = session4.createQuery(finalQuery);
			Iterator rr = qury.list().iterator();
			Object[] result = null;

			List<String> serialNumberList = new LinkedList<String>();
			while(rr.hasNext()){

				implObj = new MachineHoursReportImpl();
				serialNumber=null;

				result = (Object[]) rr.next();

				AssetEntity asset =null;
				TenancyEntity tenancyEntity =null;
				if(result[7]!=null)
				{					
					asset = (AssetEntity)result[7];
					serialNumber = asset.getSerial_number().getSerialNumber();

				}

				if(serialNumberList.contains(serialNumber))
				{
					continue;
				}
				implObj.setSerialNumber(asset.getSerial_number().getSerialNumber());


				if(result[0]!=null)
				{
					implObj.setTotalMachineHours(Double.valueOf(df2.format((Double) result[0])));
				}				

				if(result[1]!=null)
				{
					implObj.setMachineHours(Double.valueOf(df2.format((Double) result[1])));			
				}

				if(result[2]!=null)
				{
					implObj.setLastEngineRun((Timestamp) result[2]);
				}	

				if(result[3]!=null)
				{
					implObj.setLocation(result[3].toString());		
				}

				if(result[4]!=null)
				{
					implObj.setMachineName(result[4].toString());
				}

				if(result[5]!=null)
				{
					implObj.setTenancyName(result[5].toString());
				}	

				if(result[6]!=null)
				{
					implObj.setLastReported((Timestamp) result[6]);
				}	


				implObj.setTenancyId((Integer)result[8]);

				if(asset!=null)
				{
					if(asset.getProductId()!=null && asset.getProductId().getAssetGroupId()!=null)
					{
						implObj.setMachineProfileId(asset.getProductId().getAssetGroupId().getAsset_group_id());
						implObj.setMachineProfileName(asset.getProductId().getAssetGroupId().getAsset_group_name());
					}

					if(asset.getProductId()!=null && asset.getProductId().getAssetTypeId()!=null)
					{
						implObj.setModelId(asset.getProductId().getAssetTypeId().getAsset_type_id());
						implObj.setModelName(asset.getProductId().getAssetTypeId().getAsset_type_name());
					}


				}
				if(result[13]!=null)
				{
					implObj.setStatus((String)result[13]);
					status=(String)result[13];
					if(status.equalsIgnoreCase("0"))
						{
							totalMachinesDormant=totalMachinesDormant+1;
						}
						else
						{
							totalMachinesOperational=totalMachinesOperational+1;
						}
				}

				//DefectId:20150220 @ Suprava Delaer As a new parameter Added
				if(result[15]!=null)
						{
							int tenancyTypeId =(Integer) result[15];
							//If the Machine is with customer Get the parentTeancyId
							if(tenancyTypeId==4)
							{
								//String partentTenancyName =(String)result[14];
								implObj.setDealerName(result[14].toString());
							}
							//If the Machine is with Dealer
							else if(tenancyTypeId==3) 
							{
								if(result[5]!=null)
								{
								//String Dealername =(String)result[5];
								implObj.setDealerName(result[5].toString());
							}
							}
							else
							{
								implObj.setDealerName("No Dealer Tagging");
							}
						
						}
				//DefectID:1406 - Rajani Nagaraju - 20131029 - To return Report Totals
				if(!(serialNumberList.contains(serialNumber)))
				{
					totalMachineHoursSumm = totalMachineHoursSumm+(Double.valueOf(df2.format((Double) result[0])));
					machineHoursSumm = machineHoursSumm+(Double.valueOf(df2.format((Double) result[1])));
					//For Machine Activity Report 1.Machines Working less than min threshold and 2. Machines working more than Max. threshold
					if(minThreshold>=0 && maxThreshold>=0)
					{
						double machineHoursInPeriod = (Double) result[1];
						int machineHrInPeriod = (int)machineHoursInPeriod;
						if(machineHrInPeriod < minThreshold)
							totalMachineswithMinThr= totalMachineswithMinThr+1;
						else if (machineHrInPeriod > maxThreshold)
							totalMachineswithMaxThr= totalMachineswithMaxThr+1;

					}
				}

				//DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
				//Get the List of MachineGroup under the Login Tenancy to which the machine belongs to 
				if(isGroupingOnAssetGroup)
				{
					Query mgQuery=null;
					if (!(customAssetGroupIdList == null || customAssetGroupIdList.isEmpty())) 
					{
						String customAssetGroupStringList = conversionObj.getIntegerListString(customAssetGroupIdList).toString();
						mgQuery = session4.createQuery(" select a from AssetCustomGroupMapping a, CustomAssetGroupEntity b " +
								//Smitha:DefectID:20131220...to get the VIN's belonging to the machine groups under that tenancy ID
								"where serial_number='"+serialNumber+"' and a.group_id=b.group_id and b.level=2 and b.active_status=1 and b.tenancy_id in ("+loginTenIdListString+")" +
								" and b.group_id in ("+customAssetGroupStringList+")");
					}

					else
					{
						mgQuery = session4.createQuery(" select a from AssetCustomGroupMapping a, CustomAssetGroupEntity b " +
								//Smitha:DefectID:20131220...to get the VIN's belonging to the machine groups under that tenancy ID
								"where serial_number='"+serialNumber+"' and a.group_id=b.group_id and b.level=2 and b.active_status=1 and b.tenancy_id in ("+loginTenIdListString+")");
					}
					Iterator mgItr = mgQuery.list().iterator();
					int firstIteration =0;
					while(mgItr.hasNext())
					{
						AssetCustomGroupMapping mgVinMapping = (AssetCustomGroupMapping)mgItr.next();
						if(firstIteration==0)
						{
							firstIteration=1;
							implObj.setMachineGroupId(mgVinMapping.getGroup_id().getGroup_id());
							implObj.setMachineGroupName(mgVinMapping.getGroup_id().getGroup_name());
							listImplObj.add(implObj);
						}
						else
						{
							MachineHoursReportImpl newimplObj = new MachineHoursReportImpl();
							newimplObj.setSerialNumber(serialNumber);
							newimplObj.setTotalMachineHours(Double.valueOf(df2.format(implObj.getTotalMachineHours())));
							newimplObj.setMachineHours(Double.valueOf(df2.format(implObj.getMachineHours())));	
							newimplObj.setLastEngineRun(implObj.getLastEngineRun());
							newimplObj.setLocation(implObj.getLocation());		
							newimplObj.setMachineName(implObj.getMachineName());
							newimplObj.setTenancyName(implObj.getTenancyName());
							newimplObj.setLastReported(implObj.getLastReported());
							newimplObj.setTenancyId(implObj.getTenancyId());
							newimplObj.setMachineGroupId(mgVinMapping.getGroup_id().getGroup_id());
							newimplObj.setMachineGroupName(mgVinMapping.getGroup_id().getGroup_name());
							newimplObj.setMachineProfileId(implObj.getMachineProfileId());
							newimplObj.setMachineProfileName(implObj.getMachineProfileName());
							newimplObj.setModelId(implObj.getModelId());
							newimplObj.setModelName(implObj.getModelName());
							newimplObj.setStatus(implObj.getStatus());
							newimplObj.setDurationInCurrentStatus(implObj.getDurationInCurrentStatus());
							newimplObj.setDealerName(implObj.getDealerName());
							listImplObj.add(newimplObj);
						}
					}

					if(firstIteration==0)
					{
						listImplObj.add(implObj);
					}
				}

				else
				{
					listImplObj.add(implObj);
				}


				serialNumberList.add(serialNumber);

			}

			//-------------------------------------------------------------------------------------------------------------------
			//DefectId: DF20131018 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period 
			Query ownerListQuery = session4.createQuery(" select distinct c.serialNumber " +
					" from TenancyBridgeEntity a, AccountTenancyMapping b, AssetAccountMapping c " +
					" where a.childId= b.tenancy_id " +
					" and b.account_id= c.accountId " +
					" and a.parentId in ("+tenancyIDList+") and" +
					" ( (c.ownershipStartDate between '"+startDateInPeriod+"' and '"+lastDateInPeriod+"') OR " +
					"   (c.ownershipStartDate = ( select max(y.ownershipStartDate) from AssetAccountMapping y " +
					" where y.serialNumber= c.serialNumber" +
					" and y.ownershipStartDate <='"+startDateInPeriod+"')" +
					"    )" +
			" )");
			Iterator ownerListItr = ownerListQuery.list().iterator();
			List<String> actualOwnerVINList = new LinkedList<String>();
			while(ownerListItr.hasNext())
			{
				AssetEntity assetList = (AssetEntity)ownerListItr.next();
				actualOwnerVINList.add(assetList.getSerial_number().getSerialNumber());
			}

			//Get only the List of VINs which has not communicated for the Given period
			actualOwnerVINList.removeAll(serialNumberList);
			String actualOwnerVinListString = conversionObj.getStringList(actualOwnerVINList).toString();
			//DefectId:20141111 @Suprava Read Time out Changes
			List<Integer> transactionNumberList1 = new LinkedList<Integer>();
			int transactionNumber1 =0;
			String serial_num1 = null;
			Query query4 = session4
			.createQuery("select max(a.transactionNumber),a.serialNumber from AssetMonitoringHeaderEntity a where a.serialNumber in("+actualOwnerVinListString+") and a.createdTimestamp <= '"+startDateInPeriod2+"' group by a.serialNumber");
			Iterator transactionNumItr1 = query4.list().iterator();
			while (transactionNumItr1.hasNext())
			{
				AssetEntity asset =null;
				//System.out.println("Inside 2nd while");
				Object[] result1 = (Object[]) transactionNumItr1.next();
				if (result1[0] != null) {
					transactionNumber1 = (Integer)result1[0];
					transactionNumberList1.add(transactionNumber1);
					//infoLogger.info("transactionNumberList"+transactionNumberList);
				}
			}
			String transactionNumberAsStringList1 = conversionObj.getIntegerListString(transactionNumberList1).toString();
			//DefectId:20141111 en
			//groupByQuery =" group by z.serialNumber ";

			// To take the latest/Last reported row from factAgg tables
			groupByQuery =" group by z.serialNumber, ten1.tenancy_id ";
			orderByQuery = " order by d.serial_number, z.lastReported desc ";

			selectQuery = " select z.machineHours as totalMachineLifeHours, ten.tenancy_name as mgTenancyName ," +
			" z.lastEngineRun,z.Address,d.nick_name,c.tenancyName,z.lastReported,  " +
			" d , c.tenancyId, cu.group_id as machineGroupId," +
			" cu.group_name as machineGroupName, ten.tenancy_id as mgTenancy," +
			//DefectId:20150216 @ Suprava Delaer As a new parameter Added
			"c.parentTenancyName,c.tenancyTypeId ";

			fromQuery = " from AssetCustomGroupMapping h RIGHT OUTER JOIN h.serial_number d  LEFT OUTER JOIN h.group_id cu " +
			" LEFT OUTER JOIN cu.tenancy_id ten , TenancyEntity ten1," +
			" TenancyDimensionEntity c, AssetMonitoringFactDataDayAgg z " ;
			//DefectId:20141111 @Suprava Read Time out Exception
			//" AssetMonitoringDetailEntity e JOIN e.transactionNumber amh ";
			//DefectId:20141111

			whereQuery = " where ten1.tenancy_id = c.tenancyId and " +
			" z.tenancyId = c.tenacy_Dimension_Id and z.serialNumber = d.serial_number " +
			" and z.serialNumber in ("+actualOwnerVinListString+") " +
			" and z.timeKey = ( select max(p.timeKey) from AssetMonitoringFactDataDayAgg p where p.serialNumber = z.serialNumber " +
			//DefectId:20141111 @Suprava Read Time out Exception
			" and amh.transactionNumber in("+transactionNumberAsStringList1+")"+
			" and e.parameterId=18 "+
			" and amh.transactionNumber=e.transactionNumber " +
			" and z.serialNumber = amh.serialNumber " +
			//DefectId:20141111
			" and p.timeKey <= '"+startDateInPeriod+"' )";
			//DefectId:20150216 @ Suprava Delaer As a new parameter Added
			//" and c.parentTenancyId=ten1.parent_tenancy_id ";


			if (!(customAssetGroupIdList == null || customAssetGroupIdList.isEmpty())) 
			{
				String customAssetGroupStringList = conversionObj.getIntegerListString(customAssetGroupIdList).toString();
				whereQuery = whereQuery+ " and cu.group_id in ("+ customAssetGroupStringList + ")";
			}

			if ((!(machineProfileIdList == null || machineProfileIdList.isEmpty()))	|| (!(modelList == null || modelList.isEmpty()))) 
			{
				fromQuery = fromQuery+ " , AssetClassDimensionEntity b ";
				whereQuery = whereQuery	+ " and z.assetClassDimensionId = b.assetClassDimensionId";
			}


			if (!(machineProfileIdList == null || machineProfileIdList.isEmpty())) 
			{
				String machineProfileIdStringList = conversionObj.getIntegerListString(machineProfileIdList).toString();
				whereQuery = whereQuery + " and b.assetGroupId in ( "+ machineProfileIdStringList + ") ";

			}			

			if (!((modelList == null) || (modelList.isEmpty()))) 
			{
				String modelIdListStringList = conversionObj.getIntegerListString(modelList).toString();
				whereQuery = whereQuery + " and b.assetTypeId in ( "+ modelIdListStringList + " )";

			}

			//DefectID:1406 - Rajani Nagaraju - 20131028 - MachineGrouping issue
			if(! (actualOwnerVINList==null || actualOwnerVINList.isEmpty()))
			{

				//finalQuery = selectQuery + fromQuery+ whereQuery + groupByQuery + " order by d.serial_number, ten.tenancy_id ";;
				finalQuery = selectQuery + fromQuery+ whereQuery + groupByQuery + orderByQuery;
				Iterator vinListItr = session4.createQuery(finalQuery).list().iterator();
				result =null;
				serialNumberList = new LinkedList<String>();

				while(vinListItr.hasNext())
				{
					implObj = new MachineHoursReportImpl();
					serialNumber=null;
					result = (Object[]) vinListItr.next();

					AssetEntity asset =null;
					TenancyEntity tenancyEntity =null;
					if(result[7]!=null)
					{					
						asset = (AssetEntity)result[7];
						serialNumber = asset.getSerial_number().getSerialNumber();
					}

					if(serialNumberList.contains(serialNumber))
					{
						continue;
					}
					implObj.setSerialNumber(asset.getSerial_number().getSerialNumber());

					if(result[0]!=null)
					{
						implObj.setTotalMachineHours(Double.valueOf(df2.format((Double)result[0])));
					}

					if(result[2]!=null)
					{
						implObj.setLastEngineRun((Timestamp) result[2]);
					}	

					if(result[3]!=null)
					{
						implObj.setLocation(result[3].toString());		
					}

					if(result[4]!=null)
					{
						implObj.setMachineName(result[4].toString());
					}

					if(result[5]!=null)
					{
						implObj.setTenancyName(result[5].toString());
					}	

					if(result[6]!=null)
					{
						implObj.setLastReported((Timestamp) result[6]);
					}	


					implObj.setTenancyId((Integer)result[8]);


					if(asset!=null)
					{
						if(asset.getProductId()!=null && asset.getProductId().getAssetGroupId()!=null)
						{
							implObj.setMachineProfileId(asset.getProductId().getAssetGroupId().getAsset_group_id());
							implObj.setMachineProfileName(asset.getProductId().getAssetGroupId().getAsset_group_name());
						}

						if(asset.getProductId()!=null && asset.getProductId().getAssetTypeId()!=null)
						{
							implObj.setModelId(asset.getProductId().getAssetTypeId().getAsset_type_id());
							implObj.setModelName(asset.getProductId().getAssetTypeId().getAsset_type_name());
						}


					}
					implObj.setStatus("NA");
					
					//DefectId:20150220 @ Suprava Delaer As a new parameter Added
					if(result[13]!=null)
							{
								int tenancyTypeId =(Integer) result[13];
								//If the Machine is with customer Get the parentTeancyId
								if(tenancyTypeId==4)
								{
								//	String parentTeancyname =(String)result[12];
									implObj.setDealerName(result[12].toString());
								}
								//If the Machine is with Dealer
								else if(tenancyTypeId==3) 
								{
									if(result[5]!=null)
									{
									//String Dealername =(String)result[5];
									implObj.setDealerName(result[5].toString());
								}
								}
								else
								{
									implObj.setDealerName("No Dealer Tagging");
								}
							
							}
							
					//DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
					//TenancyEntity primaryOwnerTenancy = (TenancyEntity)result[1];
						int primaryOwnerAcc = asset.getPrimary_owner_id();
					int primaryOwnerTenancy=0;
					Query primaryTenQuery = session4.createQuery(" from AccountTenancyMapping where account_id='"+primaryOwnerAcc+"'");
					Iterator primaryTenItr = primaryTenQuery.list().iterator();
					while(primaryTenItr.hasNext())
					{
						AccountTenancyMapping accountTen = (AccountTenancyMapping)primaryTenItr.next();
						primaryOwnerTenancy = accountTen.getTenancy_id().getTenancy_id();
					}
					 
					//DefectID:1406 - Rajani Nagaraju - 20131029 - To return Report Totals

					if(result[12]!=null)
					{
						implObj.setStatus(result[12].toString());
					}

					//DefectID:1406 - Rajani Nagaraju - 20131029 - To return Report Totals
					if(!(serialNumberList.contains(serialNumber)))
					{
						totalMachineHoursSumm = totalMachineHoursSumm+(Double.valueOf(df2.format((Double) result[0])));
						//machineHoursSumm cannot be added since the machine has not communicated in the given period
						//machineHoursSumm = machineHoursSumm+(Double) result[1];

						//DefectId: 20131220 - Rajani Nagaraju - To sum the yellow threshold even for the machines that has not communicated
						//For Machine Activity Report 1.Machines Working less than min threshold and 2. Machines working more than Max. threshold
						if(minThreshold>=0 && maxThreshold>=0)
						{
							int machineHrInPeriod = 0;
							if(machineHrInPeriod < minThreshold)
								totalMachineswithMinThr= totalMachineswithMinThr+1;
							else if (machineHrInPeriod > maxThreshold)
								totalMachineswithMaxThr= totalMachineswithMaxThr+1;

						}
					}

					//Get the List of MachineGroup under the Login Tenancy to which the machine belongs to 
					//DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
					if(isGroupingOnAssetGroup)
					{

						Query mgQuery=null;
						if (!(customAssetGroupIdList == null || customAssetGroupIdList.isEmpty())) 
						{
							String customAssetGroupStringList = conversionObj.getIntegerListString(customAssetGroupIdList).toString();
							mgQuery = session4.createQuery(" select a from AssetCustomGroupMapping a, CustomAssetGroupEntity b " +
									//Smitha:DefectID:20131220...to get the VIN's belonging to the machine groups under that tenancy ID
									"where serial_number='"+serialNumber+"' and a.group_id=b.group_id and b.level=2 and b.active_status=1 and b.tenancy_id in ("+loginTenIdListString+")" +
									" and b.group_id in ("+customAssetGroupStringList+")");
						}
						else
						{
							mgQuery = session4.createQuery(" select a from AssetCustomGroupMapping a, CustomAssetGroupEntity b " +
									//Smitha:DefectID:20131220...to get the VIN's belonging to the machine groups under that tenancy ID
									"where serial_number='"+serialNumber+"' and a.group_id=b.group_id and b.level=2 and b.active_status=1 and b.tenancy_id in ("+loginTenIdListString+")");
						}
						Iterator mgItr = mgQuery.list().iterator();
						int firstIteration =0;
						while(mgItr.hasNext())
						{
							AssetCustomGroupMapping mgVinMapping = (AssetCustomGroupMapping)mgItr.next();
							if(firstIteration==0)
							{
								firstIteration=1;
								implObj.setMachineGroupId(mgVinMapping.getGroup_id().getGroup_id());
								implObj.setMachineGroupName(mgVinMapping.getGroup_id().getGroup_name());
								listImplObj.add(implObj);
							}
							else
							{
								MachineHoursReportImpl newimplObj = new MachineHoursReportImpl();
								newimplObj.setSerialNumber(serialNumber);
								newimplObj.setTotalMachineHours(implObj.getTotalMachineHours());
								newimplObj.setMachineHours(implObj.getMachineHours());	
								newimplObj.setLastEngineRun(implObj.getLastEngineRun());
								newimplObj.setLocation(implObj.getLocation());		
								newimplObj.setMachineName(implObj.getMachineName());
								newimplObj.setTenancyName(implObj.getTenancyName());
								newimplObj.setLastReported(implObj.getLastReported());
								newimplObj.setTenancyId(implObj.getTenancyId());
								newimplObj.setMachineGroupId(mgVinMapping.getGroup_id().getGroup_id());
								newimplObj.setMachineGroupName(mgVinMapping.getGroup_id().getGroup_name());
								newimplObj.setMachineProfileId(implObj.getMachineProfileId());
								newimplObj.setMachineProfileName(implObj.getMachineProfileName());
								newimplObj.setModelId(implObj.getModelId());
								newimplObj.setModelName(implObj.getModelName());
								newimplObj.setStatus(implObj.getStatus());
								newimplObj.setDurationInCurrentStatus(implObj.getDurationInCurrentStatus());
								newimplObj.setDealerName(implObj.getDealerName());
								listImplObj.add(newimplObj);
							}
						}

						if(firstIteration==0)
						{
							listImplObj.add(implObj);
						}
					}

					else
					{
						listImplObj.add(implObj);
					}

				}
				serialNumberList.add(serialNumber);
				listImplObj.add(implObj);


			}
			//DefectID:1406 - Rajani Nagaraju - 20131029 - To return Report Totals
			implObj = new MachineHoursReportImpl();
			implObj.setSerialNumber("Summary");
			implObj.setTotalMachineHours(Double.valueOf(df2.format((Double) totalMachineHoursSumm)));
			implObj.setMachineHours(Double.valueOf(df2.format((Double) machineHoursSumm)));	
			//In the Format No.Of Machines Operational, No. Of Machines Dormant
			implObj.setStatus(totalMachinesOperational+","+totalMachinesDormant);
			//For Machine Activity Report
			//implObj.setMachineName(totalMachineswithMinThr+","+totalMachineswithMaxThr);
			implObj.setMachineProfileName(totalMachineswithMinThr+","+totalMachineswithMaxThr);
			listImplObj.add(implObj);
		} 

		catch (Exception e) 
		{
			e.printStackTrace();
			fLogger.fatal("Exception :" + e);
		}

		finally 
		{
			if (session4.getTransaction().isActive()) 
			{
				session4.getTransaction().commit();
			}

			if (session4.isOpen()) 
			{
				session4.flush();
				session4.close();
			}

		}

		return listImplObj;*/
		//DefectId:20141011 @Suprava New Logic en

		/*MachineHoursReportImpl implObj = null;
		List<MachineHoursReportImpl> listImplObj = new LinkedList<MachineHoursReportImpl>();

		Session session4 = HibernateUtil.getSessionFactory().openSession();
		session4.beginTransaction();

		try 
		{
			String selectQuery = null;
			String fromQuery = null;
			String whereQuery = null;
			String finalQuery = null;
			String serialNumber=null;
			String status=null;
			String currentStatus=null;
			Timestamp transactionTime2=null;
			long Duration_In_Current_Status=(long)0;
			String Query=null;

			//DefectID:1406 - Rajani Nagaraju - 20131029 - To return Report Totals
			double totalMachineHoursSumm =0.0D;
			double machineHoursSumm=0.0D;
			int totalMachinesOperational=0;
			int totalMachinesDormant=0;
			int totalMachineswithMinThr =0;
			int totalMachineswithMaxThr =0;

			//DefectId: DF20131016 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period 
			DecimalFormat df2 = new DecimalFormat("###.#");
			SimpleDateFormat dateFrmt = new SimpleDateFormat("yyyy-MM-dd");
			String lastDateInPeriod=null;
			String startDateInPeriod=null;

			//DefectID:1383 - Rajani Nagaraju - 20130930 - Query modification to return correct resultset 
			SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
			sdf.setTimeZone(TimeZone.getTimeZone("GMT"));
			String timeStamp = sdf.format(Calendar.getInstance().getTime());
			Timestamp sysDate=Timestamp.valueOf(timeStamp);


			Calendar c = Calendar.getInstance();
			int currentYear = c.get(Calendar.YEAR);

			//get the List of tenancies accessible to the logged in user tenancy level
			tenancyIdList = getSubTenancyIds(tenancyIdList,session4);
			ListToStringConversion conversionObj = new ListToStringConversion();
			String tenancyIDList = conversionObj.getIntegerListString(tenancyIdList).toString();
			String loginTenIdListString = conversionObj.getIntegerListString(loginTenancyIdList).toString();

			//DefectID:1383 - Rajani Nagaraju - 20130930 - Query modification to return correct resultset
			//String groupByQuery = " group by z.serialNumber ";
			//DefectId: DF20131206 - Rajani Nagaraju - Modifying group by to return the latest tenancy record set from the given tenancy list

			//DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
			String groupByQuery =" group by z.serialNumber, ten1.tenancy_id ";
			String orderByQuery = "";

			//DefectID:1383 - Rajani Nagaraju - 20130930 - Query modification to return correct resultset
			// DefectId: - Rajani Nagaraju - 20131011 - CustomDate Implementation 
			//DefectID:1406 - Rajani Nagaraju - 20131028 - MachineGrouping issue in Reports and sending Report Totals information
			if(period !=null)
			{
				selectQuery = "select z.machineHours as totalMachineLifeHours," +
				" (z.EngineRunningBand1+z.EngineRunningBand2+z.EngineRunningBand3+z.EngineRunningBand4+z.EngineRunningBand5+z.EngineRunningBand6+z.EngineRunningBand7+z.EngineRunningBand8) as machineHours,"+
				"z.lastEngineRun,z.Address,d.nick_name,c.tenancyName,z.lastReported, d , c.tenancyId, cu.group_id as machineGroupId, " +
				" cu.group_name as machineGroupName, v.tenancy_id as primaryOwnerTenancy, ten.tenancy_id as mgTenancy ";

				//DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
				selectQuery = "select z.machineHours as totalMachineLifeHours," +
				" (z.EngineRunningBand1+z.EngineRunningBand2+z.EngineRunningBand3+z.EngineRunningBand4+z.EngineRunningBand5+z.EngineRunningBand6+z.EngineRunningBand7+z.EngineRunningBand8) as machineHours,"+
				"z.lastEngineRun,z.Address,d.nick_name,c.tenancyName,z.lastReported, d , c.tenancyId, cu.group_id as machineGroupId, " +
				" cu.group_name as machineGroupName, ten.tenancy_name as mgTenancyNname, ten.tenancy_id as mgTenancy ";

				fromQuery =" from AssetCustomGroupMapping h RIGHT OUTER JOIN h.serial_number d  LEFT OUTER JOIN h.group_id cu" +
				//DefectID:1406 
				" LEFT OUTER JOIN cu.tenancy_id ten," +
				" TenancyDimensionEntity c, AccountTenancyMapping v, ";

				//DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
				fromQuery =" from AssetCustomGroupMapping h RIGHT OUTER JOIN h.serial_number d  LEFT OUTER JOIN h.group_id cu" +
				//DefectID:1406 
				" LEFT OUTER JOIN cu.tenancy_id ten ," +
				" TenancyEntity ten1 , " +
				" TenancyDimensionEntity c, ";

				whereQuery = " where z.tenancyId = c.tenacy_Dimension_Id and c.tenancyId in ("+ tenancyIDList + " ) " +
						" and z.serialNumber = d.serial_number " +
						" and d.primary_owner_id = v.account_id ";

				//DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
				whereQuery = " where ten1.tenancy_id = c.tenancyId and " +
				" z.tenancyId = c.tenacy_Dimension_Id and c.tenancyId in ("+ tenancyIDList + " ) " +
				" and z.serialNumber = d.serial_number ";


				int year =0;int week = 0; int quarter = 0;int month =0;
				DateUtil dateUtil1 = new DateUtil();
				DateUtil thisDate =dateUtil1.getCurrentDateUtility(new Date());
				DateUtil dateUtil2 = new DateUtil();
				DateUtil prevDate = dateUtil2.getPreviousDateUtility(new Date());

				if (period.equalsIgnoreCase("Week")) 
				{
					week = thisDate.getWeek();
					year = thisDate.getYear();
					fromQuery = fromQuery+" AssetMonitoringFactDataWeekAgg z ";
					whereQuery = whereQuery	+ " and z.timeCount = "+week +" and z.year="+year;

					//DefectId: DF20131018 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period 
					//get the Last Day 
					Calendar cal = Calendar.getInstance();
					lastDateInPeriod = dateFrmt.format(cal.getTime());
					//get the first day of the week
					cal.set(Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek());
					startDateInPeriod=  dateFrmt.format(cal.getTime());

				}

				else if (period.equalsIgnoreCase("Last Week")) 
				{
					week =  prevDate.getWeek();
					if(thisDate.getWeek()==1)
					{
						year = prevDate.getYear();
					}
					else
					{
						year = prevDate.getCurrentYear();
					}

					fromQuery = fromQuery+" AssetMonitoringFactDataWeekAgg z ";

					whereQuery = whereQuery	+ " and z.timeCount = "+week+" and z.year="+year;

					//DefectId: DF20131018 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period 
					//get the Last Day of Previous Week
					Calendar cal = Calendar.getInstance();
				    int i = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
				    cal.add(Calendar.DATE, -i - 7);
				    cal.add(Calendar.DATE, 6);
				    lastDateInPeriod = dateFrmt.format(cal.getTime());
				    //get the First Day of Previous Week
				    cal = Calendar.getInstance();
				    int j = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
				    cal.add(Calendar.DATE, -j - 7);
					cal.set(Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek());
					startDateInPeriod=  dateFrmt.format(cal.getTime());
				}

				else if (period.equalsIgnoreCase("Month")) 
				{
					month =  thisDate.getMonth();
					year = thisDate.getYear();
					fromQuery = fromQuery+" AssetMonitoringFactDataMonthAgg z ";
					whereQuery = whereQuery	+ " and z.timeCount = "	+ month+" and z.year="+year;

					//DefectId: DF20131018 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period 
					//get the Last Day 
					Calendar cal = Calendar.getInstance();
					lastDateInPeriod = dateFrmt.format(cal.getTime());
					//get the First Day of current Month
					String mon = month+"";
					if(mon.length()<2)
						mon="0"+mon;
					startDateInPeriod=year+"-"+mon+"-"+"01";
				}

				else if (period.equalsIgnoreCase("Last Month")) 
				{
					month =  prevDate.getMonth();
					if(thisDate.getMonth()==1)
					{
						year = prevDate.getYear();
					}
					else
					{
						year = prevDate.getCurrentYear();
					}
					fromQuery = fromQuery+" AssetMonitoringFactDataMonthAgg z ";
					whereQuery = whereQuery	+ " and z.timeCount = "	+ month+" and z.year="+year;

					//DefectId: DF20131018 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period 
					//Get the Last Day of previous Month
					Calendar cal = Calendar.getInstance();
					cal.set(Calendar.DATE, 1);
				    cal.add(Calendar.DAY_OF_MONTH, -1);
				    lastDateInPeriod = dateFrmt.format(cal.getTime());
				   //get the First Day of Previous Month
				    String mon = month+"";
					if(mon.length()<2)
						mon="0"+mon;
					startDateInPeriod=year+"-"+mon+"-"+"01";
				}

				else if (period.equalsIgnoreCase("Quarter")) 
				{
					quarter =  thisDate.getQuarter();
					year = thisDate.getYear();
					fromQuery = fromQuery+" AssetMonitoringFactDataQuarterAgg z ";
					whereQuery = whereQuery	+ " and z.timeCount  = " +quarter+" and z.year="+year;

					//DefectId: DF20131018 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period 
					//get the Last Day 
					Calendar cal = Calendar.getInstance();
					lastDateInPeriod = dateFrmt.format(cal.getTime());
					//get the first Date of current quarter
					switch(quarter) 
					{
					    case 3 : 
					    	startDateInPeriod = year+"-07-01";
					    	break;
					    	// return July 01
					    case 2 :
					    	startDateInPeriod = year+"-04-01";
					    	break;
					        // return April 01
					    case 1 :
					    	startDateInPeriod = year+"-01-01";
					    	break;
					        // return Jan 01
					    case 4 : 
					    	startDateInPeriod = year+"-10-01";
					    	break;
					        // return Oct 01
					}
				}

				else if (period.equalsIgnoreCase("Last Quarter")) 
				{
					quarter = prevDate.getQuarter();
					if(thisDate.getQuarter()==1)
					{
						year = prevDate.getYear();
					}
					else
					{
						year = prevDate.getCurrentYear();
					}
					fromQuery = fromQuery+" AssetMonitoringFactDataQuarterAgg z ";
					whereQuery = whereQuery	+ " and z.timeCount  = " +quarter+" and z.year="+year;

					//DefectId: DF20131018 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period 
					//get the last day of previous quarter
					switch(quarter) 
					{
					    case 3 : 
					    	lastDateInPeriod = year+"-09-30";
					    	break;
					        // return September 30
					    case 2 :
					    	lastDateInPeriod = year+"-06-30";
					    	break;
					        // return June 30
					    case 1 :
					    	lastDateInPeriod = year+"-03-31";
					    	break;
					        // return March 31
					    case 4 : 
					    	lastDateInPeriod = year+"-12-31";
					    	break;
					        // return December 31
					}
					//get the first Date of Previous quarter
					switch(quarter) 
					{
					    case 3 : 
					    	startDateInPeriod = year+"-07-01";
					    	break;
					        // return July 01
					    case 2 :
					    	startDateInPeriod = year+"-04-01";
					    	break;
					        // return April 01
					    case 1 :
					    	startDateInPeriod = year+"-01-01";
					    	break;
					        // return Jan 01
					    case 4 : 
					    	startDateInPeriod = year+"-10-01";
					    	break;
					        // return Oct 01
					}
				}

				else if (period.equalsIgnoreCase("Year")) 
				{
					year = thisDate.getYear();
					fromQuery = fromQuery+" AssetMonitoringFactDataYearAgg z ";
					whereQuery = whereQuery	+ " and z.year= "+year;

					//DefectId: DF20131018 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period 
					//get the Last Day 
					Calendar cal = Calendar.getInstance();
					lastDateInPeriod = dateFrmt.format(cal.getTime());
					//get the First day of current Year
					startDateInPeriod=year+"-01"+"-01";
				}

				else if (period.equalsIgnoreCase("Last Year")) 
				{
					year = prevDate.getYear();
					fromQuery = fromQuery+" AssetMonitoringFactDataYearAgg z ";
					whereQuery = whereQuery	+ " and z.year= "+year;

					//DefectId: DF20131018 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period 
					//get the Last day of previous Year
					lastDateInPeriod=year+"-12-31";
					//get the First day of Previous Year 
					startDateInPeriod=year+"-01"+"-01";
				}

				//DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
				orderByQuery = orderByQuery + " order by d.serial_number, z.lastReported desc ";
			}

			//Custom Dates
			else
			{
				DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
				String fromdateFormatted=null;
				String todateFormatted=null;

				try 
				{	
					fromdateFormatted= dateFormat.format(dateFormat.parse(fromDate));	
					todateFormatted = dateFormat.format(dateFormat.parse(toDate));	
				} 

				catch (ParseException e) 
				{
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				if(fromdateFormatted==null || todateFormatted==null)
				{
					throw new CustomFault("Unparsable Date input for Custom dates");
				}

				//DefectId: DF20131018 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period 
				startDateInPeriod = fromdateFormatted;
				lastDateInPeriod = todateFormatted;

				groupByQuery =" group by z.serialNumber, ten1.tenancy_id ";

				//DefectID:1406 - Rajani Nagaraju - 20131028 - MachineGrouping issue in Reports and sending Report Totals information
				selectQuery = "select z.machineHours as totalMachineLifeHours," +
				" sum(u.EngineRunningBand1+u.EngineRunningBand2+u.EngineRunningBand3+u.EngineRunningBand4+u.EngineRunningBand5+u.EngineRunningBand6+u.EngineRunningBand7+u.EngineRunningBand8) as machineHours,"+
				"z.lastEngineRun,z.Address,d.nick_name,c.tenancyName,z.lastReported, d , c.tenancyId, cu.group_id as machineGroupId, " +
				" cu.group_name as machineGroupName, v.tenancy_id as primaryOwnerTenancy, ten.tenancy_id as mgTenancy ";

				//DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
				selectQuery = "select z.machineHours as totalMachineLifeHours," +
				" sum(u.EngineRunningBand1+u.EngineRunningBand2+u.EngineRunningBand3+u.EngineRunningBand4+u.EngineRunningBand5+u.EngineRunningBand6+u.EngineRunningBand7+u.EngineRunningBand8) as machineHours,"+
				"z.lastEngineRun,z.Address,d.nick_name,c.tenancyName,z.lastReported, d , c.tenancyId, cu.group_id as machineGroupId, " +
				" cu.group_name as machineGroupName, ten.tenancy_name as mgTenancyName, ten.tenancy_id as mgTenancy ";

				fromQuery =" from AssetCustomGroupMapping h RIGHT OUTER JOIN h.serial_number d  LEFT OUTER JOIN h.group_id cu" +
				//DefectID:1406
				" LEFT OUTER JOIN cu.tenancy_id ten ," +
				" TenancyDimensionEntity c, AssetMonitoringFactDataDayAgg z, AssetMonitoringFactDataDayAgg u, AccountTenancyMapping v ";

				//DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
				fromQuery =" from AssetCustomGroupMapping h RIGHT OUTER JOIN h.serial_number d  LEFT OUTER JOIN h.group_id cu" +
				//DefectID:1406
				" LEFT OUTER JOIN cu.tenancy_id ten , TenancyEntity ten1, " +
				" TenancyDimensionEntity c, AssetMonitoringFactDataDayAgg z, AssetMonitoringFactDataDayAgg u ";

				//Rajani Nagaraju - 20131204 - To fix the issue raised for 4th Dec SIT deployment
				whereQuery = " where z.tenancyId = c.tenacy_Dimension_Id and c.tenancyId in ("+ tenancyIDList + " ) " +
						" and z.serialNumber = d.serial_number " +
						" and d.primary_owner_id = v.account_id " +
						" and z.serialNumber = u.serialNumber " +
						" and z.timeKey = (select max(o.timeKey) from AssetMonitoringFactDataDayAgg o, TenancyDimensionEntity yt" +
						" where o.serialNumber=z.serialNumber and o.tenancyId = yt.tenacy_Dimension_Id and yt.tenancyId in ("+ tenancyIDList + " ) " +
											" and o.timeKey >='"+fromdateFormatted+"' and o.timeKey <= '"+todateFormatted+"')" +
						" and u.timeKey between '"+fromdateFormatted+"' and '"+todateFormatted+"'";

				//DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
				whereQuery = " where ten1.tenancy_id = c.tenancyId and " +
				" z.tenancyId = c.tenacy_Dimension_Id and c.tenancyId in ("+ tenancyIDList + " ) " +
				" and z.serialNumber = d.serial_number " +
			//	" and d.primary_owner_id = v.account_id " +
				" and z.serialNumber = u.serialNumber " +
				" and u.tenancyId=z.tenancyId " +
				" and z.timeKey = (select max(o.timeKey) from AssetMonitoringFactDataDayAgg o, TenancyDimensionEntity yt" +
				" where o.serialNumber=z.serialNumber and o.tenancyId = yt.tenacy_Dimension_Id and yt.tenancyId in ("+ tenancyIDList + " ) " +
									" and o.timeKey >='"+fromdateFormatted+"' and o.timeKey <= '"+todateFormatted+"')" +
				" and u.timeKey between '"+fromdateFormatted+"' and '"+todateFormatted+"'";

				//DefectId: DF20131206 - Rajani Nagaraju - Modifying group by to return the latest tenancy record set from the given tenancy list
				//DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
				groupByQuery = groupByQuery +" , cu.group_id ";

				//DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
				orderByQuery = orderByQuery +  " order by d.serial_number , z.lastReported desc";

			}


			if (!(customAssetGroupIdList == null || customAssetGroupIdList.isEmpty())) 
			{
				String customAssetGroupStringList = conversionObj.getIntegerListString(customAssetGroupIdList).toString();
				whereQuery = whereQuery+ " and cu.group_id in ("+ customAssetGroupStringList + ")";
			}

			if ((!(machineProfileIdList == null || machineProfileIdList.isEmpty()))	|| (!(modelList == null || modelList.isEmpty()))) 
			{
				fromQuery = fromQuery+ " , AssetClassDimensionEntity b ";
				whereQuery = whereQuery	+ " and z.assetClassDimensionId = b.assetClassDimensionId";
			}


			//DefectID:1383 - Rajani Nagaraju - 20130930 - Query modification to return correct resultset
			if (!(machineProfileIdList == null || machineProfileIdList.isEmpty())) 
			{
				String machineProfileIdStringList = conversionObj.getIntegerListString(machineProfileIdList).toString();
				whereQuery = whereQuery + " and b.assetGroupId in ( "+ machineProfileIdStringList + ") ";

			}			

			//DefectID:1383 - Rajani Nagaraju - 20130930 - Query modification to return correct resultset
			if (!((modelList == null) || (modelList.isEmpty()))) 
			{
				String modelIdListStringList = conversionObj.getIntegerListString(modelList).toString();
				whereQuery = whereQuery + " and b.assetTypeId in ( "+ modelIdListStringList + " )";

			}

			//DefectID:1406 - Rajani Nagaraju - 20131028 - MachineGrouping issue
			//finalQuery = selectQuery + fromQuery + whereQuery + groupByQuery + " order by d.serial_number, ten.tenancy_id ";
			//DefectId: DF20131206 - Rajani Nagaraju - Modifying group by to return the latest tenancy record set from the given tenancy list
			//DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
			finalQuery = selectQuery + fromQuery + whereQuery + groupByQuery + orderByQuery ;

			Query qury = session4.createQuery(finalQuery);
			Iterator rr = qury.list().iterator();
			Object[] result = null;

			// DefectId: - Rajani Nagaraju - 20131011 - CustomDate Implementation 
			List<String> serialNumberList = new LinkedList<String>();
			//DefectID:1406 - Rajani Nagaraju - 20131028 - MachineGrouping issue in Reports and sending Report Totals information
			//List<String> otherMachineGroupVins = new LinkedList<String>();
		//	List<String> finalSerialNumberList = new LinkedList<String>();

			while (rr.hasNext()) 
			{
				implObj = new MachineHoursReportImpl();
				serialNumber=null;

				result = (Object[]) rr.next();

				AssetEntity asset =null;

				if(result[7]!=null)
				{					
					asset = (AssetEntity)result[7];
					serialNumber = asset.getSerial_number().getSerialNumber();

				}

				//DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
				if(serialNumberList.contains(serialNumber))
				{
					continue;
				}

				//DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables - Commenting the below Code
				//DefectID: 1406
				int otherMachineGroup =0;
				if(result[12]!=null)
				{
					int mgTenancy = (Integer) result[12];
					if(! (loginTenancyIdList.contains(mgTenancy)) ) 
					{
						otherMachineGroup=1;
					}
				}

				if( (otherMachineGroup==1)&& ( (otherMachineGroupVins.contains(serialNumber)) || (serialNumberList.contains(serialNumber)) ) )
				{
					continue;
				}
				if( (otherMachineGroup==1) && (serialNumberList.contains(serialNumber)))
				{
					continue;
				}
				if(otherMachineGroupVins.contains(serialNumber))
				{
					if(otherMachineGroup==1)
					{
						continue;
					}
					else
					{
						if(serialNumberList.contains(serialNumber))
						{
							if(!isGroupingOnAssetGroup)
								continue;
						}
						else
						{

						}
					}
				}

				// DefectId: - Rajani Nagaraju - 20131011 - CustomDate Implementation 
				if( (!isGroupingOnAssetGroup) && (serialNumberList.contains(serialNumber))) 
				{
					continue;
				}

				implObj.setSerialNumber(asset.getSerial_number().getSerialNumber());


				if(result[0]!=null)
				{
					implObj.setTotalMachineHours(Double.valueOf(df2.format((Double) result[0])));
				}				

				if(result[1]!=null)
				{
					implObj.setMachineHours(Double.valueOf(df2.format((Double) result[1])));			
				}

				if(result[2]!=null)
				{
					implObj.setLastEngineRun((Timestamp) result[2]);
				}	

				if(result[3]!=null)
				{
					implObj.setLocation(result[3].toString());		
				}

				if(result[4]!=null)
				{
					implObj.setMachineName(result[4].toString());
				}

				if(result[5]!=null)
				{
					implObj.setTenancyName(result[5].toString());
				}	

				if(result[6]!=null)
				{
					implObj.setLastReported((Timestamp) result[6]);
				}	


				implObj.setTenancyId((Integer)result[8]);

				//DefectID:1406 - Rajani Nagaraju - 20131028 - MachineGrouping issue in Reports and sending Report Totals information
				//DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables - Commenting the below Code
				if(result[12]!=null)
				{
					int mgTenancy = (Integer) result[12];
					if(loginTenancyIdList.contains(mgTenancy)) 
					{
						if(result[9]!=null)
							implObj.setMachineGroupId((Integer)result[9]);

						if(result[10]!=null)
							implObj.setMachineGroupName(result[10].toString());
					}
					else
					{
						otherMachineGroupVins.add(serialNumber);
					}

				}

				//DefectID:1383 - Rajani Nagaraju - 20130930 - Query modification to return correct resultset
				if(asset!=null)
				{
					if(asset.getProductId()!=null && asset.getProductId().getAssetGroupId()!=null)
					{
						implObj.setMachineProfileId(asset.getProductId().getAssetGroupId().getAsset_group_id());
						implObj.setMachineProfileName(asset.getProductId().getAssetGroupId().getAsset_group_name());
					}

					if(asset.getProductId()!=null && asset.getProductId().getAssetTypeId()!=null)
					{
						implObj.setModelId(asset.getProductId().getAssetTypeId().getAsset_type_id());
						implObj.setModelName(asset.getProductId().getAssetTypeId().getAsset_type_name());
					}


				}

				//DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
			//	TenancyEntity primaryOwnerTenancy = (TenancyEntity)result[11];
				int primaryOwnerAcc = asset.getPrimary_owner_id();
				int primaryOwnerTenancy=0;
				Query primaryTenQuery = session4.createQuery(" from AccountTenancyMapping where account_id='"+primaryOwnerAcc+"'");
				Iterator primaryTenItr = primaryTenQuery.list().iterator();
				while(primaryTenItr.hasNext())
				{
					AccountTenancyMapping accountTen = (AccountTenancyMapping)primaryTenItr.next();
					primaryOwnerTenancy = accountTen.getTenancy_id().getTenancy_id();
				}

				//DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
				//If the Machine is under the user hierarchy currently, then display current status of Machine
				if( tenancyIdList.contains(primaryOwnerTenancy) )
				{
					//Added status,
					String qry="select amd.parameterValue from AssetMonitoringDetailEntity amd where amd.transactionNumber = " +
							"	(select max(a.transactionNumber) from AssetMonitoringHeaderEntity a where " +
							" a.transactionTime = (select max(a.transactionTime) from a where a.serialNumber = '"+ serialNumber +"')" +
							 " and	a.serialNumber='"+serialNumber+"') and amd.parameterId =(select m.parameterId from MonitoringParameters m where parameterName like 'ENGINE_ON')";
					Query qryyy=session4.createQuery(qry);
					Iterator itrrr=qryyy.list().iterator();			
					while(itrrr.hasNext())
					{
						status=(String)itrrr.next();
						if(status!=null)
						{
							implObj.setStatus(status);
						}
					}
					infoLogger.info("GETTING THE STATUS OF THE MACHINE2");

					//DefectId: 1403 - Rajani Nagaraju - Uncomment Duration in current status
					if(status.equalsIgnoreCase("0"))
					{
						Query=" select min(amhh.transactionTime) from AssetMonitoringHeaderEntity amhh,AssetMonitoringDetailEntity amdd," +
							  " MonitoringParameters mp where amhh.transactionNumber = amdd.transactionNumber and " +
							  " amhh.serialNumber = '"+serialNumber+"' and amhh.transactionTime > ( select max(amh.transactionTime)" +
							  " from AssetMonitoringHeaderEntity amh,AssetMonitoringDetailEntity amd " +
							  " where amh.transactionNumber = amd.transactionNumber and amh.transactionTime <=(select max(amh.transactionTime) " +
							  " from amh where amh.serialNumber = '"+ serialNumber +"') and amh.serialNumber = '"+serialNumber+"' " +
							  " and amd.parameterId =(select m.parameterId from MonitoringParameters m where parameterName like 'ENGINE_ON')  " +
							  " and amd.parameterValue = '1') and amdd.parameterId =mp.parameterId and amdd.parameterValue = '0' and mp.parameterName like 'ENGINE_ON'";
						Query qry4=session4.createQuery(Query);
						Iterator itr4=qry4.list().iterator();
						Object result5[];
						while(itr4.hasNext())
						{						
							transactionTime2=(Timestamp)itr4.next();	
							//Changes for non-cmmunicated VIN DF:20131226
							if(transactionTime2==null)
							{
								Query query=session4.createQuery("select a.ownershipStartDate from AssetAccountMapping a " +
										"where a.serialNumber= '"+ serialNumber +"' and a.accountId =(select b.account_id from AccountTenancyMapping b where b.tenancy_id='"+loginTenancyIdList.get(0)+"')");	
								Iterator iterator=query.list().iterator();
								while(iterator.hasNext())
								{
									Date temp=(Date)iterator.next();									
									transactionTime2= new Timestamp(temp.getTime());
								}

							}
							//Changes for non-cmmunicated VIN DF:20131226
							Duration_In_Current_Status=(long)toDate1(sysDate)/ (1000 * 60 * 60)-(long)toDate1(transactionTime2)/ (1000 * 60 * 60);
							if(Duration_In_Current_Status!=0L)
							{
								implObj.setDurationInCurrentStatus(Duration_In_Current_Status);
							}
						}
					}
					else
					{
						currentStatus="ON";
						Query="select min(amhh.transactionTime) from AssetMonitoringHeaderEntity amhh,AssetMonitoringDetailEntity amdd," +
							" MonitoringParameters mp where amhh.transactionNumber = amdd.transactionNumber and " +
							" amhh.serialNumber = '"+serialNumber+"' and amhh.transactionTime > (select max(amh.transactionTime)" +
						" from AssetMonitoringHeaderEntity amh,AssetMonitoringDetailEntity amd " +
						" where amh.transactionNumber = amd.transactionNumber and amh.transactionTime <=(select max(amh.transactionTime) " +
						" from amh where amh.serialNumber ='"+ serialNumber +"') and amh.serialNumber = '"+serialNumber+"' " +
						" and amd.parameterId =(select m.parameterId from MonitoringParameters m where parameterName like 'ENGINE_ON')  " +
						" and amd.parameterValue = '0') and amdd.parameterId =mp.parameterId and amdd.parameterValue = '1' and mp.parameterName like 'ENGINE_ON'";					

						Query qry4=session4.createQuery(Query);
						Iterator itr4=qry4.list().iterator();
						Object result5[];

						while(itr4.hasNext())
						{						
							transactionTime2=(Timestamp)itr4.next();	
							//Changes for non-communicated VIN DF:20131226
							if(transactionTime2==null)
							{
								Query query=session4.createQuery("select a.ownershipStartDate from AssetAccountMapping a " +
										"where a.serialNumber= '"+ serialNumber +"' and a.accountId =(select b.account_id from AccountTenancyMapping b where b.tenancy_id='"+loginTenancyIdList.get(0)+"')");	
								Iterator iterator=query.list().iterator();
								while(iterator.hasNext())
								{
									Date temp=(Date)iterator.next();									
									transactionTime2= new Timestamp(temp.getTime());
								}

							}
							//Changes for non-communicated VIN DF:20131226
							Duration_In_Current_Status=(long)toDate1(sysDate)/ (1000 * 60 * 60)-(long)toDate1(transactionTime2)/ (1000 * 60 * 60);
							if(Duration_In_Current_Status!=0L)
							{
								implObj.setDurationInCurrentStatus(Duration_In_Current_Status);

							}

						}
					}

					//DefectID:1406 - Rajani Nagaraju - 20131029 - To return Report Totals
					if(!(serialNumberList.contains(serialNumber)))
					{
						if(status.equalsIgnoreCase("0"))
						{
							totalMachinesDormant=totalMachinesDormant+1;
						}
						else
						{
							totalMachinesOperational=totalMachinesOperational+1;
						}
					}
				}

				else
				{
					implObj.setStatus("NA");
				}

				//DefectID:1406 - Rajani Nagaraju - 20131029 - To return Report Totals
				if(!(serialNumberList.contains(serialNumber)))
				{
					totalMachineHoursSumm = totalMachineHoursSumm+(Double.valueOf(df2.format((Double) result[0])));
					machineHoursSumm = machineHoursSumm+(Double.valueOf(df2.format((Double) result[1])));
					//For Machine Activity Report 1.Machines Working less than min threshold and 2. Machines working more than Max. threshold
					if(minThreshold>=0 && maxThreshold>=0)
					{
						double machineHoursInPeriod = (Double) result[1];
						int machineHrInPeriod = (int)machineHoursInPeriod;
						if(machineHrInPeriod < minThreshold)
							totalMachineswithMinThr= totalMachineswithMinThr+1;
						else if (machineHrInPeriod > maxThreshold)
							totalMachineswithMaxThr= totalMachineswithMaxThr+1;

					}
				}

				//DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
				//Get the List of MachineGroup under the Login Tenancy to which the machine belongs to 
				if(isGroupingOnAssetGroup)
				{
					Query mgQuery=null;
					if (!(customAssetGroupIdList == null || customAssetGroupIdList.isEmpty())) 
					{
						String customAssetGroupStringList = conversionObj.getIntegerListString(customAssetGroupIdList).toString();
						mgQuery = session4.createQuery(" select a from AssetCustomGroupMapping a, CustomAssetGroupEntity b " +
								//Smitha:DefectID:20131220...to get the VIN's belonging to the machine groups under that tenancy ID
								"where serial_number='"+serialNumber+"' and a.group_id=b.group_id and b.level=2 and b.active_status=1 and b.tenancy_id in ("+loginTenIdListString+")" +
								" and b.group_id in ("+customAssetGroupStringList+")");
					}

					else
					{
						mgQuery = session4.createQuery(" select a from AssetCustomGroupMapping a, CustomAssetGroupEntity b " +
								//Smitha:DefectID:20131220...to get the VIN's belonging to the machine groups under that tenancy ID
							"where serial_number='"+serialNumber+"' and a.group_id=b.group_id and b.level=2 and b.active_status=1 and b.tenancy_id in ("+loginTenIdListString+")");
					}
					Iterator mgItr = mgQuery.list().iterator();
					int firstIteration =0;
					while(mgItr.hasNext())
					{
						AssetCustomGroupMapping mgVinMapping = (AssetCustomGroupMapping)mgItr.next();
						if(firstIteration==0)
						{
							firstIteration=1;
							implObj.setMachineGroupId(mgVinMapping.getGroup_id().getGroup_id());
							implObj.setMachineGroupName(mgVinMapping.getGroup_id().getGroup_name());
							listImplObj.add(implObj);
						}
						else
						{
							MachineHoursReportImpl newimplObj = new MachineHoursReportImpl();
							newimplObj.setSerialNumber(serialNumber);
							newimplObj.setTotalMachineHours(Double.valueOf(df2.format(implObj.getTotalMachineHours())));
							newimplObj.setMachineHours(Double.valueOf(df2.format(implObj.getMachineHours())));	
							newimplObj.setLastEngineRun(implObj.getLastEngineRun());
							newimplObj.setLocation(implObj.getLocation());		
							newimplObj.setMachineName(implObj.getMachineName());
							newimplObj.setTenancyName(implObj.getTenancyName());
							newimplObj.setLastReported(implObj.getLastReported());
							newimplObj.setTenancyId(implObj.getTenancyId());
							newimplObj.setMachineGroupId(mgVinMapping.getGroup_id().getGroup_id());
							newimplObj.setMachineGroupName(mgVinMapping.getGroup_id().getGroup_name());
							newimplObj.setMachineProfileId(implObj.getMachineProfileId());
							newimplObj.setMachineProfileName(implObj.getMachineProfileName());
							newimplObj.setModelId(implObj.getModelId());
							newimplObj.setModelName(implObj.getModelName());
							newimplObj.setStatus(implObj.getStatus());
							newimplObj.setDurationInCurrentStatus(implObj.getDurationInCurrentStatus());
							listImplObj.add(newimplObj);
						}
					}

					if(firstIteration==0)
					{
						listImplObj.add(implObj);
					}
				}

				else
				{
					listImplObj.add(implObj);
				}


				serialNumberList.add(serialNumber);
				listImplObj.add(implObj);
			}

			//-------------------------------------------------------------------------------------------------------------------
			//DefectId: DF20131018 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period 
			Query ownerListQuery = session4.createQuery(" select distinct c.serialNumber " +
														" from TenancyBridgeEntity a, AccountTenancyMapping b, AssetAccountMapping c " +
														" where a.childId= b.tenancy_id " +
														" and b.account_id= c.accountId " +
														" and a.parentId in ("+tenancyIDList+") and" +
														" ( (c.ownershipStartDate between '"+startDateInPeriod+"' and '"+lastDateInPeriod+"') OR " +
														"   (c.ownershipStartDate = ( select max(y.ownershipStartDate) from AssetAccountMapping y " +
																					" where y.serialNumber= c.serialNumber" +
																					" and y.ownershipStartDate <='"+startDateInPeriod+"')" +
														"    )" +
														" )");
			Iterator ownerListItr = ownerListQuery.list().iterator();
			List<String> actualOwnerVINList = new LinkedList<String>();
			while(ownerListItr.hasNext())
			{
				AssetEntity assetList = (AssetEntity)ownerListItr.next();
				actualOwnerVINList.add(assetList.getSerial_number().getSerialNumber());
			}

			//Get only the List of VINs which has not communicated for the Given period
			actualOwnerVINList.removeAll(serialNumberList);
			String actualOwnerVinListString = conversionObj.getStringList(actualOwnerVINList).toString();
			//groupByQuery =" group by z.serialNumber ";

			//DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
			groupByQuery =" group by z.serialNumber, ten1.tenancy_id ";
			orderByQuery = " order by d.serial_number, z.lastReported desc ";

			selectQuery = " select z.machineHours as totalMachineLifeHours, v.tenancy_id as primaryOwnerTenancy ," +
						  " z.lastEngineRun,z.Address,d.nick_name,c.tenancyName,z.lastReported,  " +
						  " d , c.tenancyId, cu.group_id as machineGroupId," +
						  " cu.group_name as machineGroupName, ten.tenancy_id as mgTenancy ";

			//DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
			selectQuery = " select z.machineHours as totalMachineLifeHours, ten.tenancy_name as mgTenancyName ," +
			  " z.lastEngineRun,z.Address,d.nick_name,c.tenancyName,z.lastReported,  " +
			  " d , c.tenancyId, cu.group_id as machineGroupId," +
			  " cu.group_name as machineGroupName, ten.tenancy_id as mgTenancy ";

			fromQuery = " from AssetCustomGroupMapping h RIGHT OUTER JOIN h.serial_number d  LEFT OUTER JOIN h.group_id cu " +
						//DefectID:1406 
						" LEFT OUTER JOIN cu.tenancy_id ten," +
					    " TenancyDimensionEntity c, AssetMonitoringFactDataDayAgg z , AccountTenancyMapping v ";


			//DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
			fromQuery = " from AssetCustomGroupMapping h RIGHT OUTER JOIN h.serial_number d  LEFT OUTER JOIN h.group_id cu " +
			//DefectID:1406 
			" LEFT OUTER JOIN cu.tenancy_id ten , TenancyEntity ten1," +
		    " TenancyDimensionEntity c, AssetMonitoringFactDataDayAgg z ";


			whereQuery = " where z.tenancyId = c.tenacy_Dimension_Id and z.serialNumber = d.serial_number " +
						 " and d.primary_owner_id = v.account_id " +
						 " and z.serialNumber in ("+actualOwnerVinListString+") " +
						 " and z.timeKey = ( select max(p.timeKey) from AssetMonitoringFactDataDayAgg p where p.serialNumber = z.serialNumber " +
						 "					 and p.timeKey <= '"+startDateInPeriod+"' )";

			//DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
			whereQuery = " where ten1.tenancy_id = c.tenancyId and " +
			" z.tenancyId = c.tenacy_Dimension_Id and z.serialNumber = d.serial_number " +
			" and z.serialNumber in ("+actualOwnerVinListString+") " +
			 " and z.timeKey = ( select max(p.timeKey) from AssetMonitoringFactDataDayAgg p where p.serialNumber = z.serialNumber " +
			 "					 and p.timeKey <= '"+startDateInPeriod+"' )";

			//DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
			if((isGroupingOnAssetGroup) )
				groupByQuery = groupByQuery +", cu.group_id ";

			if (!(customAssetGroupIdList == null || customAssetGroupIdList.isEmpty())) 
			{
				String customAssetGroupStringList = conversionObj.getIntegerListString(customAssetGroupIdList).toString();
				whereQuery = whereQuery+ " and cu.group_id in ("+ customAssetGroupStringList + ")";
			}

			if ((!(machineProfileIdList == null || machineProfileIdList.isEmpty()))	|| (!(modelList == null || modelList.isEmpty()))) 
			{
				fromQuery = fromQuery+ " , AssetClassDimensionEntity b ";
				whereQuery = whereQuery	+ " and z.assetClassDimensionId = b.assetClassDimensionId";
			}


			if (!(machineProfileIdList == null || machineProfileIdList.isEmpty())) 
			{
				String machineProfileIdStringList = conversionObj.getIntegerListString(machineProfileIdList).toString();
				whereQuery = whereQuery + " and b.assetGroupId in ( "+ machineProfileIdStringList + ") ";

			}			

			if (!((modelList == null) || (modelList.isEmpty()))) 
			{
				String modelIdListStringList = conversionObj.getIntegerListString(modelList).toString();
				whereQuery = whereQuery + " and b.assetTypeId in ( "+ modelIdListStringList + " )";

			}

			//DefectID:1406 - Rajani Nagaraju - 20131028 - MachineGrouping issue
			if(! (actualOwnerVINList==null || actualOwnerVINList.isEmpty()))
			{
				//finalQuery = selectQuery + fromQuery+ whereQuery + groupByQuery + " order by d.serial_number, ten.tenancy_id ";;
				finalQuery = selectQuery + fromQuery+ whereQuery + groupByQuery + orderByQuery;
				Iterator vinListItr = session4.createQuery(finalQuery).list().iterator();
				result =null;
				serialNumberList = new LinkedList<String>();

				while(vinListItr.hasNext())
				{
					implObj = new MachineHoursReportImpl();
					serialNumber=null;
					result = (Object[]) vinListItr.next();

					AssetEntity asset =null;

					if(result[7]!=null)
					{					
						asset = (AssetEntity)result[7];
						serialNumber = asset.getSerial_number().getSerialNumber();
						//implObj.setSerialNumber(asset.getSerial_number().getSerialNumber());
					}

					//DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
					if(serialNumberList.contains(serialNumber))
					{
						continue;
					}
					//DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables - Commenting the below Code
					else
					{
						serialNumberList.add(serialNumber);
					}

					//DefectID: 1406
					int otherMachineGroup =0;
					if(result[11]!=null)
					{
						int mgTenancy = (Integer) result[11];
						if(! (loginTenancyIdList.contains(mgTenancy)) ) 
						{
							otherMachineGroup=1;
						}
					}

					if( (otherMachineGroup==1)&& ( (otherMachineGroupVins.contains(serialNumber)) || (serialNumberList.contains(serialNumber)) ) )
					{
						continue;
					}
					// DefectId: - Rajani Nagaraju - 20131011 - CustomDate Implementation 
					if( (!isGroupingOnAssetGroup) && (serialNumberList.contains(serialNumber))) 
					{
						continue;
					}

					implObj.setSerialNumber(asset.getSerial_number().getSerialNumber());

					if(result[0]!=null)
					{
						//implObj.setTotalMachineHours((Integer) result[0]);
						implObj.setTotalMachineHours(Double.valueOf(df2.format((Double)result[0])));
					}

					if(result[2]!=null)
					{
						implObj.setLastEngineRun((Timestamp) result[2]);
					}	

					if(result[3]!=null)
					{
						implObj.setLocation(result[3].toString());		
					}

					if(result[4]!=null)
					{
						implObj.setMachineName(result[4].toString());
					}

					if(result[5]!=null)
					{
						implObj.setTenancyName(result[5].toString());
					}	

					if(result[6]!=null)
					{
						implObj.setLastReported((Timestamp) result[6]);
					}	


					implObj.setTenancyId((Integer)result[8]);



					//DefectID:1406 - Rajani Nagaraju - 20131028 - MachineGrouping issue in Reports and sending Report Totals information
					//DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables - Commenting the below Code
					if(result[11]!=null)
					{
						int mgTenancy = (Integer) result[11];
						if(loginTenancyIdList.contains(mgTenancy)) 
						{
							if(result[9]!=null)
								implObj.setMachineGroupId((Integer)result[9]);

							if(result[10]!=null)
								implObj.setMachineGroupName(result[10].toString());
						}

						else
						{
							otherMachineGroupVins.add(serialNumber);
						}
					}

					//DefectID:1383 - Rajani Nagaraju - 20130930 - Query modification to return correct resultset
					if(asset!=null)
					{
						if(asset.getProductId()!=null && asset.getProductId().getAssetGroupId()!=null)
						{
							implObj.setMachineProfileId(asset.getProductId().getAssetGroupId().getAsset_group_id());
							implObj.setMachineProfileName(asset.getProductId().getAssetGroupId().getAsset_group_name());
						}

						if(asset.getProductId()!=null && asset.getProductId().getAssetTypeId()!=null)
						{
							implObj.setModelId(asset.getProductId().getAssetTypeId().getAsset_type_id());
							implObj.setModelName(asset.getProductId().getAssetTypeId().getAsset_type_name());
						}


					}

					//DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
					//TenancyEntity primaryOwnerTenancy = (TenancyEntity)result[1];
					int primaryOwnerAcc = asset.getPrimary_owner_id();
					int primaryOwnerTenancy=0;
					Query primaryTenQuery = session4.createQuery(" from AccountTenancyMapping where account_id='"+primaryOwnerAcc+"'");
					Iterator primaryTenItr = primaryTenQuery.list().iterator();
					while(primaryTenItr.hasNext())
					{
						AccountTenancyMapping accountTen = (AccountTenancyMapping)primaryTenItr.next();
						primaryOwnerTenancy = accountTen.getTenancy_id().getTenancy_id();
					}


					//DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
					//If the Machine is under the user hierarchy currently, then display current status of Machine
					if( tenancyIdList.contains(primaryOwnerTenancy) )
					{
						//Added status,
						String qry="select amd.parameterValue from AssetMonitoringDetailEntity amd where amd.transactionNumber = " +
								"	(select max(a.transactionNumber) from AssetMonitoringHeaderEntity a where " +
								" a.transactionTime = (select max(a.transactionTime) from a where a.serialNumber = '"+ serialNumber +"')" +
								 " and	a.serialNumber='"+serialNumber+"') and amd.parameterId =(select m.parameterId from MonitoringParameters m where parameterName like 'ENGINE_ON')";
						Query qryyy=session4.createQuery(qry);
						Iterator itrrr=qryyy.list().iterator();			
						while(itrrr.hasNext())
						{
							status=(String)itrrr.next();
							if(status!=null)
							{
								implObj.setStatus(status);
							}
						}
						infoLogger.info("GETTING THE STATUS OF THE MACHINE3");

						//DefectId: 1403 - Rajani Nagaraju - Uncomment Duration in current status
						if(status.equalsIgnoreCase("0"))
						{
							Query=" select min(amhh.transactionTime) from AssetMonitoringHeaderEntity amhh,AssetMonitoringDetailEntity amdd," +
								  " MonitoringParameters mp where amhh.transactionNumber = amdd.transactionNumber and " +
								  " amhh.serialNumber = '"+serialNumber+"' and amhh.transactionTime > ( select max(amh.transactionTime)" +
								  " from AssetMonitoringHeaderEntity amh,AssetMonitoringDetailEntity amd " +
								  " where amh.transactionNumber = amd.transactionNumber and amh.transactionTime <=(select max(amh.transactionTime) " +
								  " from amh where amh.serialNumber = '"+ serialNumber +"') and amh.serialNumber = '"+serialNumber+"' " +
								  " and amd.parameterId =(select m.parameterId from MonitoringParameters m where parameterName like 'ENGINE_ON')  " +
								  " and amd.parameterValue = '1') and amdd.parameterId =mp.parameterId and amdd.parameterValue = '0' and mp.parameterName like 'ENGINE_ON'";
							Query qry4=session4.createQuery(Query);
							Iterator itr4=qry4.list().iterator();
							Object result5[];
							while(itr4.hasNext())
							{						
								transactionTime2=(Timestamp)itr4.next();	
								//Changes for non-communicated VIN DF:20131226
								if(transactionTime2==null)
								{
									Query query=session4.createQuery("select a.ownershipStartDate from AssetAccountMapping a " +
											"where a.serialNumber= '"+ serialNumber +"' and a.accountId =(select b.account_id from AccountTenancyMapping b where b.tenancy_id='"+loginTenancyIdList.get(0)+"')");	
									Iterator iterator=query.list().iterator();
									while(iterator.hasNext())
									{
										Date temp=(Date)iterator.next();									
										transactionTime2= new Timestamp(temp.getTime());
									}

								}
								//Changes for non-communicated VIN DF:20131226
								Duration_In_Current_Status=(long)toDate1(sysDate)/ (1000 * 60 * 60)-(long)toDate1(transactionTime2)/ (1000 * 60 * 60);
								if(Duration_In_Current_Status!=0L)
								{
									implObj.setDurationInCurrentStatus(Duration_In_Current_Status);
								}
							}
						}
						else
						{
							currentStatus="ON";
							Query="select min(amhh.transactionTime) from AssetMonitoringHeaderEntity amhh,AssetMonitoringDetailEntity amdd," +
								" MonitoringParameters mp where amhh.transactionNumber = amdd.transactionNumber and " +
								" amhh.serialNumber = '"+serialNumber+"' and amhh.transactionTime > (select max(amh.transactionTime)" +
							" from AssetMonitoringHeaderEntity amh,AssetMonitoringDetailEntity amd " +
							" where amh.transactionNumber = amd.transactionNumber and amh.transactionTime <=(select max(amh.transactionTime) " +
							" from amh where amh.serialNumber ='"+ serialNumber +"') and amh.serialNumber = '"+serialNumber+"' " +
							" and amd.parameterId =(select m.parameterId from MonitoringParameters m where parameterName like 'ENGINE_ON')  " +
							" and amd.parameterValue = '0') and amdd.parameterId =mp.parameterId and amdd.parameterValue = '1' and mp.parameterName like 'ENGINE_ON'";					

							Query qry4=session4.createQuery(Query);
							Iterator itr4=qry4.list().iterator();
							Object result5[];

							while(itr4.hasNext())
							{						
								transactionTime2=(Timestamp)itr4.next();	
								//Changes for non-cmmunicated VIN DF:20131226
								if(transactionTime2==null)
								{
									Query query=session4.createQuery("select a.ownershipStartDate from AssetAccountMapping a " +
											"where a.serialNumber= '"+ serialNumber +"' and a.accountId =(select b.account_id from AccountTenancyMapping b where b.tenancy_id='"+loginTenancyIdList.get(0)+"')");	
									Iterator iterator=query.list().iterator();
									while(iterator.hasNext())
									{
										Date temp=(Date)iterator.next();									
										transactionTime2= new Timestamp(temp.getTime());
									}

								}
								//Changes for non-cmmunicated VIN DF:20131226
								Duration_In_Current_Status=(long)toDate1(sysDate)/ (1000 * 60 * 60)-(long)toDate1(transactionTime2)/ (1000 * 60 * 60);
								if(Duration_In_Current_Status!=0L)
								{
									implObj.setDurationInCurrentStatus(Duration_In_Current_Status);

								}

							}
						}

						//DefectID:1406 - Rajani Nagaraju - 20131029 - To return Report Totals
						if(!(serialNumberList.contains(serialNumber)))
						{
							if(status.equalsIgnoreCase("0"))
							{
								totalMachinesDormant=totalMachinesDormant+1;
							}
							else
							{
								totalMachinesOperational=totalMachinesOperational+1;
							}

							//For Machine Activity Report 1.Machines Working less than min threshold and 2. Machines working more than Max. threshold
							if(minThreshold>=0 && maxThreshold>=0)
							{
								int machineHrInPeriod = 0;
								if(machineHrInPeriod < minThreshold)
									totalMachineswithMinThr= totalMachineswithMinThr+1;
								else if (machineHrInPeriod > maxThreshold)
									totalMachineswithMaxThr= totalMachineswithMaxThr+1;

							}
						}
					}

					else
					{
						implObj.setStatus("NA");

					}



				//DefectID:1406 - Rajani Nagaraju - 20131029 - To return Report Totals
				if(!(serialNumberList.contains(serialNumber)))
				{
					totalMachineHoursSumm = totalMachineHoursSumm+(Double.valueOf(df2.format((Double) result[0])));
					//machineHoursSumm cannot be added since the machine has not communicated in the given period
					//machineHoursSumm = machineHoursSumm+(Double) result[1];

					//DefectId: 20131220 - Rajani Nagaraju - To sum the yellow threshold even for the machines that has not communicated
					//For Machine Activity Report 1.Machines Working less than min threshold and 2. Machines working more than Max. threshold
					if(minThreshold>=0 && maxThreshold>=0)
					{
						int machineHrInPeriod = 0;
						if(machineHrInPeriod < minThreshold)
							totalMachineswithMinThr= totalMachineswithMinThr+1;
						else if (machineHrInPeriod > maxThreshold)
							totalMachineswithMaxThr= totalMachineswithMaxThr+1;

					}
				}

				//Get the List of MachineGroup under the Login Tenancy to which the machine belongs to 
				//DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
				if(isGroupingOnAssetGroup)
				{

					Query mgQuery=null;
					if (!(customAssetGroupIdList == null || customAssetGroupIdList.isEmpty())) 
					{
						String customAssetGroupStringList = conversionObj.getIntegerListString(customAssetGroupIdList).toString();
						mgQuery = session4.createQuery(" select a from AssetCustomGroupMapping a, CustomAssetGroupEntity b " +
								//Smitha:DefectID:20131220...to get the VIN's belonging to the machine groups under that tenancy ID
								"where serial_number='"+serialNumber+"' and a.group_id=b.group_id and b.level=2 and b.active_status=1 and b.tenancy_id in ("+loginTenIdListString+")" +
								" and b.group_id in ("+customAssetGroupStringList+")");
					}
					else
					{
						mgQuery = session4.createQuery(" select a from AssetCustomGroupMapping a, CustomAssetGroupEntity b " +
								//Smitha:DefectID:20131220...to get the VIN's belonging to the machine groups under that tenancy ID
							"where serial_number='"+serialNumber+"' and a.group_id=b.group_id and b.level=2 and b.active_status=1 and b.tenancy_id in ("+loginTenIdListString+")");
					}
					Iterator mgItr = mgQuery.list().iterator();
					int firstIteration =0;
					while(mgItr.hasNext())
					{
						AssetCustomGroupMapping mgVinMapping = (AssetCustomGroupMapping)mgItr.next();
						if(firstIteration==0)
						{
							firstIteration=1;
							implObj.setMachineGroupId(mgVinMapping.getGroup_id().getGroup_id());
							implObj.setMachineGroupName(mgVinMapping.getGroup_id().getGroup_name());
							listImplObj.add(implObj);
						}
						else
						{
							MachineHoursReportImpl newimplObj = new MachineHoursReportImpl();
							newimplObj.setSerialNumber(serialNumber);
							newimplObj.setTotalMachineHours(implObj.getTotalMachineHours());
							newimplObj.setMachineHours(implObj.getMachineHours());	
							newimplObj.setLastEngineRun(implObj.getLastEngineRun());
							newimplObj.setLocation(implObj.getLocation());		
							newimplObj.setMachineName(implObj.getMachineName());
							newimplObj.setTenancyName(implObj.getTenancyName());
							newimplObj.setLastReported(implObj.getLastReported());
							newimplObj.setTenancyId(implObj.getTenancyId());
							newimplObj.setMachineGroupId(mgVinMapping.getGroup_id().getGroup_id());
							newimplObj.setMachineGroupName(mgVinMapping.getGroup_id().getGroup_name());
							newimplObj.setMachineProfileId(implObj.getMachineProfileId());
							newimplObj.setMachineProfileName(implObj.getMachineProfileName());
							newimplObj.setModelId(implObj.getModelId());
							newimplObj.setModelName(implObj.getModelName());
							newimplObj.setStatus(implObj.getStatus());
							newimplObj.setDurationInCurrentStatus(implObj.getDurationInCurrentStatus());
							listImplObj.add(newimplObj);
						}
					}

					if(firstIteration==0)
					{
						listImplObj.add(implObj);
					}
				}

				else
				{
					listImplObj.add(implObj);
				}

			}
				serialNumberList.add(serialNumber);
				listImplObj.add(implObj);

			}
			//DefectID:1406 - Rajani Nagaraju - 20131029 - To return Report Totals
			implObj = new MachineHoursReportImpl();
			implObj.setSerialNumber("Summary");
			implObj.setTotalMachineHours(Double.valueOf(df2.format((Double) totalMachineHoursSumm)));
			implObj.setMachineHours(Double.valueOf(df2.format((Double) machineHoursSumm)));	
			//In the Format No.Of Machines Operational, No. Of Machines Dormant
			implObj.setStatus(totalMachinesOperational+","+totalMachinesDormant);
			//For Machine Activity Report
			//implObj.setMachineName(totalMachineswithMinThr+","+totalMachineswithMaxThr);
			implObj.setMachineProfileName(totalMachineswithMinThr+","+totalMachineswithMaxThr);
			listImplObj.add(implObj);
		} 

		catch (Exception e) 
		{
			e.printStackTrace();
			fatalError.fatal("Exception :" + e);
		}

		finally 
		{
			if (session4.getTransaction().isActive()) 
			{
				session4.getTransaction().commit();
			}

			if (session4.isOpen()) 
			{
				session4.flush();
				session4.close();
			}

		}

		return listImplObj;
		 
			}*/


//Utilization Detail Service *******************************************

/*//************************************************** Get the Usage Details of the Machine ****************************************
*//** DefectID:1383 - Rajani Nagaraju - 20130930 - Query modification to return correct resultset 
 *  DefectId: - Rajani Nagaraju - 20131011 - CustomDate Implementation 
 *  DefectId: - 1406 - 20131028 - Rajani Nagaraju - Resolution to MachineGrouping Issue(Machine belonging to a machine Group of other tenancies 
 *                                              should be shown as no Machine Grouping) and ReportTotalsIssue ( To return Report totals at summary from service)
*  DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
*     method to get the machine hours report
*  @param period,customAssetGroupIdList,machineProfileIdList,tenancyIdList,modelList
*  @return list
**//*
//Added custom Dates by Juhi on 13-August-2013
public List<MachineHoursReportImpl> getMachineHoursReportService(String fromDate,String toDate,String period, 
              List<Integer> customAssetGroupIdList,List<Integer> machineProfileIdList, 
              List<Integer> tenancyIdList,List<Integer> modelList, 
              boolean isGroupingOnAssetGroup, List<Integer> loginTenancyIdList,
              int minThreshold, int maxThreshold)
              {
       //DefectId:20141011 @Suprava New Logic sn
       MachineHoursReportImpl implObj = null;
       List<MachineHoursReportImpl> listImplObj = new LinkedList<MachineHoursReportImpl>();
       Logger fLogger = FatalLoggerClass.logger;
       //Logger bLogger = BusinessErrorLoggerClass.logger;
       Logger iLogger = InfoLoggerClass.logger;
       Session session4 = HibernateUtil.getSessionFactory().openSession();
       session4.beginTransaction();

       try 
       {
              String selectQuery = null;
              String fromQuery = null;
              String whereQuery = null;
              String finalQuery = null;
              String serialNumber=null;
              String status=null;
              String currentStatus=null;
              Timestamp transactionTime2=null;
              long Duration_In_Current_Status=(long)0;
              String Query=null;

              //DefectID:1406 - Rajani Nagaraju - 20131029 - To return Report Totals
              double totalMachineHoursSumm =0.0D;
              double machineHoursSumm=0.0D;
              int totalMachinesOperational=0;
              int totalMachinesDormant=0;
              int totalMachineswithMinThr =0;
              int totalMachineswithMaxThr =0;

              DecimalFormat df2 = new DecimalFormat("###.#");
              SimpleDateFormat dateFrmt = new SimpleDateFormat("yyyy-MM-dd");
              String lastDateInPeriod=null;
              String lastDateInPeriod1=null;
              String startDateInPeriod=null;
              Date startDateInPeriod1=null;
              String startDateInPeriod2=null;
              String fromdateFormatted1=null;
              Date todateFormatted1=null;

              SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
              sdf.setTimeZone(TimeZone.getTimeZone("GMT"));
              String timeStamp = sdf.format(Calendar.getInstance().getTime());
              Timestamp sysDate=Timestamp.valueOf(timeStamp);


              Calendar c = Calendar.getInstance();
              int currentYear = c.get(Calendar.YEAR);
              int year =0;int week = 0; int quarter = 0;int month =0;
              DateUtil dateUtil1 = new DateUtil();
              DateUtil thisDate =dateUtil1.getCurrentDateUtility(new Date());
              DateUtil dateUtil2 = new DateUtil();
              DateUtil prevDate = dateUtil2.getPreviousDateUtility(new Date());
              if(period!=null){
                    if (period.equalsIgnoreCase("Week")) 
                    {
                           week = thisDate.getWeek();
                           year = thisDate.getYear();
                           //To display the VINs that has not communicated for the given time period 
                           //get the Last Day 
                            Calendar cal = Calendar.getInstance();
                           lastDateInPeriod = dateFrmt.format(cal.getTime());
                           lastDateInPeriod1 = lastDateInPeriod +" 23:59:59";
                           //System.out.println("lastDateInPeriod ***"+lastDateInPeriod1);
                           //get the first day of the week
                           cal.set(Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek());
                           startDateInPeriod=  dateFrmt.format(cal.getTime());
                           startDateInPeriod=startDateInPeriod+" 00:00:00";
                           //System.out.println("startDateInPeriod ***"+startDateInPeriod);

                    }

                    else if (period.equalsIgnoreCase("Last Week")) 
                    {
                           week =  prevDate.getWeek();
                           if(thisDate.getWeek()==1)
                           {
                                  year = prevDate.getYear();
                           }
                           else
                           {
                                  year = prevDate.getCurrentYear();
                           }
                           //get the Last Day of Previous Week
                           Calendar cal = Calendar.getInstance();
                           int i = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
                           cal.add(Calendar.DATE, -i - 7);
                           cal.add(Calendar.DATE, 6);
                           lastDateInPeriod = dateFrmt.format(cal.getTime());
                           lastDateInPeriod1 = lastDateInPeriod +" 23:59:59";
                           //System.out.println("lastDateInPeriod ***"+lastDateInPeriod1);
                           //get the First Day of Previous Week
                           cal = Calendar.getInstance();
                           int j = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
                           cal.add(Calendar.DATE, -j - 7);
                           cal.set(Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek());
                           startDateInPeriod=  dateFrmt.format(cal.getTime());
                           startDateInPeriod=startDateInPeriod+" 00:00:00";
                           //System.out.println("startDateInPeriod ***"+startDateInPeriod);
                    }

                    else if (period.equalsIgnoreCase("Month")) 
                    {
                           month =  thisDate.getMonth();
                           year = thisDate.getYear();
                           //get the Last Day 
                           Calendar cal = Calendar.getInstance();
                           lastDateInPeriod = dateFrmt.format(cal.getTime());
                           lastDateInPeriod1 = lastDateInPeriod +" 23:59:59";
                           //System.out.println("lastDateInPeriod ***"+lastDateInPeriod1);
                           //get the First Day of current Month
                           String mon = month+"";
                           if(mon.length()<2)
                                  mon="0"+mon;
                           startDateInPeriod=year+"-"+mon+"-"+"01";
                           startDateInPeriod=startDateInPeriod+" 00:00:00";
                           //System.out.println("startDateInPeriod ***"+startDateInPeriod);
                    }

                    else if (period.equalsIgnoreCase("Last Month")) 
                    {
                           month =  prevDate.getMonth();
                           if(thisDate.getMonth()==1)
                           {
                                  year = prevDate.getYear();
                           }
                           else
                           {
                                  year = prevDate.getCurrentYear();
                           }
                           //Get the Last Day of previous Month
                           Calendar cal = Calendar.getInstance();
                           cal.set(Calendar.DATE, 1);
                           cal.add(Calendar.DAY_OF_MONTH, -1);
                           lastDateInPeriod = dateFrmt.format(cal.getTime());
                           lastDateInPeriod1 = lastDateInPeriod +" 23:59:59";
                           //System.out.println("lastDateInPeriod ***"+lastDateInPeriod1);
                           //get the First Day of Previous Month
                           String mon = month+"";
                           if(mon.length()<2)
                                  mon="0"+mon;
                           startDateInPeriod=year+"-"+mon+"-"+"01";
                           startDateInPeriod=startDateInPeriod+" 00:00:00";
                           //System.out.println("startDateInPeriod2 ***"+startDateInPeriod);
                    }

                    else if (period.equalsIgnoreCase("Quarter")) 
                    {
                           quarter =  thisDate.getQuarter();
                           year = thisDate.getYear();
                           //get the Last Day 
                           Calendar cal = Calendar.getInstance();
                           lastDateInPeriod = dateFrmt.format(cal.getTime());
                           lastDateInPeriod1 = lastDateInPeriod +" 23:59:59";
                           //System.out.println("lastDateInPeriod ***"+lastDateInPeriod1);
                           //get the first Date of current quarter
                           switch(quarter) 
                           {
                           case 3 : 
                                  startDateInPeriod = year+"-07-01";
                                  startDateInPeriod=startDateInPeriod+" 00:00:00";
                                  //System.out.println("startDateInPeriod ***"+startDateInPeriod);
                                  break;
                                  // return July 01
                           case 2 :
                                  startDateInPeriod = year+"-04-01";
                                  startDateInPeriod=startDateInPeriod+" 00:00:00";
                                  //System.out.println("startDateInPeriod ***"+startDateInPeriod);
                                  break;
                                  // return April 01
                           case 1 :
                                  startDateInPeriod = year+"-01-01";
                                  startDateInPeriod=startDateInPeriod+" 00:00:00";
                                  //System.out.println("startDateInPeriod ***"+startDateInPeriod);
                                  break;
                                  // return Jan 01
                           case 4 : 
                                  startDateInPeriod = year+"-10-01";
                                  startDateInPeriod=startDateInPeriod+" 00:00:00";
                                  //System.out.println("startDateInPeriod ***"+startDateInPeriod);
                                  break;
                                  // return Oct 01
                           }
                    }

                    else if (period.equalsIgnoreCase("Last Quarter")) 
                    {
                           Calendar cal = Calendar.getInstance();
                           quarter = prevDate.getQuarter();
                           if(thisDate.getQuarter()==1)
                           {
                                  year = prevDate.getYear();
                           }
                           else
                           {
                                  year = prevDate.getCurrentYear();
                           }
                           //get the last day of previous quarter
                           switch(quarter) 
                           {
                           case 3 : 
                                  lastDateInPeriod = year+"-09-30";
                                  lastDateInPeriod1 = lastDateInPeriod +" 23:59:59";
                                  //System.out.println("lastDateInPeriod ***"+lastDateInPeriod1);
                                  break;
                                  // return September 30
                           case 2 :
                                  lastDateInPeriod = year+"-06-30";
                                  lastDateInPeriod1 = lastDateInPeriod +" 23:59:59";
                                  //System.out.println("lastDateInPeriod ***"+lastDateInPeriod1);
                                  break;
                                  // return June 30
                           case 1 :
                                  lastDateInPeriod = year+"-03-31";
                                  lastDateInPeriod1 = lastDateInPeriod +" 23:59:59";
                                  //System.out.println("lastDateInPeriod ***"+lastDateInPeriod1);
                                  break;
                                  // return March 31
                           case 4 : 
                                  lastDateInPeriod = year+"-12-31";
                                  lastDateInPeriod1 = lastDateInPeriod +" 23:59:59";
                                  //System.out.println("lastDateInPeriod ***"+lastDateInPeriod1);
                                  break;
                                  // return December 31
                           }
                           //get the first Date of Previous quarter
                           switch(quarter) 
                           {
                           case 3 : 
                                  startDateInPeriod = year+"-07-01";
                                  startDateInPeriod=startDateInPeriod+" 00:00:00";
                                  //System.out.println("startDateInPeriod2 ***"+startDateInPeriod2);
                                  break;
                                  // return July 01
                           case 2 :
                                  startDateInPeriod = year+"-04-01";
                                  startDateInPeriod=startDateInPeriod+" 00:00:00";
                                  //System.out.println("startDateInPeriod2 ***"+startDateInPeriod2);
                                  break;
                                  // return April 01
                           case 1 :
                                  startDateInPeriod = year+"-01-01";
                                  startDateInPeriod=startDateInPeriod+" 00:00:00";
                                  //System.out.println("startDateInPeriod2 ***"+startDateInPeriod2);
                                  break;
                                  // return Jan 01
                           case 4 : 
                                  startDateInPeriod = year+"-10-01";
                                  startDateInPeriod=startDateInPeriod+" 00:00:00";
                                  //System.out.println("startDateInPeriod ***"+startDateInPeriod);
                                  break;
                                  // return Oct 01
                           }
                    }

                    else if (period.equalsIgnoreCase("Year")) 
                    {
                           year = thisDate.getYear();
                           //get the Last Day 
                           Calendar cal = Calendar.getInstance();
                           lastDateInPeriod = dateFrmt.format(cal.getTime());
                           lastDateInPeriod1 = lastDateInPeriod +" 23:59:59";
                           //System.out.println("lastDateInPeriod ***"+lastDateInPeriod1);
                           //get the First day of current Year
                           startDateInPeriod=year+"-01"+"-01";
                           startDateInPeriod=startDateInPeriod+" 00:00:00";
                           //System.out.println("startDateInPeriod ***"+startDateInPeriod);
                    }

                    else if (period.equalsIgnoreCase("Last Year")) 
                    {
                           Calendar cal = Calendar.getInstance();
                           year = prevDate.getYear();
                           //get the Last day of previous Year
                           lastDateInPeriod=year+"-12-31";
                           //lastDateInPeriod1 = lastDateInPeriod +" 18:30:00";
                           //System.out.println("lastDateInPeriod ***"+lastDateInPeriod1);
                           //get the First day of Previous Year 
                           startDateInPeriod=year+"-01"+"-01";
                           startDateInPeriod=startDateInPeriod+" 00:00:00";
                           //System.out.println("startDateInPeriod ***"+startDateInPeriod);
                    }
              }
              else
              {
                        Calendar cal = Calendar.getInstance();      
                        startDateInPeriod1 = (Date)dateFrmt.parse(fromDate);
                        startDateInPeriod = dateFrmt.format(startDateInPeriod1);
                           cal.setTime(startDateInPeriod1);
                           cal.add(Calendar.DAY_OF_YEAR, -1);
                           startDateInPeriod2 = dateFrmt.format(cal.getTime());
                        startDateInPeriod = startDateInPeriod + " 00:00:00";
                           //System.out.println("startDateInPeriod ***"+startDateInPeriod);
                           todateFormatted1 = (Date)dateFrmt.parse(toDate);
                           lastDateInPeriod=dateFrmt.format(todateFormatted1);
                           lastDateInPeriod=lastDateInPeriod+ " 23:59:59"; 
                           //System.out.println("lastDateInPeriod ***"+lastDateInPeriod);
              
              }
              //Get the Status of the machine
              List<Integer> transactionNumberList = new LinkedList<Integer>();
              int transactionNumber =0;
              String serial_num = null;
              Query query3 = session4
              .createQuery("select max(a.transactionNumber),a.serialNumber from AssetMonitoringHeaderEntity a where a.createdTimestamp >= '"+startDateInPeriod+"' and  a.createdTimestamp<='"+lastDateInPeriod+"' group by a.serialNumber");
              Iterator transactionNumItr = query3.list().iterator();
              while (transactionNumItr.hasNext())
              {
                    AssetEntity asset =null;
                    Object[] result = (Object[]) transactionNumItr.next();
                    if (result[0] != null) {
                           transactionNumber = (Integer)result[0];
                           transactionNumberList.add(transactionNumber);
                           //infoLogger.info("transactionNumberList"+transactionNumberList);
                    }
              }
              ListToStringConversion conversionObj = new ListToStringConversion();
              String transactionNumberAsStringList = conversionObj.getIntegerListString(transactionNumberList).toString();
              infoLogger.info("transactionNumberAsStringList ***"+transactionNumberAsStringList);
              if(transactionNumberAsStringList==null ||transactionNumberAsStringList.equalsIgnoreCase(null) || transactionNumberAsStringList.isEmpty())
              {
                    transactionNumberAsStringList ="0";
              }
              //get the List of tenancies accessible to the logged in user tenancy level
              ListToStringConversion conversionObj = new ListToStringConversion();
              //tenancyIdList = getSubTenancyIds(tenancyIdList,session4);
              String tenancyIDList = conversionObj.getIntegerListString(tenancyIdList).toString();
              String loginTenIdListString = conversionObj.getIntegerListString(loginTenancyIdList).toString();
              String groupByQuery =" group by z.serialNumber, ten1.tenancy_id ";
              String orderByQuery = "";
              if(period !=null){

                    selectQuery = "select z.machineHours as totalMachineLifeHours," +
                    " (z.EngineRunningBand1+z.EngineRunningBand2+z.EngineRunningBand3+z.EngineRunningBand4+z.EngineRunningBand5+z.EngineRunningBand6+z.EngineRunningBand7+z.EngineRunningBand8) as machineHours,"+
                    "z.lastEngineRun,z.Address,d.nick_name,c.tenancyName,z.lastReported, d , c.tenancyId, cu.group_id as machineGroupId, " +
                    " cu.group_name as machineGroupName, ten.tenancy_name as mgTenancyNname, ten.tenancy_id as mgTenancy ,z.engineStatus as status," +
                    //DefectId:20150220 @ Suprava Delaer As a new parameter Added
                    "c.parentTenancyName,c.tenancyTypeId ";

                    fromQuery =" from AssetCustomGroupMapping h RIGHT OUTER JOIN h.serial_number d  LEFT OUTER JOIN h.group_id cu" +
                    " LEFT OUTER JOIN cu.tenancy_id ten ," +
                    "TenancyBridgeEntity tb, "+
                    " TenancyEntity ten1 , " +
                    " TenancyDimensionEntity c, " ;
                    //DefectId:20141111 @Suprava Read Time out Exception
                    //" AssetMonitoringDetailEntity e JOIN e.transactionNumber amh ,";
                    //DefectId:20141111 en
                    whereQuery = " where ten1.tenancy_id = c.tenancyId and " +
                    " z.tenancyId = c.tenacy_Dimension_Id and tb.parentId in ("+ tenancyIDList + " ) and c.tenancyId = tb.childId " +
                    //DefectId:20141111 @Suprava Read Time out Exception
                    " and amh.transactionNumber in("+transactionNumberAsStringList+")"+
                    " and e.parameterId=18 "+
                    " and amh.transactionNumber=e.transactionNumber " +
                    " and z.serialNumber = amh.serialNumber " +
                    //DefectId:20141111 en
                    " and z.serialNumber = d.serial_number " ;
                    //DefectId:20150216 @ Suprava Delaer As a new parameter Added
                    //" and c.parentTenancyId=ten1.parent_tenancy_id ";

                    if (period.equalsIgnoreCase("Week")) 
                    {
                           week = thisDate.getWeek();
                           year = thisDate.getYear();
                           fromQuery = fromQuery+" AssetMonitoringFactDataWeekAgg z ";
                           whereQuery = whereQuery    + " and z.timeCount = "+week +" and z.year="+year;

                           //To display the VINs that has not communicated for the given time period 
                           //get the Last Day 
                           Calendar cal = Calendar.getInstance();
                           lastDateInPeriod = dateFrmt.format(cal.getTime());
                           //get the first day of the week
                           cal.set(Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek());
                           startDateInPeriod=  dateFrmt.format(cal.getTime());

                    }

                    else if (period.equalsIgnoreCase("Last Week")) 
                    {
                           week =  prevDate.getWeek();
                           if(thisDate.getWeek()==1)
                           {
                                  year = prevDate.getYear();
                           }
                           else
                           {
                                  year = prevDate.getCurrentYear();
                           }

                           fromQuery = fromQuery+" AssetMonitoringFactDataWeekAgg z ";

                           whereQuery = whereQuery    + " and z.timeCount = "+week+" and z.year="+year;

                           //To display the VINs that has not communicated for the given time period 
                           //get the Last Day of Previous Week
                           Calendar cal = Calendar.getInstance();
                           int i = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
                           cal.add(Calendar.DATE, -i - 7);
                           cal.add(Calendar.DATE, 6);
                           lastDateInPeriod = dateFrmt.format(cal.getTime());
                           //get the First Day of Previous Week
                           cal = Calendar.getInstance();
                           int j = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
                           cal.add(Calendar.DATE, -j - 7);
                           cal.set(Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek());
                           startDateInPeriod=  dateFrmt.format(cal.getTime());
                    }

                    else if (period.equalsIgnoreCase("Month")) 
                    {
                           month =  thisDate.getMonth();
                           year = thisDate.getYear();
                           fromQuery = fromQuery+" AssetMonitoringFactDataMonthAgg z ";
                           whereQuery = whereQuery    + " and z.timeCount = "    + month+" and z.year="+year;

                           // To display the VINs that has not communicated for the given time period 
                           //get the Last Day 
                           Calendar cal = Calendar.getInstance();
                           lastDateInPeriod = dateFrmt.format(cal.getTime());
                           //get the First Day of current Month
                           String mon = month+"";
                           if(mon.length()<2)
                                  mon="0"+mon;
                           startDateInPeriod=year+"-"+mon+"-"+"01";
                    }

                    else if (period.equalsIgnoreCase("Last Month")) 
                    {
                           month =  prevDate.getMonth();
                           if(thisDate.getMonth()==1)
                           {
                                  year = prevDate.getYear();
                           }
                           else
                           {
                                  year = prevDate.getCurrentYear();
                           }
                           fromQuery = fromQuery+" AssetMonitoringFactDataMonthAgg z ";
                           whereQuery = whereQuery    + " and z.timeCount = "    + month+" and z.year="+year;

                           // To display the VINs that has not communicated for the given time period 
                           //Get the Last Day of previous Month
                           Calendar cal = Calendar.getInstance();
                           cal.set(Calendar.DATE, 1);
                           cal.add(Calendar.DAY_OF_MONTH, -1);
                           lastDateInPeriod = dateFrmt.format(cal.getTime());
                           //get the First Day of Previous Month
                           String mon = month+"";
                           if(mon.length()<2)
                                  mon="0"+mon;
                           startDateInPeriod=year+"-"+mon+"-"+"01";
                    }

                    else if (period.equalsIgnoreCase("Quarter")) 
                    {
                           quarter =  thisDate.getQuarter();
                           year = thisDate.getYear();
                           fromQuery = fromQuery+" AssetMonitoringFactDataQuarterAgg z ";
                           whereQuery = whereQuery    + " and z.timeCount  = " +quarter+" and z.year="+year;

                           // To display the VINs that has not communicated for the given time period 
                           //get the Last Day 
                           Calendar cal = Calendar.getInstance();
                           lastDateInPeriod = dateFrmt.format(cal.getTime());
                           //get the first Date of current quarter
                           switch(quarter) 
                           {
                           case 3 : 
                                  startDateInPeriod = year+"-07-01";
                                  break;
                                  // return July 01
                           case 2 :
                                  startDateInPeriod = year+"-04-01";
                                  break;
                                  // return April 01
                           case 1 :
                                  startDateInPeriod = year+"-01-01";
                                  break;
                                  // return Jan 01
                           case 4 : 
                                  startDateInPeriod = year+"-10-01";
                                  break;
                                  // return Oct 01
                           }
                    }

                    else if (period.equalsIgnoreCase("Last Quarter")) 
                    {
                           quarter = prevDate.getQuarter();
                           if(thisDate.getQuarter()==1)
                           {
                                  year = prevDate.getYear();
                           }
                           else
                           {
                                  year = prevDate.getCurrentYear();
                           }
                           fromQuery = fromQuery+" AssetMonitoringFactDataQuarterAgg z ";
                           whereQuery = whereQuery    + " and z.timeCount  = " +quarter+" and z.year="+year;

                           // To display the VINs that has not communicated for the given time period 
                           //get the last day of previous quarter
                           switch(quarter) 
                           {
                           case 3 : 
                                  lastDateInPeriod = year+"-09-30";
                                  break;
                                  // return September 30
                           case 2 :
                                  lastDateInPeriod = year+"-06-30";
                                  break;
                                  // return June 30
                           case 1 :
                                  lastDateInPeriod = year+"-03-31";
                                  break;
                                  // return March 31
                           case 4 : 
                                  lastDateInPeriod = year+"-12-31";
                                  break;
                                  // return December 31
                           }
                           //get the first Date of Previous quarter
                           switch(quarter) 
                           {
                           case 3 : 
                                  startDateInPeriod = year+"-07-01";
                                  break;
                                  // return July 01
                           case 2 :
                                  startDateInPeriod = year+"-04-01";
                                  break;
                                  // return April 01
                           case 1 :
                                  startDateInPeriod = year+"-01-01";
                                  break;
                                  // return Jan 01
                           case 4 : 
                                  startDateInPeriod = year+"-10-01";
                                  break;
                                  // return Oct 01
                           }
                    }

                    else if (period.equalsIgnoreCase("Year")) 
                    {
                           year = thisDate.getYear();
                           fromQuery = fromQuery+" AssetMonitoringFactDataYearAgg z ";
                           whereQuery = whereQuery    + " and z.year= "+year;

                           // To display the VINs that has not communicated for the given time period 
                           //get the Last Day 
                           Calendar cal = Calendar.getInstance();
                           lastDateInPeriod = dateFrmt.format(cal.getTime());
                           //get the First day of current Year
                           startDateInPeriod=year+"-01"+"-01";
                    }

                    else if (period.equalsIgnoreCase("Last Year")) 
                    {
                           year = prevDate.getYear();
                           fromQuery = fromQuery+" AssetMonitoringFactDataYearAgg z ";
                           whereQuery = whereQuery    + " and z.year= "+year;

                           // To display the VINs that has not communicated for the given time period 
                           //get the Last day of previous Year
                           lastDateInPeriod=year+"-12-31";
                           //get the First day of Previous Year 
                           startDateInPeriod=year+"-01"+"-01";
                    }

                    // Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
                    orderByQuery = orderByQuery + " order by d.serial_number, z.lastReported desc ";

              }
              else{

                    DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
                    String fromdateFormatted=null;
                    String todateFormatted=null;

                    try 
                    {      
                           fromdateFormatted= dateFormat.format(dateFormat.parse(fromDate));       
                           todateFormatted = dateFormat.format(dateFormat.parse(toDate));       
                    } 

                    catch (ParseException e) 
                    {
                           // TODO Auto-generated catch block
                           e.printStackTrace();
                    }

                    if(fromdateFormatted==null || todateFormatted==null)
                    {
                           throw new CustomFault("Unparsable Date input for Custom dates");
                    }

                    // To display the VINs that has not communicated for the given time period 
                    startDateInPeriod = fromdateFormatted;
                    lastDateInPeriod = todateFormatted;

                    groupByQuery =" group by z.serialNumber, ten1.tenancy_id ";

                    selectQuery = "select z.machineHours as totalMachineLifeHours," +
                    " sum(u.EngineRunningBand1+u.EngineRunningBand2+u.EngineRunningBand3+u.EngineRunningBand4+u.EngineRunningBand5+u.EngineRunningBand6+u.EngineRunningBand7+u.EngineRunningBand8) as machineHours,"+
                    "z.lastEngineRun,z.Address,d.nick_name,c.tenancyName,z.lastReported, d , c.tenancyId, cu.group_id as machineGroupId, " +
                    " cu.group_name as machineGroupName, ten.tenancy_name as mgTenancyName, ten.tenancy_id as mgTenancy, z.engineStatus as status," +
                     //DefectId:20150216 @ Suprava Delaer As a new parameter Added
                    "c.parentTenancyName,c.tenancyTypeId ";

                    fromQuery =" from AssetCustomGroupMapping h RIGHT OUTER JOIN h.serial_number d  LEFT OUTER JOIN h.group_id cu" +
                    " LEFT OUTER JOIN cu.tenancy_id ten , TenancyEntity ten1, TenancyBridgeEntity tb," +
                    " TenancyDimensionEntity c, AssetMonitoringFactDataDayAgg z, AssetMonitoringFactDataDayAgg u ";
                    //DefectId:20141111 @Suprava Read Time out Exception
              //     " AssetMonitoringDetailEntity e JOIN e.transactionNumber amh ";
                    //DefectId:20141111 @Suprava Read Time out Exception

                    whereQuery = " where ten1.tenancy_id = c.tenancyId and " +
                    " z.tenancyId = c.tenacy_Dimension_Id and tb.parentId in ("+ tenancyIDList + " ) and c.tenancyId = tb.childId" +
                    " and z.serialNumber = d.serial_number " +
                    //     " and d.primary_owner_id = v.account_id " +
                    " and z.serialNumber = u.serialNumber " +
                    " and u.tenancyId=z.tenancyId " +
                    " and z.timeKey = (select max(o.timeKey) from AssetMonitoringFactDataDayAgg o, TenancyDimensionEntity yt" +
                    " where o.serialNumber=z.serialNumber and o.tenancyId = yt.tenacy_Dimension_Id and yt.tenancyId = tb.childId " +
                    //" where o.serialNumber=z.serialNumber and o.tenancyId = yt.tenacy_Dimension_Id and yt.tenancyId in ("+ tenancyIDList + " ) " +
                    " and o.timeKey >='"+fromdateFormatted+"' and o.timeKey <= '"+todateFormatted+"')" +
                    //DefectId:20141111 @Suprava Read Time out Exception
                    " and amh.transactionNumber in("+transactionNumberAsStringList+")"+
                    " and e.parameterId=18 "+
                    " and amh.transactionNumber=e.transactionNumber " +
                    " and z.serialNumber = amh.serialNumber " +
                    //DefectId:20141111
                    " and u.timeKey between '"+fromdateFormatted+"' and '"+todateFormatted+"'" ;
                    //DefectId:20150216 @ Suprava Delaer As a new parameter Added
                    //" and c.parentTenancyId=ten1.parent_tenancy_id ";

                    groupByQuery = groupByQuery +" , cu.group_id ";

                    // To take the latest/Last reported row from factAgg tables
                    orderByQuery = orderByQuery +  " order by d.serial_number , z.lastReported desc";


              }
              if (!(customAssetGroupIdList == null || customAssetGroupIdList.isEmpty())) 
              {
                    String customAssetGroupStringList = conversionObj.getIntegerListString(customAssetGroupIdList).toString();
                    whereQuery = whereQuery+ " and cu.group_id in ("+ customAssetGroupStringList + ")";
              }

              if ((!(machineProfileIdList == null || machineProfileIdList.isEmpty()))    || (!(modelList == null || modelList.isEmpty()))) 
              {
                    fromQuery = fromQuery+ " , AssetClassDimensionEntity b ";
                    whereQuery = whereQuery    + " and z.assetClassDimensionId = b.assetClassDimensionId";
              }

              if (!(machineProfileIdList == null || machineProfileIdList.isEmpty())) 
              {
                    String machineProfileIdStringList = conversionObj.getIntegerListString(machineProfileIdList).toString();
                    whereQuery = whereQuery + " and b.assetGroupId in ( "+ machineProfileIdStringList + ") ";

              }                    

              if (!((modelList == null) || (modelList.isEmpty()))) 
              {
                    String modelIdListStringList = conversionObj.getIntegerListString(modelList).toString();
                    whereQuery = whereQuery + " and b.assetTypeId in ( "+ modelIdListStringList + " )";

              }

              finalQuery = selectQuery + fromQuery + whereQuery + groupByQuery + orderByQuery ;

              Query qury = session4.createQuery(finalQuery);
              Iterator rr = qury.list().iterator();
              Object[] result = null;

              List<String> serialNumberList = new LinkedList<String>();
              while(rr.hasNext()){

                    implObj = new MachineHoursReportImpl();
                    serialNumber=null;

                    result = (Object[]) rr.next();

                    AssetEntity asset =null;
                    TenancyEntity tenancyEntity =null;
                    if(result[7]!=null)
                    {                                 
                           asset = (AssetEntity)result[7];
                           serialNumber = asset.getSerial_number().getSerialNumber();

                    }

                    if(serialNumberList.contains(serialNumber))
                    {
                           continue;
                    }
                    implObj.setSerialNumber(asset.getSerial_number().getSerialNumber());


                    if(result[0]!=null)
                    {
                           implObj.setTotalMachineHours(Double.valueOf(df2.format((Double) result[0])));
                    }                          

                    if(result[1]!=null)
                    {
                           implObj.setMachineHours(Double.valueOf(df2.format((Double) result[1])));              
                    }

                    if(result[2]!=null)
                    {
                           implObj.setLastEngineRun((Timestamp) result[2]);
                    }      

                    if(result[3]!=null)
                    {
                           implObj.setLocation(result[3].toString());             
                    }

                    if(result[4]!=null)
                    {
                           implObj.setMachineName(result[4].toString());
                    }

                    if(result[5]!=null)
                    {
                           implObj.setTenancyName(result[5].toString());
                    }      

                    if(result[6]!=null)
                    {
                           implObj.setLastReported((Timestamp) result[6]);
                    }      


                    implObj.setTenancyId((Integer)result[8]);

                    if(asset!=null)
                    {
                           if(asset.getProductId()!=null && asset.getProductId().getAssetGroupId()!=null)
                           {
                                  implObj.setMachineProfileId(asset.getProductId().getAssetGroupId().getAsset_group_id());
                                  implObj.setMachineProfileName(asset.getProductId().getAssetGroupId().getAsset_group_name());
                           }

                           if(asset.getProductId()!=null && asset.getProductId().getAssetTypeId()!=null)
                           {
                                  implObj.setModelId(asset.getProductId().getAssetTypeId().getAsset_type_id());
                                  implObj.setModelName(asset.getProductId().getAssetTypeId().getAsset_type_name());
                           }


                    }
                    if(result[13]!=null)
                    {
                           implObj.setStatus((String)result[13]);
                           status=(String)result[13];
                           if(status.equalsIgnoreCase("0"))
                                  {
                                         totalMachinesDormant=totalMachinesDormant+1;
                                  }
                                  else
                                  {
                                         totalMachinesOperational=totalMachinesOperational+1;
                                  }
                    }

                    //DefectId:20150220 @ Suprava Delaer As a new parameter Added
                    if(result[15]!=null)
                                  {
                                         int tenancyTypeId =(Integer) result[15];
                                         //If the Machine is with customer Get the parentTeancyId
                                         if(tenancyTypeId==4)
                                         {
                                                //String partentTenancyName =(String)result[14];
                                                implObj.setDealerName(result[14].toString());
                                         }
                                         //If the Machine is with Dealer
                                         else if(tenancyTypeId==3) 
                                         {
                                                if(result[5]!=null)
                                                {
                                                //String Dealername =(String)result[5];
                                                implObj.setDealerName(result[5].toString());
                                         }
                                         }
                                         else
                                         {
                                                implObj.setDealerName("No Dealer Tagging");
                                         }
                                  
                                  }
                    //DefectID:1406 - Rajani Nagaraju - 20131029 - To return Report Totals
                    if(!(serialNumberList.contains(serialNumber)))
                    {
                           totalMachineHoursSumm = totalMachineHoursSumm+(Double.valueOf(df2.format((Double) result[0])));
                           machineHoursSumm = machineHoursSumm+(Double.valueOf(df2.format((Double) result[1])));
                           //For Machine Activity Report 1.Machines Working less than min threshold and 2. Machines working more than Max. threshold
                           if(minThreshold>=0 && maxThreshold>=0)
                           {
                                  double machineHoursInPeriod = (Double) result[1];
                                  int machineHrInPeriod = (int)machineHoursInPeriod;
                                  if(machineHrInPeriod < minThreshold)
                                         totalMachineswithMinThr= totalMachineswithMinThr+1;
                                  else if (machineHrInPeriod > maxThreshold)
                                         totalMachineswithMaxThr= totalMachineswithMaxThr+1;

                           }
                    }

                    //DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
                    //Get the List of MachineGroup under the Login Tenancy to which the machine belongs to 
                    if(isGroupingOnAssetGroup)
                    {
                           Query mgQuery=null;
                           if (!(customAssetGroupIdList == null || customAssetGroupIdList.isEmpty())) 
                           {
                                  String customAssetGroupStringList = conversionObj.getIntegerListString(customAssetGroupIdList).toString();
                                  mgQuery = session4.createQuery(" select a from AssetCustomGroupMapping a, CustomAssetGroupEntity b " +
                                                //Smitha:DefectID:20131220...to get the VIN's belonging to the machine groups under that tenancy ID
                                                "where serial_number='"+serialNumber+"' and a.group_id=b.group_id and b.level=2 and b.active_status=1 and b.tenancy_id in ("+loginTenIdListString+")" +
                                                " and b.group_id in ("+customAssetGroupStringList+")");
                           }

                           else
                           {
                                  mgQuery = session4.createQuery(" select a from AssetCustomGroupMapping a, CustomAssetGroupEntity b " +
                                                //Smitha:DefectID:20131220...to get the VIN's belonging to the machine groups under that tenancy ID
                                                "where serial_number='"+serialNumber+"' and a.group_id=b.group_id and b.level=2 and b.active_status=1 and b.tenancy_id in ("+loginTenIdListString+")");
                           }
                           Iterator mgItr = mgQuery.list().iterator();
                           int firstIteration =0;
                           while(mgItr.hasNext())
                           {
                                  AssetCustomGroupMapping mgVinMapping = (AssetCustomGroupMapping)mgItr.next();
                                  if(firstIteration==0)
                                  {
                                         firstIteration=1;
                                         implObj.setMachineGroupId(mgVinMapping.getGroup_id().getGroup_id());
                                         implObj.setMachineGroupName(mgVinMapping.getGroup_id().getGroup_name());
                                         listImplObj.add(implObj);
                                  }
                                  else
                                  {
                                         MachineHoursReportImpl newimplObj = new MachineHoursReportImpl();
                                         newimplObj.setSerialNumber(serialNumber);
                                         newimplObj.setTotalMachineHours(Double.valueOf(df2.format(implObj.getTotalMachineHours())));
                                         newimplObj.setMachineHours(Double.valueOf(df2.format(implObj.getMachineHours()))); 
                                         newimplObj.setLastEngineRun(implObj.getLastEngineRun());
                                         newimplObj.setLocation(implObj.getLocation());         
                                         newimplObj.setMachineName(implObj.getMachineName());
                                         newimplObj.setTenancyName(implObj.getTenancyName());
                                         newimplObj.setLastReported(implObj.getLastReported());
                                         newimplObj.setTenancyId(implObj.getTenancyId());
                                         newimplObj.setMachineGroupId(mgVinMapping.getGroup_id().getGroup_id());
                                         newimplObj.setMachineGroupName(mgVinMapping.getGroup_id().getGroup_name());
                                         newimplObj.setMachineProfileId(implObj.getMachineProfileId());
                                         newimplObj.setMachineProfileName(implObj.getMachineProfileName());
                                         newimplObj.setModelId(implObj.getModelId());
                                         newimplObj.setModelName(implObj.getModelName());
                                         newimplObj.setStatus(implObj.getStatus());
                                         newimplObj.setDurationInCurrentStatus(implObj.getDurationInCurrentStatus());
                                         newimplObj.setDealerName(implObj.getDealerName());
                                         listImplObj.add(newimplObj);
                                  }
                           }

                           if(firstIteration==0)
                           {
                                  listImplObj.add(implObj);
                           }
                    }

                    else
                    {
                           listImplObj.add(implObj);
                    }


                    serialNumberList.add(serialNumber);

              }

              //-------------------------------------------------------------------------------------------------------------------
              //DefectId: DF20131018 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period 
              Query ownerListQuery = session4.createQuery(" select distinct c.serialNumber " +
                           " from TenancyBridgeEntity a, AccountTenancyMapping b, AssetAccountMapping c " +
                           " where a.childId= b.tenancy_id " +
                           " and b.account_id= c.accountId " +
                           " and a.parentId in ("+tenancyIDList+") and" +
                           " ( (c.ownershipStartDate between '"+startDateInPeriod+"' and '"+lastDateInPeriod+"') OR " +
                           "   (c.ownershipStartDate = ( select max(y.ownershipStartDate) from AssetAccountMapping y " +
                           " where y.serialNumber= c.serialNumber" +
                           " and y.ownershipStartDate <='"+startDateInPeriod+"')" +
                           "    )" +
              " )");
              Iterator ownerListItr = ownerListQuery.list().iterator();
              List<String> actualOwnerVINList = new LinkedList<String>();
              while(ownerListItr.hasNext())
              {
                    AssetEntity assetList = (AssetEntity)ownerListItr.next();
                    actualOwnerVINList.add(assetList.getSerial_number().getSerialNumber());
              }

              //Get only the List of VINs which has not communicated for the Given period
              actualOwnerVINList.removeAll(serialNumberList);
              String actualOwnerVinListString = conversionObj.getStringList(actualOwnerVINList).toString();
              //DefectId:20141111 @Suprava Read Time out Changes
              List<Integer> transactionNumberList1 = new LinkedList<Integer>();
              int transactionNumber1 =0;
              String serial_num1 = null;
              Query query4 = session4
              .createQuery("select max(a.transactionNumber),a.serialNumber from AssetMonitoringHeaderEntity a where a.serialNumber in("+actualOwnerVinListString+") and a.createdTimestamp <= '"+startDateInPeriod2+"' group by a.serialNumber");
              Iterator transactionNumItr1 = query4.list().iterator();
              while (transactionNumItr1.hasNext())
              {
                    AssetEntity asset =null;
                    //System.out.println("Inside 2nd while");
                    Object[] result1 = (Object[]) transactionNumItr1.next();
                    if (result1[0] != null) {
                           transactionNumber1 = (Integer)result1[0];
                           transactionNumberList1.add(transactionNumber1);
                           //infoLogger.info("transactionNumberList"+transactionNumberList);
                    }
              }
              String transactionNumberAsStringList1 = conversionObj.getIntegerListString(transactionNumberList1).toString();
              //DefectId:20141111 en
              //groupByQuery =" group by z.serialNumber ";

              // To take the latest/Last reported row from factAgg tables
              groupByQuery =" group by z.serialNumber, ten1.tenancy_id ";
              orderByQuery = " order by d.serial_number, z.lastReported desc ";

              selectQuery = " select z.machineHours as totalMachineLifeHours, ten.tenancy_name as mgTenancyName ," +
              " z.lastEngineRun,z.Address,d.nick_name,c.tenancyName,z.lastReported,  " +
              " d , c.tenancyId, cu.group_id as machineGroupId," +
              " cu.group_name as machineGroupName, ten.tenancy_id as mgTenancy," +
              //DefectId:20150216 @ Suprava Delaer As a new parameter Added
              "c.parentTenancyName,c.tenancyTypeId ";

              fromQuery = " from AssetCustomGroupMapping h RIGHT OUTER JOIN h.serial_number d  LEFT OUTER JOIN h.group_id cu " +
              " LEFT OUTER JOIN cu.tenancy_id ten , TenancyEntity ten1," +
              " TenancyDimensionEntity c, AssetMonitoringFactDataDayAgg z " ;
              //DefectId:20141111 @Suprava Read Time out Exception
              //" AssetMonitoringDetailEntity e JOIN e.transactionNumber amh ";
              //DefectId:20141111

              whereQuery = " where ten1.tenancy_id = c.tenancyId and " +
              " z.tenancyId = c.tenacy_Dimension_Id and z.serialNumber = d.serial_number " +
              " and z.serialNumber in ("+actualOwnerVinListString+") " +
              " and z.timeKey = ( select max(p.timeKey) from AssetMonitoringFactDataDayAgg p where p.serialNumber = z.serialNumber " +
              //DefectId:20141111 @Suprava Read Time out Exception
              " and amh.transactionNumber in("+transactionNumberAsStringList1+")"+
              " and e.parameterId=18 "+
              " and amh.transactionNumber=e.transactionNumber " +
              " and z.serialNumber = amh.serialNumber " +
              //DefectId:20141111
              " and p.timeKey <= '"+startDateInPeriod+"' )";
              //DefectId:20150216 @ Suprava Delaer As a new parameter Added
              //" and c.parentTenancyId=ten1.parent_tenancy_id ";


              if (!(customAssetGroupIdList == null || customAssetGroupIdList.isEmpty())) 
              {
                    String customAssetGroupStringList = conversionObj.getIntegerListString(customAssetGroupIdList).toString();
                    whereQuery = whereQuery+ " and cu.group_id in ("+ customAssetGroupStringList + ")";
              }

              if ((!(machineProfileIdList == null || machineProfileIdList.isEmpty()))    || (!(modelList == null || modelList.isEmpty()))) 
              {
                    fromQuery = fromQuery+ " , AssetClassDimensionEntity b ";
                    whereQuery = whereQuery    + " and z.assetClassDimensionId = b.assetClassDimensionId";
              }


              if (!(machineProfileIdList == null || machineProfileIdList.isEmpty())) 
              {
                    String machineProfileIdStringList = conversionObj.getIntegerListString(machineProfileIdList).toString();
                    whereQuery = whereQuery + " and b.assetGroupId in ( "+ machineProfileIdStringList + ") ";

              }                    

              if (!((modelList == null) || (modelList.isEmpty()))) 
              {
                    String modelIdListStringList = conversionObj.getIntegerListString(modelList).toString();
                    whereQuery = whereQuery + " and b.assetTypeId in ( "+ modelIdListStringList + " )";

              }

              //DefectID:1406 - Rajani Nagaraju - 20131028 - MachineGrouping issue
              if(! (actualOwnerVINList==null || actualOwnerVINList.isEmpty()))
              {

                    //finalQuery = selectQuery + fromQuery+ whereQuery + groupByQuery + " order by d.serial_number, ten.tenancy_id ";;
                    finalQuery = selectQuery + fromQuery+ whereQuery + groupByQuery + orderByQuery;
                    Iterator vinListItr = session4.createQuery(finalQuery).list().iterator();
                    result =null;
                    serialNumberList = new LinkedList<String>();

                    while(vinListItr.hasNext())
                    {
                           implObj = new MachineHoursReportImpl();
                           serialNumber=null;
                           result = (Object[]) vinListItr.next();

                           AssetEntity asset =null;
                           TenancyEntity tenancyEntity =null;
                           if(result[7]!=null)
                           {                                 
                                  asset = (AssetEntity)result[7];
                                  serialNumber = asset.getSerial_number().getSerialNumber();
                           }

                           if(serialNumberList.contains(serialNumber))
                           {
                                  continue;
                           }
                           implObj.setSerialNumber(asset.getSerial_number().getSerialNumber());

                           if(result[0]!=null)
                           {
                                  implObj.setTotalMachineHours(Double.valueOf(df2.format((Double)result[0])));
                           }

                           if(result[2]!=null)
                           {
                                  implObj.setLastEngineRun((Timestamp) result[2]);
                           }      

                           if(result[3]!=null)
                           {
                                  implObj.setLocation(result[3].toString());             
                           }

                           if(result[4]!=null)
                           {
                                  implObj.setMachineName(result[4].toString());
                           }

                           if(result[5]!=null)
                           {
                                  implObj.setTenancyName(result[5].toString());
                           }      

                           if(result[6]!=null)
                           {
                                  implObj.setLastReported((Timestamp) result[6]);
                           }      


                           implObj.setTenancyId((Integer)result[8]);


                           if(asset!=null)
                           {
                                  if(asset.getProductId()!=null && asset.getProductId().getAssetGroupId()!=null)
                                  {
                                         implObj.setMachineProfileId(asset.getProductId().getAssetGroupId().getAsset_group_id());
                                         implObj.setMachineProfileName(asset.getProductId().getAssetGroupId().getAsset_group_name());
                                  }

                                  if(asset.getProductId()!=null && asset.getProductId().getAssetTypeId()!=null)
                                  {
                                         implObj.setModelId(asset.getProductId().getAssetTypeId().getAsset_type_id());
                                         implObj.setModelName(asset.getProductId().getAssetTypeId().getAsset_type_name());
                                  }


                           }
                           implObj.setStatus("NA");
                           
                           //DefectId:20150220 @ Suprava Delaer As a new parameter Added
                           if(result[13]!=null)
                                         {
                                                int tenancyTypeId =(Integer) result[13];
                                                //If the Machine is with customer Get the parentTeancyId
                                                if(tenancyTypeId==4)
                                                {
                                                //     String parentTeancyname =(String)result[12];
                                                       implObj.setDealerName(result[12].toString());
                                                }
                                                //If the Machine is with Dealer
                                                else if(tenancyTypeId==3) 
                                                {
                                                       if(result[5]!=null)
                                                       {
                                                       //String Dealername =(String)result[5];
                                                       implObj.setDealerName(result[5].toString());
                                                }
                                                }
                                                else
                                                {
                                                       implObj.setDealerName("No Dealer Tagging");
                                                }
                                         
                                         }
                                         
                           //DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
                           //TenancyEntity primaryOwnerTenancy = (TenancyEntity)result[1];
                                int primaryOwnerAcc = asset.getPrimary_owner_id();
                           int primaryOwnerTenancy=0;
                           Query primaryTenQuery = session4.createQuery(" from AccountTenancyMapping where account_id='"+primaryOwnerAcc+"'");
                           Iterator primaryTenItr = primaryTenQuery.list().iterator();
                           while(primaryTenItr.hasNext())
                           {
                                  AccountTenancyMapping accountTen = (AccountTenancyMapping)primaryTenItr.next();
                                  primaryOwnerTenancy = accountTen.getTenancy_id().getTenancy_id();
                           }
                           
                           //DefectID:1406 - Rajani Nagaraju - 20131029 - To return Report Totals

                           if(result[12]!=null)
                           {
                                  implObj.setStatus(result[12].toString());
                           }

                           //DefectID:1406 - Rajani Nagaraju - 20131029 - To return Report Totals
                           if(!(serialNumberList.contains(serialNumber)))
                           {
                                  totalMachineHoursSumm = totalMachineHoursSumm+(Double.valueOf(df2.format((Double) result[0])));
                                  //machineHoursSumm cannot be added since the machine has not communicated in the given period
                                  //machineHoursSumm = machineHoursSumm+(Double) result[1];

                                  //DefectId: 20131220 - Rajani Nagaraju - To sum the yellow threshold even for the machines that has not communicated
                                  //For Machine Activity Report 1.Machines Working less than min threshold and 2. Machines working more than Max. threshold
                                  if(minThreshold>=0 && maxThreshold>=0)
                                  {
                                         int machineHrInPeriod = 0;
                                         if(machineHrInPeriod < minThreshold)
                                                totalMachineswithMinThr= totalMachineswithMinThr+1;
                                         else if (machineHrInPeriod > maxThreshold)
                                                totalMachineswithMaxThr= totalMachineswithMaxThr+1;

                                  }
                           }

                           //Get the List of MachineGroup under the Login Tenancy to which the machine belongs to 
                           //DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
                           if(isGroupingOnAssetGroup)
                           {

                                  Query mgQuery=null;
                                  if (!(customAssetGroupIdList == null || customAssetGroupIdList.isEmpty())) 
                                  {
                                         String customAssetGroupStringList = conversionObj.getIntegerListString(customAssetGroupIdList).toString();
                                         mgQuery = session4.createQuery(" select a from AssetCustomGroupMapping a, CustomAssetGroupEntity b " +
                                                       //Smitha:DefectID:20131220...to get the VIN's belonging to the machine groups under that tenancy ID
                                                      "where serial_number='"+serialNumber+"' and a.group_id=b.group_id and b.level=2 and b.active_status=1 and b.tenancy_id in ("+loginTenIdListString+")" +
                                                       " and b.group_id in ("+customAssetGroupStringList+")");
                                  }
                                  else
                                  {
                                         mgQuery = session4.createQuery(" select a from AssetCustomGroupMapping a, CustomAssetGroupEntity b " +
                                                       //Smitha:DefectID:20131220...to get the VIN's belonging to the machine groups under that tenancy ID
                                                       "where serial_number='"+serialNumber+"' and a.group_id=b.group_id and b.level=2 and b.active_status=1 and b.tenancy_id in ("+loginTenIdListString+")");
                                  }
                                  Iterator mgItr = mgQuery.list().iterator();
                                  int firstIteration =0;
                                  while(mgItr.hasNext())
                                  {
                                         AssetCustomGroupMapping mgVinMapping = (AssetCustomGroupMapping)mgItr.next();
                                         if(firstIteration==0)
                                         {
                                                firstIteration=1;
                                                implObj.setMachineGroupId(mgVinMapping.getGroup_id().getGroup_id());
                                                implObj.setMachineGroupName(mgVinMapping.getGroup_id().getGroup_name());
                                                listImplObj.add(implObj);
                                         }
                                         else
                                         {
                                                MachineHoursReportImpl newimplObj = new MachineHoursReportImpl();
                                                newimplObj.setSerialNumber(serialNumber);
                                                newimplObj.setTotalMachineHours(implObj.getTotalMachineHours());
                                                newimplObj.setMachineHours(implObj.getMachineHours()); 
                                                newimplObj.setLastEngineRun(implObj.getLastEngineRun());
                                                newimplObj.setLocation(implObj.getLocation());              
                                                newimplObj.setMachineName(implObj.getMachineName());
                                                newimplObj.setTenancyName(implObj.getTenancyName());
                                                newimplObj.setLastReported(implObj.getLastReported());
                                                newimplObj.setTenancyId(implObj.getTenancyId());
                                                newimplObj.setMachineGroupId(mgVinMapping.getGroup_id().getGroup_id());
                                                newimplObj.setMachineGroupName(mgVinMapping.getGroup_id().getGroup_name());
                                                newimplObj.setMachineProfileId(implObj.getMachineProfileId());
                                                newimplObj.setMachineProfileName(implObj.getMachineProfileName());
                                                newimplObj.setModelId(implObj.getModelId());
                                                newimplObj.setModelName(implObj.getModelName());
                                                newimplObj.setStatus(implObj.getStatus());
                                                newimplObj.setDurationInCurrentStatus(implObj.getDurationInCurrentStatus());
                                                newimplObj.setDealerName(implObj.getDealerName());
                                                listImplObj.add(newimplObj);
                                         }
                                  }

                                  if(firstIteration==0)
                                  {
                                         listImplObj.add(implObj);
                                  }
                           }

                           else
                            {
                                  listImplObj.add(implObj);
                           }

                    }
                    serialNumberList.add(serialNumber);
                    listImplObj.add(implObj);


              }
              //DefectID:1406 - Rajani Nagaraju - 20131029 - To return Report Totals
              implObj = new MachineHoursReportImpl();
              implObj.setSerialNumber("Summary");
              implObj.setTotalMachineHours(Double.valueOf(df2.format((Double) totalMachineHoursSumm)));
              implObj.setMachineHours(Double.valueOf(df2.format((Double) machineHoursSumm)));       
              //In the Format No.Of Machines Operational, No. Of Machines Dormant
              implObj.setStatus(totalMachinesOperational+","+totalMachinesDormant);
              //For Machine Activity Report
              //implObj.setMachineName(totalMachineswithMinThr+","+totalMachineswithMaxThr);
              implObj.setMachineProfileName(totalMachineswithMinThr+","+totalMachineswithMaxThr);
              listImplObj.add(implObj);
       } 

       catch (Exception e) 
       {
              e.printStackTrace();
              fLogger.fatal("Exception :" + e);
       }

       finally 
       {
              if (session4.getTransaction().isActive()) 
              {
                    session4.getTransaction().commit();
              }

              if (session4.isOpen()) 
              {
                    session4.flush();
                    session4.close();
              }

       }

       return listImplObj;
}*/

	
	//defectId: - S Suresh - 20160331 - Query tweaking for custom dates 
	//************************************************** Get the Usage Details of the Machine ****************************************
	/** DefectID:1383 - Rajani Nagaraju - 20130930 - Query modification to return correct resultset 
	 *  DefectId: - Rajani Nagaraju - 20131011 - CustomDate Implementation 
	 *  DefectId: - 1406 - 20131028 - Rajani Nagaraju - Resolution to MachineGrouping Issue(Machine belonging to a machine Group of other tenancies 
	 *                                              should be shown as no Machine Grouping) and ReportTotalsIssue ( To return Report totals at summary from service)
	*  DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
	*     method to get the machine hours report
	*  @param period,customAssetGroupIdList,machineProfileIdList,tenancyIdList,modelList
	*  @return list
	**/
	//Added custom Dates by Juhi on 13-August-2013
	public List<MachineHoursReportImpl> getMachineHoursReportService(String fromDate,String toDate,String period, 
	              List<Integer> customAssetGroupIdList,List<Integer> machineProfileIdList, 
	              List<Integer> tenancyIdList,List<Integer> modelList, 
	              boolean isGroupingOnAssetGroup, List<Integer> loginTenancyIdList,
	              int minThreshold, int maxThreshold)
	              {
	       //DefectId:20141011 @Suprava New Logic sn
	       MachineHoursReportImpl implObj = null;
	       List<MachineHoursReportImpl> listImplObj = new LinkedList<MachineHoursReportImpl>();
	       Logger fLogger = FatalLoggerClass.logger;
	       //Logger bLogger = BusinessErrorLoggerClass.logger;
	       Logger iLogger = InfoLoggerClass.logger;
	       Session session4 = HibernateUtil.getSessionFactory().openSession();
	       session4.beginTransaction();

	       try 
	       {
	              String selectQuery = null;
	              String fromQuery = null;
	              String whereQuery = null;
	              String finalQuery = null;
	              String serialNumber=null;
	              String status=null;
	              String currentStatus=null;
	              Timestamp transactionTime2=null;
	              long Duration_In_Current_Status=(long)0;
	              String Query=null;

	              //DefectID:1406 - Rajani Nagaraju - 20131029 - To return Report Totals
	              double totalMachineHoursSumm =0.0D;
	              double machineHoursSumm=0.0D;
	              int totalMachinesOperational=0;
	              int totalMachinesDormant=0;
	              int totalMachineswithMinThr =0;
	              int totalMachineswithMaxThr =0;

	              DecimalFormat df2 = new DecimalFormat("###.#");
	              SimpleDateFormat dateFrmt = new SimpleDateFormat("yyyy-MM-dd");
	              String lastDateInPeriod=null;
	              String lastDateInPeriod1=null;
	              String startDateInPeriod=null;
	              Date startDateInPeriod1=null;
	              String startDateInPeriod2=null;
	              String fromdateFormatted1=null;
	              Date todateFormatted1=null;

	              SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
	              sdf.setTimeZone(TimeZone.getTimeZone("GMT"));
	              String timeStamp = sdf.format(Calendar.getInstance().getTime());
	              Timestamp sysDate=Timestamp.valueOf(timeStamp);


	              Calendar c = Calendar.getInstance();
	              int currentYear = c.get(Calendar.YEAR);
	              int year =0;int week = 0; int quarter = 0;int month =0;
	              DateUtil dateUtil1 = new DateUtil();
	              DateUtil thisDate =dateUtil1.getCurrentDateUtility(new Date());
	              DateUtil dateUtil2 = new DateUtil();
	              DateUtil prevDate = dateUtil2.getPreviousDateUtility(new Date());
	              if(period!=null){
	                    if (period.equalsIgnoreCase("Week")) 
	                    {
	                           week = thisDate.getWeek();
	                           year = thisDate.getYear();
	                           //To display the VINs that has not communicated for the given time period 
	                           //get the Last Day 
	                            Calendar cal = Calendar.getInstance();
	                           lastDateInPeriod = dateFrmt.format(cal.getTime());
	                           lastDateInPeriod1 = lastDateInPeriod +" 23:59:59";
	                           //System.out.println("lastDateInPeriod ***"+lastDateInPeriod1);
	                           //get the first day of the week
	                           cal.set(Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek());
	                           startDateInPeriod=  dateFrmt.format(cal.getTime());
	                           startDateInPeriod=startDateInPeriod+" 00:00:00";
	                           //System.out.println("startDateInPeriod ***"+startDateInPeriod);

	                    }

	                    else if (period.equalsIgnoreCase("Last Week")) 
	                    {
	                           week =  prevDate.getWeek();
	                           if(thisDate.getWeek()==1)
	                           {
	                                  year = prevDate.getYear();
	                           }
	                           else
	                           {
	                                  year = prevDate.getCurrentYear();
	                           }
	                           //get the Last Day of Previous Week
	                           Calendar cal = Calendar.getInstance();
	                           int i = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
	                           cal.add(Calendar.DATE, -i - 7);
	                           cal.add(Calendar.DATE, 6);
	                           lastDateInPeriod = dateFrmt.format(cal.getTime());
	                           lastDateInPeriod1 = lastDateInPeriod +" 23:59:59";
	                           //System.out.println("lastDateInPeriod ***"+lastDateInPeriod1);
	                           //get the First Day of Previous Week
	                           cal = Calendar.getInstance();
	                           int j = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
	                           cal.add(Calendar.DATE, -j - 7);
	                           cal.set(Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek());
	                           startDateInPeriod=  dateFrmt.format(cal.getTime());
	                           startDateInPeriod=startDateInPeriod+" 00:00:00";
	                           //System.out.println("startDateInPeriod ***"+startDateInPeriod);
	                    }

	                    else if (period.equalsIgnoreCase("Month")) 
	                    {
	                           month =  thisDate.getMonth();
	                           year = thisDate.getYear();
	                           //get the Last Day 
	                           Calendar cal = Calendar.getInstance();
	                           lastDateInPeriod = dateFrmt.format(cal.getTime());
	                           lastDateInPeriod1 = lastDateInPeriod +" 23:59:59";
	                           //System.out.println("lastDateInPeriod ***"+lastDateInPeriod1);
	                           //get the First Day of current Month
	                           String mon = month+"";
	                           if(mon.length()<2)
	                                  mon="0"+mon;
	                           startDateInPeriod=year+"-"+mon+"-"+"01";
	                           startDateInPeriod=startDateInPeriod+" 00:00:00";
	                           //System.out.println("startDateInPeriod ***"+startDateInPeriod);
	                    }

	                    else if (period.equalsIgnoreCase("Last Month")) 
	                    {
	                           month =  prevDate.getMonth();
	                           if(thisDate.getMonth()==1)
	                           {
	                                  year = prevDate.getYear();
	                           }
	                           else
	                           {
	                                  year = prevDate.getCurrentYear();
	                           }
	                           //Get the Last Day of previous Month
	                           Calendar cal = Calendar.getInstance();
	                           cal.set(Calendar.DATE, 1);
	                           cal.add(Calendar.DAY_OF_MONTH, -1);
	                           lastDateInPeriod = dateFrmt.format(cal.getTime());
	                           lastDateInPeriod1 = lastDateInPeriod +" 23:59:59";
	                           //System.out.println("lastDateInPeriod ***"+lastDateInPeriod1);
	                           //get the First Day of Previous Month
	                           String mon = month+"";
	                           if(mon.length()<2)
	                                  mon="0"+mon;
	                           startDateInPeriod=year+"-"+mon+"-"+"01";
	                           startDateInPeriod=startDateInPeriod+" 00:00:00";
	                           //System.out.println("startDateInPeriod2 ***"+startDateInPeriod);
	                    }

	                    else if (period.equalsIgnoreCase("Quarter")) 
	                    {
	                           quarter =  thisDate.getQuarter();
	                           year = thisDate.getYear();
	                           //get the Last Day 
	                           Calendar cal = Calendar.getInstance();
	                           lastDateInPeriod = dateFrmt.format(cal.getTime());
	                           lastDateInPeriod1 = lastDateInPeriod +" 23:59:59";
	                           //System.out.println("lastDateInPeriod ***"+lastDateInPeriod1);
	                           //get the first Date of current quarter
	                           switch(quarter) 
	                           {
	                           case 3 : 
	                                  startDateInPeriod = year+"-07-01";
	                                  startDateInPeriod=startDateInPeriod+" 00:00:00";
	                                  //System.out.println("startDateInPeriod ***"+startDateInPeriod);
	                                  break;
	                                  // return July 01
	                           case 2 :
	                                  startDateInPeriod = year+"-04-01";
	                                  startDateInPeriod=startDateInPeriod+" 00:00:00";
	                                  //System.out.println("startDateInPeriod ***"+startDateInPeriod);
	                                  break;
	                                  // return April 01
	                           case 1 :
	                                  startDateInPeriod = year+"-01-01";
	                                  startDateInPeriod=startDateInPeriod+" 00:00:00";
	                                  //System.out.println("startDateInPeriod ***"+startDateInPeriod);
	                                  break;
	                                  // return Jan 01
	                           case 4 : 
	                                  startDateInPeriod = year+"-10-01";
	                                  startDateInPeriod=startDateInPeriod+" 00:00:00";
	                                  //System.out.println("startDateInPeriod ***"+startDateInPeriod);
	                                  break;
	                                  // return Oct 01
	                           }
	                    }

	                    else if (period.equalsIgnoreCase("Last Quarter")) 
	                    {
	                           Calendar cal = Calendar.getInstance();
	                           quarter = prevDate.getQuarter();
	                           if(thisDate.getQuarter()==1)
	                           {
	                                  year = prevDate.getYear();
	                           }
	                           else
	                           {
	                                  year = prevDate.getCurrentYear();
	                           }
	                           //get the last day of previous quarter
	                           switch(quarter) 
	                           {
	                           case 3 : 
	                                  lastDateInPeriod = year+"-09-30";
	                                  lastDateInPeriod1 = lastDateInPeriod +" 23:59:59";
	                                  //System.out.println("lastDateInPeriod ***"+lastDateInPeriod1);
	                                  break;
	                                  // return September 30
	                           case 2 :
	                                  lastDateInPeriod = year+"-06-30";
	                                  lastDateInPeriod1 = lastDateInPeriod +" 23:59:59";
	                                  //System.out.println("lastDateInPeriod ***"+lastDateInPeriod1);
	                                  break;
	                                  // return June 30
	                           case 1 :
	                                  lastDateInPeriod = year+"-03-31";
	                                  lastDateInPeriod1 = lastDateInPeriod +" 23:59:59";
	                                  //System.out.println("lastDateInPeriod ***"+lastDateInPeriod1);
	                                  break;
	                                  // return March 31
	                           case 4 : 
	                                  lastDateInPeriod = year+"-12-31";
	                                  lastDateInPeriod1 = lastDateInPeriod +" 23:59:59";
	                                  //System.out.println("lastDateInPeriod ***"+lastDateInPeriod1);
	                                  break;
	                                  // return December 31
	                           }
	                           //get the first Date of Previous quarter
	                           switch(quarter) 
	                           {
	                           case 3 : 
	                                  startDateInPeriod = year+"-07-01";
	                                  startDateInPeriod=startDateInPeriod+" 00:00:00";
	                                  //System.out.println("startDateInPeriod2 ***"+startDateInPeriod2);
	                                  break;
	                                  // return July 01
	                           case 2 :
	                                  startDateInPeriod = year+"-04-01";
	                                  startDateInPeriod=startDateInPeriod+" 00:00:00";
	                                  //System.out.println("startDateInPeriod2 ***"+startDateInPeriod2);
	                                  break;
	                                  // return April 01
	                           case 1 :
	                                  startDateInPeriod = year+"-01-01";
	                                  startDateInPeriod=startDateInPeriod+" 00:00:00";
	                                  //System.out.println("startDateInPeriod2 ***"+startDateInPeriod2);
	                                  break;
	                                  // return Jan 01
	                           case 4 : 
	                                  startDateInPeriod = year+"-10-01";
	                                  startDateInPeriod=startDateInPeriod+" 00:00:00";
	                                  //System.out.println("startDateInPeriod ***"+startDateInPeriod);
	                                  break;
	                                  // return Oct 01
	                           }
	                    }

	                    else if (period.equalsIgnoreCase("Year")) 
	                    {
	                           year = thisDate.getYear();
	                           //get the Last Day 
	                           Calendar cal = Calendar.getInstance();
	                           lastDateInPeriod = dateFrmt.format(cal.getTime());
	                           lastDateInPeriod1 = lastDateInPeriod +" 23:59:59";
	                           //System.out.println("lastDateInPeriod ***"+lastDateInPeriod1);
	                           //get the First day of current Year
	                           startDateInPeriod=year+"-01"+"-01";
	                           startDateInPeriod=startDateInPeriod+" 00:00:00";
	                           //System.out.println("startDateInPeriod ***"+startDateInPeriod);
	                    }

	                    else if (period.equalsIgnoreCase("Last Year")) 
	                    {
	                           Calendar cal = Calendar.getInstance();
	                           year = prevDate.getYear();
	                           //get the Last day of previous Year
	                           lastDateInPeriod=year+"-12-31";
	                           //lastDateInPeriod1 = lastDateInPeriod +" 18:30:00";
	                           //System.out.println("lastDateInPeriod ***"+lastDateInPeriod1);
	                           //get the First day of Previous Year 
	                           startDateInPeriod=year+"-01"+"-01";
	                           startDateInPeriod=startDateInPeriod+" 00:00:00";
	                           //System.out.println("startDateInPeriod ***"+startDateInPeriod);
	                    }
	              }
	              else
	              {
	                        Calendar cal = Calendar.getInstance();      
	                        startDateInPeriod1 = (Date)dateFrmt.parse(fromDate);
	                        startDateInPeriod = dateFrmt.format(startDateInPeriod1);
	                           /*cal.setTime(startDateInPeriod1);
	                           cal.add(Calendar.DAY_OF_YEAR, -1);
	                           startDateInPeriod2 = dateFrmt.format(cal.getTime());*/
	                        startDateInPeriod = startDateInPeriod + " 00:00:00";
	                           //System.out.println("startDateInPeriod ***"+startDateInPeriod);
	                           todateFormatted1 = (Date)dateFrmt.parse(toDate);
	                           lastDateInPeriod=dateFrmt.format(todateFormatted1);
	                           lastDateInPeriod=lastDateInPeriod+ " 23:59:59"; 
	                           //System.out.println("lastDateInPeriod ***"+lastDateInPeriod);
	              
	              }
	              //Get the Status of the machine
	              /*List<Integer> transactionNumberList = new LinkedList<Integer>();
	              int transactionNumber =0;
	              String serial_num = null;
	              Query query3 = session4
	              .createQuery("select max(a.transactionNumber),a.serialNumber from AssetMonitoringHeaderEntity a where a.createdTimestamp >= '"+startDateInPeriod+"' and  a.createdTimestamp<='"+lastDateInPeriod+"' group by a.serialNumber");
	              Iterator transactionNumItr = query3.list().iterator();
	              while (transactionNumItr.hasNext())
	              {
	                    AssetEntity asset =null;
	                    Object[] result = (Object[]) transactionNumItr.next();
	                    if (result[0] != null) {
	                           transactionNumber = (Integer)result[0];
	                           transactionNumberList.add(transactionNumber);
	                           //infoLogger.info("transactionNumberList"+transactionNumberList);
	                    }
	              }
	              ListToStringConversion conversionObj = new ListToStringConversion();
	              String transactionNumberAsStringList = conversionObj.getIntegerListString(transactionNumberList).toString();
	              infoLogger.info("transactionNumberAsStringList ***"+transactionNumberAsStringList);
	              if(transactionNumberAsStringList==null ||transactionNumberAsStringList.equalsIgnoreCase(null) || transactionNumberAsStringList.isEmpty())
	              {
	                    transactionNumberAsStringList ="0";
	              }*/
	              //get the List of tenancies accessible to the logged in user tenancy level
	              ListToStringConversion conversionObj = new ListToStringConversion();
	              //tenancyIdList = getSubTenancyIds(tenancyIdList,session4);
	              String tenancyIDList = conversionObj.getIntegerListString(tenancyIdList).toString();
	              String loginTenIdListString = conversionObj.getIntegerListString(loginTenancyIdList).toString();
	              String groupByQuery =" group by z.serialNumber, ten1.tenancy_id ";
	              String orderByQuery = "";
	              if(period !=null){

	            	  
	            	  
	                    selectQuery = "select z.machineHours as totalMachineLifeHours," +
	                    " (z.EngineRunningBand1+z.EngineRunningBand2+z.EngineRunningBand3+z.EngineRunningBand4+z.EngineRunningBand5+z.EngineRunningBand6+z.EngineRunningBand7+z.EngineRunningBand8) as machineHours,"+
	                    "z.lastEngineRun,z.Address,d.nick_name,c.tenancyName,z.lastReported, d , c.tenancyId, cu.group_id as machineGroupId, " +
	                    " cu.group_name as machineGroupName, ten.tenancy_name as mgTenancyNname, ten.tenancy_id as mgTenancy ,z.engineStatus as status," +
	                    //DefectId:20150220 @ Suprava Delaer As a new parameter Added
	                    "c.parentTenancyName,c.tenancyTypeId ";

	                    fromQuery =" from AssetCustomGroupMapping h RIGHT OUTER JOIN h.serial_number d  LEFT OUTER JOIN h.group_id cu" +
	                    " LEFT OUTER JOIN cu.tenancy_id ten ," +
	                    "TenancyBridgeEntity tb, "+
	                    " TenancyEntity ten1 , " +
	                    " TenancyDimensionEntity c, " ;
	                    //DefectId:20141111 @Suprava Read Time out Exception
	                    //" AssetMonitoringDetailEntity e JOIN e.transactionNumber amh ,";
	                    //DefectId:20141111 en
	                    whereQuery = " where ten1.tenancy_id = c.tenancyId and " +
	                    " z.tenancyId = c.tenacy_Dimension_Id and tb.parentId in ("+ tenancyIDList + " ) and c.tenancyId = tb.childId " +
	                    //DefectId:20141111 @Suprava Read Time out Exception
	                    /*" and amh.transactionNumber in("+transactionNumberAsStringList+")"+
	                    " and e.parameterId=18 "+
	                    " and amh.transactionNumber=e.transactionNumber " +
	                    " and z.serialNumber = amh.serialNumber " +*/
	                    //DefectId:20141111 en
	                    " and z.serialNumber = d.serial_number " ;
	                    //DefectId:20150216 @ Suprava Delaer As a new parameter Added
	                    //" and c.parentTenancyId=ten1.parent_tenancy_id ";

	                    if (period.equalsIgnoreCase("Week")) 
	                    {
	                           week = thisDate.getWeek();
	                           year = thisDate.getYear();
	                           fromQuery = fromQuery+" AssetMonitoringFactDataWeekAgg z ";
	                           whereQuery = whereQuery    + " and z.timeCount = "+week +" and z.year="+year;

	                           //To display the VINs that has not communicated for the given time period 
	                           //get the Last Day 
	                           Calendar cal = Calendar.getInstance();
	                           lastDateInPeriod = dateFrmt.format(cal.getTime());
	                           //get the first day of the week
	                           cal.set(Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek());
	                           startDateInPeriod=  dateFrmt.format(cal.getTime());

	                    }

	                    else if (period.equalsIgnoreCase("Last Week")) 
	                    {
	                           week =  prevDate.getWeek();
	                           if(thisDate.getWeek()==1)
	                           {
	                                  year = prevDate.getYear();
	                           }
	                           else
	                           {
	                                  year = prevDate.getCurrentYear();
	                           }

	                           fromQuery = fromQuery+" AssetMonitoringFactDataWeekAgg z ";

	                           whereQuery = whereQuery    + " and z.timeCount = "+week+" and z.year="+year;

	                           //To display the VINs that has not communicated for the given time period 
	                           //get the Last Day of Previous Week
	                           Calendar cal = Calendar.getInstance();
	                           int i = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
	                           cal.add(Calendar.DATE, -i - 7);
	                           cal.add(Calendar.DATE, 6);
	                           lastDateInPeriod = dateFrmt.format(cal.getTime());
	                           //get the First Day of Previous Week
	                           cal = Calendar.getInstance();
	                           int j = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
	                           cal.add(Calendar.DATE, -j - 7);
	                           cal.set(Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek());
	                           startDateInPeriod=  dateFrmt.format(cal.getTime());
	                    }

	                    else if (period.equalsIgnoreCase("Month")) 
	                    {
	                           month =  thisDate.getMonth();
	                           year = thisDate.getYear();
	                           fromQuery = fromQuery+" AssetMonitoringFactDataMonthAgg z ";
	                           whereQuery = whereQuery    + " and z.timeCount = "    + month+" and z.year="+year;

	                           // To display the VINs that has not communicated for the given time period 
	                           //get the Last Day 
	                           Calendar cal = Calendar.getInstance();
	                           lastDateInPeriod = dateFrmt.format(cal.getTime());
	                           //get the First Day of current Month
	                           String mon = month+"";
	                           if(mon.length()<2)
	                                  mon="0"+mon;
	                           startDateInPeriod=year+"-"+mon+"-"+"01";
	                    }

	                    else if (period.equalsIgnoreCase("Last Month")) 
	                    {
	                           month =  prevDate.getMonth();
	                           if(thisDate.getMonth()==1)
	                           {
	                                  year = prevDate.getYear();
	                           }
	                           else
	                           {
	                                  year = prevDate.getCurrentYear();
	                           }
	                           fromQuery = fromQuery+" AssetMonitoringFactDataMonthAgg z ";
	                           whereQuery = whereQuery    + " and z.timeCount = "    + month+" and z.year="+year;

	                           // To display the VINs that has not communicated for the given time period 
	                           //Get the Last Day of previous Month
	                           Calendar cal = Calendar.getInstance();
	                           cal.set(Calendar.DATE, 1);
	                           cal.add(Calendar.DAY_OF_MONTH, -1);
	                           lastDateInPeriod = dateFrmt.format(cal.getTime());
	                           //get the First Day of Previous Month
	                           String mon = month+"";
	                           if(mon.length()<2)
	                                  mon="0"+mon;
	                           startDateInPeriod=year+"-"+mon+"-"+"01";
	                    }

	                    else if (period.equalsIgnoreCase("Quarter")) 
	                    {
	                           quarter =  thisDate.getQuarter();
	                           year = thisDate.getYear();
	                           fromQuery = fromQuery+" AssetMonitoringFactDataQuarterAgg z ";
	                           whereQuery = whereQuery    + " and z.timeCount  = " +quarter+" and z.year="+year;

	                           // To display the VINs that has not communicated for the given time period 
	                           //get the Last Day 
	                           Calendar cal = Calendar.getInstance();
	                           lastDateInPeriod = dateFrmt.format(cal.getTime());
	                           //get the first Date of current quarter
	                           switch(quarter) 
	                           {
	                           case 3 : 
	                                  startDateInPeriod = year+"-07-01";
	                                  break;
	                                  // return July 01
	                           case 2 :
	                                  startDateInPeriod = year+"-04-01";
	                                  break;
	                                  // return April 01
	                           case 1 :
	                                  startDateInPeriod = year+"-01-01";
	                                  break;
	                                  // return Jan 01
	                           case 4 : 
	                                  startDateInPeriod = year+"-10-01";
	                                  break;
	                                  // return Oct 01
	                           }
	                    }

	                    else if (period.equalsIgnoreCase("Last Quarter")) 
	                    {
	                           quarter = prevDate.getQuarter();
	                           if(thisDate.getQuarter()==1)
	                           {
	                                  year = prevDate.getYear();
	                           }
	                           else
	                           {
	                                  year = prevDate.getCurrentYear();
	                           }
	                           fromQuery = fromQuery+" AssetMonitoringFactDataQuarterAgg z ";
	                           whereQuery = whereQuery    + " and z.timeCount  = " +quarter+" and z.year="+year;

	                           // To display the VINs that has not communicated for the given time period 
	                           //get the last day of previous quarter
	                           switch(quarter) 
	                           {
	                           case 3 : 
	                                  lastDateInPeriod = year+"-09-30";
	                                  break;
	                                  // return September 30
	                           case 2 :
	                                  lastDateInPeriod = year+"-06-30";
	                                  break;
	                                  // return June 30
	                           case 1 :
	                                  lastDateInPeriod = year+"-03-31";
	                                  break;
	                                  // return March 31
	                           case 4 : 
	                                  lastDateInPeriod = year+"-12-31";
	                                  break;
	                                  // return December 31
	                           }
	                           //get the first Date of Previous quarter
	                           switch(quarter) 
	                           {
	                           case 3 : 
	                                  startDateInPeriod = year+"-07-01";
	                                  break;
	                                  // return July 01
	                           case 2 :
	                                  startDateInPeriod = year+"-04-01";
	                                  break;
	                                  // return April 01
	                           case 1 :
	                                  startDateInPeriod = year+"-01-01";
	                                  break;
	                                  // return Jan 01
	                           case 4 : 
	                                  startDateInPeriod = year+"-10-01";
	                                  break;
	                                  // return Oct 01
	                           }
	                    }

	                    else if (period.equalsIgnoreCase("Year")) 
	                    {
	                           year = thisDate.getYear();
	                           fromQuery = fromQuery+" AssetMonitoringFactDataYearAgg z ";
	                           whereQuery = whereQuery    + " and z.year= "+year;

	                           // To display the VINs that has not communicated for the given time period 
	                           //get the Last Day 
	                           Calendar cal = Calendar.getInstance();
	                           lastDateInPeriod = dateFrmt.format(cal.getTime());
	                           //get the First day of current Year
	                           startDateInPeriod=year+"-01"+"-01";
	                    }

	                    else if (period.equalsIgnoreCase("Last Year")) 
	                    {
	                           year = prevDate.getYear();
	                           fromQuery = fromQuery+" AssetMonitoringFactDataYearAgg z ";
	                           whereQuery = whereQuery    + " and z.year= "+year;

	                           // To display the VINs that has not communicated for the given time period 
	                           //get the Last day of previous Year
	                           lastDateInPeriod=year+"-12-31";
	                           //get the First day of Previous Year 
	                           startDateInPeriod=year+"-01"+"-01";
	                    }

	                    // Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
	                    orderByQuery = orderByQuery + " order by d.serial_number, z.lastReported desc ";

	              }
	              else{

	                    DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
	                    String fromdateFormatted=null;
	                    String todateFormatted=null;

	                    try 
	                    {      
	                           fromdateFormatted= dateFormat.format(dateFormat.parse(fromDate));       
	                           todateFormatted = dateFormat.format(dateFormat.parse(toDate));       
	                    } 

	                    catch (ParseException e) 
	                    {
	                           // TODO Auto-generated catch block
	                           e.printStackTrace();
	                    }

	                    if(fromdateFormatted==null || todateFormatted==null)
	                    {
	                           throw new CustomFault("Unparsable Date input for Custom dates");
	                    }

	                    // To display the VINs that has not communicated for the given time period 
	                    startDateInPeriod = fromdateFormatted;
	                    lastDateInPeriod = todateFormatted;
	              
	                    selectQuery = "select aa.Machine_Hours,aa.Period_hours,aa.Last_Engine_Run," +
	                    		"aa.Address,bb.Engine_Number,aa.Tenancy_Name,aa.Last_Reported," +
	                    		"aa.Serial_Number,"+
	                    				"aa.tenancy_id,aa.Engine_Status,"+
	                    				"aa.Parent_Tenancy_Name,"+
	                    				"aa.Tenancy_Type_ID,"+
	                    				"bb.Asset_Type_ID,"+
	                    				"bb.Asset_Type_Name,"+
	                    				"bb.Asset_Group_ID,"+
	                    				"bb.Asseet_Group_Name from";
	                    
	                   selectQuery =  selectQuery + "(select "	+
	   	            			"o.Machine_Hours, sum(u.EngineRunningBand1+u.EngineRunningBand2 "+
	   	            			"+u.EngineRunningBand3+u.EngineRunningBand4 "+
	   	            			"+u.EngineRunningBand5+u.EngineRunningBand6 +"+
	   	            			"u.EngineRunningBand7 + u.EngineRunningBand8) as Period_hours,o.Last_Engine_Run,o.Address," +
	   	            			"a.Engine_Number,td.Tenancy_Name,o.Last_Reported," +
	   	            			"a.Serial_Number,td.tenancy_id,o.Engine_Status,td.Parent_Tenancy_Name," +
	   	            			"td.Tenancy_Type_ID "; 
	            	
	                   fromQuery = "from "+ 
	                		   "remote_monitoring_fact_data_dayagg u, "+
	                		   "remote_monitoring_fact_data_dayagg o, "+
	                		   "tenancy_dimension td,"+
	                		   "tenancy_bridge tb,"+
	                		   "asset a,"+
	                		   "(select max(z.Time_Key) as time_key,z.Serial_Number from remote_monitoring_fact_data_dayagg z where z.Time_Key>='"+fromdateFormatted+"' and Time_Key<='"+todateFormatted+"' group by z.Serial_Number,z.tenancy_id) as cc ";
	            	
	                   whereQuery = "where "+ 
	                		   "tb.Parent_Id in ("+ tenancyIDList + ") and "+ 
	                		   "td.tenancy_id = tb.Child_ID and "+ 
	                		   "u.tenancy_id = td.Tenancy_Dimension_ID and "+ 
	                		   "u.Time_Key between '"+fromdateFormatted+"' and '"+todateFormatted+"' and "+ 
	                		   "a.Serial_Number = u.Serial_Number and "+ 
	                		   "o.Serial_Number = u.Serial_number and "+ 
	                		   "cc.Serial_Number = o.Serial_Number and "+ 
	                		   "o.Time_Key = cc.time_key group by u.Serial_Number,u.tenancy_id order by o.Serial_Number , o.Last_Reported desc) as aa " +
	                		   "LEFT OUTER JOIN ("+
	                		   "SELECT "+ 
	                		   "a.Serial_Number,a.Engine_Number,"+
	                		   "a_t.Asset_Type_ID,"+
	                		   "a_t.Asset_Type_Name,"+
	                		   "ag.Asset_Group_ID,"+
	                		   "ag.Asseet_Group_Name "+  
	                		   "FROM "+ 
	                		   "asset a,products p, "+
	                		   "asset_type a_t,asset_group ag "+
	                		   "WHERE "+ 
	                		   "p.Product_ID = a.Product_ID and "+ 
	                		   "ag.Asset_Group_ID = p.Asset_Group_ID and "+ 
	                		   "a_t.Asset_Type_ID = p.Asset_Type_ID "+
	                		   ") as bb on "+ 
	                		   "aa.Serial_Number = bb.Serial_Number ";
	                	
	                   
	                    
	                    /*groupByQuery =" group by u.serialNumber, u.tenancyId ";

	                    selectQuery = "select z.machineHours as totalMachineLifeHours," +
	                    " sum(u.EngineRunningBand1+u.EngineRunningBand2+u.EngineRunningBand3+u.EngineRunningBand4+u.EngineRunningBand5+u.EngineRunningBand6+u.EngineRunningBand7+u.EngineRunningBand8) as machineHours,"+
	                    "z.lastEngineRun,z.Address,a.nick_name,c.tenancyName,z.lastReported,a, c.tenancyId," +
	                    "z.engineStatus as status," +
	                     //DefectId:20150216 @ Suprava Delaer As a new parameter Added
	                    "c.parentTenancyName,c.tenancyTypeId ";

	                    fromQuery =" from " +
	                    " TenancyBridgeEntity tb,AssetEntity a," +
	                    " TenancyDimensionEntity c, AssetMonitoringFactDataDayAgg z, AssetMonitoringFactDataDayAgg u, " +
	                    " (select max(o.timeKey) as time_key,o.serialNumber from AssetMonitoringFactDataDayAgg o " +
	                    //" where o.serialNumber=z.serialNumber and o.tenancyId = yt.tenacy_Dimension_Id and yt.tenancyId in ("+ tenancyIDList + " ) " +
	                    " where o.timeKey >='"+fromdateFormatted+"' and o.timeKey <= '"+todateFormatted+"' group by o.serialNumber,o.tenancyId) as maxTimeKey ";
	                    //DefectId:20141111 @Suprava Read Time out Exception
	              //     " AssetMonitoringDetailEntity e JOIN e.transactionNumber amh ";
	                    //DefectId:20141111 @Suprava Read Time out Exception

	                    whereQuery = " where  " +
	                    " u.tenancyId = c.tenacy_Dimension_Id and tb.parentId in ("+ tenancyIDList + " ) and c.tenancyId = tb.childId" +
	                    " and u.timeKey between '"+fromdateFormatted+"' and '"+todateFormatted+"'" +
	                    " and a.serialNumber = u.serial_number " +
	                    //     " and d.primary_owner_id = v.account_id " +
	                    " and z.serialNumber = u.serialNumber " +
	                    "and maxTimeKey.serialNumber = z.serialNumber "+
	                    " and z.timeKey = maxTimeKey.time_key";
	                    //DefectId:20141111 @Suprava Read Time out Exception
	                    " and amh.transactionNumber in("+transactionNumberAsStringList+")"+
	                    " and e.parameterId=18 "+
	                    " and amh.transactionNumber=e.transactionNumber " +
	                    " and z.serialNumber = amh.serialNumber " +
	                    //DefectId:20141111
	                    
	                    //DefectId:20150216 @ Suprava Delaer As a new parameter Added
	                    //" and c.parentTenancyId=ten1.parent_tenancy_id ";

	    

	                    // To take the latest/Last reported row from factAgg tables
	                    orderByQuery = orderByQuery +  " order by z.serial_number , z.lastReported desc";
*/

	              }
	             /* if (!(customAssetGroupIdList == null || customAssetGroupIdList.isEmpty())) 
	              {
	                    String customAssetGroupStringList = conversionObj.getIntegerListString(customAssetGroupIdList).toString();
	                    whereQuery = whereQuery+ " and cu.group_id in ("+ customAssetGroupStringList + ")";
	              }

	              if ((!(machineProfileIdList == null || machineProfileIdList.isEmpty()))    || (!(modelList == null || modelList.isEmpty()))) 
	              {
	                    fromQuery = fromQuery+ " , AssetClassDimensionEntity b ";
	                    whereQuery = whereQuery    + " and z.assetClassDimensionId = b.assetClassDimensionId";
	              }

	              if (!(machineProfileIdList == null || machineProfileIdList.isEmpty())) 
	              {
	                    String machineProfileIdStringList = conversionObj.getIntegerListString(machineProfileIdList).toString();
	                    whereQuery = whereQuery + " and b.assetGroupId in ( "+ machineProfileIdStringList + ") ";

	              }                    

	              if (!((modelList == null) || (modelList.isEmpty()))) 
	              {
	                    String modelIdListStringList = conversionObj.getIntegerListString(modelList).toString();
	                    whereQuery = whereQuery + " and b.assetTypeId in ( "+ modelIdListStringList + " )";

	              }
*/
	              finalQuery = selectQuery + fromQuery + whereQuery ;

	              //System.out.println("QUery started:");
	              
	              SQLQuery qury = session4.createSQLQuery(finalQuery);
	              Iterator rr = qury.list().iterator();
	              Object[] result = null;

	              
	             // System.out.println("QUery finished:");
	              List<String> serialNumberList = new LinkedList<String>();
	              while(rr.hasNext()){

	                    implObj = new MachineHoursReportImpl();
	                    serialNumber=null;

	                    result = (Object[]) rr.next();

	                    AssetEntity asset =null;
	                   // TenancyEntity tenancyEntity =null;
	                    if(result[7]!=null)
	                    {                                 
	                           //asset = (AssetEntity)result[7];
	                           serialNumber = (String)result[7];

	                    }

	                    if(serialNumberList.contains(serialNumber))
	                    {
	                           continue;
	                    }
	                    implObj.setSerialNumber(serialNumber);


	                    if(result[0]!=null)
	                    {
	                           implObj.setTotalMachineHours(Double.valueOf(df2.format((Double) result[0])));
	                    }                          

	                    if(result[1]!=null)
	                    {
	                           implObj.setMachineHours(Double.valueOf(df2.format((Double) result[1])));              
	                    }

	                    if(result[2]!=null)
	                    {
	                           implObj.setLastEngineRun((Timestamp) result[2]);
	                    }      

	                    if(result[3]!=null)
	                    {
	                           implObj.setLocation(result[3].toString());             
	                    }

	                    if(result[4]!=null)
	                    {
	                           implObj.setMachineName(result[4].toString());
	                    }

	                    if(result[5]!=null)
	                    {
	                           implObj.setTenancyName(result[5].toString());
	                    }      

	                    if(result[6]!=null)
	                    {
	                           implObj.setLastReported((Timestamp) result[6]);
	                    }      


	                    implObj.setTenancyId((Integer)result[8]);
	                    if(result[12]!=null)
                        {     
                               implObj.setModelId((Integer)result[12]);
                        }

                        if(result[13]!=null)
                        {
                               implObj.setModelName((String)result[13]);
                        }
                        if(result[14]!=null)
                        {
                        	implObj.setMachineProfileId((Integer)result[14]);
                        }
                        if(result[15]!=null)
                        {
                        	implObj.setMachineProfileName((String)result[15]);
                        }

	                    /*if(asset!=null)
	                    {
	                           if(asset.getProductId()!=null && asset.getProductId().getAssetGroupId()!=null)
	                           {
	                                  implObj.setMachineProfileId(asset.getProductId().getAssetGroupId().getAsset_group_id());
	                                  implObj.setMachineProfileName(asset.getProductId().getAssetGroupId().getAsset_group_name());
	                           }

	                           if(asset.getProductId()!=null && asset.getProductId().getAssetTypeId()!=null)
	                           {
	                                  implObj.setModelId(asset.getProductId().getAssetTypeId().getAsset_type_id());
	                                  implObj.setModelName(asset.getProductId().getAssetTypeId().getAsset_type_name());
	                           }


	                    }*/
	                    if(result[9]!=null)
	                    {
	                           implObj.setStatus((String)result[9]);
	                           status=(String)result[9];
	                           if(status.equalsIgnoreCase("0"))
	                                  {
	                                         totalMachinesDormant=totalMachinesDormant+1;
	                                  }
	                                  else
	                                  {
	                                         totalMachinesOperational=totalMachinesOperational+1;
	                                  }
	                    }

	                    //DefectId:20150220 @ Suprava Delaer As a new parameter Added
	                    if(result[11]!=null)
	                                  {
	                                         int tenancyTypeId =Integer.parseInt((String) result[11]);
	                                         //If the Machine is with customer Get the parentTeancyId
	                                         if(tenancyTypeId==4)
	                                         {
	                                                //String partentTenancyName =(String)result[14];
	                                                implObj.setDealerName(result[10].toString());
	                                         }
	                                         //If the Machine is with Dealer
	                                         else if(tenancyTypeId==3) 
	                                         {
	                                                if(result[5]!=null)
	                                                {
	                                                //String Dealername =(String)result[5];
	                                                implObj.setDealerName(result[5].toString());
	                                         }
	                                         }
	                                         else
	                                         {
	                                                implObj.setDealerName("No Dealer Tagging");
	                                         }
	                                  
	                                  }
	                    //DefectID:1406 - Rajani Nagaraju - 20131029 - To return Report Totals
	                    if(!(serialNumberList.contains(serialNumber)))
	                    {
	                           totalMachineHoursSumm = totalMachineHoursSumm+(Double.valueOf(df2.format((Double) result[0])));
	                           machineHoursSumm = machineHoursSumm+(Double.valueOf(df2.format((Double) result[1])));
	                           //For Machine Activity Report 1.Machines Working less than min threshold and 2. Machines working more than Max. threshold
	                           if(minThreshold>=0 && maxThreshold>=0)
	                           {
	                                  double machineHoursInPeriod = (Double) result[1];
	                                  int machineHrInPeriod = (int)machineHoursInPeriod;
	                                  if(machineHrInPeriod < minThreshold)
	                                         totalMachineswithMinThr= totalMachineswithMinThr+1;
	                                  else if (machineHrInPeriod > maxThreshold)
	                                         totalMachineswithMaxThr= totalMachineswithMaxThr+1;

	                           }
	                    }

	                    //DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
	                    //Get the List of MachineGroup under the Login Tenancy to which the machine belongs to 
	                   /* if(isGroupingOnAssetGroup)
	                    {
	                           Query mgQuery=null;
	                           if (!(customAssetGroupIdList == null || customAssetGroupIdList.isEmpty())) 
	                           {
	                                  String customAssetGroupStringList = conversionObj.getIntegerListString(customAssetGroupIdList).toString();
	                                  mgQuery = session4.createQuery(" select a from AssetCustomGroupMapping a, CustomAssetGroupEntity b " +
	                                                //Smitha:DefectID:20131220...to get the VIN's belonging to the machine groups under that tenancy ID
	                                                "where serial_number='"+serialNumber+"' and a.group_id=b.group_id and b.level=2 and b.active_status=1 and b.tenancy_id in ("+loginTenIdListString+")" +
	                                                " and b.group_id in ("+customAssetGroupStringList+")");
	                           }

	                           else
	                           {
	                                  mgQuery = session4.createQuery(" select a from AssetCustomGroupMapping a, CustomAssetGroupEntity b " +
	                                                //Smitha:DefectID:20131220...to get the VIN's belonging to the machine groups under that tenancy ID
	                                                "where serial_number='"+serialNumber+"' and a.group_id=b.group_id and b.level=2 and b.active_status=1 and b.tenancy_id in ("+loginTenIdListString+")");
	                           }
	                           Iterator mgItr = mgQuery.list().iterator();
	                           int firstIteration =0;
	                           while(mgItr.hasNext())
	                           {
	                                  AssetCustomGroupMapping mgVinMapping = (AssetCustomGroupMapping)mgItr.next();
	                                  if(firstIteration==0)
	                                  {
	                                         firstIteration=1;
	                                         implObj.setMachineGroupId(mgVinMapping.getGroup_id().getGroup_id());
	                                         implObj.setMachineGroupName(mgVinMapping.getGroup_id().getGroup_name());
	                                         listImplObj.add(implObj);
	                                  }
	                                  else
	                                  {
	                                         MachineHoursReportImpl newimplObj = new MachineHoursReportImpl();
	                                         newimplObj.setSerialNumber(serialNumber);
	                                         newimplObj.setTotalMachineHours(Double.valueOf(df2.format(implObj.getTotalMachineHours())));
	                                         newimplObj.setMachineHours(Double.valueOf(df2.format(implObj.getMachineHours()))); 
	                                         newimplObj.setLastEngineRun(implObj.getLastEngineRun());
	                                         newimplObj.setLocation(implObj.getLocation());         
	                                         newimplObj.setMachineName(implObj.getMachineName());
	                                         newimplObj.setTenancyName(implObj.getTenancyName());
	                                         newimplObj.setLastReported(implObj.getLastReported());
	                                         newimplObj.setTenancyId(implObj.getTenancyId());
	                                         newimplObj.setMachineGroupId(mgVinMapping.getGroup_id().getGroup_id());
	                                         newimplObj.setMachineGroupName(mgVinMapping.getGroup_id().getGroup_name());
	                                         newimplObj.setMachineProfileId(implObj.getMachineProfileId());
	                                         newimplObj.setMachineProfileName(implObj.getMachineProfileName());
	                                         newimplObj.setModelId(implObj.getModelId());
	                                         newimplObj.setModelName(implObj.getModelName());
	                                         newimplObj.setStatus(implObj.getStatus());
	                                         newimplObj.setDurationInCurrentStatus(implObj.getDurationInCurrentStatus());
	                                         newimplObj.setDealerName(implObj.getDealerName());
	                                         listImplObj.add(newimplObj);
	                                  }
	                           }

	                           if(firstIteration==0)
	                           {
	                                  listImplObj.add(implObj);
	                           }
	                    }*/

	                
	                           listImplObj.add(implObj);
	                


	                    serialNumberList.add(serialNumber);

	              }

	              //-------------------------------------------------------------------------------------------------------------------
	              //DefectId: DF20131018 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period 
	              Query ownerListQuery = session4.createQuery(" select distinct c.serialNumber " +
	                           " from TenancyBridgeEntity a, AccountTenancyMapping b, AssetAccountMapping c " +
	                           " where a.childId= b.tenancy_id " +
	                           " and b.account_id= c.accountId " +
	                           " and a.parentId in ("+tenancyIDList+") and" +
	                           " ( (c.ownershipStartDate between '"+startDateInPeriod+"' and '"+lastDateInPeriod+"') OR " +
	                           "   (c.ownershipStartDate = ( select max(y.ownershipStartDate) from AssetAccountMapping y " +
	                           " where y.serialNumber= c.serialNumber" +
	                           " and y.ownershipStartDate <='"+startDateInPeriod+"')" +
	                           "    )" +
	              " )");
	              Iterator ownerListItr = ownerListQuery.list().iterator();
	              List<String> actualOwnerVINList = new LinkedList<String>();
	              while(ownerListItr.hasNext())
	              {
	                    AssetEntity assetList = (AssetEntity)ownerListItr.next();
	                    actualOwnerVINList.add(assetList.getSerial_number().getSerialNumber());
	              }

	              //Get only the List of VINs which has not communicated for the Given period
	              actualOwnerVINList.removeAll(serialNumberList);
	              String actualOwnerVinListString = conversionObj.getStringList(actualOwnerVINList).toString();
	              //DefectId:20141111 @Suprava Read Time out Changes
	              /*List<Integer> transactionNumberList1 = new LinkedList<Integer>();
	              int transactionNumber1 =0;
	              String serial_num1 = null;
	              Query query4 = session4
	              .createQuery("select max(a.transactionNumber),a.serialNumber from AssetMonitoringHeaderEntity a where a.serialNumber in("+actualOwnerVinListString+") and a.createdTimestamp <= '"+startDateInPeriod2+"' group by a.serialNumber");
	              Iterator transactionNumItr1 = query4.list().iterator();
	              while (transactionNumItr1.hasNext())
	              {
	                    AssetEntity asset =null;
	                    //System.out.println("Inside 2nd while");
	                    Object[] result1 = (Object[]) transactionNumItr1.next();
	                    if (result1[0] != null) {
	                           transactionNumber1 = (Integer)result1[0];
	                           transactionNumberList1.add(transactionNumber1);
	                           //infoLogger.info("transactionNumberList"+transactionNumberList);
	                    }
	              }
	              String transactionNumberAsStringList1 = conversionObj.getIntegerListString(transactionNumberList1).toString();*/
	              //DefectId:20141111 en
	              //groupByQuery =" group by z.serialNumber ";

	              // To take the latest/Last reported row from factAgg tables
	              
	              
	              //@2016-03-31 - S Suresh Query Tweaking for Machine Hours report Service - start
	              
	            

	              
	              //@2016-03-31 - S Suresh Query Tweaking for Machine Hours report Service - end
	              
	              
                  groupByQuery =" group by z.serialNumber, z.tenancyId ";
	              //groupByQuery =" group by z.serialNumber, ten1.tenancy_id ";
	              //orderByQuery = " order by d.serial_number, z.lastReported desc ";
	              orderByQuery = " order by z.serialNumber , z.lastReported desc";

	           /*   selectQuery = " select z.machineHours as totalMachineLifeHours ," +
	              " z.lastEngineRun,z.Address,d.nick_name,c.tenancyName,z.lastReported,  " +
	              " d , c.tenancyId," +
	              //DefectId:20150216 @ Suprava Delaer As a new parameter Added
	              "c.parentTenancyName,c.tenancyTypeId ";
*/
	             selectQuery = "select z.machineHours as totalMachineLifeHours," +
	                      "z.lastEngineRun,z.Address,a.nick_name,c.tenancyName,z.lastReported,a, c.tenancyId," +
	                      "z.engineStatus as status," +
	                      "c.parentTenancyName,c.tenancyTypeId ";
	              
	              //@2016-03-31 - S Suresh - native sql query as hibernate does not support subquery in from clause
	              
	             /* selectQuery =  "select "	+
	   	            		"o.Machine_Hours, " +
	   	            		"o.Last_Engine_Run,o.Address,a.Engine_Number,td.Tenancy_Name,o.Last_Reported,a.Serial_Number,td.tenancy_id,o.Engine_Status,td.Parent_Tenancy_Name,td.Tenancy_Type_ID "; */
	              
	             /* fromQuery = " from AssetCustomGroupMapping h RIGHT OUTER JOIN h.serial_number d  LEFT OUTER JOIN h.group_id cu " +
	              " LEFT OUTER JOIN cu.tenancy_id ten , TenancyEntity ten1," +
	              " TenancyDimensionEntity c, AssetMonitoringFactDataDayAgg z " ;*/
	              
	              
	              fromQuery =" from " +
	                      " AssetEntity a," +
	                      " TenancyDimensionEntity c, AssetMonitoringFactDataDayAgg z " ;
	                      
	              
	            //@2016-03-31 - S Suresh - native sql query as hibernate does not support subquery in from clause
	              
	             /* fromQuery = " from "+ 
		            		"remote_monitoring_fact_data_dayagg u, "+
		            		"tenancy_dimension td,"+
		            		"asset a,"+
		            		"(select max(z.Time_Key) as time_key,z.Serial_Number from remote_monitoring_fact_data_dayagg z where Time_Key<='"+startDateInPeriod+"' group by z.Serial_Number,z.tenancy_id) as bb ";*/
	              
	              
	              //DefectId:20141111 @Suprava Read Time out Exception
	              //" AssetMonitoringDetailEntity e JOIN e.transactionNumber amh ";
	              //DefectId:20141111

	           /*   whereQuery = " where ten1.tenancy_id = c.tenancyId and " +
	              " z.tenancyId = c.tenacy_Dimension_Id and z.serialNumber = d.serial_number " +
	              " and z.serialNumber in ("+actualOwnerVinListString+") " +
	              " and z.timeKey = ( select max(p.timeKey) from AssetMonitoringFactDataDayAgg p where p.serialNumber = z.serialNumber " +
	              //DefectId:20141111 @Suprava Read Time out Exception
	              " and amh.transactionNumber in("+transactionNumberAsStringList1+")"+
	              " and e.parameterId=18 "+
	              " and amh.transactionNumber=e.transactionNumber " +
	              " and z.serialNumber = amh.serialNumber " +
	              //DefectId:20141111
	              " and p.timeKey <= '"+startDateInPeriod+"' )";
	              //DefectId:20150216 @ Suprava Delaer As a new parameter Added
	              //" and c.parentTenancyId=ten1.parent_tenancy_id ";
*/
	              /*whereQuery = " where  " +
	                      " z.tenancyId = c.tenacy_Dimension_Id " +
	                      " and z.serialNumber in ("+actualOwnerVinListString+") " +
	                      " and a.serialNumber = z.serial_number " +
	                      //     " and d.primary_owner_id = v.account_id " +
	                      "and maxTimeKey.serialNumber = z.serialNumber "+
	                      " and z.timeKey = maxTimeKey.time_key";*/
	              
	             
	              //@2016-03-31 - S Suresh - native sql query as hibernate does not support subquery in from clause
	            	whereQuery = "where "+ 
	            		"z.tenancyId = c.tenacy_Dimension_Id and "+ 
	            		 " z.serialNumber in ("+actualOwnerVinListString+") and " +
	            		"a.serial_number = z.serialNumber"+  
	            		 " and z.timeKey = ( select max(p.timeKey) from AssetMonitoringFactDataDayAgg p where p.serialNumber = z.serialNumber " +
	            		 " and p.timeKey <= '"+startDateInPeriod+"' )";
	              //@2016-03-31 - S Suresh Query Tweaking for Machine Hours report Service - end
	              
	             /* if (!(customAssetGroupIdList == null || customAssetGroupIdList.isEmpty())) 
	              {
	                    String customAssetGroupStringList = conversionObj.getIntegerListString(customAssetGroupIdList).toString();
	                    whereQuery = whereQuery+ " and cu.group_id in ("+ customAssetGroupStringList + ")";
	              }

	              if ((!(machineProfileIdList == null || machineProfileIdList.isEmpty()))    || (!(modelList == null || modelList.isEmpty()))) 
	              {
	                    fromQuery = fromQuery+ " , AssetClassDimensionEntity b ";
	                    whereQuery = whereQuery    + " and z.assetClassDimensionId = b.assetClassDimensionId";
	              }


	              if (!(machineProfileIdList == null || machineProfileIdList.isEmpty())) 
	              {
	                    String machineProfileIdStringList = conversionObj.getIntegerListString(machineProfileIdList).toString();
	                    whereQuery = whereQuery + " and b.assetGroupId in ( "+ machineProfileIdStringList + ") ";

	              }                    

	              if (!((modelList == null) || (modelList.isEmpty()))) 
	              {
	                    String modelIdListStringList = conversionObj.getIntegerListString(modelList).toString();
	                    whereQuery = whereQuery + " and b.assetTypeId in ( "+ modelIdListStringList + " )";

	              }
*/
	              //DefectID:1406 - Rajani Nagaraju - 20131028 - MachineGrouping issue
	              if(! (actualOwnerVINList==null || actualOwnerVINList.isEmpty()))
	              {

	                    //finalQuery = selectQuery + fromQuery+ whereQuery + groupByQuery + " order by d.serial_number, ten.tenancy_id ";;
	                    finalQuery = selectQuery + fromQuery+ whereQuery + groupByQuery + orderByQuery;
	                    Iterator vinListItr = session4.createQuery(finalQuery).list().iterator();
	                    result =null;
	                    serialNumberList = new LinkedList<String>();

	                    while(vinListItr.hasNext())
	                    {
	                           implObj = new MachineHoursReportImpl();
	                           serialNumber=null;
	                           result = (Object[]) vinListItr.next();

	                           AssetEntity asset =null;
	                           TenancyEntity tenancyEntity =null;
	                           if(result[6]!=null)
	                           {                                 
	                                 asset = (AssetEntity)result[6];
	                                  serialNumber = asset.getSerial_number().getSerialNumber();
	                        	   //serialNumber = (String)result[6];
	                           }

	                           if(serialNumberList.contains(serialNumber))
	                           {
	                                  continue;
	                           }
	                           implObj.setSerialNumber(asset.getSerial_number().getSerialNumber());

	                           if(result[0]!=null)
	                           {
	                                  implObj.setTotalMachineHours(Double.valueOf(df2.format((Double)result[0])));
	                           }

	                           if(result[1]!=null)
	                           {
	                                  implObj.setLastEngineRun((Timestamp) result[1]);
	                           }      

	                           if(result[2]!=null)
	                           {
	                                  implObj.setLocation(result[2].toString());             
	                           }

	                           if(result[3]!=null)
	                           {
	                                  implObj.setMachineName(result[3].toString());
	                           }

	                           if(result[4]!=null)
	                           {
	                                  implObj.setTenancyName(result[4].toString());
	                           }      

	                           if(result[5]!=null)
	                           {
	                                  implObj.setLastReported((Timestamp) result[5]);
	                           }      


	                           implObj.setTenancyId((Integer)result[7]);


	                           if(asset!=null)
	                           {
	                                  if(asset.getProductId()!=null && asset.getProductId().getAssetGroupId()!=null)
	                                  {
	                                         implObj.setMachineProfileId(asset.getProductId().getAssetGroupId().getAsset_group_id());
	                                         implObj.setMachineProfileName(asset.getProductId().getAssetGroupId().getAsset_group_name());
	                                  }

	                                  if(asset.getProductId()!=null && asset.getProductId().getAssetTypeId()!=null)
	                                  {
	                                         implObj.setModelId(asset.getProductId().getAssetTypeId().getAsset_type_id());
	                                         implObj.setModelName(asset.getProductId().getAssetTypeId().getAsset_type_name());
	                                  }


	                           }
	                           implObj.setStatus("NA");
	                           
	                           //DefectId:20150220 @ Suprava Delaer As a new parameter Added
	                           if(result[10]!=null)
	                                         {
	                        	   int tenancyTypeId =(Integer) result[10];
	                                                //If the Machine is with customer Get the parentTeancyId
	                                                if(tenancyTypeId==4)
	                                                {
	                                                //     String parentTeancyname =(String)result[12];
	                                                       implObj.setDealerName(result[9].toString());
	                                                }
	                                                //If the Machine is with Dealer
	                                                else if(tenancyTypeId==3) 
	                                                {
	                                                       if(result[5]!=null)
	                                                       {
	                                                       //String Dealername =(String)result[5];
	                                                       implObj.setDealerName(result[5].toString());
	                                                }
	                                                }
	                                                else
	                                                {
	                                                       implObj.setDealerName("No Dealer Tagging");
	                                                }
	                                         
	                                         }
	                                         
	                           //DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
	                           //TenancyEntity primaryOwnerTenancy = (TenancyEntity)result[1];
	                           /*     int primaryOwnerAcc = asset.getPrimary_owner_id();
	                           int primaryOwnerTenancy=0;
	                           Query primaryTenQuery = session4.createQuery(" from AccountTenancyMapping where account_id='"+primaryOwnerAcc+"'");
	                           Iterator primaryTenItr = primaryTenQuery.list().iterator();
	                           while(primaryTenItr.hasNext())
	                           {
	                                  AccountTenancyMapping accountTen = (AccountTenancyMapping)primaryTenItr.next();
	                                  primaryOwnerTenancy = accountTen.getTenancy_id().getTenancy_id();
	                           }
	                           */
	                           //DefectID:1406 - Rajani Nagaraju - 20131029 - To return Report Totals

	                           /*if(result[12]!=null)
	                           {
	                                  implObj.setStatus(result[12].toString());
	                           }*/

	                           //DefectID:1406 - Rajani Nagaraju - 20131029 - To return Report Totals
	                           if(!(serialNumberList.contains(serialNumber)))
	                           {
	                                  totalMachineHoursSumm = totalMachineHoursSumm+(Double.valueOf(df2.format((Double) result[0])));
	                                  //machineHoursSumm cannot be added since the machine has not communicated in the given period
	                                  //machineHoursSumm = machineHoursSumm+(Double) result[1];

	                                  //DefectId: 20131220 - Rajani Nagaraju - To sum the yellow threshold even for the machines that has not communicated
	                                  //For Machine Activity Report 1.Machines Working less than min threshold and 2. Machines working more than Max. threshold
	                                  if(minThreshold>=0 && maxThreshold>=0)
	                                  {
	                                         int machineHrInPeriod = 0;
	                                         if(machineHrInPeriod < minThreshold)
	                                                totalMachineswithMinThr= totalMachineswithMinThr+1;
	                                         else if (machineHrInPeriod > maxThreshold)
	                                                totalMachineswithMaxThr= totalMachineswithMaxThr+1;

	                                  }
	                           }

	                           //Get the List of MachineGroup under the Login Tenancy to which the machine belongs to 
	                           //DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
	                          /* if(isGroupingOnAssetGroup)
	                           {

	                                  Query mgQuery=null;
	                                  if (!(customAssetGroupIdList == null || customAssetGroupIdList.isEmpty())) 
	                                  {
	                                         String customAssetGroupStringList = conversionObj.getIntegerListString(customAssetGroupIdList).toString();
	                                         mgQuery = session4.createQuery(" select a from AssetCustomGroupMapping a, CustomAssetGroupEntity b " +
	                                                       //Smitha:DefectID:20131220...to get the VIN's belonging to the machine groups under that tenancy ID
	                                                      "where serial_number='"+serialNumber+"' and a.group_id=b.group_id and b.level=2 and b.active_status=1 and b.tenancy_id in ("+loginTenIdListString+")" +
	                                                       " and b.group_id in ("+customAssetGroupStringList+")");
	                                  }
	                                  else
	                                  {
	                                         mgQuery = session4.createQuery(" select a from AssetCustomGroupMapping a, CustomAssetGroupEntity b " +
	                                                       //Smitha:DefectID:20131220...to get the VIN's belonging to the machine groups under that tenancy ID
	                                                       "where serial_number='"+serialNumber+"' and a.group_id=b.group_id and b.level=2 and b.active_status=1 and b.tenancy_id in ("+loginTenIdListString+")");
	                                  }
	                                  Iterator mgItr = mgQuery.list().iterator();
	                                  int firstIteration =0;
	                                  while(mgItr.hasNext())
	                                  {
	                                         AssetCustomGroupMapping mgVinMapping = (AssetCustomGroupMapping)mgItr.next();
	                                         if(firstIteration==0)
	                                         {
	                                                firstIteration=1;
	                                                implObj.setMachineGroupId(mgVinMapping.getGroup_id().getGroup_id());
	                                                implObj.setMachineGroupName(mgVinMapping.getGroup_id().getGroup_name());
	                                                listImplObj.add(implObj);
	                                         }
	                                         else
	                                         {
	                                                MachineHoursReportImpl newimplObj = new MachineHoursReportImpl();
	                                                newimplObj.setSerialNumber(serialNumber);
	                                                newimplObj.setTotalMachineHours(implObj.getTotalMachineHours());
	                                                newimplObj.setMachineHours(implObj.getMachineHours()); 
	                                                newimplObj.setLastEngineRun(implObj.getLastEngineRun());
	                                                newimplObj.setLocation(implObj.getLocation());              
	                                                newimplObj.setMachineName(implObj.getMachineName());
	                                                newimplObj.setTenancyName(implObj.getTenancyName());
	                                                newimplObj.setLastReported(implObj.getLastReported());
	                                                newimplObj.setTenancyId(implObj.getTenancyId());
	                                                newimplObj.setMachineGroupId(mgVinMapping.getGroup_id().getGroup_id());
	                                                newimplObj.setMachineGroupName(mgVinMapping.getGroup_id().getGroup_name());
	                                                newimplObj.setMachineProfileId(implObj.getMachineProfileId());
	                                                newimplObj.setMachineProfileName(implObj.getMachineProfileName());
	                                                newimplObj.setModelId(implObj.getModelId());
	                                                newimplObj.setModelName(implObj.getModelName());
	                                                newimplObj.setStatus(implObj.getStatus());
	                                                newimplObj.setDurationInCurrentStatus(implObj.getDurationInCurrentStatus());
	                                                newimplObj.setDealerName(implObj.getDealerName());
	                                                listImplObj.add(newimplObj);
	                                         }
	                                  }

	                                  if(firstIteration==0)
	                                  {
	                                         listImplObj.add(implObj);
	                                  }
	                           }
*/
	                           
	                                  listImplObj.add(implObj);
	                                  serialNumberList.add(serialNumber);

	                    }
	                   
	                    /*listImplObj.add(implObj);*/


	              }
	              //DefectID:1406 - Rajani Nagaraju - 20131029 - To return Report Totals
	              implObj = new MachineHoursReportImpl();
	              implObj.setSerialNumber("Summary");
	              implObj.setTotalMachineHours(Double.valueOf(df2.format((Double) totalMachineHoursSumm)));
	              implObj.setMachineHours(Double.valueOf(df2.format((Double) machineHoursSumm)));       
	              //In the Format No.Of Machines Operational, No. Of Machines Dormant
	              implObj.setStatus(totalMachinesOperational+","+totalMachinesDormant);
	              //For Machine Activity Report
	              //implObj.setMachineName(totalMachineswithMinThr+","+totalMachineswithMaxThr);
	              implObj.setMachineProfileName(totalMachineswithMinThr+","+totalMachineswithMaxThr);
	              listImplObj.add(implObj);
	       } 

	       catch (Exception e) 
	       {
	              e.printStackTrace();
	              fLogger.fatal("Exception :" + e);
	       }

	       finally 
	       {
	              if (session4.getTransaction().isActive()) 
	              {
	                    session4.getTransaction().commit();
	              }

	              if (session4.isOpen()) 
	              {
	                    session4.flush();
	                    session4.close();
	              }

	       }

	       return listImplObj;
	}


	//**************************************************END of get Usage Details of the Machine ****************************************

	private long toDate(Timestamp transactionTime2) {
		// TODO Auto-generated method stub
		return 0;
	}


	/**
     * DefectID:1383 - Rajani Nagaraju - 20130930 - Query modification to return correct resultset
     * @param period
     *            , which may be 'Week','Month', 'Quarter', 'Year', 'Last Week', 'Last Month', 'Last Quarter', 'Last Year'
     * @param machineGroupIdList
     *            List of customAssetGroupId as input
     * @param machineProfineIdList
     *            List of machineProfineId which is asset_Group_Id - Eg: BHL
     * @param tenancyIdList
     *            List of tenancyId
     * @param modelIdList
     *            List of modelId which is AssetTypeId
     * @return listImplObj gets the response as list/Summary on fleet
     */
     //Logic for Custom Dates (fromDate,toDate) added by Juhi on 19-August-2013

     public List<FleetSummaryReporImpl> getFleetSummaryReportService(String fromDate,String toDate,String period, List<Integer> machineGroupIdList,
                   List<Integer> machineProfileIdList, List<Integer> tenancyIdList,List<Integer> modelIdList, boolean isGroupingOnAssetGroup,List<Integer> loginTenancyIdList) 
                   {           
            FleetSummaryReporImpl implObj = null;
            List<FleetSummaryReporImpl> listImplObj = new LinkedList<FleetSummaryReporImpl>();            

            Session session = HibernateUtil.getSessionFactory().openSession();
            session.beginTransaction();
            Logger fLogger = FatalLoggerClass.logger;
            //Logger bLogger = BusinessErrorLoggerClass.logger;
            Logger iLogger = InfoLoggerClass.logger;
            try
            {
                   DecimalFormat df2 = new DecimalFormat("###.#");  
                   String selectQuery = null;
                   String fromQuery = null;
                   String whereQuery = null;
                   String finalQuery = null;
                   String selectQueryCustomDates=null;
                   List<Integer> bandIdLowList = new ArrayList<Integer>();
                   List<Integer> bandIdMediumList = new ArrayList<Integer>();
                   List<Integer> bandIdHighList = new ArrayList<Integer>();
                   List<String>  tempSerNumList = new ArrayList<String>();
                   List<String>  AllSerNumList = new ArrayList<String>();
                   HashMap<String, Integer> calledSerNumMap = new HashMap<String, Integer>();
                   String fromQueryCustomDates = null;
                   String whereQueryCustomDates = null;
                   String tempSerialNumber = null;
                   //Get all the VIN's belonging to a particular tenancy_id

                   //DefectID:1406 - Smitha - 20131029 - To return Report Totals
                   double totalMachineLifeHoursSum =0;
                   double machineHoursSum=0.0D;
                   double totalfuelusedSum=0.0D;
                   int totalMachines=0;

                   //Get the RPM BandIdList for each band Category - High,Medium,Low
                   Query rpmBandQuery = session.createQuery("from RpmBands");
                   Iterator rpmBandItr = rpmBandQuery.list().iterator();
                   while(rpmBandItr.hasNext())
                   {
                         RpmBands rpmBand = (RpmBands)rpmBandItr.next();
                         if(rpmBand.getPower_Band().equalsIgnoreCase("Low"))
                         {
                                bandIdLowList.add(rpmBand.getBand_ID());
                         }
                         if(rpmBand.getPower_Band().equalsIgnoreCase("Med"))
                         {
                                bandIdMediumList.add(rpmBand.getBand_ID());
                         }
                         if(rpmBand.getPower_Band().equalsIgnoreCase("High"))
                         {
                                bandIdHighList.add(rpmBand.getBand_ID());
                         }
                   }
                   //added by smitha on oct 14th 2013[to display the machines which have not communicated.... Internal Defect 20131014]
                   //               calledSerNumMap=getserialNumberList(tenancyIdList,machineGroupIdList,machineProfileIdList,modelIdList);
                   //ended on oct 14th 2013[to display the machines which have not communicated.... Internal Defect 20131014]
                   //Get the tenancyIds all down the hierarchy
                   ListToStringConversion conversionObj = new ListToStringConversion();
                   String tenancyIdStringList = conversionObj.getIntegerListString(tenancyIdList).toString();
                   tenancyIdList=getSubTenancyIds(tenancyIdList,session);

                   //ListToStringConversion conversionObj = new ListToStringConversion();
                   String tenancyIDList = conversionObj.getIntegerListString(tenancyIdList).toString();
                   String loginTenIdListString = conversionObj.getIntegerListString(loginTenancyIdList).toString();                


                   boolean machineGroup = false;
                   boolean machineProfile = false;
                   boolean model = false;
                   boolean querySelected = false;
                   int year =0;int week = 0; int quarter = 0;int month =0;
                   //For input Period: Week, Month, Quarter, Year
                   DateUtil dateUtil1 = new DateUtil();
                   DateUtil thisDate =dateUtil1.getCurrentDateUtility(new Date());

                   //For input period: Last Week, Last Month, Last Quarter, Last Year
                   DateUtil dateUtil2 = new DateUtil();
                   DateUtil prevDate = dateUtil2.getPreviousDateUtility(new Date());

                   //DefectId: DF20131209 - Smitha - To display the VINs that has not communicated for the given time period 
                   SimpleDateFormat dateFrmt = new SimpleDateFormat("yyyy-MM-dd");
                   String lastDateInPeriod=null;
                   String startDateInPeriod=null;

                   //DefectID:1383 - Rajani Nagaraju - 20130930 - Query modification to return correct resultset
                   selectQuery = " select c.tenancyId,z.engineOffHours,z.machineHours,c.tenancyName,z.fuelUsedIdle,z.EngineRunningBand1, " +
                   "z.EngineRunningBand2,z.EngineRunningBand3,z.EngineRunningBand4,z.EngineRunningBand5,z.EngineRunningBand6," +
                   "z.EngineRunningBand7,z.EngineRunningBand8, x ,z.fuelUsedWorking, s.group_id as machineGroupId, s.group_name as machineGroupName,ten.tenancy_id as mgTenancy," +
                   //DefectId:20150216 @ Suprava Delaer As a new parameter Added
                   "ten1.parent_tenancy_id,c.tenancyTypeId ";

                   fromQuery =" from AssetCustomGroupMapping a RIGHT OUTER JOIN a.serial_number x  LEFT OUTER JOIN a.group_id s " +
                   //DefectID:1406 
                   " LEFT OUTER JOIN s.tenancy_id ten," +

                   "  TenancyEntity ten1 , TenancyDimensionEntity c ," +
                   //DefectId:20150216 @ Suresh joining with tenancy bridge to tweak the query
                   "TenancyBridgeEntity tb , ";

                   /*whereQuery = " where ten1.tenancy_id = c.tenancyId and z.tenancyId = c.tenacy_Dimension_Id and c.tenancyId in ("+ tenancyIDList + ") and z.serialNumber = x.serial_number " +
                   //DefectId:20150216 @ Suprava Delaer As a new parameter Added
                   " and c.parentTenancyId=ten1.parent_tenancy_id ";*/
                   
                   whereQuery = " where ten1.tenancy_id = c.tenancyId and z.tenancyId = c.tenacy_Dimension_Id and c.tenancyId =tb.childId and tb.parentId in ("+ tenancyIdStringList + ") and z.serialNumber = x.serial_number " +
                                //DefectId:20150216 @ Suprava Delaer As a new parameter Added
                                " and c.parentTenancyId=ten1.parent_tenancy_id ";

                   //DefectID:1383 - Rajani Nagaraju - 20130930 - Query modification to return correct resultset
                   String groupByQuery = " group by z.serialNumber, ten1.tenancy_id ";
                   
                   
                   
                   
                   if((isGroupingOnAssetGroup) )
                   groupByQuery=groupByQuery + ", s.group_id ";


                   //Logic for Custom Dates (fromDate,toDate) added by Juhi on 19-August-2013 
                   if(period !=null)
                   {

                         if (period.equalsIgnoreCase("Week")) 
                         {
                                week =   thisDate.getWeek();
                                year = thisDate.getYear();

                                fromQuery = fromQuery+" AssetMonitoringFactDataWeekAgg z ";
                                whereQuery = whereQuery + " and z.timeCount = "+week +" and z.year="+year;

                                //DefectId: DF20131209 - Smitha - To display the VINs that has not communicated for the given time period 
                                //get the Last Day 
                                Calendar cal = Calendar.getInstance();
                                lastDateInPeriod = dateFrmt.format(cal.getTime());
                                //get the first day of the week
                                cal.set(Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek());
                                startDateInPeriod=  dateFrmt.format(cal.getTime());
                         }

                         else if (period.equalsIgnoreCase("Last Week")) 
                         {
                                week =  prevDate.getWeek();
                                if(thisDate.getWeek()==1)
                                {
                                       year = prevDate.getYear();
                                }
                                else
                                {
                                       year = prevDate.getCurrentYear();
                                }

                                fromQuery = fromQuery+" AssetMonitoringFactDataWeekAgg z ";
                                whereQuery = whereQuery + " and z.timeCount = "+week+" and z.year="+year;

                                //DefectId: DF20131209 - Smitha - To display the VINs that has not communicated for the given time period 
                                //get the Last Day of Previous Week
                                Calendar cal = Calendar.getInstance();
                                int i = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
                                cal.add(Calendar.DATE, -i - 7);
                                cal.add(Calendar.DATE, 6);
                                lastDateInPeriod = dateFrmt.format(cal.getTime());
                                //get the First Day of Previous Week
                                cal = Calendar.getInstance();
                                int j = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
                                cal.add(Calendar.DATE, -j - 7);
                                cal.set(Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek());
                                startDateInPeriod=  dateFrmt.format(cal.getTime());
                         }

                         else if (period.equalsIgnoreCase("Month")) 
                         {
                                month =  thisDate.getMonth();
                                year = thisDate.getYear();

                                fromQuery = fromQuery+" AssetMonitoringFactDataMonthAgg z ";
                                whereQuery = whereQuery + " and z.timeCount = " + month+" and z.year="+year;

                                //DefectId: DF20131209 - Smitha - To display the VINs that has not communicated for the given time period 
                                //get the Last Day 
                                Calendar cal = Calendar.getInstance();
                                lastDateInPeriod = dateFrmt.format(cal.getTime());
                                //get the First Day of current Month
                                String mon = month+"";
                                if(mon.length()<2)
                                       mon="0"+mon;
                                startDateInPeriod=year+"-"+mon+"-"+"01";

                         }

                         else if (period.equalsIgnoreCase("Last Month")) 
                         {
                                month =  prevDate.getMonth();
                                if(thisDate.getMonth()==1)
                                {
                                       year = prevDate.getYear();
                                }
                                else
                                {
                                       year = prevDate.getCurrentYear();
                                }

                                fromQuery = fromQuery+" AssetMonitoringFactDataMonthAgg z ";
                                whereQuery = whereQuery + " and z.timeCount = " + month+" and z.year="+year;

                                //DefectId: DF20131209 - Smitha - To display the VINs that has not communicated for the given time period 
                                //Get the Last Day of previous Month
                                Calendar cal = Calendar.getInstance();
                                cal.set(Calendar.DATE, 1);
                                cal.add(Calendar.DAY_OF_MONTH, -1);
                                lastDateInPeriod = dateFrmt.format(cal.getTime());
                                //get the First Day of Previous Month
                                String mon = month+"";
                                if(mon.length()<2)
                                       mon="0"+mon;
                                startDateInPeriod=year+"-"+mon+"-"+"01";
                         }

                         else if (period.equalsIgnoreCase("Quarter")) 
                         {
                                quarter =  thisDate.getQuarter();
                                year = thisDate.getYear();

                                fromQuery = fromQuery+" AssetMonitoringFactDataQuarterAgg z ";
                                whereQuery = whereQuery + " and z.timeCount  = " +quarter+" and z.year="+year;

                                //DefectId: DF20131209 - Smitha - To display the VINs that has not communicated for the given time period 
                                //get the Last Day 
                                Calendar cal = Calendar.getInstance();
                                lastDateInPeriod = dateFrmt.format(cal.getTime());
                                //get the first Date of current quarter
                                switch(quarter) 
                                {
                                case 3 : 
                                       startDateInPeriod = year+"-07-01";
                                       break;
                                       // return July 01
                                case 2 :
                                       startDateInPeriod = year+"-04-01";
                                       break;
                                       // return April 01
                                case 1 :
                                       startDateInPeriod = year+"-01-01";
                                       break;
                                       // return Jan 01
                                case 4 : 
                                       startDateInPeriod = year+"-10-01";
                                       break;
                                       // return Oct 01
                                }

                         }

                         else if (period.equalsIgnoreCase("Last Quarter")) 
                         {
                                quarter = prevDate.getQuarter();
                                if(thisDate.getQuarter()==1)
                                {
                                       year = prevDate.getYear();
                                }
                                else
                                {
                                       year = prevDate.getCurrentYear();
                                }

                                fromQuery = fromQuery+" AssetMonitoringFactDataQuarterAgg z ";
                                whereQuery = whereQuery + " and z.timeCount  = " +quarter+" and z.year="+year;

                                //DefectId: DF20131209 - Smitha - To display the VINs that has not communicated for the given time period 
                                //get the last day of previous quarter
                                switch(quarter) 
                                {
                                case 3 : 
                                       lastDateInPeriod = year+"-09-30";
                                       break;
                                       // return September 30
                                case 2 :
                                       lastDateInPeriod = year+"-06-30";
                                       break;
                                       // return June 30
                                case 1 :
                                       lastDateInPeriod = year+"-03-31";
                                       break;
                                       // return March 31
                                case 4 : 
                                       lastDateInPeriod = year+"-12-31";
                                       break;
                                       // return December 31
                                }
                                //get the first Date of Previous quarter
                                switch(quarter) 
                                {
                                case 3 : 
                                       startDateInPeriod = year+"-07-01";
                                       break;
                                       // return July 01
                                case 2 :
                                       startDateInPeriod = year+"-04-01";
                                       break;
                                       // return April 01
                                case 1 :
                                       startDateInPeriod = year+"-01-01";
                                       break;
                                       // return Jan 01
                                case 4 : 
                                       startDateInPeriod = year+"-10-01";
                                       break;
                                       // return Oct 01
                                }
                         }


                         else if (period.equalsIgnoreCase("Year")) 
                         {
                                year = thisDate.getYear();

                                fromQuery = fromQuery+" AssetMonitoringFactDataYearAgg z ";
                                whereQuery = whereQuery + " and z.year= "+year;

                                //DefectId: DF20131209 - Smitha - To display the VINs that has not communicated for the given time period 
                                //get the Last Day 
                                Calendar cal = Calendar.getInstance();
                                lastDateInPeriod = dateFrmt.format(cal.getTime());
                                //get the First day of current Year
                                startDateInPeriod=year+"-01"+"-01";
                         }

                         else if (period.equalsIgnoreCase("Last Year")) 
                         {
                                year = prevDate.getYear();

                                fromQuery = fromQuery+" AssetMonitoringFactDataYearAgg z ";
                                whereQuery = whereQuery + " and z.year= "+year;

                                //DefectId: DF20131209 - Smitha - To display the VINs that has not communicated for the given time period 
                                //get the Last day of previous Year
                                lastDateInPeriod=year+"-12-31";
                                //get the First day of Previous Year 
                                startDateInPeriod=year+"-01"+"-01";
                         }     
                   }

                   //Logic for Custom Dates (fromDate,toDate) added by Juhi on 19-August-2013 
                   else
                   {
                         //added by smitha on oct 14th 2013[custom dates aggregation for a VIN query change.... Internal Defect 20131014]
                         //DefectID:1406 - smitha - 20131029 - MachineGrouping issue in Reports and sending Report Totals information
                         querySelected=true;
                         selectQueryCustomDates = " select c.tenancyId,sum(z.engineOffHours),sum(z.machineHours),c.tenancyName,sum(z.fuelUsedIdle),sum(z.EngineRunningBand1), " +
                   "sum(z.EngineRunningBand2),sum(z.EngineRunningBand3),sum(z.EngineRunningBand4),sum(z.EngineRunningBand5),sum(z.EngineRunningBand6)," +
                   "sum(z.EngineRunningBand7),sum(z.EngineRunningBand8), x ,sum(z.fuelUsedWorking), s.group_id as machineGroupId, s.group_name as machineGroupName, ten.tenancy_id as mgTenancy ";
                         

                         selectQueryCustomDates = " select c.tenancyId,sum(u.engineOffHours),z.machineHours,c.tenancyName,sum(u.fuelUsedIdle),sum(u.EngineRunningBand1), " +
                          "sum(u.EngineRunningBand2),sum(u.EngineRunningBand3),sum(u.EngineRunningBand4),sum(u.EngineRunningBand5),sum(u.EngineRunningBand6)," +
                         "sum(u.EngineRunningBand7),sum(u.EngineRunningBand8), x ,sum(u.fuelUsedWorking), s.group_id as machineGroupId, s.group_name as machineGroupName, ten.tenancy_id as mgTenancy," +
                         //DefectId:20150216 @ Suprava Delaer As a new parameter Added
                          "ten1.parent_tenancy_id,c.tenancyTypeId ";


                         //ended on oct 14th 2013[custom dates aggregation for a VIN query change.... Internal Defect 20131014]
                         DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
                         DateFormat dateFormat1 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
                         Date fromdate1=null;
                         String fromdate2=null;
                         String todate2=null;

                         try 
                         {                                                         
                                fromdate1 = (Date)dateFormat.parse(fromDate);         
                                String fromdate=dateFormat.format(fromdate1);
                                fromdate2=dateFormat1.format(fromdate1);

                                Date todate1=(Date)dateFormat.parse(toDate);

                                String todate=dateFormat.format(todate1);
                                todate2=dateFormat1.format(todate1);


                         } 
                         catch (ParseException e) 
                         {
                                // TODO Auto-generated catch block
                                e.printStackTrace();
                         }

                         //DefectId: DF20131209 - Smitha - To display the VINs that has not communicated for the given time period 

                         if(fromdate2==null || todate2==null)
                          {
                                throw new CustomFault("Unparsable Date input for Custom dates");
                         }


                         startDateInPeriod = fromdate2;
                         lastDateInPeriod = todate2;

                         fromQuery =fromQuery+ " AssetMonitoringFactDataDayAgg z ";
                   whereQuery = whereQuery+ " and z.timeKey between '"+fromdate2+"' and '"+todate2+"' ";    
                         //DefectID:20131211...Smitha for custom dates implementation
                         fromQueryCustomDates = " from AssetCustomGroupMapping h RIGHT OUTER JOIN h.serial_number x  LEFT OUTER JOIN h.group_id s" +
                         //DefectID:1406
                         " LEFT OUTER JOIN s.tenancy_id ten , TenancyEntity ten1, " +
                         " TenancyDimensionEntity c, AssetMonitoringFactDataDayAgg z, AssetMonitoringFactDataDayAgg u ";
                         
                         whereQueryCustomDates = " where ten1.tenancy_id = c.tenancyId and " +
                         " z.tenancyId = c.tenacy_Dimension_Id and c.tenancyId =tb.childId and tb.parentId in ("+ tenancyIdStringList + ") " +
                         " and z.serialNumber = x.serial_number " +
                         //     " and d.primary_owner_id = v.account_id " +
                         " and z.serialNumber = u.serialNumber " +
                         " and u.tenancyId=z.tenancyId " +
                         " and z.timeKey = (select max(o.timeKey) from AssetMonitoringFactDataDayAgg o, TenancyDimensionEntity yt" +
                         " where o.serialNumber=z.serialNumber and o.tenancyId = yt.tenacy_Dimension_Id and yt.tenancyId in ("+ tenancyIdStringList + " ) " +
                         " and o.timeKey >='"+fromdate2+"' and o.timeKey <= '"+todate2+"')" +
                         " and u.timeKey between '"+fromdate2+"' and '"+todate2+"'" +
                         //DefectId:20150216 @ Suprava Delaer As a new parameter Added
                         " and c.parentTenancyId=ten1.parent_tenancy_id ";

                         //DefectID:1383 - Rajani Nagaraju - 20130930 - Query modification to return correct resultset
                         //                   groupByQuery=groupByQuery+" ,z.timeKey,z.tenancyId";
                         //                     groupByQuery=groupByQuery+" ,z.tenancyId,s.group_id ";
                         groupByQuery=groupByQuery+" ,s.group_id ";


                   }

                   if (!(machineGroupIdList == null || machineGroupIdList.isEmpty())) 
                   {
                         String customAssetGroupStringList = conversionObj.getIntegerListString(machineGroupIdList).toString();
                         whereQuery = whereQuery + " and s.group_id in ("+ customAssetGroupStringList + ")";
                         //DefectID's:1736 and 1406 and 1924 -----Smitha----- filterig based on machine grouping for custom dates.
                         whereQueryCustomDates = whereQueryCustomDates + " and s.group_id in ("+ customAssetGroupStringList + ")";
                   }

                   if ((!(machineProfileIdList == null || machineProfileIdList.isEmpty())) || (!(modelIdList == null || modelIdList.isEmpty()))) 
                   {
                         fromQuery = fromQuery+ " , AssetClassDimensionEntity b ";
                         //DefectID's:1736 and 1406 and 1924 -----Smitha----- filterig based on machine grouping for custom dates.
                         fromQueryCustomDates = fromQueryCustomDates+ " , AssetClassDimensionEntity b ";
                         whereQuery = whereQuery + " and z.assetClassDimensionId = b.assetClassDimensionId ";
                         //DefectID's:1736 and 1406 and 1924 -----Smitha----- filterig based on machine grouping for custom dates.
                         whereQueryCustomDates = whereQueryCustomDates + " and z.assetClassDimensionId = b.assetClassDimensionId ";

                   }

                   //DefectID:1383 - Rajani Nagaraju - 20130930 - Query modification to return correct resultset
                   if (!(machineProfileIdList == null || machineProfileIdList.isEmpty())) 
                   {
                         String machineProfileIdStringList = conversionObj.getIntegerListString(machineProfileIdList).toString();
                         whereQuery = whereQuery + " and b.assetGroupId in ( "+ machineProfileIdStringList + ") ";
                         //DefectID's:1736 and 1406 and 1924 -----Smitha----- filterig based on machine grouping for custom dates.
                         whereQueryCustomDates = whereQueryCustomDates + " and b.assetGroupId in ( "+ machineProfileIdStringList + ") ";
                   }

                   //DefectID:1383 - Rajani Nagaraju - 20130930 - Query modification to return correct resultset
                   if (!(modelIdList == null || modelIdList.isEmpty())) 
                   {
                         String modelIdStringList = conversionObj.getIntegerListString(modelIdList).toString();
                         whereQuery = whereQuery + " and b.assetTypeId in ( "+ modelIdStringList + " )";
                         //DefectID's:1736 and 1406 and 1924 -----Smitha----- filterig based on machine grouping for custom dates.
                         whereQueryCustomDates = whereQueryCustomDates + " and b.assetTypeId in ( "+ modelIdStringList + " )";
                   }

                   if(querySelected==false){
                   //     System.out.println("Fleet summary final query");//Roopa
                         finalQuery = selectQuery + fromQuery + whereQuery + groupByQuery+" order by x.serial_number, z.lastReported desc ";
                   }
                   else{
                         iLogger.info("query for custom dates ");
                         //DefectID:20131211...Smitha for custom dates implementation
                         finalQuery = selectQueryCustomDates + fromQueryCustomDates + whereQueryCustomDates + groupByQuery+" order by x.serial_number, z.lastReported desc ";
                   }

                   //Execute the hibernate Query
                   System.out.println("finalQuery:"+finalQuery);
                   Query qury = session.createQuery(finalQuery);
                   Iterator tq = qury.list().iterator();

                   Object[] result = null;
                   double      EngineRunningBand1=0;
                   double      EngineRunningBand2=0;
                   double      EngineRunningBand3=0;
                   double      EngineRunningBand4=0;
                   double      EngineRunningBand5=0;
                   double      EngineRunningBand6=0;
                   double      EngineRunningBand7=0;
                   double      EngineRunningBand8=0;

                   //    Changes dony by Juhi on 19 july2013 for decimal format
                   // DecimalFormat df2 = new DecimalFormat("###.#");
                   //DefectID:1406 - Smitha - 20131029 - MachineGrouping issue in Reports and sending Report Totals information
                   List<String> otherMachineGroupVins = new LinkedList<String>();

                   while (tq.hasNext()) 
                   {
                         implObj = new FleetSummaryReporImpl();
                         tempSerialNumber = null;

                         result = (Object[]) tq.next();  
                         AssetEntity asset = null;
                         TenancyEntity tenancyEntity =null;
                         // 12/3/2013 null check handled by Keerthi
                         if(result[17]!=null){
                                implObj.setTenanctIdList((Integer) result[17]); 
                         }

                         //added by smitha on oct 14th 2013[custom dates aggregation for a VIN query change.... Internal Defect 20131014]
                         if(querySelected==false){
                   if(result[1]!=null)
                         implObj.setEngineOff(Double.valueOf(df2.format((Double)result[1])));
                   } else {
                   if(result[1]!=null)
                         implObj.setEngineOff(Double.valueOf(df2.format((Double)result[1])));   
                   }

                         if(result[1]!=null){
                                implObj.setEngineOff(Double.valueOf(df2.format((Double)result[1])));
                         }

                         //ended on oct 14th 2013[custom dates aggregation for a VIN query change.... Internal Defect 20131014]
                         if(result[2]!=null)
                                implObj.setTotalMachineLifeHours(Double.valueOf(df2.format((Double)result[2])));                      

                         //DefectId:20150313 @ Suprava Null check handle.
                         if(result[3]!=null){
                         implObj.setTenancyName(result[3].toString()); 
                         }
                         
                         if(result[4]!=null)
                                implObj.setFuelUsedInIdle(Double.valueOf(df2.format((Double)result[4])));     
                         //                   Keerthi : 02/12/13 : rounding off band values to one decimal point
                         //Commented DF:20131219 Juhi and Suprava
                         if(result[5]!=null)
                                if(((Double)result[5]).intValue()<0)
                                {
                                       EngineRunningBand1=((Double)result[5]).intValue();
                                }
                                else{
                                       EngineRunningBand1= (Double)result[5];
                                }
                         if(result[6]!=null)
                                if(((Double)result[6]).intValue()<0)
                                {
                                       EngineRunningBand2=((Double)result[6]).intValue();
                                }
                                else{

                                       EngineRunningBand2= (Double)result[6];
                                }



                         if(result[7]!=null)
                                if(((Double)result[7]).intValue()<0)
                                {
                                       EngineRunningBand3=((Double)result[7]).intValue();
                                }
                                else{
                                       EngineRunningBand3= (Double)result[7];

                                }

                         if(result[8]!=null)
                                if(((Double)result[8]).intValue()<0)
                                {
                                       EngineRunningBand4=((Double)result[8]).intValue();
                                }
                                else{
                                       EngineRunningBand4=(Double)result[8];

                                }


                         if(result[9]!=null)
                                if(((Double)result[9]).intValue()<0)
                                {
                                       EngineRunningBand5=((Double)result[9]).intValue();
                                }
                                else{
                                       EngineRunningBand5= (Double)result[9];

                                }


                         if(result[10]!=null)
                                if(((Double)result[10]).intValue()<0)
                                {
                                       EngineRunningBand6=((Double)result[10]).intValue();
                                }
                                else{
                                       EngineRunningBand6= (Double)result[10];

                                }


                         if(result[11]!=null)
                                if(((Double)result[11]).intValue()<0)
                                {
                                       EngineRunningBand7=((Double)result[11]).intValue();
                                }
                                else{
                                       EngineRunningBand7=(Double)result[11];

                                }


                         if(result[12]!=null)
                                if(((Double)result[12]).intValue()<0)
                                {
                                       EngineRunningBand8=((Double)result[12]).intValue();
                                }
                                else{
                                       EngineRunningBand8= (Double)result[12];

                                }


                         if(result[13]!=null){
                                asset = (AssetEntity)result[13]; 
                                //added by smitha on oct 14th 2013[custom dates aggregation for a VIN query change and to display the machines which have not communicated .... Internal Defect 20131014]
                                tempSerialNumber=asset.getSerial_number().getSerialNumber();
                         }
                         //Smitha:DefectID:20131218...to avoid same VIN with same machine groupID repeating                   
                         if(tempSerNumList.contains(tempSerialNumber)){
                                continue;
                         }

                         //DefectID: 1406
                         int otherMachineGroup =0;
                   if(result[17]!=null)
                   {
                         int mgTenancy = (Integer) result[17];
                         if(!(loginTenancyIdList.contains(mgTenancy))) 
                         {
                               otherMachineGroup=1;
                         }
                   }

                   if( (otherMachineGroup==1)&& ( (otherMachineGroupVins.contains(tempSerialNumber)) || (tempSerNumList.contains(tempSerialNumber)) ) )
                   {
                         continue;
                   }
                   if(tempSerNumList.contains(tempSerialNumber)){
                         if(isGroupingOnAssetGroup==false){
                               continue;
                         }
                   }     

                         //                   tempSerNumList.add(asset.getSerial_number().getSerialNumber());
                         //ended on oct 14th 2013[custom dates aggregation for a VIN query change and to display the machines which have not communicated .... Internal Defect 20131014]
                         implObj.setSerialNumber(asset.getSerial_number().getSerialNumber());

                         double workingTime= EngineRunningBand3+EngineRunningBand4+EngineRunningBand5+EngineRunningBand6+EngineRunningBand7+EngineRunningBand8;
                         double idleTime=EngineRunningBand1+EngineRunningBand2;

                         //                   Keerthi : 02/12/13 : hour values to one decimal point
                         implObj.setWorkingTime(Double.valueOf(df2.format((Double)workingTime)));                        
                         implObj.setIdleTime(Double.valueOf(df2.format((Double)idleTime)));

                         double machineHours=workingTime+idleTime;   
                          implObj.setMachineHours(Double.valueOf(df2.format((Double)machineHours)));
                         double fuelUsedIdle1=0;
                         if( result[4]!=null)
                                fuelUsedIdle1=(Double.valueOf(df2.format((Double)result[4])));

                         double fuelUsedWorking=0;
                         if(result[14]!=null)
                                fuelUsedWorking=(Double.valueOf(df2.format((Double)result[14])));

                         double fuelUsed1=fuelUsedIdle1+fuelUsedWorking;
                         implObj.setFuelused(Double.valueOf(df2.format(fuelUsed1)));

                         //DF20140529 - Rajani Nagaraju - averageFuelConsumption was getting set as NAN, since it was doing 0.0/0.0
                         if(Double.valueOf(df2.format((Double)machineHours))!=0)
                                //if(machineHours!=0)
                         {
                                double averageFuelConsumption= ((Double.valueOf(df2.format(fuelUsed1)))/(Double.valueOf(df2.format((Double)machineHours))));
                         //     System.out.println("fuelUsed1:"+fuelUsed1);
                         //     System.out.println("machineHours:"+machineHours);
                         //       System.out.println("averageFuelConsumption:"+averageFuelConsumption);
                                implObj.setAverageFuelConsumption(Double.valueOf(df2.format(averageFuelConsumption)));
                         }

                         double lowValue = bandCalculation(bandIdLowList,
                                       EngineRunningBand1, EngineRunningBand2,
                                       EngineRunningBand3, EngineRunningBand4,
                                       EngineRunningBand5, EngineRunningBand6,
                                       EngineRunningBand7, EngineRunningBand8);

                         double midValue = bandCalculation(bandIdMediumList,
                                       EngineRunningBand1, EngineRunningBand2,
                                       EngineRunningBand3, EngineRunningBand4,
                                       EngineRunningBand5, EngineRunningBand6,
                                       EngineRunningBand7, EngineRunningBand8);
                         double highValue = bandCalculation(bandIdHighList,
                                       EngineRunningBand1, EngineRunningBand2,
                                       EngineRunningBand3, EngineRunningBand4,
                                       EngineRunningBand5, EngineRunningBand6,
                                       EngineRunningBand7, EngineRunningBand8);              

                         implObj.setPowerBandhigh(Double.valueOf(df2.format(highValue)));
                         implObj.setPowerBandLow(Double.valueOf(df2.format(lowValue)));
                         implObj.setPowerBandMedium(Double.valueOf(df2.format(midValue)));
                         //DefectId:20150216 @ Suprava Delaer As a new parameter Added
                         if(result[19]!=null)
                         {
                                int tenancyTypeId =(Integer) result[19];
                                //If the Machine is with customer Get the parentTeancyId
                                if(tenancyTypeId==4)
                                {
                                       tenancyEntity =(TenancyEntity)result[18];
                                       implObj.setDealername(tenancyEntity.getTenancy_name());
                                }
                                //If the Machine is with Dealer
                                else if(tenancyTypeId==3) 
                                {
                                       if(result[3]!=null)
                                       {
                                       String Dealername =(String)result[3];
                                       implObj.setDealername(Dealername);
                                }
                                }
                                else
                                {
                                       implObj.setDealername("No Dealer Tagging");
                                }
                         
                         }

                         if(result[15]!=null)
                         implObj.setMachineGroupIdList((Integer) result[15]);

                   if(result[16]!=null)
                         implObj.setMachineGroupName(result[16].toString());

                         //DefectID:1406 - Smitha- 20131029 - MachineGrouping issue in Reports and sending Report Totals information
                         if(result[17]!=null)
                   {
                         int mgTenancy = (Integer) result[17];
                         if(loginTenancyIdList.contains(mgTenancy)) 
                         {
                               if(result[15]!=null)
                                     implObj.setMachineGroupIdList((Integer)result[15]);

                               if(result[16]!=null)
                                     implObj.setMachineGroupName(result[16].toString());
                         }
                         else
                         {
                               otherMachineGroupVins.add(tempSerialNumber);
                         }

                   }

                         //DefectID:1383 - Rajani Nagaraju - 20130930 - Query modification to return correct resultset
                         if(asset!=null)
                         {
                                if(asset.getProductId()!=null && asset.getProductId().getAssetGroupId()!=null)
                                {
                                       implObj.setMachineProfile(asset.getProductId().getAssetGroupId().getAsset_group_id());
                                       implObj.setProfile(asset.getProductId().getAssetGroupId().getAsset_group_name());
                                }

                                if(asset.getProductId()!=null && asset.getProductId().getAssetTypeId()!=null)
                                {
                                       implObj.setModelIdList(asset.getProductId().getAssetTypeId().getAsset_type_id());
                                       implObj.setModelName(asset.getProductId().getAssetTypeId().getAsset_type_name());
                                }

                                implObj.setMachineName(asset.getNick_name());
                         }                 

                         //DefectID:1406 - Rajani Nagaraju - 20131029 - To return Report Totals                        
                         if(!(tempSerNumList.contains(tempSerialNumber)))
                         {

                                totalMachineLifeHoursSum = totalMachineLifeHoursSum+(Double.valueOf(df2.format(((Double)result[2]))));
                                double        tempMachineHours=(Double.valueOf(df2.format(machineHours)));
                                //Commented DF:20131219
                                   if(tempMachineHours<0){
                               tempMachineHours=0.0d;
                        }
                                //System.out.println("Serial_Number "+tempMachineHours);
                                //System.out.println("tempMachineHours "+tempMachineHours);
                                machineHoursSum = machineHoursSum+tempMachineHours;
                                //System.out.println("machineHoursSum "+ machineHoursSum);
                                totalfuelusedSum = totalfuelusedSum+(Double.valueOf(df2.format(fuelUsed1)));
                         }  
                         //  machineHoursSum = machineHoursSum+tempMachineHours;
                         //DefectID: DF20131210 - Smitha - To take the latest/Last reported row from factAgg tables
                         //Get the List of MachineGroup under the Login Tenancy to which the machine belongs to 
                         if(isGroupingOnAssetGroup)
                         {
                                Query mgQuery=null;
                                if (!(machineGroupIdList == null || machineGroupIdList.isEmpty())) 
                                {
                                       String customAssetGroupStringList = conversionObj.getIntegerListString(machineGroupIdList).toString();
                                       //Smitha:DefectID:20131218...to get the VIN's belonging to the machine groups under that tenancy ID
                                       mgQuery = session.createQuery(" select a from AssetCustomGroupMapping a, CustomAssetGroupEntity b " +
                                                     "where serial_number='"+tempSerialNumber+"' and a.group_id=b.group_id and b.level=2 and b.active_status=1 and b.tenancy_id in ("+loginTenIdListString+")" +
                                                     " and b.group_id in ("+customAssetGroupStringList+")");
                                }

                                else
                                {
                                       //Smitha:DefectID:20131218...to get the VIN's belonging to the machine groups under that tenancy ID
                                       mgQuery = session.createQuery(" select a from AssetCustomGroupMapping a, CustomAssetGroupEntity b " +
                                                     "where serial_number='"+tempSerialNumber+"' and a.group_id=b.group_id and b.level=2 and b.active_status=1 and b.tenancy_id in ("+loginTenIdListString+")");
                                }
                                Iterator mgItr = mgQuery.list().iterator();
                                int firstIteration =0;
                                while(mgItr.hasNext())
                                {
                                       AssetCustomGroupMapping mgVinMapping = (AssetCustomGroupMapping)mgItr.next();
                                       if(firstIteration==0)
                                       {
                                              firstIteration=1;
                                              implObj.setMachineGroupIdList(mgVinMapping.getGroup_id().getGroup_id());
                                              implObj.setMachineGroupName(mgVinMapping.getGroup_id().getGroup_name());
                                              listImplObj.add(implObj);
                                       }
                                       else
                                       {
                                              FleetSummaryReporImpl newimplObj = new FleetSummaryReporImpl();
                                              newimplObj.setSerialNumber(tempSerialNumber);
                                              newimplObj.setTotalMachineLifeHours(Double.valueOf(df2.format((Double)(implObj.getTotalMachineLifeHours()))));
                                              newimplObj.setMachineHours(Double.valueOf(df2.format((Double)(implObj.getMachineHours()))));       
                                              newimplObj.setMachineName(implObj.getMachineName());
                                              newimplObj.setTenancyName(implObj.getTenancyName());
                                              newimplObj.setMachineGroupIdList(mgVinMapping.getGroup_id().getGroup_id());
                                              newimplObj.setMachineGroupName(mgVinMapping.getGroup_id().getGroup_name());
                                              newimplObj.setMachineProfile(implObj.getMachineProfile());
                                              newimplObj.setProfile(implObj.getProfile());
                                              newimplObj.setModelIdList(implObj.getModelIdList());
                                              newimplObj.setModelName(implObj.getModelName());
                                              newimplObj.setAverageFuelConsumption(implObj.getAverageFuelConsumption());
                                              newimplObj.setEngineOff(Double.valueOf(df2.format((Double)(implObj.getEngineOff()))));
                                              newimplObj.setFuelused(Double.valueOf(df2.format((Double)(implObj.getFuelused()))));
                                              newimplObj.setFuelUsedInIdle(Double.valueOf(df2.format((Double)(implObj.getFuelUsedInIdle()))));
                                              newimplObj.setIdleTime(Double.valueOf(df2.format((Double)(implObj.getIdleTime()))));
                                              newimplObj.setPowerBandhigh((Double.valueOf(df2.format((Double)(implObj.getPowerBandhigh())))));
                                              newimplObj.setPowerBandLow(Double.valueOf(df2.format((Double)(implObj.getPowerBandLow()))));
                                              newimplObj.setPowerBandMedium(Double.valueOf(df2.format((Double)(implObj.getPowerBandMedium()))));
                                              newimplObj.setTenanctIdList(implObj.getTenanctIdList());
                                              newimplObj.setWorkingTime(Double.valueOf(df2.format((Double)(implObj.getWorkingTime()))));
                                              newimplObj.setDealername(implObj.getDealername());
                                              listImplObj.add(newimplObj);
                                       }
                                }

                                if(firstIteration==0)
                                {
                                       listImplObj.add(implObj);
                                }
                         }

                         else
                         {
                                listImplObj.add(implObj);
                         }


                         tempSerNumList.add(asset.getSerial_number().getSerialNumber());
                         tempSerNumList.add(tempSerialNumber);
                         listImplObj.add(implObj);
                   }

                   //-------------------------------------------------------------------------------------------------------------------
                   //DefectId: DF201312089 - Smitha - To display the VINs that has not communicated for the given time period
                   Query ownerListQuery = session.createQuery(" select distinct c.serialNumber " +
                                " from TenancyBridgeEntity a, AccountTenancyMapping b, AssetAccountMapping c " +
                                " where a.childId= b.tenancy_id " +
                                " and b.account_id= c.accountId " +
                                " and a.parentId in ("+tenancyIdStringList+") and" +
                                " ( (c.ownershipStartDate between '"+startDateInPeriod+"' and '"+lastDateInPeriod+"') OR " +
                                "   (c.ownershipStartDate = ( select max(y.ownershipStartDate) from AssetAccountMapping y " +
                                " where y.serialNumber= c.serialNumber" +
                                " and y.ownershipStartDate <='"+startDateInPeriod+"')" +
                                "    )" +
                   " )");
                   Iterator ownerListItr = ownerListQuery.list().iterator();
                   List<String> actualOwnerVINList = new LinkedList<String>();
                   while(ownerListItr.hasNext())
                   {
                         AssetEntity assetList = (AssetEntity)ownerListItr.next();
                         actualOwnerVINList.add(assetList.getSerial_number().getSerialNumber());
                   }

                   //Get only the List of VINs which has not communicated for the Given period
                   actualOwnerVINList.removeAll(tempSerNumList);
                   String actualOwnerVinListString = conversionObj.getStringList(actualOwnerVINList).toString();

                   
      			 
                   int actualOwnerVinListStringItr = actualOwnerVINList.size();
                   iLogger.info("actualOwnerVinListStringItr :"+actualOwnerVinListStringItr);
                   int startlimit=0;
      			 
      			   int endlimit=500;
      			 
      			   List<String> tempactualOwnerVINList;
      			 
      			   for ( int i=0; i<actualOwnerVinListStringItr; i= i+500 ) {
      				   
      				 iLogger.info("actualOwnerVinListStringItr :"+actualOwnerVinListStringItr);
      				 if(endlimit >= actualOwnerVinListStringItr)
      					 endlimit = actualOwnerVinListStringItr-1;
      				 tempactualOwnerVINList=actualOwnerVINList.subList(startlimit, endlimit);
      				 
      				 iLogger.info("tempactualOwnerVINList :"+tempactualOwnerVINList);
                   //DefectID: DF20131210 - Smitha - To take the latest/Last reported row from factAgg tables
                   groupByQuery =" group by z.serialNumber, ten1.tenancy_id ";

                   selectQuery = " select c.tenancyId,z.engineOffHours,z.machineHours,c.tenancyName,z.fuelUsedIdle,z.EngineRunningBand1, " +
                   "z.EngineRunningBand2,z.EngineRunningBand3,z.EngineRunningBand4,z.EngineRunningBand5,z.EngineRunningBand6," +
                   "z.EngineRunningBand7,z.EngineRunningBand8, x ,z.fuelUsedWorking, s.group_id as machineGroupId, s.group_name as machineGroupName,ten.tenancy_id as mgTenancy," +
                   //DefectId:20150216 @ Suprava Delaer As a new parameter Added
                   "ten1.parent_tenancy_id,c.tenancyTypeId ";

                   fromQuery =" from AssetCustomGroupMapping a RIGHT OUTER JOIN a.serial_number x  LEFT OUTER JOIN a.group_id s " +
                   //DefectID:1406 
                   " LEFT OUTER JOIN s.tenancy_id ten, TenancyEntity ten1, " +

                   " TenancyDimensionEntity c, AssetMonitoringFactDataDayAgg z ";
                   //Smitha:DefectID:20131218...to avoid same VIN with same machine groupID repeating
                   whereQuery = " where ten1.tenancy_id = c.tenancyId and z.tenancyId = c.tenacy_Dimension_Id and z.serialNumber = x.serial_number " +
                   " and z.serialNumber in (:list) " +
                   " and z.timeKey = ( select max(p.timeKey) from AssetMonitoringFactDataDayAgg p where p.serialNumber = z.serialNumber " +
                   " and p.timeKey <= '"+startDateInPeriod+"' )" +
                   //DefectId:20150216 @ Suprava Delaer As a new parameter Added
                   " and c.parentTenancyId=ten1.parent_tenancy_id ";

                   if (!(machineGroupIdList == null || machineGroupIdList.isEmpty())) 
                   {
                         String customAssetGroupStringList = conversionObj.getIntegerListString(machineGroupIdList).toString();
                         whereQuery = whereQuery + " and s.group_id in ("+ customAssetGroupStringList + ")";
                   }

                   if ((!(machineProfileIdList == null || machineProfileIdList.isEmpty())) || (!(modelIdList == null || modelIdList.isEmpty()))) 
                   {
                         fromQuery = fromQuery+ " , AssetClassDimensionEntity b ";
                         whereQuery = whereQuery + " and z.assetClassDimensionId = b.assetClassDimensionId ";

                   }

                   //DefectID:1383 - Smitha - 20131210 - Query modification to return correct resultset
                   if (!(machineProfileIdList == null || machineProfileIdList.isEmpty())) 
                   {
                         String machineProfileIdStringList = conversionObj.getIntegerListString(machineProfileIdList).toString();
                         whereQuery = whereQuery + " and b.assetGroupId in ( "+ machineProfileIdStringList + ") ";
                   }

                   //DefectID:1383 - Smitha - 20131210 - Query modification to return correct resultset
                   if (!(modelIdList == null || modelIdList.isEmpty())) 
                   {
                         String modelIdStringList = conversionObj.getIntegerListString(modelIdList).toString();
                         whereQuery = whereQuery + " and b.assetTypeId in ( "+ modelIdStringList + " )";
                   }


                   //DefectID:1406 - Smitha - 20131210 - MachineGrouping issue
                /*  if(! (actualOwnerVINList==null || actualOwnerVINList.isEmpty()))
                   {*/
                         finalQuery = selectQuery + fromQuery+ whereQuery + groupByQuery + " order by x.serial_number, z.lastReported desc ";
                       //  Iterator vinListItr = session.createQuery(finalQuery).list().iterator();
                         result =null;
                         Query vinListItrquery= session.createQuery(finalQuery).setParameterList("list", tempactualOwnerVINList);
                         Iterator vinListItr = vinListItrquery.list().iterator();
                         iLogger.info("finalQuery).list():"+vinListItrquery.list().size()+" Final Query :"+finalQuery);
                         tempSerNumList = new LinkedList<String>();
                         while(vinListItr.hasNext()){

                                implObj = new FleetSummaryReporImpl();
                                tempSerialNumber = null;

                                result = (Object[]) vinListItr.next();
                                AssetEntity asset =null;
                                TenancyEntity tenancyEntity=null;
                                // 12/3/2013 null check handled by Keerthi
                                if(result[17]!=null){
                                       implObj.setTenanctIdList((Integer) result[17]); 
                                }

                                //added by smitha on oct 14th 2013[custom dates aggregation for a VIN query change.... Internal Defect 20131014]
                                //DefectID:20131211...Smitha for custom dates implementation
                                if(result[1]!=null)
                                       // implObj.setEngineOff(Double.valueOf(df2.format((Double)result[1])));
                                       //DefectId:20140912 Running band issue @suprava
                                       implObj.setEngineOff(100L);

                                //ended on oct 14th 2013[custom dates aggregation for a VIN query change.... Internal Defect 20131014]
                                if(result[2]!=null)
                                       implObj.setTotalMachineLifeHours(Double.valueOf(df2.format((Double)result[2])));                      

                                //DefectId:20150313 @Suprava Null Check Handled
                                if(result[3]!=null){
                                implObj.setTenancyName(result[3].toString());
                                }

                                if(result[4]!=null)
                                       implObj.setFuelUsedInIdle(Double.valueOf(df2.format((Double)result[4])));     
                                //                       Keerthi : 02/12/13 : rounding off band values to one decimal point
                                if(result[5]!=null)
                                       EngineRunningBand1= (Double)result[5];

                                if(result[6]!=null)
                                       EngineRunningBand2= (Double)result[6];

                                if(result[7]!=null)
                                       EngineRunningBand3= (Double)result[7];

                                if(result[8]!=null)
                                       EngineRunningBand4=(Double)result[8];

                                if(result[9]!=null)
                                       EngineRunningBand5= (Double)result[9];

                                if(result[10]!=null)
                                       EngineRunningBand6= (Double)result[10];

                                if(result[11]!=null)
                                       EngineRunningBand7= (Double)result[11];

                                if(result[12]!=null)
                                       EngineRunningBand8= (Double)result[12];

                                if(result[13]!=null){
                                       asset = (AssetEntity)result[13]; 
                                       //added by smitha on oct 14th 2013[custom dates aggregation for a VIN query change and to display the machines which have not communicated .... Internal Defect 20131014]
                                       tempSerialNumber=asset.getSerial_number().getSerialNumber();
                                }                       
                                //Smitha:DefectID:20131218...to avoid same VIN with same machine groupID repeating
                                if(tempSerNumList.contains(tempSerialNumber))
                                {
                                       continue;
                                }

                                //DefectID: 1406
                                int otherMachineGroup =0;
                       if(result[17]!=null)
                       {
                             int mgTenancy = (Integer) result[17];
                             if(!(loginTenancyIdList.contains(mgTenancy))) 
                             {
                                   otherMachineGroup=1;
                             }
                       }

                       if( (otherMachineGroup==1)&& ( (otherMachineGroupVins.contains(tempSerialNumber)) || (tempSerNumList.contains(tempSerialNumber)) ) )
                       {
                             continue;
                       }
                       if(tempSerNumList.contains(tempSerialNumber)){
                             if(isGroupingOnAssetGroup==false){
                                   continue;
                             }
                       }     

                                //ended on oct 14th 2013[custom dates aggregation for a VIN query change and to display the machines which have not communicated .... Internal Defect 20131014]
                                implObj.setSerialNumber(asset.getSerial_number().getSerialNumber());

                                double workingTime= EngineRunningBand3+EngineRunningBand4+EngineRunningBand5+EngineRunningBand6+EngineRunningBand7+EngineRunningBand8;
                                double idleTime=EngineRunningBand1+EngineRunningBand2;
                                //                       Keerthi : 02/12/13 : hour values to one decimal point
                                //  implObj.setWorkingTime(Double.valueOf(df2.format((Double)workingTime)));                        
                                //   implObj.setIdleTime(Double.valueOf(df2.format((Double)idleTime)));

                                //     double machineHours=workingTime+idleTime;   
                                double machineHours=0;
                                //    implObj.setMachineHours(Double.valueOf(df2.format((Double)machineHours)));

                                double fuelUsedIdle1=0;
                                if( result[4]!=null)
                                       fuelUsedIdle1=(Double.valueOf(df2.format((Double)result[4])));

                                double fuelUsedWorking=0;
                                if(result[14]!=null)
                                       fuelUsedWorking=(Double.valueOf(df2.format((Double)result[14])));

                                double fuelUsed1=fuelUsedIdle1+fuelUsedWorking;
                                implObj.setFuelused(Double.valueOf(df2.format(fuelUsed1)));

                                //DF20140529 - Rajani Nagaraju - averageFuelConsumption was getting set as NAN, since it was doing 0.0/0.0
                                if(Double.valueOf(df2.format((Double)machineHours))!=0)
                                       //if(machineHours!=0)
                                {
                                       double averageFuelConsumption=(Double.valueOf(df2.format(fuelUsed1))/Double.valueOf(df2.format((Double)machineHours)));
                                       implObj.setAverageFuelConsumption(Double.valueOf(df2.format(averageFuelConsumption)));
                                }

                                double lowValue = bandCalculation(bandIdLowList,
                                              EngineRunningBand1, EngineRunningBand2,
                                              EngineRunningBand3, EngineRunningBand4,
                                              EngineRunningBand5, EngineRunningBand6,
                                              EngineRunningBand7, EngineRunningBand8);

                                double midValue = bandCalculation(bandIdMediumList,
                                              EngineRunningBand1, EngineRunningBand2,
                                              EngineRunningBand3, EngineRunningBand4,
                                              EngineRunningBand5, EngineRunningBand6,
                                              EngineRunningBand7, EngineRunningBand8);
                                double highValue = bandCalculation(bandIdHighList,
                                              EngineRunningBand1, EngineRunningBand2,
                                              EngineRunningBand3, EngineRunningBand4,
                                              EngineRunningBand5, EngineRunningBand6,
                                              EngineRunningBand7, EngineRunningBand8);              

                                implObj.setPowerBandhigh(Double.valueOf(df2.format(highValue)));
                       implObj.setPowerBandLow(Double.valueOf(df2.format(lowValue)));
                       implObj.setPowerBandMedium(Double.valueOf(df2.format(midValue)));
                                //DefectId:20140912 Running band issue @suprava
                                implObj.setPowerBandhigh(0.0);
                                implObj.setPowerBandLow(0.0);
                                implObj.setPowerBandMedium(0.0);
                                if(result[19]!=null)
                                {
                                       int tenancyTypeId =(Integer) result[19];
                                       //If the Machine is with customer Get the parentTeancyId
                                       if(tenancyTypeId==4)
                                       {
                                              tenancyEntity =(TenancyEntity)result[18];
                                              implObj.setDealername(tenancyEntity.getTenancy_name());
                                       }
                                       //If the Machine is with Dealer
                                       else if(tenancyTypeId==3) 
                                       {
                                              if(result[19]!=null)
                                              {
                                              String Dealername =(String)result[3];
                                              implObj.setDealername(Dealername);
                                       }
                                       }
                                       else
                                       {
                                              implObj.setDealername("No Dealer Tagging");
                                       }
                                
                                }

                                //DefectID:1406 - Smitha- 20131029 - MachineGrouping issue in Reports and sending Report Totals information
                                if(result[17]!=null)
                       {
                             int mgTenancy = (Integer) result[17];
                             if(loginTenancyIdList.contains(mgTenancy)) 
                             {
                                   if(result[15]!=null)
                                         implObj.setMachineGroupIdList((Integer)result[15]);

                                   if(result[16]!=null)
                                         implObj.setMachineGroupName(result[16].toString());
                             }
                             else
                             {
                                  otherMachineGroupVins.add(tempSerialNumber);
                             }

                       }

                                //DefectID:1383 - Rajani Nagaraju - 20130930 - Query modification to return correct resultset
                                if(asset!=null)
                                {
                                       if(asset.getProductId()!=null && asset.getProductId().getAssetGroupId()!=null)
                                       {
                                              implObj.setMachineProfile(asset.getProductId().getAssetGroupId().getAsset_group_id());
                                              implObj.setProfile(asset.getProductId().getAssetGroupId().getAsset_group_name());
                                       }

                                       if(asset.getProductId()!=null && asset.getProductId().getAssetTypeId()!=null)
                                       {
                                              implObj.setModelIdList(asset.getProductId().getAssetTypeId().getAsset_type_id());
                                              implObj.setModelName(asset.getProductId().getAssetTypeId().getAsset_type_name());
                                       }

                                       implObj.setMachineName(asset.getNick_name());
                                }                 

                                //DefectID:1406 - Rajani Nagaraju - 20131029 - To return Report Totals                        
                                if(!(tempSerNumList.contains(tempSerialNumber)))
                                {

                                       totalMachineLifeHoursSum = totalMachineLifeHoursSum+(Double.valueOf(df2.format((Double)result[2])));
                                       double tempMachineHours=(Double.valueOf(df2.format(machineHours)));
                                       if(tempMachineHours<0){
                                              tempMachineHours=0.0d;
                                       }
                                       //  machineHoursSum = machineHoursSum+tempMachineHours;
                                       totalfuelusedSum = totalfuelusedSum+(Double.valueOf(df2.format(fuelUsed1)));
                                } 

                                //Get the List of MachineGroup under the Login Tenancy to which the machine belongs to 
                                //DefectID: DF20131210 - Rajani Nagaraju - To take the latest/Last reported row from factAgg tables
                                if(isGroupingOnAssetGroup)
                                {

                                       Query mgQuery=null;
                                       if (!(machineGroupIdList == null || machineGroupIdList.isEmpty())) 
                                       {
                                              String customAssetGroupStringList = conversionObj.getIntegerListString(machineGroupIdList).toString();
                                              //Smitha:DefectID:20131218...to get the VIN's belonging to the machine groups under that tenancy ID
                                              mgQuery = session.createQuery(" select a from AssetCustomGroupMapping a, CustomAssetGroupEntity b " +
                                                            "where serial_number='"+tempSerialNumber+"' and a.group_id=b.group_id and b.level=2 and b.active_status=1 and b.tenancy_id in ("+loginTenIdListString+")" +
                                                            " and b.group_id in ("+customAssetGroupStringList+")");
                                       }
                                       else
                                       {
                                              //Smitha:DefectID:20131218...to get the VIN's belonging to the machine groups under that tenancy ID
                                              mgQuery = session.createQuery(" select a from AssetCustomGroupMapping a, CustomAssetGroupEntity b " +
                                                            "where serial_number='"+tempSerialNumber+"' and a.group_id=b.group_id and b.level=2 and b.active_status=1 and b.tenancy_id in ("+loginTenIdListString+")");
                                       }
                                       Iterator mgItr = mgQuery.list().iterator();
                                       int firstIteration =0;
                                       while(mgItr.hasNext())
                                       {
                                              AssetCustomGroupMapping mgVinMapping = (AssetCustomGroupMapping)mgItr.next();
                                              if(firstIteration==0)
                                              {
                                                     firstIteration=1;
                                                     implObj.setMachineGroupIdList(mgVinMapping.getGroup_id().getGroup_id());
                                                     implObj.setMachineGroupName(mgVinMapping.getGroup_id().getGroup_name());
                                                     listImplObj.add(implObj);
                                              }
                                              else
                                              {
                                                     FleetSummaryReporImpl newimplObj = new FleetSummaryReporImpl();
                                                     newimplObj.setSerialNumber(tempSerialNumber);
                                                     newimplObj.setTotalMachineLifeHours(implObj.getTotalMachineLifeHours());
                                                     newimplObj.setMachineHours(implObj.getMachineHours()); 
                                                     newimplObj.setMachineName(implObj.getMachineName());
                                                     newimplObj.setTenancyName(implObj.getTenancyName());
                                                     newimplObj.setMachineGroupIdList(mgVinMapping.getGroup_id().getGroup_id());
                                                     newimplObj.setMachineGroupName(mgVinMapping.getGroup_id().getGroup_name());
                                                     newimplObj.setMachineProfile(implObj.getMachineProfile());
                                                     newimplObj.setProfile(implObj.getProfile());
                                                     newimplObj.setModelIdList(implObj.getModelIdList());
                                                     newimplObj.setModelName(implObj.getModelName());
                                                     newimplObj.setAverageFuelConsumption(implObj.getAverageFuelConsumption());
                                                     newimplObj.setEngineOff(implObj.getEngineOff());
                                                     newimplObj.setFuelused(implObj.getFuelused());
                                                     newimplObj.setFuelUsedInIdle(implObj.getFuelUsedInIdle());
                                                     newimplObj.setIdleTime(implObj.getIdleTime());
                                                     newimplObj.setPowerBandhigh(implObj.getPowerBandhigh());
                                                     newimplObj.setPowerBandLow(implObj.getPowerBandLow());
                                                     newimplObj.setPowerBandMedium(implObj.getPowerBandMedium());
                                                     newimplObj.setTenanctIdList(implObj.getTenanctIdList());
                                                     newimplObj.setWorkingTime(implObj.getWorkingTime());
                                                     newimplObj.setDealername(implObj.getDealername());
                                                     listImplObj.add(newimplObj);
                                              }
                                       }

                                       if(firstIteration==0)
                                       {
                                              listImplObj.add(implObj);
                                       }
                                }

                                else
                                {
                                       listImplObj.add(implObj);
                                }

                         tempSerNumList.add(tempSerialNumber);
                         listImplObj.add(implObj);

                   }
      			 iLogger.info("startlimit :"+startlimit);
				 
				 iLogger.info("endlimit :"+endlimit);
				 
				 startlimit=endlimit;
				 
				 endlimit=endlimit+500;
              }                   //               }

                   //added by smitha on oct 14th 2013[to display the machines which have not communicated .... Internal Defect 20131014]
             Set mapSet = (Set) calledSerNumMap.entrySet();
             Iterator mapIterator = mapSet.iterator(); 
             while (mapIterator.hasNext()) {
                   Map.Entry mapEntry = (Map.Entry) mapIterator.next(); 
                   String keyValue = (String) mapEntry.getKey(); 
                   int value = (Integer)mapEntry.getValue();
                   AllSerNumList.add(keyValue);

       }     

             int tenancyId=0;
             String tenancyName2=null;
             Integer groupID1=0;
             String groupName2=null;
             AssetDetailsBO assetDetailsBO = new AssetDetailsBO();
             AssetEntity assetEntity = null;
             Iterator iterSerialNoList = AllSerNumList.iterator();
             for (String serialNo : AllSerNumList) {
             if(!tempSerNumList.contains(serialNo))    {
                   implObj = new FleetSummaryReporImpl();
                   implObj.setAverageFuelConsumption(0.0d);
//                 Keerthi : 03/12/13 : engine off duration is 100%
                   implObj.setEngineOff(100l);
                   implObj.setFuelused(0.0d);
                   implObj.setFuelUsedInIdle(0.0d);
                   implObj.setIdleTime(0.0d);
                   tenancyId=calledSerNumMap.get(serialNo);
                   //DefectID:1406 - Smitha- 20131029 - MachineGrouping issue in Reports and sending Report Totals information
                   if(loginTenancyIdList.contains(tenancyId)){
                   groupID1=serGroupID.get(serialNo);
                   if(groupID1!=0){
                         implObj.setMachineGroupIdList(groupID1);
                   }else{
                   implObj.setMachineGroupIdList(0);
                   }

                   groupName2=GroupData.get(groupID1);
                   if(groupName2!="" || groupName2!=null){
                         implObj.setMachineGroupName(groupName2);
                   }else {
                         implObj.setMachineGroupName(null);
                   }
                   }

                   assetEntity = assetDetailsBO.getAssetEntity(serialNo);            
                   implObj.setMachineHours(0.0d);
                   implObj.setMachineName(null);
                   implObj.setMachineProfile(0);
                   implObj.setModelIdList(0);          
                   if(assetEntity!=null){
                         if(assetEntity.getProductId()!=null){
                               if(assetEntity.getProductId().getAssetTypeId()!=null){
                                     implObj.setModelName(assetEntity.getProductId().getAssetTypeId().getAsset_type_name());
                               }
                               if(assetEntity.getProductId().getAssetGroupId()!=null){
                                     implObj.setProfile(assetEntity.getProductId().getAssetGroupId().getAsset_group_name());
                               }
                         }

                   }
                   implObj.setPowerBandhigh(0.0d);
                   implObj.setPowerBandLow(0.0d);
                   implObj.setPowerBandMedium(0.0d);
                   if(!(assetEntity.getProductId()==null)){
                   implObj.setProfile(assetEntity.getProductId().getAssetGroupId().getAsset_group_name());
                   }
                   implObj.setSerialNumber(serialNo);
                   tenancyId=calledSerNumMap.get(serialNo);
                   implObj.setTenanctIdList(tenancyId);
                   tenancyName2=TenancyData.get(tenancyId);
                   implObj.setTenancyName(tenancyName2);
//                 Keerthi : 03/12/13 : non communicated : total machine life hours : taking from agg tables
//                 implObj.setTotalMachineLifeHours(0l);
//                 get total machine life hours from respective agg table
                   long machineLifeHours = (long) getMachineLifeHours(serialNo,tenancyId,period,fromDate,toDate,session);
                   implObj.setTotalMachineLifeHours(machineLifeHours);
                   implObj.setWorkingTime(0.0d);
                   listImplObj.add(implObj);
             }
             }
                   //ended on oct 14th 2013[to display the machines which have not communicated .... Internal Defect 20131014]
                   implObj = new FleetSummaryReporImpl();
                   implObj.setSerialNumber("Summary");
                   implObj.setTotalMachineLifeHours(Double.valueOf(df2.format((Double)totalMachineLifeHoursSum)));
                   //System.out.println("MachineHours"+Double.valueOf(df2.format((Double)machineHoursSum)));
                   implObj.setMachineHours(Double.valueOf(df2.format((Double)machineHoursSum)));
                   implObj.setFuelused(Double.valueOf(df2.format((Double)totalfuelusedSum)));

                   listImplObj.add(implObj);
            } 

            catch (Exception e) 
            {
                   e.printStackTrace();
                   fLogger.fatal("Exception: "+ e.getMessage());
            } 

            finally 
            {
                   if (session.getTransaction().isActive()) 
                   {
                         session.getTransaction().commit();
                   }

                   if (session.isOpen()) 
                   {
                         session.flush();
                         session.close();
                   }

            }

            return listImplObj;
                   }  

	//	Keerthi : 02/12/13 : non communicated PIN's machine hours
	/**
	 * method to get machine life hours for noncommunicated PINs
	 * @param serialNo
	 * @param tenancyId
	 * @param period
	 * @param session
	 * @return
	 */
	public double getMachineLifeHours(String serialNo, int tenancyId, String period,String fromDate,String toDate, Session session){
		double machineLifeHours = 0.0D;
		int week=0,month=0,quarter=0,year=0;

		DateUtil dateUtil1 = new DateUtil();
		DateUtil thisDate =dateUtil1.getCurrentDateUtility(new Date());

		//For input period: Last Week, Last Month, Last Quarter, Last Year
		DateUtil dateUtil2 = new DateUtil();
		DateUtil prevDate = dateUtil2.getPreviousDateUtility(new Date());
		Logger fLogger = FatalLoggerClass.logger;
		//Logger bLogger = BusinessErrorLoggerClass.logger;
		Logger iLogger = InfoLoggerClass.logger;
		SimpleDateFormat dateFrmt = new SimpleDateFormat("yyyy-MM-dd");
		String lastDateInPeriod=null;
		String startDateInPeriod=null;
		if(period!=null){

			if (period.equalsIgnoreCase("Week")) 
			{
				//get the Last Day 
				Calendar cal = Calendar.getInstance();
				lastDateInPeriod = dateFrmt.format(cal.getTime());
				//get the first day of the week
				cal.set(Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek());
				startDateInPeriod=  dateFrmt.format(cal.getTime());
			}

			else if (period.equalsIgnoreCase("Last Week")) 
			{
				Calendar cal = Calendar.getInstance();
				int i = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
				cal.add(Calendar.DATE, -i - 7);
				cal.add(Calendar.DATE, 6);
				lastDateInPeriod = dateFrmt.format(cal.getTime());
				//get the First Day of Previous Week
				cal = Calendar.getInstance();
				int j = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
				cal.add(Calendar.DATE, -j - 7);
				cal.set(Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek());
				startDateInPeriod=  dateFrmt.format(cal.getTime());
			}

			else if (period.equalsIgnoreCase("Month")) 
			{
				month =  thisDate.getMonth();
				year = thisDate.getYear();

				//DefectId: DF20131018 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period 
				//get the Last Day 
				Calendar cal = Calendar.getInstance();
				lastDateInPeriod = dateFrmt.format(cal.getTime());
				//get the First Day of current Month
				String mon = month+"";
				if(mon.length()<2)
					mon="0"+mon;
				startDateInPeriod=year+"-"+mon+"-"+"01";
			}

			else if (period.equalsIgnoreCase("Last Month")) 
			{
				month =  prevDate.getMonth();
				if(thisDate.getMonth()==1)
				{
					year = prevDate.getYear();
				}
				else
				{
					year = prevDate.getCurrentYear();
				}
				Calendar cal = Calendar.getInstance();
				cal.set(Calendar.DATE, 1);
				cal.add(Calendar.DAY_OF_MONTH, -1);
				lastDateInPeriod = dateFrmt.format(cal.getTime());
				//get the First Day of Previous Month
				String mon = month+"";
				if(mon.length()<2)
					mon="0"+mon;
				startDateInPeriod=year+"-"+mon+"-"+"01";			
			}

			else if (period.equalsIgnoreCase("Quarter")) 
			{
				quarter =  thisDate.getQuarter();
				year = thisDate.getYear();

				Calendar cal = Calendar.getInstance();
				lastDateInPeriod = dateFrmt.format(cal.getTime());
				//get the first Date of current quarter
				switch(quarter) 
				{
				case 3 : 
					startDateInPeriod = year+"-07-01";
					break;
					// return July 01
				case 2 :
					startDateInPeriod = year+"-04-01";
					break;
					// return April 01
				case 1 :
					startDateInPeriod = year+"-01-01";
					break;
					// return Jan 01
				case 4 : 
					startDateInPeriod = year+"-10-01";
					break;
					// return Oct 01
				}

			}

			else if (period.equalsIgnoreCase("Last Quarter")) 
			{
				quarter = prevDate.getQuarter();
				if(thisDate.getQuarter()==1)
				{
					year = prevDate.getYear();
				}
				else
				{
					year = prevDate.getCurrentYear();
				}


				switch(quarter) 
				{
				case 3 : 
					lastDateInPeriod = year+"-09-30";
					break;
					// return September 30
				case 2 :
					lastDateInPeriod = year+"-06-30";
					break;
					// return June 30
				case 1 :
					lastDateInPeriod = year+"-03-31";
					break;
					// return March 31
				case 4 : 
					lastDateInPeriod = year+"-12-31";
					break;
					// return December 31
				}
				//get the first Date of Previous quarter
				switch(quarter) 
				{
				case 3 : 
					startDateInPeriod = year+"-07-01";
					break;
					// return July 01
				case 2 :
					startDateInPeriod = year+"-04-01";
					break;
					// return April 01
				case 1 :
					startDateInPeriod = year+"-01-01";
					break;
					// return Jan 01
				case 4 : 
					startDateInPeriod = year+"-10-01";
					break;
					// return Oct 01
				}
			}


			else if (period.equalsIgnoreCase("Year")) 
			{
				year = thisDate.getYear();


				Calendar cal = Calendar.getInstance();
				lastDateInPeriod = dateFrmt.format(cal.getTime());
				//get the First day of current Year
				startDateInPeriod=year+"-01"+"-01";
			}

			else if (period.equalsIgnoreCase("Last Year")) 
			{
				year = prevDate.getYear();


				//DefectId: DF20131018 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period 
				//get the Last day of previous Year
				lastDateInPeriod=year+"-12-31";
				//get the First day of Previous Year 
				startDateInPeriod=year+"-01"+"-01";
			}	

		}
		else if(fromDate!=null && toDate!=null){
			DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
			String fromdateFormatted=null;
			String todateFormatted=null;

			try 
			{	
				fromdateFormatted= dateFormat.format(dateFormat.parse(fromDate));	
				todateFormatted = dateFormat.format(dateFormat.parse(toDate));	
			} 

			catch (ParseException e) 
			{
				// TODO Auto-generated catch block
				e.printStackTrace();
			}			
			startDateInPeriod = fromdateFormatted;
			lastDateInPeriod = todateFormatted;
		}
		String selectQuery="SELECT z.machineHours";
		String fromQuery =" FROM AssetMonitoringFactDataDayAgg z,TenancyDimensionEntity td ";
		String whereQuery=" WHERE z.serialNumber='"+serialNo+"' AND td.tenancyId="+tenancyId+" AND td.tenacy_Dimension_Id=z.tenancyId AND " +
		" z.timeKey = ( select max(p.timeKey) from AssetMonitoringFactDataDayAgg p where p.serialNumber = z.serialNumber " +
		" AND p.timeKey <= '"+startDateInPeriod+"' )";
		String finalQuery = selectQuery+fromQuery+whereQuery;
		Query query = session.createQuery(finalQuery);
		Iterator iterator = query.list().iterator();
		while(iterator.hasNext()){
			machineLifeHours = (Double) iterator.next();
		}
		return machineLifeHours;
	}



	/**
	 * method to fetch list of child ids for given parent tenancy id list
	 * @param tenancyIdList
	 * @return
	 */
	public List<Integer> getSubTenancyIds(List<Integer> tenancyIdList,Session session){	
		long startTime = System.currentTimeMillis();
		boolean sessionNull = false;
		if(null==session){
			sessionNull = true;
			session = HibernateUtil.getSessionFactory().openSession();
			session.beginTransaction();
		}
		
		Logger iLogger = InfoLoggerClass.logger;

		ListToStringConversion conversionObj = new ListToStringConversion();
		String tenancyIdStringList = conversionObj.getIntegerListString(tenancyIdList).toString();
		List<Integer> subTenancyIdList = new ArrayList<Integer>();

		String finalQuery = null;

		try {
			finalQuery = "SELECT t1.childId,t1.parentId FROM  TenancyBridgeEntity  t1 WHERE t1.parentId in("+ tenancyIdStringList+")";
			Query query = session.createQuery(finalQuery);
			Iterator itr = query.list().iterator();
			Object[] result = null;


			while (itr.hasNext()) {
				result = (Object[]) itr.next();
				int childId=(Integer) result[0];
				if (result[0] != null) {
					subTenancyIdList.add((Integer) result[0]);
				}		
			}
		}
		finally {
			//			if (session.getTransaction().isActive()) {
			//				session.getTransaction().commit();
			//			}
			if(sessionNull){
				if (session.isOpen()) {
					session.flush();
					session.close();
				}
			}

		}
		long endTime = System.currentTimeMillis();
		long duration = endTime - startTime;
		iLogger.info("Total time taken by getSubTenancyIds() is"+ duration);
		if(subTenancyIdList==null || subTenancyIdList.size()==0){
			return tenancyIdList;
		}
		return subTenancyIdList;
	}

	/**
	 * method to fetch list of child ids for given parent tenancy id list
	 * @param tenancyIdList
	 * @return
	 */
	public List<Integer> getCustomerTenancyIds(List<Integer> tenancyIdList){            
		long startTime = System.currentTimeMillis();
		Session session = HibernateUtil.getSessionFactory().openSession();
		session.beginTransaction();

		ListToStringConversion conversionObj = new ListToStringConversion();
		String tenancyIdStringList = conversionObj.getIntegerListString(tenancyIdList).toString();
		List<Integer> subTenancyIdList = new ArrayList<Integer>();
		List<Integer> customerList=new ArrayList<Integer>();
		String finalQuery = null;
		
		Logger iLogger = InfoLoggerClass.logger;
		try {
			finalQuery = "SELECT t1.childId,t1.parentId FROM  TenancyBridgeEntity  t1 WHERE t1.parentId in("+ tenancyIdStringList+") and t1.childId!=t1.parentId ";
			//   " and t1.level =4";//only customer machines
			Query query = session.createQuery(finalQuery);
			Iterator itr = query.list().iterator();
			Object[] result = null;


			while (itr.hasNext()) {
				result = (Object[]) itr.next();

				if (result[0] != null) {
					int childId=(Integer) result[0];
					//                      infoLogger.info("Sub tenancy id : "+childId);
					subTenancyIdList.add(childId);
				}           
			}
			if(subTenancyIdList.size()>0){
				String subTenancyIdStringList = conversionObj.getIntegerListString(subTenancyIdList).toString();
				//Defect Id:1410 on 8th oct 2013 (Smitha)
				Query dealerQuery=session.createQuery("select t.tenancyId from TenancyDimensionEntity t where t.tenancyTypeId=4 and t.tenancyId in ("+subTenancyIdStringList+")"); 
				//Query dealerQuery=session.createQuery("select t.tenancy_id from TenancyEntity t where t.tenancy_type_id=3 and t.tenancy_id in ("+subTenancyIdStringList+")");
				Iterator dealerIterator=dealerQuery.list().iterator();
				List<Integer> dealerIdList=new LinkedList<Integer>();
				if(dealerQuery.list().size()>0)
				{
					while(dealerIterator.hasNext())
					{
						dealerIdList.add((Integer)dealerIterator.next());
					}
				}
				//  String dealerIdStringList = conversionObj.getIntegerListString(dealerIdList).toString();
				/*Query cutomerQuery=session.createQuery("SELECT t1.parentId FROM  TenancyBridgeEntity  t1 WHERE t1.level=4 and t1.parentId in("+subTenancyIdStringList+")");
              Iterator customerIterator=cutomerQuery.list().iterator();
              while(customerIterator.hasNext())
              {
                    customerList.add((Integer)customerIterator.next() );
              }*/
				/*for(int i=0;i<dealerIdList.size();i++)
              {
              Query cutomerQuery=session.createQuery("SELECT t1.tenancy_id FROM  TenancyEntity  t1 WHERE t1.tenancy_id in("+subTenancyIdStringList+") and t1.tenancy_type_id=4 and t1.parent_tenancy_id ="+dealerIdList.get(i)+"");
              Iterator customerIterator=cutomerQuery.list().iterator();
              while(customerIterator.hasNext())
              {
                    customerList.add((Integer)customerIterator.next() );
              }
              }*/
				customerList=dealerIdList;
				//ended on 8th oct 2013 Defect Id:1410
			}

		}
		finally {
			if (session.getTransaction().isActive()) {
				session.getTransaction().commit();
			}

			if (session.isOpen()) {
				session.flush();
				session.close();
			}

		}
		long endTime = System.currentTimeMillis();
		long duration = endTime - startTime;
		iLogger.info("Total time taken by getCustomerTenancyIds() is "+ duration);

		return customerList;

	}

	//***************************************************** Get Machine Hours Service Report ********************************************
	/** DefectId: 1400 - Rajani Nagaraju - 20131003 - To improve the Performance of Service- Machine hours  
	 * DefectID:1411 - Rajani Nagaraju - 20131008 - Query Tweaking
	 * This method provides the next/previous service details of the specified VINs
	 * @param customAssetGroupIdList list of custom asset group that filters the VINs
	 * @param machineProfileIdList list of asset groups that filters the required VIN list
	 * @param tenancyIdList list of tenancy Ids for which the corresponding VIN details are required
	 * @param modelIdList list of asset type(Model) that filters the required VIN list
	 * @param isGroupingOnAssetGroup flag which determines whether the grouping of VINs has to be done on customAssetGroup or not
	 * @return Returns the List of VINs with their service details
	 */
	//DefectID:1406 - Juhi  2013-October-29 - MachineGrouping issue in Reports and sending Report Totals information
	public List<MachineHoursServiceReportImpl> getMachineHoursService(List<Integer> customAssetGroupIdList,
			List<Integer> machineProfileIdList, List<Integer> tenancyIdList,
			List<Integer> modelIdList,  boolean isGroupingOnAssetGroup,List<Integer> loginTenancyIdList) 
			{
		List<MachineHoursServiceReportImpl> listResponse = new LinkedList<MachineHoursServiceReportImpl>();
		MachineHoursServiceReportImpl implObj = null;
		Logger fLogger = FatalLoggerClass.logger;
		//Logger bLogger = BusinessErrorLoggerClass.logger;
		Logger iLogger = InfoLoggerClass.logger;
		String status = null;
		int eventId=0;

		String basicSelectQuery = null;
		String basicFromQuery = null;
		String basicWhereQuery = null;
		String finalQuery = null;
		//DefectID:1406 - Juhi  2013-October-29 -To return Report Totals
		double totalMachineHoursSumm =0.0D;
		ListToStringConversion conversionObj = new ListToStringConversion();
		SimpleDateFormat dateFormatter = new SimpleDateFormat("yyyy-MM-dd");

		Session session=HibernateUtil.getSessionFactory().openSession();
		session.beginTransaction();
		// get child ids for the input tenancy id list
		//tenancyIdList = getSubTenancyIds(tenancyIdList,session);                   
		String tenancyIdStringList = conversionObj.getIntegerListString(tenancyIdList).toString();
		//Smitha....DefectID:20131220....for machine group logic
		String loginTenIdListString = conversionObj.getIntegerListString(loginTenancyIdList).toString();
		String orderByQuery = "";		
		DecimalFormat df2 = new DecimalFormat("###.#");
		String accountType ="Dealer";	
		
		//DefectID:1373 - Rajani Nagaraju - 20130927 - Query replacement
		//DefectID:1406 - Juhi  2013-October-29 - MachineGrouping issue in Reports and sending Report Totals information
		basicSelectQuery = " select b.tenancyId,b.tenancyName, ae ,g.Address, s.totalEngineHours as totalMachineLifeHours," +
		" ae.nick_name, t.group_id, t.group_name, s.serviceScheduleName, s.lastServiceName, s.lastServiceDate, s.lastServiceHours," +
		" s.nextServiceName, s.nextServiceDate, s.nextServiceHours, s.eventId" +
		", g.engineStatus , ten.tenancy_id as mgTenancy," +
		
		// Added one more column called 
		//DefectId:20150216 @ Suprava Delaer As a new parameter Added
		//" ten1.parent_tenancy_id,b.tenancyTypeId ";
		//DefectId:20150928 @Suprav DealerName from Aos table due to Dealer Movement
		
		//Kishore....DefectID:20151230....for machine group logic
		" acc.account_name,aos.accountType,ee.eventSeverity ";

		
		// DefectId:2015-01-07 @Suprava Engine_status Changes
		//", amd.parameterValue , ten.tenancy_id as mgTenancy ";
		// DefectId:2015-01-07 en
		
		//Here ae represents AssetEntity, t represents CustomAssetGroupEntity
		basicFromQuery =" from AssetCustomGroupMapping w right outer join " +
		" w.serial_number ae left outer join w.group_id t  " +
		//DefectID:1406
		//Smitha....DefectID:20131220....for machine group logic
		" LEFT OUTER JOIN t.tenancy_id ten , TenancyEntity ten1 , " +
		" TenancyDimensionEntity b, AssetMonitoringFactDataYearAgg g, " +
		//DefectId:20150928 @Suprava DealerName from Aos table due to Dealer Movement
		" ServiceDetailsReportEntity s, AssetOwnerSnapshotEntity aos, AccountEntity acc, TenancyBridgeEntity tb, " + 
		// DefectId:2015-01-07 @Suprava Engine_status Changes
		//", AssetMonitoringDetailEntity amd ";
		// DefectId:2015-01-07 en
		//DefectID:1411 - Rajani Nagaraju - 20131008 - Query Tweaking
		//Smitha....DefectID:20131220....for machine group logic
		
		"EventEntity ee";      //Kishore....DefectID:20151230....for machine group logic
		
		basicWhereQuery = " where ten1.tenancy_id = b.tenancyId and g.tenancyId = b.tenacy_Dimension_Id and b.tenancyId = tb.childId  and tb.parentId in ("+tenancyIdStringList+") "+
		" and g.serialNumber = ae.serial_number and g.year = (select max(year) from AssetMonitoringFactDataYearAgg) " +
		//Defect ID:20131212 ------Juhi------For Machine Not communicated
		" and g.lastReported=(select max(q.lastReported) from AssetMonitoringFactDataYearAgg q where q.year=g.year and q.serialNumber=g.serialNumber)" +
		" and g.serialNumber = s.serialNumber " +
		//DefectId:20150216 @ Suprava Delaer As a new parameter Added
		" and b.parentTenancyId=ten1.parent_tenancy_id " +
		//Kishore....DefectID:20151230....for machine group logic
		" and s.eventId=ee.eventId " +
		//DefectId:20150928 @Suprava DealerName from Aos table due to Dealer Movement
		" and aos.serialNumber=s.serialNumber and aos.accountId=acc.account_id and aos.accountType='"+accountType+"'";
		
		// DefectId:2015-01-07 @Suprava Engine_status Changes
		/*" and amd.transactionNumber = (select max(a.transactionNumber) from AssetMonitoringHeaderEntity a " +
		" where " +
		 "a.transactionTime = (select max(a.transactionTime) from a " +
																  								"where a.serialNumber =g.serialNumber" +
																  							 ")" +
		" a.serialNumber=g.serialNumber" +
		") " +
		" and amd.parameterId =(select m.parameterId from MonitoringParameters m where " +
		"parameterName like 'IGNITION_ON')"*/
		// DefectId:2015-01-07 en
		
		//Removed for Today by Juhi on 6 May 2013
		//Added custom Dates by Juhi on 13-August-2013
		//Smitha....DefectID:20131220....for machine group logic
		String basicGroupByQuery = " group by g.serialNumber , ten1.tenancy_id ";

		/*if(isGroupingOnAssetGroup)
		{
			basicGroupByQuery = basicGroupByQuery+", t.group_id";
		}*/

		if (!(customAssetGroupIdList == null || customAssetGroupIdList.isEmpty()))
		{
			String customAssetGroupStringList = conversionObj.getIntegerListString(customAssetGroupIdList).toString();
			basicWhereQuery = basicWhereQuery+ "and w.group_id in ("+ customAssetGroupStringList + ") ";
		}

		if ((!(machineProfileIdList == null || machineProfileIdList.isEmpty()))	|| (!(modelIdList == null || modelIdList.isEmpty()))) 
		{
			basicFromQuery = basicFromQuery+ " , AssetClassDimensionEntity d ";
			basicWhereQuery = basicWhereQuery + " and g.assetClassDimensionId = d.assetClassDimensionId";

		}

		if (!(machineProfileIdList == null || machineProfileIdList.isEmpty())) 
		{
			String assetGroupStringList = conversionObj.getIntegerListString(machineProfileIdList).toString();
			basicWhereQuery = basicWhereQuery + " and d.assetGroupId in ( "+ assetGroupStringList + " )";
		}

		if (!(modelIdList == null || modelIdList.isEmpty())) 
		{
			String modelIdStringList = conversionObj.getIntegerListString(modelIdList).toString();
			basicWhereQuery = basicWhereQuery + " and d.assetTypeId in ( "+ modelIdStringList + " )";
		}
		//Smitha....DefectID:20131220....for machine group logic
		orderByQuery = orderByQuery + " order by ae.serial_number, g.lastReported desc ";

		List<String> serialNumberList = new LinkedList<String>();
		finalQuery = basicSelectQuery + basicFromQuery + basicWhereQuery + basicGroupByQuery + orderByQuery ;
		//System.out.println("final query---"+finalQuery.toString());
		//DefectID:1406 - Juhi  2013-October-29 - MachineGrouping issue in Reports and sending Report Totals information
		List<String> otherMachineGroupVins = new LinkedList<String>();
		String serialNumber=null;
		try 
		{
			Query query = session.createQuery(finalQuery);
			Iterator itr = query.list().iterator();
			Object[] result = null;

			while (itr.hasNext()) 
			{
				result = (Object[]) itr.next();
				implObj = new MachineHoursServiceReportImpl();
				serialNumber=null;

				if (result[0] != null) 
					implObj.setTenancyId((Integer)result[0]);

				if (result[1] != null) 
					implObj.setTenancyName(result[1].toString() );

				//AssetEntity ae = (AssetEntity) result[2];
				//implObj.setSerialNumber(ae.getSerial_number().getSerialNumber());
				AssetEntity ae=null;
				if(result[2]!=null)
				{					
					ae = (AssetEntity)result[2];
					serialNumber = ae.getSerial_number().getSerialNumber();

				}
				//Smitha....DefectID:20131220....for machine group logic
				if(serialNumberList.contains(serialNumber))
				{
					continue;
				}

				//DefectID: 1406
				/*int otherMachineGroup =0;
				if(result[17]!=null)
				{
					int mgTenancy = (Integer) result[17];
					infoLogger.info("mgTenancy"+mgTenancy+"loginTenancyIdList"+loginTenancyIdList);
					if(! (loginTenancyIdList.contains(mgTenancy)) ) 
					{
						otherMachineGroup=1;
					}
				}

				if( (otherMachineGroup==1)&& ( (otherMachineGroupVins.contains(serialNumber)) || (serialNumberList.contains(serialNumber)) ) )
				{
					continue;		
					}



				if( (!isGroupingOnAssetGroup) && (serialNumberList.contains(serialNumber))) 
				{
					continue;
				}*/


				implObj.setSerialNumber(ae.getSerial_number().getSerialNumber());
				if (result[3]!= null) 
					implObj.setLocation(result[3].toString());

				if (result[4] != null)
				{
					String machineHours = result[4].toString();
					implObj.setTotalMachineLifeHours(Double.valueOf(df2.format(Double.valueOf(machineHours))));
					//DefectID:1406 - Juhi - 2013-October-29 - To return Report Totals
					if(!(serialNumberList.contains(serialNumber)))
					{
						totalMachineHoursSumm = totalMachineHoursSumm+Double.valueOf(df2.format(Double.valueOf(machineHours)));
					}
				}	

				if ( result[5]!= null) 
					implObj.setNickName(result[5].toString());

				//DefectID:1406 - Juhi  2013-October-29 - MachineGrouping issue in Reports and sending Report Totals information

				/*if(result[17]!=null)
				{
					int mgTenancy = (Integer) result[17];
					if(loginTenancyIdList.contains(mgTenancy)) 
					{
						if(result[6]!=null)
							implObj.setMachineGroupId((Integer)result[6]);

						if(result[7]!=null)
							implObj.setMachineGroupName(result[7].toString());
					}
					else
					{
						otherMachineGroupVins.add(serialNumber);
					}

				}*/
				//DefectID:1373 - Rajani Nagaraju - 20130927 - Query replacement
				/*if(result[6]!=null)
						implObj.setMachineGroupId((Integer)result[6]);

					if(result[7]!=null)
						implObj.setMachineGroupName(result[7].toString());
				*/

				if(ae!=null){
					if(ae.getProductId()!=null && ae.getProductId().getAssetGroupId()!=null)
					{
						implObj.setMachineProfileId(ae.getProductId().getAssetGroupId().getAsset_group_id());
						implObj.setMachineProfileName(ae.getProductId().getAssetGroupId().getAsset_group_name());
					}				

					if(ae.getProductId()!=null && ae.getProductId().getAssetTypeId()!=null)
					{
						implObj.setModelId(ae.getProductId().getAssetTypeId().getAsset_type_id());
						implObj.setModelName(ae.getProductId().getAssetTypeId().getAsset_type_name());
					}				
				}
				//Set the Service details of the machine
				if(result[8]!=null)
					implObj.setScheduleName(result[8].toString());

				//-----------------------Service History details
				if(result[9]!=null)
					implObj.setServiceName(result[9].toString());

				if(result[10]!=null)
				{
					Timestamp lastServicedDate = (Timestamp) result[10];
					implObj.setServiceDate(dateFormatter.format(lastServicedDate.getTime()));
				}

				if(result[11]!=null)
				{
					String lastServiceHours = result[11].toString();
					//					Keerthi : 05/09/14 : fix for can't format given number 
					implObj.setLastServiceHour(Double.valueOf(df2.format(Double.valueOf(lastServiceHours))));
				}


				//---------------------- Details of next scheduled service
				if(result[12]!=null)
					implObj.setNextService(result[12].toString());

				if(result[13]!=null)
				{
					Timestamp nextServicedDate = (Timestamp) result[13];
					implObj.setApproximateServiceDate(dateFormatter.format(nextServicedDate.getTime()));
				}

				if(result[14]!=null && result[4] != null)
				{
					String machineHours = result[4].toString();
					String nextServiceHours = result[14].toString();

					double currentMachineHours = Double.valueOf(df2.format(Double.valueOf(machineHours)));
					double scheduledServiceHours = Double.valueOf(df2.format(Double.valueOf(nextServiceHours)));
					implObj.setHoursToNextService(Double.valueOf(df2.format(Double.valueOf(scheduledServiceHours - currentMachineHours))));
				}

				if(result[15]!=null)
					eventId = (Integer)result[15];
					
                if(result[16]!=null)
					implObj.setStatus(result[16].toString());
			  //DefectId:20150217 @Suprava DealerName Addition
				/*TenancyEntity tenancyEntity =null;
				if(result[19]!=null)
				{
					int tenancyTypeId =(Integer) result[19];
					//If the Machine is with customer Get the parentTeancyId
					if(tenancyTypeId==4)
					{
						tenancyEntity =(TenancyEntity)result[18];
						implObj.setDealerName(tenancyEntity.getTenancy_name());
					}
					//If the Machine is with Dealer
					else if(tenancyTypeId==3) 
					{
						if(result[19]!=null)
						{
						String Dealername =(String)result[1];
						implObj.setDealerName(Dealername);
					}
					}
					else
					{
						implObj.setDealerName("No Dealer Tagging");
					}
				
				}*/
				//DefectId:20150928 @Suprav DealerName from Aos table due to Dealer Movement
				if(result[19]!=null)
				{
					String accType =(String) result[19];
					//If the Machine is with customer/Dealer Get the parentTeancyId
					if(accType.equalsIgnoreCase(accountType))
					{
						implObj.setDealerName(result[18].toString());
					}
					else
					{
						implObj.setDealerName("No Dealer Tagging");
					}
				
				}
				
				//Kishore....DefectID:20151230....for machine group logic; if block added to get Severity
				
				if(result[20]!=null)
					implObj.setSeverity(result[20].toString());
				
				//Kishore....DefectID:20151230....for machine group logic; below if block is commented as it is consuming more time in results we are getting connection time out
				//Get the severity if the machine has service alert
				/*if(eventId!=0)
				{
					Query qy = session.createQuery(" from EventEntity where eventId="+eventId);
					Iterator iy = qy.list().iterator();
					while(iy.hasNext())
					{
						EventEntity e = (EventEntity)iy.next();
						implObj.setSeverity(e.getEventSeverity());
					}
				}*/
				//Smitha....DefectID:20131220....for machine group logic
				//Get the List of MachineGroup under the Login Tenancy to which the machine belongs to 
				if(isGroupingOnAssetGroup)
				{
					Query mgQuery=null;
					if (!(customAssetGroupIdList == null || customAssetGroupIdList.isEmpty())) 
					{
						String customAssetGroupStringList = conversionObj.getIntegerListString(customAssetGroupIdList).toString();
						mgQuery = session.createQuery(" select a from AssetCustomGroupMapping a, CustomAssetGroupEntity b " +
								"where serial_number='"+serialNumber+"' and a.group_id=b.group_id and b.level=2 and b.active_status=1 and b.tenancy_id in ("+loginTenIdListString+")" +
								" and b.group_id in ("+customAssetGroupStringList+")");
					}

					else
					{
						mgQuery = session.createQuery(" select a from AssetCustomGroupMapping a, CustomAssetGroupEntity b " +
								"where serial_number='"+serialNumber+"' and a.group_id=b.group_id and b.level=2 and b.active_status=1 and b.tenancy_id in ("+loginTenIdListString+")");
					}
					Iterator mgItr = mgQuery.list().iterator();
					int firstIteration =0;
					while(mgItr.hasNext())
					{
						AssetCustomGroupMapping mgVinMapping = (AssetCustomGroupMapping)mgItr.next();
						if(firstIteration==0)
						{
							firstIteration=1;
							implObj.setMachineGroupId(mgVinMapping.getGroup_id().getGroup_id());
							implObj.setMachineGroupName(mgVinMapping.getGroup_id().getGroup_name());
							listResponse.add(implObj);
						}
						else
						{
							MachineHoursServiceReportImpl newimplObj = new MachineHoursServiceReportImpl();

							newimplObj.setSerialNumber(serialNumber);							
							newimplObj.setApproximateServiceDate(implObj.getApproximateServiceDate());
							newimplObj.setHoursToNextService(implObj.getHoursToNextService());
							newimplObj.setLastServiceHour(implObj.getLastServiceHour());
							newimplObj.setLocation(implObj.getLocation());
							newimplObj.setMachineGroupId(mgVinMapping.getGroup_id().getGroup_id());
							newimplObj.setMachineGroupName(mgVinMapping.getGroup_id().getGroup_name());
							newimplObj.setMachineProfileId(implObj.getMachineProfileId());
							newimplObj.setMachineProfileName(implObj.getMachineProfileName());
							newimplObj.setModelId(implObj.getModelId());
							newimplObj.setModelName(implObj.getModelName());
							newimplObj.setNextService(implObj.getNextService());
							newimplObj.setNickName(implObj.getNickName());
							newimplObj.setScheduleName(implObj.getScheduleName());
							newimplObj.setServiceDate(implObj.getServiceDate());
							newimplObj.setServiceName(implObj.getServiceName());
							newimplObj.setSeverity(implObj.getSeverity());
							newimplObj.setStatus(implObj.getStatus());
							newimplObj.setTenancyId(implObj.getTenancyId());
							newimplObj.setTenancyName(implObj.getTenancyName());
							newimplObj.setTotalMachineLifeHours(implObj.getTotalMachineLifeHours());
							newimplObj.setDealerName(implObj.getDealerName());
							listResponse.add(newimplObj);
						}
					}

					if(firstIteration==0)
					{
						listResponse.add(implObj);
					}
				}

				else
				{
					listResponse.add(implObj);
				}

				serialNumberList.add(serialNumber);
				/*listResponse.add(implObj);*/
				
				
			}
			
			//DefectID:1406 - Juhi - 2013-October-29  - To return Report Totals
			implObj = new MachineHoursServiceReportImpl();
			implObj.setSerialNumber("Summary");
			implObj.setTotalMachineLifeHours(Double.valueOf(df2.format(Double.valueOf(totalMachineHoursSumm))));			
			listResponse.add(implObj);

		} 

		catch(Exception e)
		{
			e.printStackTrace();
			fLogger.error(e.getMessage());
		}

		finally 
		{
			if (session.getTransaction().isActive()) 
			{
				session.getTransaction().commit();
			}
			if (session.isOpen()) 
			{
				session.flush();
				session.close();
			}
		}

		return listResponse;
			}
	// ********************************************END OF MachineHoursServiceReport****************************************************



	// ********************************************END OF MachineHoursServiceReport****************************************************


	/*// ********************************************START OF MachinePerformanceReportService************************
	*//** DefectId:  DF20131014 - Custom Date Implementation - Rajani Nagaraju 
	 * DefectId: DF20131023 - To add the Machines that has not communicated for the given period
	 * DefectId: DF20131015 - Rajani Nagaraju - Logic Change to return correct parameter Values
	 * This method returns the performance details of the machine for the given time period
	 * @param period - Can be either of Today/Week/Month/Quarter/Year - Mandatory parameter
	 * @param machineGroupIdList - List of Custom AssetGroupId as input filter
	 * @param machineProfileIdList - List of MachineProfileId as input filter
	 * @param tenancyIdList - List of TenancyId as input filter - Mandatory parameter
	 * @param modelIdList - List of Models as input filter
	 * @return Returns the Machine Performance details
	 *//*
	//Custom Dates (fromDate,toDate) added by Juhi on 14-August-2013 
	public List<MachinePerformanceReportImpl> getMachPerformanceReport(String fromDate,String toDate,String period, List<Integer> machineGroupIdList,
			List<Integer> machineProfileIdList, List<Integer> tenancyIdList,
			List<Integer> modelIdList, boolean isGroupingOnAssetGroup) 
			{

		List<MachinePerformanceReportImpl> listImplObj = new LinkedList<MachinePerformanceReportImpl>();
		Logger fLogger = FatalLoggerClass.logger;
		//Logger bLogger = BusinessErrorLoggerClass.logger;
		Logger iLogger = InfoLoggerClass.logger;
		String basicFromQuery = null;
		String basicSelectQuery = null;
		String basicWhereQuery = null;
		String finalQuery = null;
		String basicGroupByQuery = " group by g.serialNumber ";

		String fromdateFormatted=null;
		String todateFormatted=null;

		SimpleDateFormat dateFrmt = new SimpleDateFormat("yyyy-MM-dd");
		String lastDateInPeriod =null;
		String startDateInPeriod=null;

		//Logger businessError = Logger.getLogger("businessErrorLogger");
		//Logger fatalError = Logger.getLogger("fatalErrorLogger");

		Session session = HibernateUtil.getSessionFactory().getCurrentSession();
		session.beginTransaction();

		try 
		{
			DecimalFormat df2 = new DecimalFormat("###.#");
			//------- Get the List of TenancyIds all down the hierarchy
			tenancyIdList=getSubTenancyIds(tenancyIdList,session);
			ListToStringConversion conversionObj = new ListToStringConversion();
			String tenancyIdStringList = conversionObj.getIntegerListString(tenancyIdList).toString();

			List<Integer> bandIdLowList = new ArrayList<Integer>();
			List<Integer> bandIdMediumList = new ArrayList<Integer>();
			List<Integer> bandIdHighList = new ArrayList<Integer>();

			//Get the RPM BandIdList for each band Category - High,Medium,Low
			Query rpmBandQuery = session.createQuery("from RpmBands");
			Iterator rpmBandItr = rpmBandQuery.list().iterator();
			while(rpmBandItr.hasNext())
			{
				RpmBands rpmBand = (RpmBands)rpmBandItr.next();
				if(rpmBand.getPower_Band().equalsIgnoreCase("Low"))
				{
					bandIdLowList.add(rpmBand.getBand_ID());
				}
				if(rpmBand.getPower_Band().equalsIgnoreCase("Med"))
				{
					bandIdMediumList.add(rpmBand.getBand_ID());
				}
				if(rpmBand.getPower_Band().equalsIgnoreCase("High"))
				{
					bandIdHighList.add(rpmBand.getBand_ID());
				}
			}

			//DefectID: DF20131014 - Rajani Nagaraju - Custom Dates Implementation
			if(period !=null)
			{
				basicSelectQuery = "select g.engineOffHours,g.machineHours,g.EngineRunningBand1,g.EngineRunningBand2,g.EngineRunningBand3," +
				" g.EngineRunningBand4,g.EngineRunningBand5,g.EngineRunningBand6,g.EngineRunningBand7,g.EngineRunningBand8," +
				" x ,g.fuelUsedWorking,g.fuelUsedIdle, b.tenancyId,b.tenancyName, c.group_id as machineGroupId, " +
				" c.group_name as machineGroupName,  v.tenancy_id as primaryOwnerTenancy ," +
				//DefectId:20150220 @ Suprava Delaer As a new parameter Added
				"b.parentTenancyName,b.tenancyTypeId ";
				
				//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
				basicFromQuery = " from AssetCustomGroupMapping w RIGHT OUTER JOIN w.serial_number x  LEFT OUTER JOIN w.group_id c," +
				" TenancyDimensionEntity b , AccountTenancyMapping v,";
				//end Defect ID:1406

				basicWhereQuery = " where g.tenancyId = b.tenacy_Dimension_Id and b.tenancyId in ("+tenancyIdStringList+" ) and " +
				" x.serial_number = g.serialNumber " +
				" and x.primary_owner_id = v.account_id " ;
				//DefectId:20150216 @ Suprava Delaer As a new parameter Added
				//" and b.parentTenancyId=ten1.parent_tenancy_id ";


				int year =0;int week = 0; int quarter = 0;int month =0;
				DateUtil thisDate =new DateUtil().getCurrentDateUtility(new Date());
				DateUtil prevDate = new DateUtil().getPreviousDateUtility(new Date());

				if (period.equalsIgnoreCase("Week")) 
				{
					week =   thisDate.getWeek();
					year = thisDate.getYear();
					//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
					basicFromQuery = basicFromQuery + " AssetMonitoringFactDataWeekAgg g ";
					//end Defect ID:1406
					basicWhereQuery = basicWhereQuery+ " and g.timeCount =  "+week +" and g.year=" + year;

					//get the Last Day 
					Calendar c = Calendar.getInstance();
					lastDateInPeriod = dateFrmt.format(c.getTime());

					//DefectId: DF20131023 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period 
					//get the first day of the week
					c.set(Calendar.DAY_OF_WEEK, c.getFirstDayOfWeek());
					startDateInPeriod=  dateFrmt.format(c.getTime());
				}

				else if (period.equalsIgnoreCase("Last Week")) 
				{
					week =   prevDate.getWeek();
					if(thisDate.getWeek()==1)
					{
						year = prevDate.getYear();
					}

					else
					{
						year = prevDate.getCurrentYear();
					}

					//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
					basicFromQuery = basicFromQuery + " AssetMonitoringFactDataWeekAgg g ";
					//end Defect ID:1406
					basicWhereQuery = basicWhereQuery+ " and g.timeCount =  "+week +" and g.year=" + year;

					//get the Last Day of Previous Week
					Calendar c = Calendar.getInstance();
					int i = c.get(Calendar.DAY_OF_WEEK) - c.getFirstDayOfWeek();
					c.add(Calendar.DATE, -i - 7);
					c.add(Calendar.DATE, 6);
					lastDateInPeriod = dateFrmt.format(c.getTime());

					//DefectId: DF20131023 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period 
					//get the First Day of Previous Week
					c = Calendar.getInstance();
					int j = c.get(Calendar.DAY_OF_WEEK) - c.getFirstDayOfWeek();
					c.add(Calendar.DATE, -j - 7);
					c.set(Calendar.DAY_OF_WEEK, c.getFirstDayOfWeek());
					startDateInPeriod=  dateFrmt.format(c.getTime());

				}	

				else if (period.equalsIgnoreCase("Month")) 
				{
					month =   thisDate.getMonth();
					year = thisDate.getYear();

					//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
					basicFromQuery = basicFromQuery + " AssetMonitoringFactDataMonthAgg g ";
					//end Defect ID:1406
					basicWhereQuery = basicWhereQuery+ " and g.timeCount= "+ month + " and g.year=" + year;

					//get the Last Day 
					Calendar c = Calendar.getInstance();
					lastDateInPeriod = dateFrmt.format(c.getTime());

					//DefectId: DF20131023 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period 
					//get the First Day of current Month
					String mon = month+"";
					if(mon.length()<2)
						mon="0"+mon;
					startDateInPeriod=year+"-"+mon+"-"+"01";
				} 

				else if (period.equalsIgnoreCase("Last Month")) 
				{
					month =  prevDate.getMonth();
					if(thisDate.getMonth()==1)
					{
						year = prevDate.getYear();
					}
					else
					{
						year = prevDate.getCurrentYear();
					}

					//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
					basicFromQuery = basicFromQuery + " AssetMonitoringFactDataMonthAgg g ";
					//end Defect ID:1406
					basicWhereQuery = basicWhereQuery+ " and g.timeCount= "+ month + " and g.year=" + year;

					//Get the Last Day of previous Month
					Calendar c = Calendar.getInstance();
					c.set(Calendar.DATE, 1);
					c.add(Calendar.DAY_OF_MONTH, -1);
					lastDateInPeriod = dateFrmt.format(c.getTime());

					//DefectId: DF20131023 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period 
					//get the First Day of Previous Month
					String mon = month+"";
					if(mon.length()<2)
						mon="0"+mon;
					startDateInPeriod=year+"-"+mon+"-"+"01";
				}

				else if (period.equalsIgnoreCase("Quarter")) 
				{
					quarter =   thisDate.getQuarter();
					year = thisDate.getYear();

					//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
					basicFromQuery = basicFromQuery + " AssetMonitoringFactDataQuarterAgg g ";
					//end Defect ID:1406
					basicWhereQuery = basicWhereQuery+ " and g.timeCount = "+ quarter + " and g.year=" + year;

					//get the Last Day 
					Calendar c = Calendar.getInstance();
					lastDateInPeriod = dateFrmt.format(c.getTime());

					//DefectId: DF20131023 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period 
					//get the first Date of current quarter
					switch(quarter) 
					{
					case 3 : 
						startDateInPeriod = year+"-07-01";
						break;
						// return July 01
					case 2 :
						startDateInPeriod = year+"-04-01";
						break;
						// return April 01
					case 1 :
						startDateInPeriod = year+"-01-01";
						break;
						// return Jan 01
					case 4 : 
						startDateInPeriod = year+"-10-01";
						break;
						// return Oct 01
					}
				} 

				else if (period.equalsIgnoreCase("Last Quarter")) 
				{
					quarter = prevDate.getQuarter();
					if(thisDate.getQuarter()==1)
					{
						year = prevDate.getYear();
					}
					else
					{
						year = prevDate.getCurrentYear();
					}

					//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
					basicFromQuery = basicFromQuery + " AssetMonitoringFactDataQuarterAgg g ";
					//end Defect ID:1406
					basicWhereQuery = basicWhereQuery+ " and g.timeCount = "+ quarter + " and g.year=" + year;

					//get the last day of previous quarter
					switch(quarter) 
					{
					case 3 : 
						lastDateInPeriod = year+"-09-30";
						break;
						// return September 30
					case 2 :
						lastDateInPeriod = year+"-06-30";
						break;
						// return June 30
					case 1 :
						lastDateInPeriod = year+"-03-31";
						break;
						// return March 31
					case 4 : 
						lastDateInPeriod = year+"-12-31";
						break;
						// return December 31
					}

					//DefectId: DF20131023 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period 
					//get the first Date of Previous quarter
					switch(quarter) 
					{
					case 3 : 
						startDateInPeriod = year+"-07-01";
						break;
						// return July 01
					case 2 :
						startDateInPeriod = year+"-04-01";
						break;
						// return April 01
					case 1 :
						startDateInPeriod = year+"-01-01";
						break;
						// return Jan 01
					case 4 : 
						startDateInPeriod = year+"-10-01";
						break;
						// return Oct 01
					}
				} 

				else if (period.equalsIgnoreCase("Year")) 
				{
					year = thisDate.getYear();

					//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
					basicFromQuery = basicFromQuery + " AssetMonitoringFactDataYearAgg g ";
					//end Defect ID:1406
					basicWhereQuery = basicWhereQuery+ " and g.year = "+year;

					//get the Last Day 
					Calendar c = Calendar.getInstance();
					lastDateInPeriod = dateFrmt.format(c.getTime());

					//DefectId: DF20131023 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period 
					//get the First day of current Year
					startDateInPeriod=year+"-01"+"-01";
				}

				else if (period.equalsIgnoreCase("Last Year")) 
				{
					year = prevDate.getYear();

					//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
					basicFromQuery = basicFromQuery + " AssetMonitoringFactDataYearAgg g ";
					//end Defect ID:1406
					basicWhereQuery = basicWhereQuery+ " and g.year = "+year;

					//get the Last day of previous Year
					lastDateInPeriod=year+"-12-31";

					//DefectId: DF20131023 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period 
					//get the First day of Previous Year 
					startDateInPeriod=year+"-01"+"-01";
				}

				if((isGroupingOnAssetGroup) )
					basicGroupByQuery = basicGroupByQuery + ", c.group_id ";

			}

			//Logic for Custom Dates (fromDate,toDate) added by Juhi on 14-August-2013 
			//DefectID: DF20131014 - Rajani Nagaraju - Custom Dates Implementation
			else
			{
				DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");

				try 
				{	
					fromdateFormatted= dateFormat.format(dateFormat.parse(fromDate));	
					todateFormatted = dateFormat.format(dateFormat.parse(toDate));	
				} 

				catch (ParseException e) 
				{
					e.printStackTrace();
				}

				if(fromdateFormatted==null || todateFormatted==null)
				{
					throw new CustomFault("Unparsable Date input for Custom dates");
				}

				//DefectId: DF20131023 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period 
				startDateInPeriod = fromdateFormatted;
				//get the Last date in the selected period
				lastDateInPeriod = todateFormatted;

				basicSelectQuery = "select sum(u.engineOffHours) as engineOffHours, g.machineHours, sum(u.EngineRunningBand1) as EngineRunningBand1," +
				" sum(u.EngineRunningBand2) as EngineRunningBand2, sum(u.EngineRunningBand3) as EngineRunningBand3," +
				" sum(u.EngineRunningBand4) as EngineRunningBand4, sum(u.EngineRunningBand5) as EngineRunningBand5," +
				" sum(u.EngineRunningBand6) as EngineRunningBand6, sum(u.EngineRunningBand7) as EngineRunningBand7," +
				" sum(u.EngineRunningBand8) as EngineRunningBand8," +
				" x, sum(u.fuelUsedWorking) as fuelUsedWorking, sum(u.fuelUsedIdle) as fuelUsedIdle, " +
				" b.tenancyId,b.tenancyName, c.group_id as machineGroupId, " +
				" c.group_name as machineGroupName, v.tenancy_id as primaryOwnerTenancy," +
				//DefectId:20150223 @ Suprava Delaer As a new parameter Added
				"b.parentTenancyName,b.tenancyTypeId ";

				//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
				basicFromQuery = " from AssetCustomGroupMapping w RIGHT OUTER JOIN w.serial_number x  LEFT OUTER JOIN w.group_id c," +
				" TenancyDimensionEntity b, AssetMonitoringFactDataDayAgg g, AssetMonitoringFactDataDayAgg u," +
				" AccountTenancyMapping v " ;
				//end Defect ID:1406
				//DefectId:20150223 @ Suprava Delaer As a new parameter Added
				//" TenancyEntity ten1 ";

				//Rajani Nagaraju - 20131204 - To fix the issue raised for 4th Dec SIT deployment - to handle machine movement b/w diff ten hierarchies
				basicWhereQuery = " where g.tenancyId = b.tenacy_Dimension_Id and b.tenancyId in ("+tenancyIdStringList+" ) and " +
				" x.serial_number = g.serialNumber "+
				" and x.primary_owner_id = v.account_id" +
				" and g.serialNumber = u.serialNumber " + 
				" and g.timeKey = (select max(o.timeKey) from AssetMonitoringFactDataDayAgg o , TenancyDimensionEntity yt" +
				" where o.serialNumber=g.serialNumber and o.tenancyId = yt.tenacy_Dimension_Id and yt.tenancyId in ("+ tenancyIdStringList + " ) " +
				" and o.timeKey >='"+fromdateFormatted+"' and o.timeKey <= '"+todateFormatted+"')" +
				" and u.timeKey between '"+fromdateFormatted+"' and '"+todateFormatted+"'";
				//DefectId:20150216 @ Suprava Delaer As a new parameter Added
				//" and b.parentTenancyId=ten1.parent_tenancy_id ";

				basicGroupByQuery = basicGroupByQuery + ", c.group_id, g.tenancyId ";

			}

			//Custom Asset Group Filter
			//DefectID:DF20131014 - Rajani Nagaraju - DF20131014 - Query modification to return correct resultset
			if (!(machineGroupIdList == null || machineGroupIdList.isEmpty())) 
			{
				String customAssetGroupStringList = conversionObj.getIntegerListString(machineGroupIdList).toString();
				basicWhereQuery = basicWhereQuery+ " and c.group_id in ("+ customAssetGroupStringList + ")";
			}

			//DefectID:DF20131014 - Rajani Nagaraju - DF20131014 - Query modification to return correct resultset
			if ((!(machineProfileIdList == null || machineProfileIdList.isEmpty()))	|| (!(modelIdList == null || modelIdList.isEmpty()))) 
			{
				basicFromQuery = basicFromQuery+ " , AssetClassDimensionEntity y ";
				basicWhereQuery = basicWhereQuery	+ " and g.assetClassDimensionId = y.assetClassDimensionId";
			}


			//DefectID:DF20131014 - Rajani Nagaraju - DF20131014 - Query modification to return correct resultset
			if (!(machineProfileIdList == null || machineProfileIdList.isEmpty())) 
			{
				String machineProfileIdStringList = conversionObj.getIntegerListString(machineProfileIdList).toString();
				basicWhereQuery = basicWhereQuery + " and y.assetGroupId in ( "+ machineProfileIdStringList + ") ";
			}			

			//DefectID:DF20131014 - Rajani Nagaraju - DF20131014 - Query modification to return correct resultset
			if (!((modelIdList == null) || (modelIdList.isEmpty()))) 
			{
				String modelIdListStringList = conversionObj.getIntegerListString(modelIdList).toString();
				basicWhereQuery = basicWhereQuery + " and y.assetTypeId in ( "+ modelIdListStringList + " )";
			}

			finalQuery = basicSelectQuery + basicFromQuery + basicWhereQuery + basicGroupByQuery;

			Query query = session.createQuery(finalQuery);
			Iterator itr = query.list().iterator();

			Object[] result = null;
			MachinePerformanceReportImpl implObj=null;
			double EngineRunningBand1;
			double EngineRunningBand2;
			double EngineRunningBand3;
			double EngineRunningBand4;
			double EngineRunningBand5;
			double EngineRunningBand6;
			double EngineRunningBand7;
			double EngineRunningBand8;
			String serNum = null;
			double fuelUsedWorking =0.0D;
			double fuelUsedIdle=0.0D;
			double fuelUsedLitres=0.0D;
			double fuelUsedIdleLife = 0.0D;
			double fuelUsedWorkingLife = 0.0D;
			double FinishEngineRunHours =0.0D;
			double OverallFuelConsumption=0.0D;
			double startingEngineRunHoursLife=0.0D;

			// DefectId: DF20131014 - Rajani Nagaraju - 20131014 - CustomDate Implementation 
			List<String> serialNumberList = new LinkedList<String>();

			while (itr.hasNext()) 
			{
				result = (Object[]) itr.next();
				implObj = new MachinePerformanceReportImpl();
				Double engineOffInt=0.0D;
				fuelUsedWorking =0.0D;
				fuelUsedIdle=0.0D;
				fuelUsedLitres=0.0D;
				fuelUsedIdleLife = 0.0D;
				fuelUsedWorkingLife = 0.0D;
				FinishEngineRunHours =0.0D;
				OverallFuelConsumption=0.0D;
				startingEngineRunHoursLife=0.0D;

				//------------------1.Set Asset and Asset Properties
				AssetEntity asset =null;
				TenancyEntity tenancyEntity =null;
				if(result[10]!=null)
				{					
					asset = (AssetEntity)result[10];
					serNum = asset.getSerial_number().getSerialNumber();
					implObj.setSerialNumber(serNum);
				}

				// DefectId:DF20131014 - Rajani Nagaraju - 20131014 - CustomDate Implementation 
				if( (!isGroupingOnAssetGroup) && (serialNumberList.contains(serNum))) 
				{
					continue;
				}
				else
				{
					serialNumberList.add(serNum);
				}

				//1.1 Tenancy Details
				if(result[13] !=null)
					implObj.setTenancyId((Integer)result[13]);
				if(result[14]!=null)
					implObj.setTenancyName(result[14].toString());

				//1.2 Machine Group Details
				if(result[15]!=null)
					implObj.setCustomMachineGroupId((Integer) result[15]);
				if (result[16] != null)
					implObj.setCustomMachineGroupName((String) result[16]);

				//1.3 Machine Profile and Model Details
				//DefectID:DF20131014 - Rajani Nagaraju - Query modification to return correct resultset
				if(asset!=null)
				{
					if(asset.getProductId()!=null && asset.getProductId().getAssetGroupId()!=null)
					{
						implObj.setAssetGroupId(asset.getProductId().getAssetGroupId().getAsset_group_id());
						implObj.setAsset_group_name(asset.getProductId().getAssetGroupId().getAsset_group_name());
					}

					if(asset.getProductId()!=null && asset.getProductId().getAssetTypeId()!=null)
					{
						implObj.setModelId(asset.getProductId().getAssetTypeId().getAsset_type_id());
						implObj.setModelName(asset.getProductId().getAssetTypeId().getAsset_type_name());
					}


				}
				//DefectId:20150223 @ Suprava Delaer As a new parameter Added
				if(result[19]!=null)
						{
							int tenancyTypeId =(Integer) result[19];
							//If the Machine is with customer Get the parentTeancyId
							if(tenancyTypeId==4)
							{
							//	tenancyEntity =(TenancyEntity)result[18];
								implObj.setDealerName(result[18].toString());
							}
							//If the Machine is with Dealer
							else if(tenancyTypeId==3) 
							{
								if(result[14]!=null)
								{
								//String Dealername =(String)result[14];
								implObj.setDealerName(result[14].toString());
							}
							}
							else
							{
								implObj.setDealerName("No Dealer Tagging");
							}
						
						}
				//------------------END of 1.Set Asset and Asset Properties

				//-------------------------- 2. Set Machine Utilization Details
				//2.1 Engine Off Period In hours - For the given Period
				if(period!=null)
				{
					if(result[0] != null)
					{
						try
						{
							double engineOff = (Double)result[0];
							engineOffInt = (Double)engineOff;
						}

						catch(ClassCastException e)
						{
							engineOffInt = (Double)result[0];
						}
						//implObj.setEngineOff(engineOffInt);
						implObj.setEngineOff(Double.valueOf(df2.format((Double)engineOffInt)));
					}
				}

				//2.2 Engine On Period In hours - For the given Time Period
				EngineRunningBand1 = (Double) result[2];
				EngineRunningBand2 = (Double) result[3];
				EngineRunningBand3 = (Double) result[4];
				EngineRunningBand4 = (Double) result[5];
				EngineRunningBand5 = (Double) result[6];
				EngineRunningBand6 = (Double) result[7];
				EngineRunningBand7 = (Double) result[8];
				EngineRunningBand8 = (Double) result[9];
				double workingTime1 = (EngineRunningBand3 + EngineRunningBand4+ EngineRunningBand5 + 
						EngineRunningBand6 + EngineRunningBand7 + EngineRunningBand8);
				double idleTime1 = (EngineRunningBand1 + EngineRunningBand2);

				double engineOn = (double) (workingTime1 + idleTime1);
				//implObj.setEngineOn(engineOn);
				implObj.setEngineOn(Double.valueOf(df2.format((Double)engineOn)));
				//2.1 Engine Off Period In hours - For Custom Dates
				if(period==null)
				{
					Date newerDate = dateFrmt.parse(todateFormatted);
					Date olderDate = dateFrmt.parse(fromdateFormatted);
					double diffInDays = (double)( (newerDate.getTime() - olderDate.getTime()) 
							/ (1000 * 60 * 60 * 24) );
					diffInDays= diffInDays+1;
					double engineOffLong = (24*diffInDays)-engineOn;
					engineOffInt = (double)engineOffLong;
					//	implObj.setEngineOff(engineOffInt);
					implObj.setEngineOff(Double.valueOf(df2.format((Double)engineOffInt)));
				}

				//2.3 Working Time Period in Hours - For the given Time Period
				//Decimal format change @suprava
				implObj.setWorkingTime(Double.valueOf(df2.format((Double)workingTime1)));

				//2.4 Idle Time Period in Hours - For the given Time Period
				implObj.setIdleTime(Double.valueOf(df2.format((Double)idleTime1)));

				//-------------------------- END of  2. Set Machine Utilization Details


				//-------------------------- 3. Set Machine Productivity Details
				double lowValue = bandCalculation(bandIdLowList,
						EngineRunningBand1, EngineRunningBand2,
						EngineRunningBand3, EngineRunningBand4,
						EngineRunningBand5, EngineRunningBand6,
						EngineRunningBand7, EngineRunningBand8);
				double midValue = bandCalculation(bandIdMediumList,
						EngineRunningBand1, EngineRunningBand2,
						EngineRunningBand3, EngineRunningBand4,
						EngineRunningBand5, EngineRunningBand6,
						EngineRunningBand7, EngineRunningBand8);
				double highValue = bandCalculation(bandIdHighList,
						EngineRunningBand1, EngineRunningBand2,
						EngineRunningBand3, EngineRunningBand4,
						EngineRunningBand5, EngineRunningBand6,
						EngineRunningBand7, EngineRunningBand8);

				//3.1 Poweer band Low (Period In Hrs) - For the given time Period
				implObj.setPowerBandLow(Double.valueOf(df2.format((Double)lowValue)));

				//3.2 Poweer band Medium (Period In Hrs) - For the given time Period
				implObj.setPowerBandMedium(Double.valueOf(df2.format((Double)midValue)));

				//3.1 Poweer band High (Period In Hrs) - For the given time Period
				implObj.setPowerBandHigh(Double.valueOf(df2.format((Double)highValue)));

				//-------------------------- 3. END of Set Machine Productivity Details


				//--------------------------- 4. Set Consumption Details
				//4.1 Starting Engine Run Hours - CMHR of the machine at the start of the Period
				if(result[1] != null)
				{
					FinishEngineRunHours = (Double) result[1]; // - This is the finish Engine Hours at the end of the given period
				}
				double startingEngineRunHours = (FinishEngineRunHours - engineOn);
				//implObj.setStartingEngineRunHours(startingEngineRunHours);
				implObj.setStartingEngineRunHours(Double.valueOf(df2.format((Double)startingEngineRunHours)));
				//4.2 Finish Engine Run Hours - CMHR of the machine at the End of the Period
				//implObj.setFinishEngineRunHours(FinishEngineRunHours);
				implObj.setFinishEngineRunHours(Double.valueOf(df2.format((Double)FinishEngineRunHours)));
				//4.3 Fuel Used(In Litres) In the given Period
				if(result[11]!=null)
					fuelUsedWorking = (Double) result[11];
				if(result[12] !=null)
					fuelUsedIdle = (Double) result[12];
				fuelUsedLitres = (fuelUsedWorking + fuelUsedIdle);
				//implObj.setFuelUsedLitres(fuelUsedLitres);
				implObj.setFuelUsedLitres(Double.valueOf(df2.format((Double)fuelUsedLitres)));


				//4.4 Fuel Used Idle(In Litres) In the given Period
				implObj.setFuelUsedIdleLitres(fuelUsedIdle);

				//4.6 Overall Fuel Consumption (in Litres/hr) in the given Period
				double engineOff=engineOffInt;
				if(fuelUsedLitres != 0.0)
				{
					OverallFuelConsumption = (fuelUsedLitres / (engineOn+engineOff));
					//implObj.setOverallFuelConsumptionLitres(OverallFuelConsumption);
					implObj.setOverallFuelConsumptionLitres(Double.valueOf(df2.format((Double)OverallFuelConsumption)));
				}

				//4.5 Finish Fuel Level % - Finish Fuel Level at the End of the Period
				//Find Last Date in the given Period
				String getMaxTxn = " select max(h.transactionNumber) from AssetMonitoringHeaderEntity h where h.serialNumber='"+ serNum +"' ";
				if(lastDateInPeriod != null)
				{
					getMaxTxn = getMaxTxn + " and h.transactionTime <= '"+lastDateInPeriod+" 23:59:59' ";
				}

				// 2014-06-23: Fuel Level change : To take the fuel level from the Snapshot table - Deepthi
				String hql = "select s.parameterValue from AssetMonitoringDetailEntity s where " +
							" s.transactionNumber=("+getMaxTxn+")and s.parameterId=(select max(m.parameterId) from " +
									" MonitoringParameters m where m.parameterName like 'FuelLevel')";

				String hql = "Select s.fuelLevel from AssetMonitoringSnapshotEntity s where s.serialNumber = '"+serNum + "' ";
				String parameterValue = null;
				Query query1 = session.createQuery(hql);
				List queryList =  query1.list();
				Iterator itr2 =queryList.iterator();
				if( (itr2.hasNext()) && (queryList.size() > 0) && (queryList.get(0) != null))
				{
					while (itr2.hasNext()) 
					{
						parameterValue = itr2.next().toString();
						if(!parameterValue.equalsIgnoreCase(null)){
							implObj.setFinishFuelLevel(parameterValue);
						}
					}
				}
				else
				{
					implObj.setFinishFuelLevel("0.0");
				}

				//--------------------------- 4. END of Set Consumption Details


				//--------------------------- 5. Set Consumption Details for the Complete Machine Life
				//5.1 Start Engine Hours Life - This will always be Zero
				startingEngineRunHoursLife = 0.0D;
				//implObj.setStartingEngineRunHoursLife(startingEngineRunHoursLife);
				implObj.setStartingEngineRunHoursLife(Double.valueOf(df2.format((Double)startingEngineRunHoursLife)));
				TenancyEntity primaryOwnerTenancy = (TenancyEntity)result[17];
				//If the Machine is under the user hierarchy currently, then display current status of Machine
				if( tenancyIdList.contains(primaryOwnerTenancy.getTenancy_id()) )
				{
					//5.2 Finish Engine Hours Life - CMHR of the last received packet from the Machine
					//5.3 Finish Fuel Level% Life - Fuel Level% of the last received packet from the Machine
					Query q = session.createQuery(" select s.parameterId, s.parameterValue from AssetMonitoringDetailEntity s,AssetMonitoringHeaderEntity b" +
							" where s.transactionNumber= b.transactionNumber and " +
							" b.transactionTime= (select max(h.transactionTime) from AssetMonitoringHeaderEntity h " +
							"where h.serialNumber='"+ serNum +"') and s.parameterId in ('4','5')");
					Iterator itrq = q.list().iterator();
					Object[] itrRes=null;
					while(itrq.hasNext())
					{
						itrRes = (Object[]) itrq.next();
						MonitoringParameters paramObj = (MonitoringParameters)itrRes[0];
						String value = null;
						if(itrRes[1]!=null)
							value=itrRes[1].toString();

						//ParameterId 4 corresponds to EngineHours
						if(paramObj.getParameterId()==4 && value!=null)
						{
							double d = Double.parseDouble(value);
							//long l = (long)d;
							//	implObj.set(d);
							implObj.setFinishEngineRunHoursLife(Double.valueOf(df2.format((Double)d)));
						}
						//ParameterId 5 corresponds to FuelLevelPercentage
						else if(paramObj.getParameterId()==5 && value!=null)
						{
							//DefectId:20140702 Fuel Level change : To take the fuel level from the Snapshot table - Suprava
							implObj.setFinishFuelLevelLife(parameterValue);
						}
					}

					//5.4 FuelUsedLitresLife
					if(result[17]!=null)
						fuelUsedWorkingLife = (Double) result[17];
					if(result[18] !=null)
						fuelUsedIdleLife = (Double) result[18];
					double fuelUsedLitresLife = (fuelUsedWorkingLife + fuelUsedIdleLife);
					implObj.setFuelUsedLitresLife(fuelUsedLitresLife);
					Query qw = session.createQuery(" select m.serialNumber, sum(m.fuelUsedWorking) as totalFuelUsedWorking, sum(m.fuelUsedIdle) as totalFuelUsedIdle " +
							" from AssetMonitoringFactDataYearAgg m where m.serialNumber='"+serNum+"'");
					Iterator itrQw = qw.list().iterator();
					Object[] fuelResult =null;
					while(itrQw.hasNext())
					{
						fuelResult = (Object[])itrQw.next();
						if(fuelResult[1]!=null)
							fuelUsedWorkingLife = (Double) fuelResult[1];
						if(fuelResult[2]!=null)
							fuelUsedIdleLife = (Double) fuelResult[2];
						//double fuelUsedLitresLife = (fuelUsedWorkingLife + fuelUsedIdleLife);
						double fuelUsedLitresLife = ((Double.valueOf(df2.format((Double)fuelUsedWorkingLife))) + (Double.valueOf(df2.format((Double)fuelUsedIdleLife))));
						implObj.setFuelUsedLitresLife(fuelUsedLitresLife);
					}

					//5.5 Fuel Used in Idle Life
					implObj.setFuelUsedIdleLitresLife(fuelUsedIdleLife);

					//--------------------------- END of 5. Set Consumption Details for the Complete Machine Life
				}

				listImplObj.add(implObj);

			}


			//-------------------------------------------------------------------------------------------------------------------
			//DefectId: DF20131023 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period 
			Query ownerListQuery = session.createQuery(" select distinct c.serialNumber " +
					" from TenancyBridgeEntity a, AccountTenancyMapping b, AssetAccountMapping c " +
					" where a.childId= b.tenancy_id " +
					" and b.account_id= c.accountId " +
					" and a.parentId in ("+tenancyIdStringList+") and" +
					" ( (c.ownershipStartDate between '"+startDateInPeriod+"' and '"+lastDateInPeriod+"') OR " +
					"   (c.ownershipStartDate = ( select max(y.ownershipStartDate) from AssetAccountMapping y " +
					" where y.serialNumber= c.serialNumber" +
					" and y.ownershipStartDate <='"+startDateInPeriod+"')" +
					"    )" +
			" )");
			Iterator ownerListItr = ownerListQuery.list().iterator();
			List<String> actualOwnerVINList = new LinkedList<String>();
			while(ownerListItr.hasNext())
			{
				AssetEntity assetList = (AssetEntity)ownerListItr.next();
				actualOwnerVINList.add(assetList.getSerial_number().getSerialNumber());
			}

			//Get only the List of VINs which has not communicated for the Given period
			actualOwnerVINList.removeAll(serialNumberList);
			String actualOwnerVinListString = conversionObj.getStringList(actualOwnerVINList).toString();
			//DefectId:20150316 @Suprava Null check handle 
			if(actualOwnerVinListString!=null){
			basicGroupByQuery =" group by g.serialNumber ";


			basicSelectQuery = "select x ,g.machineHours, b.tenancyId,b.tenancyName, c.group_id as machineGroupId, " +
			" c.group_name as machineGroupName, v.tenancy_id as primaryOwnerTenancy," +
			//DefectId:20150220 @ Suprava DelaerName As a new parameter Added
			" b.parentTenancyName,b.tenancyTypeId ";

			//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
			basicFromQuery = " from AssetCustomGroupMapping w RIGHT OUTER JOIN w.serial_number x  LEFT OUTER JOIN w.group_id c," +
			" TenancyDimensionEntity b ,  AssetMonitoringFactDataDayAgg g , AccountTenancyMapping v " ;
			//end Defect ID:1406
			//DefectId:20150220 @ Suprava DelaerName As a new parameter Added
			//" TenancyEntity ten1";

			basicWhereQuery = " where g.tenancyId = b.tenacy_Dimension_Id " +
			" and x.serial_number = g.serialNumber " +
			" and x.primary_owner_id = v.account_id" +
			" and g.serialNumber in ("+actualOwnerVinListString+") " +
			" and g.timeKey = ( select max(p.timeKey) from AssetMonitoringFactDataDayAgg p where p.serialNumber = g.serialNumber " +
			"					 and p.timeKey <= '"+startDateInPeriod+"' )" ;
			//DefectId:20150216 @ Suprava Delaer As a new parameter Added
			//" and b.parentTenancyId=ten1.parent_tenancy_id ";

			//Custom Asset Group Filter
			//DefectID:DF20131014 - Rajani Nagaraju - DF20131014 - Query modification to return correct resultset
			if (!(machineGroupIdList == null || machineGroupIdList.isEmpty())) 
			{
				String customAssetGroupStringList = conversionObj.getIntegerListString(machineGroupIdList).toString();
				basicWhereQuery = basicWhereQuery+ " and c.group_id in ("+ customAssetGroupStringList + ")";
			}

			//DefectID:DF20131014 - Rajani Nagaraju - DF20131014 - Query modification to return correct resultset
			if ((!(machineProfileIdList == null || machineProfileIdList.isEmpty()))	|| (!(modelIdList == null || modelIdList.isEmpty()))) 
			{
				basicFromQuery = basicFromQuery+ " , AssetClassDimensionEntity y ";
				basicWhereQuery = basicWhereQuery	+ " and g.assetClassDimensionId = y.assetClassDimensionId";
			}


			//DefectID:DF20131014 - Rajani Nagaraju - DF20131014 - Query modification to return correct resultset
			if (!(machineProfileIdList == null || machineProfileIdList.isEmpty())) 
			{
				String machineProfileIdStringList = conversionObj.getIntegerListString(machineProfileIdList).toString();
				basicWhereQuery = basicWhereQuery + " and y.assetGroupId in ( "+ machineProfileIdStringList + ") ";
			}			

			//DefectID:DF20131014 - Rajani Nagaraju - DF20131014 - Query modification to return correct resultset
			if (!((modelIdList == null) || (modelIdList.isEmpty()))) 
			{
				String modelIdListStringList = conversionObj.getIntegerListString(modelIdList).toString();
				basicWhereQuery = basicWhereQuery + " and y.assetTypeId in ( "+ modelIdListStringList + " )";
			}

			finalQuery = basicSelectQuery + basicFromQuery + basicWhereQuery + basicGroupByQuery;

			Iterator vinListItr = session.createQuery(finalQuery).list().iterator();
			result = null;

			// DefectId: DF20131014 - Rajani Nagaraju - 20131014 - CustomDate Implementation 
			serialNumberList = new LinkedList<String>();
			while (vinListItr.hasNext()) 
			{
				serNum =null;

				result = (Object[]) vinListItr.next();
				implObj = new MachinePerformanceReportImpl();
				double engineOffInt=0.0D;

				fuelUsedIdleLife = 0.0D;
				fuelUsedWorkingLife = 0.0D;
				FinishEngineRunHours =0.0D;
				startingEngineRunHoursLife=0.0D;

				//------------------1.Set Asset and Asset Properties
				AssetEntity asset =null;
				TenancyEntity tenancyEntity= null;
				if(result[0]!=null)
				{					
					asset = (AssetEntity)result[0];
					serNum = asset.getSerial_number().getSerialNumber();
					implObj.setSerialNumber(serNum);
				}

				// DefectId:DF20131014 - Rajani Nagaraju - 20131014 - CustomDate Implementation 
				if( (!isGroupingOnAssetGroup) && (serialNumberList.contains(serNum))) 
				{
					continue;
				}
				else
				{
					serialNumberList.add(serNum);
				}

				//1.1 Tenancy Details
				if(result[2] !=null)
					implObj.setTenancyId((Integer)result[2]);
				if(result[3]!=null)
					implObj.setTenancyName(result[3].toString());

				//1.2 Machine Group Details
				if(result[4]!=null)
					implObj.setCustomMachineGroupId((Integer) result[4]);
				if (result[5] != null)
					implObj.setCustomMachineGroupName((String) result[5]);

				//1.3 Machine Profile and Model Details
				//DefectID:DF20131014 - Rajani Nagaraju - Query modification to return correct resultset
				if(asset!=null)
				{
					if(asset.getProductId()!=null && asset.getProductId().getAssetGroupId()!=null)
					{
						implObj.setAssetGroupId(asset.getProductId().getAssetGroupId().getAsset_group_id());
						implObj.setAsset_group_name(asset.getProductId().getAssetGroupId().getAsset_group_name());
					}

					if(asset.getProductId()!=null && asset.getProductId().getAssetTypeId()!=null)
					{
						implObj.setModelId(asset.getProductId().getAssetTypeId().getAsset_type_id());
						implObj.setModelName(asset.getProductId().getAssetTypeId().getAsset_type_name());
					}


				}
				//DefectId:20150223 @ Suprava Delaer As a new parameter Added
				if(result[8]!=null)
						{
							int tenancyTypeId =(Integer) result[8];
							//If the Machine is with customer Get the parentTeancyId
							if(tenancyTypeId==4)
							{
							//	tenancyEntity =(TenancyEntity)result[7];
								implObj.setDealerName(result[7].toString());
							}
							//If the Machine is with Dealer
							else if(tenancyTypeId==3) 
							{
								if(result[3]!=null)
								{
							//	String Dealername =(String)result[3];
								implObj.setDealerName(result[3].toString());
							}
							}
							else
							{
								implObj.setDealerName("No Dealer Tagging");
							}
						
						}
				//------------------END of 1.Set Asset and Asset Properties

				//-------------------------- 2. Set Machine Utilization Details
				//2.1 Engine Off Period In hours - For the given Period
				//-----get Total Time duration in hours between the given period
				SimpleDateFormat dtFmt = new SimpleDateFormat("yyyy-MM-dd");
				Date startDate = dtFmt.parse(startDateInPeriod);
				Date lastDate = dtFmt.parse(lastDateInPeriod);
				long engineOffLong = (startDate.getTime()-lastDate.getTime())/(60*60 * 1000);
				engineOffInt = (double)engineOffLong;
				//implObj.setEngineOff(engineOffInt);
				implObj.setEngineOff(Double.valueOf(df2.format((Double)engineOffInt)));


				//2.2 Engine On Period In hours - For the given Time Period 
				//------ This will be 0 hours

				//2.3 Working Time Period in Hours - For the given Time Period
				//------ This will be 0 hours

				//2.4 Idle Time Period in Hours - For the given Time Period
				//------ This will be 0 hours

				//-------------------------- END of  2. Set Machine Utilization Details


				//-------------------------- 3. Set Machine Productivity Details

				//3.1 Poweer band Low (Period In Hrs) - For the given time Period
				//------ This will be 0 hours

				//3.2 Poweer band Medium (Period In Hrs) - For the given time Period
				//------ This will be 0 hours

				//3.1 Poweer band High (Period In Hrs) - For the given time Period
				//------ This will be 0 hours

				//-------------------------- 3. END of Set Machine Productivity Details


				//--------------------------- 4. Set Consumption Details
				//4.1 Starting Engine Run Hours - CMHR of the machine at the start of the Period
				if(result[1] != null)
				{
					FinishEngineRunHours = (Double) result[1]; // - This is the finish Engine Hours at the end of the given period
				}
				//Since the Machine has not communicated for the given period, StartEngineRunHours and FinishEngineRunHours are the same
				//implObj.setStartingEngineRunHours(FinishEngineRunHours);
				//need to be check @suprava 
				implObj.setStartingEngineRunHours(Double.valueOf(df2.format((Double)FinishEngineRunHours)));

				//4.2 Finish Engine Run Hours - CMHR of the machine at the End of the Period
				//implObj.setFinishEngineRunHours(FinishEngineRunHours);
				implObj.setFinishEngineRunHours(Double.valueOf(df2.format((Double)FinishEngineRunHours)));	

				//4.3 Fuel Used(In Litres) In the given Period
				//------ This will be 0 Litres

				//4.4 Fuel Used Idle(In Litres) In the given Period
				//------ This will be 0 Litres

				//--------------------------- 5. Set Consumption Details for the Complete Machine Life
				//5.1 Start Engine Hours Life - This will always be Zero
				startingEngineRunHoursLife = 0.0;
				//implObj.setStartingEngineRunHoursLife(startingEngineRunHoursLife);
				implObj.setStartingEngineRunHoursLife(Double.valueOf(df2.format((Double)startingEngineRunHoursLife)));

				//4.5 Finish Fuel Level % - Finish Fuel Level at the End of the Period
				//Find Last Date in the given Period
				String getMaxTxn = " select max(h.transactionNumber) from AssetMonitoringHeaderEntity h where h.serialNumber='"+ serNum +"' ";
				if(lastDateInPeriod != null)
				{
					getMaxTxn = getMaxTxn + " and h.transactionTime <= '"+lastDateInPeriod+" 23:59:59' ";
				}

				String hql = "select s.parameterValue from AssetMonitoringDetailEntity s where " +
							" s.transactionNumber=("+getMaxTxn+")and s.parameterId=(select max(m.parameterId) from " +
									" MonitoringParameters m where m.parameterName like 'FuelLevel')";

				// 2014-07-02: Fuel Level change : To take the fuel level from the Snapshot table - Suprava 
				String hql = "Select s.fuelLevel from AssetMonitoringSnapshotEntity s where s.serialNumber = '"+serNum + "' ";
				String parameterValue = null;
				Query query1 = session.createQuery(hql);
				List queryList =  query1.list();
				Iterator itr2 = query1.list().iterator();
				if( (itr2.hasNext()) && (queryList.size() > 0) && (queryList.get(0) != null))
				{
					while (itr2.hasNext()) 
					{
						parameterValue = itr2.next().toString();
						if(!parameterValue.equalsIgnoreCase(null)){
							implObj.setFinishFuelLevel(parameterValue);
						}
					}
				}
				else
				{
					implObj.setFinishFuelLevel("0.0");
				}
				while (itr2.hasNext()) 
				{
					parameterValue = itr2.next().toString();
					implObj.setFinishFuelLevel(parameterValue);
				}

				if(result[6]!=null)
				{
					TenancyEntity primaryOwnerTenancy = (TenancyEntity)result[6];
					//If the Machine is under the user hierarchy currently, then display current status of Machine
					if( tenancyIdList.contains(primaryOwnerTenancy.getTenancy_id()) )
					{
						//4.6 Overall Fuel Consumption (in Litres/hr) in the given Period
						//------ This will be 0 Litres
						//--------------------------- 4. END of Set Consumption Details

						//5.2 Finish Engine Hours Life - CMHR of the last received packet from the Machine
						//5.3 Finish Fuel Level% Life - Fuel Level% of the last received packet from the Machine
						Query q = session.createQuery(" select s.parameterId, s.parameterValue from AssetMonitoringDetailEntity s,AssetMonitoringHeaderEntity b" +
								" where s.transactionNumber= b.transactionNumber and " +
								" b.transactionTime= (select max(h.transactionTime) from AssetMonitoringHeaderEntity h " +
								"where h.serialNumber='"+ serNum +"') and s.parameterId in ('4','5')");
						Iterator itrq = q.list().iterator();
						Object[] itrRes=null;
						while(itrq.hasNext())
						{
							itrRes = (Object[]) itrq.next();
							MonitoringParameters paramObj = (MonitoringParameters)itrRes[0];
							String value = null;
							if(itrRes[1]!=null)
								value=itrRes[1].toString();

							//ParameterId 4 corresponds to EngineHours
							if(paramObj.getParameterId()==4 && value!=null)
							{
								double d = Double.parseDouble(value);
								// long l = (long)d;
								implObj.setFinishEngineRunHoursLife(Double.valueOf(df2.format((Double)d)));;
							}
							//ParameterId 5 corresponds to FuelLevelPercentage
							else if(paramObj.getParameterId()==5 && value!=null)
							{
								// 2014-07-02: Fuel Level change : To take the fuel level from the Snapshot table - Suprava
								implObj.setFinishFuelLevelLife(parameterValue);
							}
						}

						//5.4 FuelUsedLitresLife
						Query qw = session.createQuery(" select m.serialNumber, sum(m.fuelUsedWorking) as totalFuelUsedWorking, sum(m.fuelUsedIdle) as totalFuelUsedIdle " +
								" from AssetMonitoringFactDataYearAgg m where m.serialNumber='"+serNum+"'");
						Iterator itrQw = qw.list().iterator();
						Object[] fuelResult =null;
						while(itrQw.hasNext())
						{
							fuelResult = (Object[])itrQw.next();
							if(fuelResult[1]!=null)
								fuelUsedWorkingLife = (Double) fuelResult[1];
							if(fuelResult[2]!=null)
								fuelUsedIdleLife = (Double) fuelResult[2];
							double fuelUsedLitresLife = (fuelUsedWorkingLife + fuelUsedIdleLife);
							implObj.setFuelUsedLitresLife(fuelUsedLitresLife);
						}

						//5.5 Fuel Used in Idle Life
						implObj.setFuelUsedIdleLitresLife(fuelUsedIdleLife);

						//--------------------------- END of 5. Set Consumption Details for the Complete Machine Life
					}
				}

				listImplObj.add(implObj);
			}
			}
			//DefectId:20150316 End
		}

		catch (Exception e) 
		{
			e.printStackTrace();
			fLogger.fatal("Exception :" + e);
		}

		finally 
		{
			//			Keerthi : 14/01/14 : not needed
			//			if (session.getTransaction().isActive()) 
			//			{
			//				session.getTransaction().commit();
			//			}

			if (session.isOpen()) 
			{
				session.flush();
				session.close();
			}

		}

		return listImplObj;
			}*/
	// **************************************************** END OF MachinePerformanceReportService************************ ****************

	
	// ********************************************START OF MachinePerformanceReportService************************
	/** DefectId:  DF20131014 - Custom Date Implementation - Rajani Nagaraju 
	 * DefectId: DF20131023 - To add the Machines that has not communicated for the given period
	 * DefectId: DF20131015 - Rajani Nagaraju - Logic Change to return correct parameter Values
	 * This method returns the performance details of the machine for the given time period
	 * @param period - Can be either of Today/Week/Month/Quarter/Year - Mandatory parameter
	 * @param machineGroupIdList - List of Custom AssetGroupId as input filter
	 * @param machineProfileIdList - List of MachineProfileId as input filter
	 * @param tenancyIdList - List of TenancyId as input filter - Mandatory parameter
	 * @param modelIdList - List of Models as input filter
	 * @return Returns the Machine Performance details
	 */
	//Custom Dates (fromDate,toDate) added by Juhi on 14-August-2013 
	public List<MachinePerformanceReportImpl> getMachPerformanceReport(String fromDate,String toDate,String period, List<Integer> machineGroupIdList,
			List<Integer> machineProfileIdList, List<Integer> tenancyIdList,
			List<Integer> modelIdList, boolean isGroupingOnAssetGroup) 
			{

		List<MachinePerformanceReportImpl> listImplObj = new LinkedList<MachinePerformanceReportImpl>();
		Logger fLogger = FatalLoggerClass.logger;
		//Logger bLogger = BusinessErrorLoggerClass.logger;
		Logger iLogger = InfoLoggerClass.logger;
		String basicFromQuery = null;
		String basicSelectQuery = null;
		String basicWhereQuery = null;
		String finalQuery = null;
		String basicGroupByQuery = " group by g.serialNumber ";

		String fromdateFormatted=null;
		String todateFormatted=null;

		SimpleDateFormat dateFrmt = new SimpleDateFormat("yyyy-MM-dd");
		String lastDateInPeriod =null;
		String startDateInPeriod=null;

		//Logger businessError = Logger.getLogger("businessErrorLogger");
		//Logger fatalError = Logger.getLogger("fatalErrorLogger");

		Session session = HibernateUtil.getSessionFactory().getCurrentSession();
		session.beginTransaction();

		try 
		{
			DecimalFormat df2 = new DecimalFormat("###.#");
			//------- Get the List of TenancyIds all down the hierarchy
			//tenancyIdList=getSubTenancyIds(tenancyIdList,session);
			ListToStringConversion conversionObj = new ListToStringConversion();
			String tenancyIdStringList = conversionObj.getIntegerListString(tenancyIdList).toString();

			List<Integer> bandIdLowList = new ArrayList<Integer>();
			List<Integer> bandIdMediumList = new ArrayList<Integer>();
			List<Integer> bandIdHighList = new ArrayList<Integer>();

			//Get the RPM BandIdList for each band Category - High,Medium,Low
			Query rpmBandQuery = session.createQuery("from RpmBands");
			Iterator rpmBandItr = rpmBandQuery.list().iterator();
			while(rpmBandItr.hasNext())
			{
				RpmBands rpmBand = (RpmBands)rpmBandItr.next();
				if(rpmBand.getPower_Band().equalsIgnoreCase("Low"))
				{
					bandIdLowList.add(rpmBand.getBand_ID());
				}
				if(rpmBand.getPower_Band().equalsIgnoreCase("Med"))
				{
					bandIdMediumList.add(rpmBand.getBand_ID());
				}
				if(rpmBand.getPower_Band().equalsIgnoreCase("High"))
				{
					bandIdHighList.add(rpmBand.getBand_ID());
				}
			}
			
					//DefectId:20160104 - added by S Suresh 
					if(period !=null)
					{
						basicSelectQuery = "select g.engineOffHours,g.machineHours,g.EngineRunningBand1,g.EngineRunningBand2,g.EngineRunningBand3," +
						" g.EngineRunningBand4,g.EngineRunningBand5,g.EngineRunningBand6,g.EngineRunningBand7,g.EngineRunningBand8," +
						" x ,g.fuelUsedWorking,g.fuelUsedIdle, b.tenancyId,b.tenancyName, c.group_id as machineGroupId, " +
						" c.group_name as machineGroupName,  v.tenancy_id as primaryOwnerTenancy ," +
						//DefectId:20150220 @ Suprava Delaer As a new parameter Added
						"b.parentTenancyName,b.tenancyTypeId,s.fuelLevel,sum(m.fuelUsedWorking) as totalFuelUsedWorking," +
						"sum(m.fuelUsedIdle) as totalFuelUsedIdle ";
						
						//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
						basicFromQuery = " from AssetCustomGroupMapping w RIGHT OUTER JOIN w.serial_number x  LEFT OUTER JOIN w.group_id c," +
						" TenancyDimensionEntity b ,TenancyBridgeEntity tb, AccountTenancyMapping v,AssetMonitoringSnapshotEntity s," +
						"AssetMonitoringFactDataYearAgg m,";
						//end Defect ID:1406
						//tb.parentId in ("+ tenancyIDList + " ) and c.tenancyId = tb.childId "
						basicWhereQuery = " where g.tenancyId = b.tenacy_Dimension_Id and b.tenancyId = tb.childId and tb.parentId in ("+tenancyIdStringList+" ) and " +
						" x.serial_number = g.serialNumber " +
						" and x.primary_owner_id = v.account_id and s.serialNumber = g.serialNumber" +
						" and m.serialNumber = g.serialNumber and m.tenancyId = b.tenacy_Dimension_Id" ;
			
			//DefectID: DF20131014 - Rajani Nagaraju - Custom Dates Implementation
			/*if(period !=null)
			{
				basicSelectQuery = "select g.engineOffHours,g.machineHours,g.EngineRunningBand1,g.EngineRunningBand2,g.EngineRunningBand3," +
				" g.EngineRunningBand4,g.EngineRunningBand5,g.EngineRunningBand6,g.EngineRunningBand7,g.EngineRunningBand8," +
				" x ,g.fuelUsedWorking,g.fuelUsedIdle, b.tenancyId,b.tenancyName, c.group_id as machineGroupId, " +
				" c.group_name as machineGroupName,  v.tenancy_id as primaryOwnerTenancy ," +
				//DefectId:20150220 @ Suprava Delaer As a new parameter Added
				"b.parentTenancyName,b.tenancyTypeId ";
				
				//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
				basicFromQuery = " from AssetCustomGroupMapping w RIGHT OUTER JOIN w.serial_number x  LEFT OUTER JOIN w.group_id c," +
				" TenancyDimensionEntity b ,TenancyBridgeEntity tb, AccountTenancyMapping v,";
				//end Defect ID:1406
				//tb.parentId in ("+ tenancyIDList + " ) and c.tenancyId = tb.childId "
				basicWhereQuery = " where g.tenancyId = b.tenacy_Dimension_Id and b.tenancyId = tb.childId and tb.parentId in ("+tenancyIdStringList+" ) and " +
				" x.serial_number = g.serialNumber " +
				" and x.primary_owner_id = v.account_id " ;*/
				//DefectId:20150216 @ Suprava Delaer As a new parameter Added
				//" and b.parentTenancyId=ten1.parent_tenancy_id ";


				int year =0;int week = 0; int quarter = 0;int month =0;
				DateUtil thisDate =new DateUtil().getCurrentDateUtility(new Date());
				DateUtil prevDate = new DateUtil().getPreviousDateUtility(new Date());

				if (period.equalsIgnoreCase("Week")) 
				{
					week =   thisDate.getWeek();
					year = thisDate.getYear();
					//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
					basicFromQuery = basicFromQuery + " AssetMonitoringFactDataWeekAgg g ";
					//end Defect ID:1406
					basicWhereQuery = basicWhereQuery+ " and g.timeCount =  "+week +" and g.year=" + year;

					
					//DefectId:20160104 - added by Suresh 
					basicWhereQuery = basicWhereQuery+ " and m.year=" + year;
					
					//get the Last Day 
					Calendar c = Calendar.getInstance();
					lastDateInPeriod = dateFrmt.format(c.getTime());

					//DefectId: DF20131023 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period 
					//get the first day of the week
					c.set(Calendar.DAY_OF_WEEK, c.getFirstDayOfWeek());
					startDateInPeriod=  dateFrmt.format(c.getTime());
				}

				else if (period.equalsIgnoreCase("Last Week")) 
				{
					week =   prevDate.getWeek();
					if(thisDate.getWeek()==1 || (prevDate.getMonth()==12 && prevDate.getWeek()==53))
					{
						year = prevDate.getYear();
					}

					else
					{
						year = prevDate.getCurrentYear();
					}

					//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
					basicFromQuery = basicFromQuery + " AssetMonitoringFactDataWeekAgg g ";
					//end Defect ID:1406
					basicWhereQuery = basicWhereQuery+ " and g.timeCount =  "+week +" and g.year=" + year;

					//DefectId:20160104 - added by Suresh 
					basicWhereQuery = basicWhereQuery+ " and m.year=" + year;
					
					//get the Last Day of Previous Week
					Calendar c = Calendar.getInstance();
					int i = c.get(Calendar.DAY_OF_WEEK) - c.getFirstDayOfWeek();
					c.add(Calendar.DATE, -i - 7);
					c.add(Calendar.DATE, 6);
					lastDateInPeriod = dateFrmt.format(c.getTime());

					//DefectId: DF20131023 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period 
					//get the First Day of Previous Week
					c = Calendar.getInstance();
					int j = c.get(Calendar.DAY_OF_WEEK) - c.getFirstDayOfWeek();
					c.add(Calendar.DATE, -j - 7);
					c.set(Calendar.DAY_OF_WEEK, c.getFirstDayOfWeek());
					startDateInPeriod=  dateFrmt.format(c.getTime());

				}	

				else if (period.equalsIgnoreCase("Month")) 
				{
					month =   thisDate.getMonth();
					year = thisDate.getYear();

					//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
					basicFromQuery = basicFromQuery + " AssetMonitoringFactDataMonthAgg g ";
					//end Defect ID:1406
					basicWhereQuery = basicWhereQuery+ " and g.timeCount= "+ month + " and g.year=" + year;

					//DefectId:20160104 - added by Suresh 
					basicWhereQuery = basicWhereQuery+ " and m.year=" + year;
					
					//get the Last Day 
					Calendar c = Calendar.getInstance();
					lastDateInPeriod = dateFrmt.format(c.getTime());

					//DefectId: DF20131023 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period 
					//get the First Day of current Month
					String mon = month+"";
					if(mon.length()<2)
						mon="0"+mon;
					startDateInPeriod=year+"-"+mon+"-"+"01";
				} 

				else if (period.equalsIgnoreCase("Last Month")) 
				{
					month =  prevDate.getMonth();
					if(thisDate.getMonth()==1)
					{
						year = prevDate.getYear();
					}
					else
					{
						year = prevDate.getCurrentYear();
					}

					//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
					basicFromQuery = basicFromQuery + " AssetMonitoringFactDataMonthAgg g ";
					//end Defect ID:1406
					basicWhereQuery = basicWhereQuery+ " and g.timeCount= "+ month + " and g.year=" + year;

					//DefectId:20160104 - added by Suresh 
					basicWhereQuery = basicWhereQuery+ " and m.year=" + year;
					
					//Get the Last Day of previous Month
					Calendar c = Calendar.getInstance();
					c.set(Calendar.DATE, 1);
					c.add(Calendar.DAY_OF_MONTH, -1);
					lastDateInPeriod = dateFrmt.format(c.getTime());

					//DefectId: DF20131023 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period 
					//get the First Day of Previous Month
					String mon = month+"";
					if(mon.length()<2)
						mon="0"+mon;
					startDateInPeriod=year+"-"+mon+"-"+"01";
				}

				else if (period.equalsIgnoreCase("Quarter")) 
				{
					quarter =   thisDate.getQuarter();
					year = thisDate.getYear();

					//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
					basicFromQuery = basicFromQuery + " AssetMonitoringFactDataQuarterAgg g ";
					//end Defect ID:1406
					basicWhereQuery = basicWhereQuery+ " and g.timeCount = "+ quarter + " and g.year=" + year;

					
					//DefectId:20160104 - added by Suresh 
					basicWhereQuery = basicWhereQuery+ " and m.year=" + year;
					
					//get the Last Day 
					Calendar c = Calendar.getInstance();
					lastDateInPeriod = dateFrmt.format(c.getTime());

					//DefectId: DF20131023 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period 
					//get the first Date of current quarter
					switch(quarter) 
					{
					case 3 : 
						startDateInPeriod = year+"-07-01";
						break;
						// return July 01
					case 2 :
						startDateInPeriod = year+"-04-01";
						break;
						// return April 01
					case 1 :
						startDateInPeriod = year+"-01-01";
						break;
						// return Jan 01
					case 4 : 
						startDateInPeriod = year+"-10-01";
						break;
						// return Oct 01
					}
				} 

				else if (period.equalsIgnoreCase("Last Quarter")) 
				{
					quarter = prevDate.getQuarter();
					if(thisDate.getQuarter()==1)
					{
						year = prevDate.getYear();
					}
					else
					{
						year = prevDate.getCurrentYear();
					}

					//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
					basicFromQuery = basicFromQuery + " AssetMonitoringFactDataQuarterAgg g ";
					//end Defect ID:1406
					basicWhereQuery = basicWhereQuery+ " and g.timeCount = "+ quarter + " and g.year=" + year;

					//DefectId:20160104 - added by Suresh 
					basicWhereQuery = basicWhereQuery+ " and m.year=" + year;
					
					//get the last day of previous quarter
					switch(quarter) 
					{
					case 3 : 
						lastDateInPeriod = year+"-09-30";
						break;
						// return September 30
					case 2 :
						lastDateInPeriod = year+"-06-30";
						break;
						// return June 30
					case 1 :
						lastDateInPeriod = year+"-03-31";
						break;
						// return March 31
					case 4 : 
						lastDateInPeriod = year+"-12-31";
						break;
						// return December 31
					}

					//DefectId: DF20131023 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period 
					//get the first Date of Previous quarter
					switch(quarter) 
					{
					case 3 : 
						startDateInPeriod = year+"-07-01";
						break;
						// return July 01
					case 2 :
						startDateInPeriod = year+"-04-01";
						break;
						// return April 01
					case 1 :
						startDateInPeriod = year+"-01-01";
						break;
						// return Jan 01
					case 4 : 
						startDateInPeriod = year+"-10-01";
						break;
						// return Oct 01
					}
				} 

				else if (period.equalsIgnoreCase("Year")) 
				{
					year = thisDate.getYear();

					//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
					basicFromQuery = basicFromQuery + " AssetMonitoringFactDataYearAgg g ";
					//end Defect ID:1406
					basicWhereQuery = basicWhereQuery+ " and g.year = "+year;

					//DefectId:20160104 - added by Suresh 
					basicWhereQuery = basicWhereQuery+ " and m.year=" + year;
					
					//get the Last Day 
					Calendar c = Calendar.getInstance();
					lastDateInPeriod = dateFrmt.format(c.getTime());

					//DefectId: DF20131023 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period 
					//get the First day of current Year
					startDateInPeriod=year+"-01"+"-01";
				}

				else if (period.equalsIgnoreCase("Last Year")) 
				{
					year = prevDate.getYear();

					//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
					basicFromQuery = basicFromQuery + " AssetMonitoringFactDataYearAgg g ";
					//end Defect ID:1406
					basicWhereQuery = basicWhereQuery+ " and g.year = "+year;

					//DefectId:20160104 - added by Suresh 
					basicWhereQuery = basicWhereQuery+ " and m.year=" + year;
					
					//get the Last day of previous Year
					lastDateInPeriod=year+"-12-31";

					//DefectId: DF20131023 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period 
					//get the First day of Previous Year 
					startDateInPeriod=year+"-01"+"-01";
				}

				if((isGroupingOnAssetGroup) )
					basicGroupByQuery = basicGroupByQuery + ", c.group_id ";

			}

			//Logic for Custom Dates (fromDate,toDate) added by Juhi on 14-August-2013 
			//DefectID: DF20131014 - Rajani Nagaraju - Custom Dates Implementation
			else
			{
				DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");

				try 
				{	
					fromdateFormatted= dateFormat.format(dateFormat.parse(fromDate));	
					todateFormatted = dateFormat.format(dateFormat.parse(toDate));	
				} 

				catch (ParseException e) 
				{
					e.printStackTrace();
				}

				if(fromdateFormatted==null || todateFormatted==null)
				{
					throw new CustomFault("Unparsable Date input for Custom dates");
				}

				//DefectId: DF20131023 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period 
				startDateInPeriod = fromdateFormatted;
				//get the Last date in the selected period
				lastDateInPeriod = todateFormatted;

				basicSelectQuery = "select sum(u.engineOffHours) as engineOffHours, g.machineHours, sum(u.EngineRunningBand1) as EngineRunningBand1," +
				" sum(u.EngineRunningBand2) as EngineRunningBand2, sum(u.EngineRunningBand3) as EngineRunningBand3," +
				" sum(u.EngineRunningBand4) as EngineRunningBand4, sum(u.EngineRunningBand5) as EngineRunningBand5," +
				" sum(u.EngineRunningBand6) as EngineRunningBand6, sum(u.EngineRunningBand7) as EngineRunningBand7," +
				" sum(u.EngineRunningBand8) as EngineRunningBand8," +
				" x, sum(u.fuelUsedWorking) as fuelUsedWorking, sum(u.fuelUsedIdle) as fuelUsedIdle, " +
				" b.tenancyId,b.tenancyName, c.group_id as machineGroupId, " +
				" c.group_name as machineGroupName, v.tenancy_id as primaryOwnerTenancy," +
				//DefectId:20150223 @ Suprava Delaer As a new parameter Added
				"b.parentTenancyName,b.tenancyTypeId,s.fuelLevel,sum(m.fuelUsedWorking) as totalFuelUsedWorking," +
						"sum(m.fuelUsedIdle) as totalFuelUsedIdle ";

				//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
				basicFromQuery = " from AssetCustomGroupMapping w RIGHT OUTER JOIN w.serial_number x  LEFT OUTER JOIN w.group_id c," +
				" TenancyDimensionEntity b, AssetMonitoringFactDataDayAgg g, TenancyBridgeEntity tb,AssetMonitoringFactDataDayAgg u," +
				" AccountTenancyMapping v,AssetMonitoringSnapshotEntity s," +
						"AssetMonitoringFactDataYearAgg m " ;
				//end Defect ID:1406
				//DefectId:20150223 @ Suprava Delaer As a new parameter Added
				//" TenancyEntity ten1 ";

				//Rajani Nagaraju - 20131204 - To fix the issue raised for 4th Dec SIT deployment - to handle machine movement b/w diff ten hierarchies
				basicWhereQuery = " where g.tenancyId = b.tenacy_Dimension_Id and b.tenancyId = tb.childId and tb.parentId in ("+tenancyIdStringList+" ) and " +
				" x.serial_number = g.serialNumber "+
				" and x.primary_owner_id = v.account_id" +
				" and g.serialNumber = u.serialNumber " + 
				" and g.timeKey = (select max(o.timeKey) from AssetMonitoringFactDataDayAgg o" +
				//" where o.serialNumber=g.serialNumber and o.tenancyId = yt.tenacy_Dimension_Id and yt.tenancyId in ("+ tenancyIdStringList + " ) " +
				" where o.serialNumber=g.serialNumber and o.tenancyId = b.tenacy_Dimension_Id" +
				" and o.timeKey >='"+fromdateFormatted+"' and o.timeKey <= '"+todateFormatted+"')" +
				" and u.timeKey between '"+fromdateFormatted+"' and '"+todateFormatted+"' and s.serialNumber = g.serialNumber" +
						" and m.serialNumber = g.serialNumber and m.tenancyId = b.tenacy_Dimension_Id";
				//DefectId:20150216 @ Suprava Delaer As a new parameter Added
				//" and b.parentTenancyId=ten1.parent_tenancy_id ";

				basicGroupByQuery = basicGroupByQuery + ", c.group_id, g.tenancyId ";

			}

			//Custom Asset Group Filter
			//DefectID:DF20131014 - Rajani Nagaraju - DF20131014 - Query modification to return correct resultset
			if (!(machineGroupIdList == null || machineGroupIdList.isEmpty())) 
			{
				String customAssetGroupStringList = conversionObj.getIntegerListString(machineGroupIdList).toString();
				basicWhereQuery = basicWhereQuery+ " and c.group_id in ("+ customAssetGroupStringList + ")";
			}

			//DefectID:DF20131014 - Rajani Nagaraju - DF20131014 - Query modification to return correct resultset
			if ((!(machineProfileIdList == null || machineProfileIdList.isEmpty()))	|| (!(modelIdList == null || modelIdList.isEmpty()))) 
			{
				basicFromQuery = basicFromQuery+ " , AssetClassDimensionEntity y ";
				basicWhereQuery = basicWhereQuery	+ " and g.assetClassDimensionId = y.assetClassDimensionId";
			}


			//DefectID:DF20131014 - Rajani Nagaraju - DF20131014 - Query modification to return correct resultset
			if (!(machineProfileIdList == null || machineProfileIdList.isEmpty())) 
			{
				String machineProfileIdStringList = conversionObj.getIntegerListString(machineProfileIdList).toString();
				basicWhereQuery = basicWhereQuery + " and y.assetGroupId in ( "+ machineProfileIdStringList + ") ";
			}			

			//DefectID:DF20131014 - Rajani Nagaraju - DF20131014 - Query modification to return correct resultset
			if (!((modelIdList == null) || (modelIdList.isEmpty()))) 
			{
				String modelIdListStringList = conversionObj.getIntegerListString(modelIdList).toString();
				basicWhereQuery = basicWhereQuery + " and y.assetTypeId in ( "+ modelIdListStringList + " )";
			}

			finalQuery = basicSelectQuery + basicFromQuery + basicWhereQuery + basicGroupByQuery;

			Query query = session.createQuery(finalQuery);
			Iterator itr = query.list().iterator();

			Object[] result = null;
			MachinePerformanceReportImpl implObj=null;
			double EngineRunningBand1;
			double EngineRunningBand2;
			double EngineRunningBand3;
			double EngineRunningBand4;
			double EngineRunningBand5;
			double EngineRunningBand6;
			double EngineRunningBand7;
			double EngineRunningBand8;
			String serNum = null;
			double fuelUsedWorking =0.0D;
			double fuelUsedIdle=0.0D;
			double fuelUsedLitres=0.0D;
			double fuelUsedIdleLife = 0.0D;
			double fuelUsedWorkingLife = 0.0D;
			double FinishEngineRunHours =0.0D;
			double OverallFuelConsumption=0.0D;
			double startingEngineRunHoursLife=0.0D;

			// DefectId: DF20131014 - Rajani Nagaraju - 20131014 - CustomDate Implementation 
			List<String> serialNumberList = new LinkedList<String>();

			while (itr.hasNext()) 
			{
				result = (Object[]) itr.next();
				implObj = new MachinePerformanceReportImpl();
				Double engineOffInt=0.0D;
				fuelUsedWorking =0.0D;
				fuelUsedIdle=0.0D;
				fuelUsedLitres=0.0D;
				fuelUsedIdleLife = 0.0D;
				fuelUsedWorkingLife = 0.0D;
				FinishEngineRunHours =0.0D;
				OverallFuelConsumption=0.0D;
				startingEngineRunHoursLife=0.0D;

				//------------------1.Set Asset and Asset Properties
				AssetEntity asset =null;
				TenancyEntity tenancyEntity =null;
				if(result[10]!=null)
				{					
					asset = (AssetEntity)result[10];
					serNum = asset.getSerial_number().getSerialNumber();
					implObj.setSerialNumber(serNum);
				}

				// DefectId:DF20131014 - Rajani Nagaraju - 20131014 - CustomDate Implementation 
				if( (!isGroupingOnAssetGroup) && (serialNumberList.contains(serNum))) 
				{
					continue;
				}
				else
				{
					serialNumberList.add(serNum);
				}

				//1.1 Tenancy Details
				if(result[13] !=null)
					implObj.setTenancyId((Integer)result[13]);
				if(result[14]!=null)
					implObj.setTenancyName(result[14].toString());

				//1.2 Machine Group Details
				if(result[15]!=null)
					implObj.setCustomMachineGroupId((Integer) result[15]);
				if (result[16] != null)
					implObj.setCustomMachineGroupName((String) result[16]);

				//1.3 Machine Profile and Model Details
				//DefectID:DF20131014 - Rajani Nagaraju - Query modification to return correct resultset
				if(asset!=null)
				{
					if(asset.getProductId()!=null && asset.getProductId().getAssetGroupId()!=null)
					{
						implObj.setAssetGroupId(asset.getProductId().getAssetGroupId().getAsset_group_id());
						implObj.setAsset_group_name(asset.getProductId().getAssetGroupId().getAsset_group_name());
					}

					if(asset.getProductId()!=null && asset.getProductId().getAssetTypeId()!=null)
					{
						implObj.setModelId(asset.getProductId().getAssetTypeId().getAsset_type_id());
						implObj.setModelName(asset.getProductId().getAssetTypeId().getAsset_type_name());
					}


				}
				//DefectId:20150223 @ Suprava Delaer As a new parameter Added
				if(result[19]!=null)
						{
							int tenancyTypeId =(Integer) result[19];
							//If the Machine is with customer Get the parentTeancyId
							if(tenancyTypeId==4)
							{
							//	tenancyEntity =(TenancyEntity)result[18];
								implObj.setDealerName(result[18].toString());
							}
							//If the Machine is with Dealer
							else if(tenancyTypeId==3) 
							{
								if(result[14]!=null)
								{
								//String Dealername =(String)result[14];
								implObj.setDealerName(result[14].toString());
							}
							}
							else
							{
								implObj.setDealerName("No Dealer Tagging");
							}
						
						}
				//------------------END of 1.Set Asset and Asset Properties

				//-------------------------- 2. Set Machine Utilization Details
				//2.1 Engine Off Period In hours - For the given Period
				if(period!=null)
				{
					if(result[0] != null)
					{
						try
						{
							double engineOff = (Double)result[0];
							engineOffInt = (Double)engineOff;
						}

						catch(ClassCastException e)
						{
							engineOffInt = (Double)result[0];
						}
						//implObj.setEngineOff(engineOffInt);
						implObj.setEngineOff(Double.valueOf(df2.format((Double)engineOffInt)));
					}
				}

				//2.2 Engine On Period In hours - For the given Time Period
				EngineRunningBand1 = (Double) result[2];
				EngineRunningBand2 = (Double) result[3];
				EngineRunningBand3 = (Double) result[4];
				EngineRunningBand4 = (Double) result[5];
				EngineRunningBand5 = (Double) result[6];
				EngineRunningBand6 = (Double) result[7];
				EngineRunningBand7 = (Double) result[8];
				EngineRunningBand8 = (Double) result[9];
				double workingTime1 = (EngineRunningBand3 + EngineRunningBand4+ EngineRunningBand5 + 
						EngineRunningBand6 + EngineRunningBand7 + EngineRunningBand8);
				double idleTime1 = (EngineRunningBand1 + EngineRunningBand2);

				double engineOn = (double) (workingTime1 + idleTime1);
				//implObj.setEngineOn(engineOn);
				implObj.setEngineOn(Double.valueOf(df2.format((Double)engineOn)));
				//2.1 Engine Off Period In hours - For Custom Dates
				if(period==null)
				{
					Date newerDate = dateFrmt.parse(todateFormatted);
					Date olderDate = dateFrmt.parse(fromdateFormatted);
					double diffInDays = (double)( (newerDate.getTime() - olderDate.getTime()) 
							/ (1000 * 60 * 60 * 24) );
					diffInDays= diffInDays+1;
					double engineOffLong = (24*diffInDays)-engineOn;
					engineOffInt = (double)engineOffLong;
					//	implObj.setEngineOff(engineOffInt);
					implObj.setEngineOff(Double.valueOf(df2.format((Double)engineOffInt)));
				}

				//2.3 Working Time Period in Hours - For the given Time Period
				//Decimal format change @suprava
				implObj.setWorkingTime(Double.valueOf(df2.format((Double)workingTime1)));

				//2.4 Idle Time Period in Hours - For the given Time Period
				implObj.setIdleTime(Double.valueOf(df2.format((Double)idleTime1)));

				//-------------------------- END of  2. Set Machine Utilization Details


				//-------------------------- 3. Set Machine Productivity Details
				double lowValue = bandCalculation(bandIdLowList,
						EngineRunningBand1, EngineRunningBand2,
						EngineRunningBand3, EngineRunningBand4,
						EngineRunningBand5, EngineRunningBand6,
						EngineRunningBand7, EngineRunningBand8);
				double midValue = bandCalculation(bandIdMediumList,
						EngineRunningBand1, EngineRunningBand2,
						EngineRunningBand3, EngineRunningBand4,
						EngineRunningBand5, EngineRunningBand6,
						EngineRunningBand7, EngineRunningBand8);
				double highValue = bandCalculation(bandIdHighList,
						EngineRunningBand1, EngineRunningBand2,
						EngineRunningBand3, EngineRunningBand4,
						EngineRunningBand5, EngineRunningBand6,
						EngineRunningBand7, EngineRunningBand8);

				//3.1 Poweer band Low (Period In Hrs) - For the given time Period
				implObj.setPowerBandLow(Double.valueOf(df2.format((Double)lowValue)));

				//3.2 Poweer band Medium (Period In Hrs) - For the given time Period
				implObj.setPowerBandMedium(Double.valueOf(df2.format((Double)midValue)));

				//3.1 Poweer band High (Period In Hrs) - For the given time Period
				implObj.setPowerBandHigh(Double.valueOf(df2.format((Double)highValue)));

				//-------------------------- 3. END of Set Machine Productivity Details


				//--------------------------- 4. Set Consumption Details
				//4.1 Starting Engine Run Hours - CMHR of the machine at the start of the Period
				if(result[1] != null)
				{
					FinishEngineRunHours = (Double) result[1]; // - This is the finish Engine Hours at the end of the given period
				}
				double startingEngineRunHours = (FinishEngineRunHours - engineOn);
				//implObj.setStartingEngineRunHours(startingEngineRunHours);
				implObj.setStartingEngineRunHours(Double.valueOf(df2.format((Double)startingEngineRunHours)));
				//4.2 Finish Engine Run Hours - CMHR of the machine at the End of the Period
				//implObj.setFinishEngineRunHours(FinishEngineRunHours);
				implObj.setFinishEngineRunHours(Double.valueOf(df2.format((Double)FinishEngineRunHours)));
				//4.3 Fuel Used(In Litres) In the given Period
				if(result[11]!=null)
					fuelUsedWorking = (Double) result[11];
				if(result[12] !=null)
					fuelUsedIdle = (Double) result[12];
				fuelUsedLitres = (fuelUsedWorking + fuelUsedIdle);
				//implObj.setFuelUsedLitres(fuelUsedLitres);
				implObj.setFuelUsedLitres(Double.valueOf(df2.format((Double)fuelUsedLitres)));


				//4.4 Fuel Used Idle(In Litres) In the given Period
				implObj.setFuelUsedIdleLitres(fuelUsedIdle);

				//4.6 Overall Fuel Consumption (in Litres/hr) in the given Period
				double engineOff=engineOffInt;
				if(fuelUsedLitres != 0.0)
				{
					OverallFuelConsumption = (fuelUsedLitres / (engineOn+engineOff));
					//implObj.setOverallFuelConsumptionLitres(OverallFuelConsumption);
					implObj.setOverallFuelConsumptionLitres(Double.valueOf(df2.format((Double)OverallFuelConsumption)));
				}

				//4.5 Finish Fuel Level % - Finish Fuel Level at the End of the Period
				//Find Last Date in the given Period
				/*String getMaxTxn = " select max(h.transactionNumber) from AssetMonitoringHeaderEntity h where h.serialNumber='"+ serNum +"' ";
				if(lastDateInPeriod != null)
				{
					getMaxTxn = getMaxTxn + " and h.transactionTime <= '"+lastDateInPeriod+" 23:59:59' ";
				}*/

				// 2014-06-23: Fuel Level change : To take the fuel level from the Snapshot table - Deepthi
				/*String hql = "select s.parameterValue from AssetMonitoringDetailEntity s where " +
							" s.transactionNumber=("+getMaxTxn+")and s.parameterId=(select max(m.parameterId) from " +
									" MonitoringParameters m where m.parameterName like 'FuelLevel')";*/

				/*String hql = "Select s.fuelLevel from AssetMonitoringSnapshotEntity s where s.serialNumber = '"+serNum + "' ";
				String parameterValue = null;
				Query query1 = session.createQuery(hql);
				List queryList =  query1.list();
				Iterator itr2 =queryList.iterator();
				if( (itr2.hasNext()) && (queryList.size() > 0) && (queryList.get(0) != null))
				{
					while (itr2.hasNext()) 
					{
						parameterValue = itr2.next().toString();
						if(!parameterValue.equalsIgnoreCase(null)){
							implObj.setFinishFuelLevel(parameterValue);
						}
					}
				}*/
				//DefectId:20160104 - added by S Suresh 
				String parameterValue = null;
				if(result[20]!=null)
				{
					parameterValue = (String)result[20];
					if(!parameterValue.equalsIgnoreCase(null)){
						implObj.setFinishFuelLevel(parameterValue);
					}
				}
				else
				{
					implObj.setFinishFuelLevel("0.0");
				}

				//--------------------------- 4. END of Set Consumption Details


				//--------------------------- 5. Set Consumption Details for the Complete Machine Life
				//5.1 Start Engine Hours Life - This will always be Zero
				startingEngineRunHoursLife = 0.0D;
				//implObj.setStartingEngineRunHoursLife(startingEngineRunHoursLife);
				implObj.setStartingEngineRunHoursLife(Double.valueOf(df2.format((Double)startingEngineRunHoursLife)));
				TenancyEntity primaryOwnerTenancy = (TenancyEntity)result[17];
				//If the Machine is under the user hierarchy currently, then display current status of Machine
				/*if( tenancyIdList.contains(primaryOwnerTenancy.getTenancy_id()) )
				{
					//5.2 Finish Engine Hours Life - CMHR of the last received packet from the Machine
					//5.3 Finish Fuel Level% Life - Fuel Level% of the last received packet from the Machine
					Query q = session.createQuery(" select s.parameterId, s.parameterValue from AssetMonitoringDetailEntity s,AssetMonitoringHeaderEntity b" +
							" where s.transactionNumber= b.transactionNumber and " +
							" b.transactionTime= (select max(h.transactionTime) from AssetMonitoringHeaderEntity h " +
							"where h.serialNumber='"+ serNum +"') and s.parameterId in ('4','5')");
					Iterator itrq = q.list().iterator();
					Object[] itrRes=null;
					while(itrq.hasNext())
					{
						itrRes = (Object[]) itrq.next();
						MonitoringParameters paramObj = (MonitoringParameters)itrRes[0];
						String value = null;
						if(itrRes[1]!=null)
							value=itrRes[1].toString();

						//ParameterId 4 corresponds to EngineHours
						if(paramObj.getParameterId()==4 && value!=null)
						{
							double d = Double.parseDouble(value);
							//long l = (long)d;
							//	implObj.set(d);
							implObj.setFinishEngineRunHoursLife(Double.valueOf(df2.format((Double)d)));
						}
						//ParameterId 5 corresponds to FuelLevelPercentage
						else if(paramObj.getParameterId()==5 && value!=null)
						{
							//DefectId:20140702 Fuel Level change : To take the fuel level from the Snapshot table - Suprava
							implObj.setFinishFuelLevelLife(parameterValue);
						}
					}

				
				
					//5.4 FuelUsedLitresLife
					if(result[17]!=null)
						fuelUsedWorkingLife = (Double) result[17];
					if(result[18] !=null)
						fuelUsedIdleLife = (Double) result[18];
					double fuelUsedLitresLife = (fuelUsedWorkingLife + fuelUsedIdleLife);
					implObj.setFuelUsedLitresLife(fuelUsedLitresLife);
					Query qw = session.createQuery(" select m.serialNumber, sum(m.fuelUsedWorking) as totalFuelUsedWorking, sum(m.fuelUsedIdle) as totalFuelUsedIdle " +
							" from AssetMonitoringFactDataYearAgg m where m.serialNumber='"+serNum+"'");
					Iterator itrQw = qw.list().iterator();
					Object[] fuelResult =null;
					while(itrQw.hasNext())
					{
						fuelResult = (Object[])itrQw.next();
						if(fuelResult[1]!=null)
							fuelUsedWorkingLife = (Double) fuelResult[1];
						if(fuelResult[2]!=null)
							fuelUsedIdleLife = (Double) fuelResult[2];
						//double fuelUsedLitresLife = (fuelUsedWorkingLife + fuelUsedIdleLife);
						double fuelUsedLitresLife = ((Double.valueOf(df2.format((Double)fuelUsedWorkingLife))) + (Double.valueOf(df2.format((Double)fuelUsedIdleLife))));
						implObj.setFuelUsedLitresLife(fuelUsedLitresLife);
					}
					//DefectId:20160104 - added by S Suresh
					if(result[21]!=null)
						fuelUsedWorkingLife = (Double) result[21];
					if(result[22]!=null)
						fuelUsedIdleLife = (Double) result[22];
					//double fuelUsedLitresLife = (fuelUsedWorkingLife + fuelUsedIdleLife);
					double fuelUsedLitresLife = ((Double.valueOf(df2.format((Double)fuelUsedWorkingLife))) + (Double.valueOf(df2.format((Double)fuelUsedIdleLife))));
					implObj.setFuelUsedLitresLife(fuelUsedLitresLife);
					//System.out.println("fuelUsedLitresLife"+fuelUsedLitresLife);
					//5.5 Fuel Used in Idle Life
					implObj.setFuelUsedIdleLitresLife(fuelUsedIdleLife);

					//--------------------------- END of 5. Set Consumption Details for the Complete Machine Life
				}
*/
				
				
				//DefectId:20160105 - added by S Suresh
				if( tenancyIdList.contains(primaryOwnerTenancy.getTenancy_id()) )
				{
					//5.2 Finish Engine Hours Life - CMHR of the last received packet from the Machine
					//5.3 Finish Fuel Level% Life - Fuel Level% of the last received packet from the Machine
					/*Query q = session.createQuery(" select s.parameterId, s.parameterValue from AssetMonitoringDetailEntity s,AssetMonitoringHeaderEntity b" +
							" where s.transactionNumber= b.transactionNumber and " +
							" b.transactionTime= (select max(h.transactionTime) from AssetMonitoringHeaderEntity h " +
							"where h.serialNumber='"+ serNum +"') and s.parameterId in ('4','5')");
					Iterator itrq = q.list().iterator();
					Object[] itrRes=null;
					while(itrq.hasNext())
					{
						itrRes = (Object[]) itrq.next();
						MonitoringParameters paramObj = (MonitoringParameters)itrRes[0];
						String value = null;
						if(itrRes[1]!=null)
							value=itrRes[1].toString();

						//ParameterId 4 corresponds to EngineHours
						if(paramObj.getParameterId()==4 && value!=null)
						{
							double d = Double.parseDouble(value);
							//long l = (long)d;
							//	implObj.set(d);
							implObj.setFinishEngineRunHoursLife(Double.valueOf(df2.format((Double)d)));
						}
						//ParameterId 5 corresponds to FuelLevelPercentage
						else if(paramObj.getParameterId()==5 && value!=null)
						{
							//DefectId:20140702 Fuel Level change : To take the fuel level from the Snapshot table - Suprava
							implObj.setFinishFuelLevelLife(parameterValue);
						}
					}*/
					
					if(result[1]!=null){
						implObj.setFinishEngineRunHoursLife(Double.valueOf(result[1].toString()));
					}
					if(parameterValue!=null)
						implObj.setFinishFuelLevelLife(parameterValue);
				
				
					//5.4 FuelUsedLitresLife
					/*if(result[17]!=null)
						fuelUsedWorkingLife = (Double) result[17];
					if(result[18] !=null)
						fuelUsedIdleLife = (Double) result[18];
					double fuelUsedLitresLife = (fuelUsedWorkingLife + fuelUsedIdleLife);
					implObj.setFuelUsedLitresLife(fuelUsedLitresLife);
					Query qw = session.createQuery(" select m.serialNumber, sum(m.fuelUsedWorking) as totalFuelUsedWorking, sum(m.fuelUsedIdle) as totalFuelUsedIdle " +
							" from AssetMonitoringFactDataYearAgg m where m.serialNumber='"+serNum+"'");
					Iterator itrQw = qw.list().iterator();
					Object[] fuelResult =null;
					while(itrQw.hasNext())
					{
						fuelResult = (Object[])itrQw.next();
						if(fuelResult[1]!=null)
							fuelUsedWorkingLife = (Double) fuelResult[1];
						if(fuelResult[2]!=null)
							fuelUsedIdleLife = (Double) fuelResult[2];
						//double fuelUsedLitresLife = (fuelUsedWorkingLife + fuelUsedIdleLife);
						double fuelUsedLitresLife = ((Double.valueOf(df2.format((Double)fuelUsedWorkingLife))) + (Double.valueOf(df2.format((Double)fuelUsedIdleLife))));
						implObj.setFuelUsedLitresLife(fuelUsedLitresLife);
					}*/
					//DefectId:20160104 - added by S Suresh
					if(result[21]!=null)
						fuelUsedWorkingLife = (Double) result[21];
					if(result[22]!=null)
						fuelUsedIdleLife = (Double) result[22];
					//double fuelUsedLitresLife = (fuelUsedWorkingLife + fuelUsedIdleLife);
					double fuelUsedLitresLife = ((Double.valueOf(df2.format((Double)fuelUsedWorkingLife))) + (Double.valueOf(df2.format((Double)fuelUsedIdleLife))));
					implObj.setFuelUsedLitresLife(fuelUsedLitresLife);
					//System.out.println("fuelUsedLitresLife"+fuelUsedLitresLife);
					//5.5 Fuel Used in Idle Life
					implObj.setFuelUsedIdleLitresLife(fuelUsedIdleLife);

					//--------------------------- END of 5. Set Consumption Details for the Complete Machine Life
				}

				listImplObj.add(implObj);

			}


			//-------------------------------------------------------------------------------------------------------------------
			//DefectId: DF20131023 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period 
			Query ownerListQuery = session.createQuery(" select distinct c.serialNumber " +
					" from TenancyBridgeEntity a, AccountTenancyMapping b, AssetAccountMapping c " +
					" where a.childId= b.tenancy_id " +
					" and b.account_id= c.accountId " +
					" and a.parentId in ("+tenancyIdStringList+") and" +
					" ( (c.ownershipStartDate between '"+startDateInPeriod+"' and '"+lastDateInPeriod+"') OR " +
					"   (c.ownershipStartDate = ( select max(y.ownershipStartDate) from AssetAccountMapping y " +
					" where y.serialNumber= c.serialNumber" +
					" and y.ownershipStartDate <='"+startDateInPeriod+"')" +
					"    )" +
			" )");
			Iterator ownerListItr = ownerListQuery.list().iterator();
			List<String> actualOwnerVINList = new LinkedList<String>();
			while(ownerListItr.hasNext())
			{
				AssetEntity assetList = (AssetEntity)ownerListItr.next();
				actualOwnerVINList.add(assetList.getSerial_number().getSerialNumber());
			}

			//Get only the List of VINs which has not communicated for the Given period
			actualOwnerVINList.removeAll(serialNumberList);
			String actualOwnerVinListString = conversionObj.getStringList(actualOwnerVINList).toString();
			//DefectId:20150316 @Suprava Null check handle 
			if(actualOwnerVinListString!=null){
				
			basicGroupByQuery =" group by g.serialNumber ";


			basicSelectQuery = "select x ,g.machineHours, b.tenancyId,b.tenancyName, c.group_id as machineGroupId, " +
			" c.group_name as machineGroupName, v.tenancy_id as primaryOwnerTenancy," +
			//DefectId:20150220 @ Suprava DelaerName As a new parameter Added
			" b.parentTenancyName,b.tenancyTypeId,s.fuelLevel,sum(m.fuelUsedWorking) as totalFuelUsedWorking," +
						"sum(m.fuelUsedIdle) as totalFuelUsedIdle "; 

			//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
			basicFromQuery = " from AssetCustomGroupMapping w RIGHT OUTER JOIN w.serial_number x  LEFT OUTER JOIN w.group_id c," +
			" TenancyDimensionEntity b ,  AssetMonitoringFactDataDayAgg g , AccountTenancyMapping v,AssetMonitoringSnapshotEntity s," +
						"AssetMonitoringFactDataYearAgg m "; 
			//end Defect ID:1406
			//DefectId:20150220 @ Suprava DelaerName As a new parameter Added
			//" TenancyEntity ten1";

			basicWhereQuery = " where g.tenancyId = b.tenacy_Dimension_Id " +
			" and x.serial_number = g.serialNumber " +
			" and x.primary_owner_id = v.account_id" +
			" and g.serialNumber in ("+actualOwnerVinListString+") " +
			" and g.timeKey = ( select max(p.timeKey) from AssetMonitoringFactDataDayAgg p where p.serialNumber = g.serialNumber " +
			"					 and p.timeKey <= '"+startDateInPeriod+"' ) and s.serialNumber = g.serialNumber" +
						" and m.serialNumber = g.serialNumber and m.tenancyId = b.tenacy_Dimension_Id " ;
			//DefectId:20150216 @ Suprava Delaer As a new parameter Added
			//" and b.parentTenancyId=ten1.parent_tenancy_id ";

			//Custom Asset Group Filter
			//DefectID:DF20131014 - Rajani Nagaraju - DF20131014 - Query modification to return correct resultset
			if (!(machineGroupIdList == null || machineGroupIdList.isEmpty())) 
			{
				String customAssetGroupStringList = conversionObj.getIntegerListString(machineGroupIdList).toString();
				basicWhereQuery = basicWhereQuery+ " and c.group_id in ("+ customAssetGroupStringList + ")";
			}

			//DefectID:DF20131014 - Rajani Nagaraju - DF20131014 - Query modification to return correct resultset
			if ((!(machineProfileIdList == null || machineProfileIdList.isEmpty()))	|| (!(modelIdList == null || modelIdList.isEmpty()))) 
			{
				basicFromQuery = basicFromQuery+ " , AssetClassDimensionEntity y ";
				basicWhereQuery = basicWhereQuery	+ " and g.assetClassDimensionId = y.assetClassDimensionId";
			}


			//DefectID:DF20131014 - Rajani Nagaraju - DF20131014 - Query modification to return correct resultset
			if (!(machineProfileIdList == null || machineProfileIdList.isEmpty())) 
			{
				String machineProfileIdStringList = conversionObj.getIntegerListString(machineProfileIdList).toString();
				basicWhereQuery = basicWhereQuery + " and y.assetGroupId in ( "+ machineProfileIdStringList + ") ";
			}			

			//DefectID:DF20131014 - Rajani Nagaraju - DF20131014 - Query modification to return correct resultset
			if (!((modelIdList == null) || (modelIdList.isEmpty()))) 
			{
				String modelIdListStringList = conversionObj.getIntegerListString(modelIdList).toString();
				basicWhereQuery = basicWhereQuery + " and y.assetTypeId in ( "+ modelIdListStringList + " )";
			}

			finalQuery = basicSelectQuery + basicFromQuery + basicWhereQuery + basicGroupByQuery;

			Iterator vinListItr = session.createQuery(finalQuery).list().iterator();
			result = null;

			// DefectId: DF20131014 - Rajani Nagaraju - 20131014 - CustomDate Implementation 
			serialNumberList = new LinkedList<String>();
			while (vinListItr.hasNext()) 
			{
				serNum =null;

				result = (Object[]) vinListItr.next();
				implObj = new MachinePerformanceReportImpl();
				double engineOffInt=0.0D;

				fuelUsedIdleLife = 0.0D;
				fuelUsedWorkingLife = 0.0D;
				FinishEngineRunHours =0.0D;
				startingEngineRunHoursLife=0.0D;

				//------------------1.Set Asset and Asset Properties
				AssetEntity asset =null;
				TenancyEntity tenancyEntity= null;
				if(result[0]!=null)
				{					
					asset = (AssetEntity)result[0];
					serNum = asset.getSerial_number().getSerialNumber();
					implObj.setSerialNumber(serNum);
				}

				// DefectId:DF20131014 - Rajani Nagaraju - 20131014 - CustomDate Implementation 
				if( (!isGroupingOnAssetGroup) && (serialNumberList.contains(serNum))) 
				{
					continue;
				}
				else
				{
					serialNumberList.add(serNum);
				}

				//1.1 Tenancy Details
				if(result[2] !=null)
					implObj.setTenancyId((Integer)result[2]);
				if(result[3]!=null)
					implObj.setTenancyName(result[3].toString());

				//1.2 Machine Group Details
				if(result[4]!=null)
					implObj.setCustomMachineGroupId((Integer) result[4]);
				if (result[5] != null)
					implObj.setCustomMachineGroupName((String) result[5]);

				//1.3 Machine Profile and Model Details
				//DefectID:DF20131014 - Rajani Nagaraju - Query modification to return correct resultset
				if(asset!=null)
				{
					if(asset.getProductId()!=null && asset.getProductId().getAssetGroupId()!=null)
					{
						implObj.setAssetGroupId(asset.getProductId().getAssetGroupId().getAsset_group_id());
						implObj.setAsset_group_name(asset.getProductId().getAssetGroupId().getAsset_group_name());
					}

					if(asset.getProductId()!=null && asset.getProductId().getAssetTypeId()!=null)
					{
						implObj.setModelId(asset.getProductId().getAssetTypeId().getAsset_type_id());
						implObj.setModelName(asset.getProductId().getAssetTypeId().getAsset_type_name());
					}


				}
				//DefectId:20150223 @ Suprava Delaer As a new parameter Added
				if(result[8]!=null)
						{
							int tenancyTypeId =(Integer) result[8];
							//If the Machine is with customer Get the parentTeancyId
							if(tenancyTypeId==4)
							{
							//	tenancyEntity =(TenancyEntity)result[7];
								implObj.setDealerName(result[7].toString());
							}
							//If the Machine is with Dealer
							else if(tenancyTypeId==3) 
							{
								if(result[3]!=null)
								{
							//	String Dealername =(String)result[3];
								implObj.setDealerName(result[3].toString());
							}
							}
							else
							{
								implObj.setDealerName("No Dealer Tagging");
							}
						
						}
				//------------------END of 1.Set Asset and Asset Properties

				//-------------------------- 2. Set Machine Utilization Details
				//2.1 Engine Off Period In hours - For the given Period
				//-----get Total Time duration in hours between the given period
				SimpleDateFormat dtFmt = new SimpleDateFormat("yyyy-MM-dd");
				Date startDate = dtFmt.parse(startDateInPeriod);
				Date lastDate = dtFmt.parse(lastDateInPeriod);
				long engineOffLong = (startDate.getTime()-lastDate.getTime())/(60*60 * 1000);
				engineOffInt = (double)engineOffLong;
				//implObj.setEngineOff(engineOffInt);
				implObj.setEngineOff(Double.valueOf(df2.format((Double)engineOffInt)));


				//2.2 Engine On Period In hours - For the given Time Period 
				//------ This will be 0 hours

				//2.3 Working Time Period in Hours - For the given Time Period
				//------ This will be 0 hours

				//2.4 Idle Time Period in Hours - For the given Time Period
				//------ This will be 0 hours

				//-------------------------- END of  2. Set Machine Utilization Details


				//-------------------------- 3. Set Machine Productivity Details

				//3.1 Poweer band Low (Period In Hrs) - For the given time Period
				//------ This will be 0 hours

				//3.2 Poweer band Medium (Period In Hrs) - For the given time Period
				//------ This will be 0 hours

				//3.1 Poweer band High (Period In Hrs) - For the given time Period
				//------ This will be 0 hours

				//-------------------------- 3. END of Set Machine Productivity Details


				//--------------------------- 4. Set Consumption Details
				//4.1 Starting Engine Run Hours - CMHR of the machine at the start of the Period
				if(result[1] != null)
				{
					FinishEngineRunHours = (Double) result[1]; // - This is the finish Engine Hours at the end of the given period
				}
				//Since the Machine has not communicated for the given period, StartEngineRunHours and FinishEngineRunHours are the same
				//implObj.setStartingEngineRunHours(FinishEngineRunHours);
				//need to be check @suprava 
				implObj.setStartingEngineRunHours(Double.valueOf(df2.format((Double)FinishEngineRunHours)));

				//4.2 Finish Engine Run Hours - CMHR of the machine at the End of the Period
				//implObj.setFinishEngineRunHours(FinishEngineRunHours);
				implObj.setFinishEngineRunHours(Double.valueOf(df2.format((Double)FinishEngineRunHours)));	

				//4.3 Fuel Used(In Litres) In the given Period
				//------ This will be 0 Litres

				//4.4 Fuel Used Idle(In Litres) In the given Period
				//------ This will be 0 Litres

				//--------------------------- 5. Set Consumption Details for the Complete Machine Life
				//5.1 Start Engine Hours Life - This will always be Zero
				startingEngineRunHoursLife = 0.0;
				//implObj.setStartingEngineRunHoursLife(startingEngineRunHoursLife);
				implObj.setStartingEngineRunHoursLife(Double.valueOf(df2.format((Double)startingEngineRunHoursLife)));

				//4.5 Finish Fuel Level % - Finish Fuel Level at the End of the Period
				//Find Last Date in the given Period
				/*String getMaxTxn = " select max(h.transactionNumber) from AssetMonitoringHeaderEntity h where h.serialNumber='"+ serNum +"' ";
				if(lastDateInPeriod != null)
				{
					getMaxTxn = getMaxTxn + " and h.transactionTime <= '"+lastDateInPeriod+" 23:59:59' ";
				}*/

				/*String hql = "select s.parameterValue from AssetMonitoringDetailEntity s where " +
							" s.transactionNumber=("+getMaxTxn+")and s.parameterId=(select max(m.parameterId) from " +
									" MonitoringParameters m where m.parameterName like 'FuelLevel')";*/

				// 2014-07-02: Fuel Level change : To take the fuel level from the Snapshot table - Suprava 
				/*String hql = "Select s.fuelLevel from AssetMonitoringSnapshotEntity s where s.serialNumber = '"+serNum + "' ";
				String parameterValue = null;
				Query query1 = session.createQuery(hql);
				List queryList =  query1.list();
				Iterator itr2 = query1.list().iterator();
				if( (itr2.hasNext()) && (queryList.size() > 0) && (queryList.get(0) != null))
				{
					while (itr2.hasNext()) 
					{
						parameterValue = itr2.next().toString();
						if(!parameterValue.equalsIgnoreCase(null)){
							implObj.setFinishFuelLevel(parameterValue);
						}
					}
				}
				else
				{
					implObj.setFinishFuelLevel("0.0");
				}*/
				
				//DefectId:20160104 - added by S Suresh 
				String parameterValue = null;
				if(result[9]!=null)
				{
					parameterValue = (String)result[9];
					if(!parameterValue.equalsIgnoreCase(null)){
						implObj.setFinishFuelLevel(parameterValue);
					}
				}
				else
				{
					implObj.setFinishFuelLevel("0.0");
				}
				/*while (itr2.hasNext()) 
				{
					parameterValue = itr2.next().toString();
					implObj.setFinishFuelLevel(parameterValue);
				}*/

				/*if(result[6]!=null)
				{
					TenancyEntity primaryOwnerTenancy = (TenancyEntity)result[6];
					//If the Machine is under the user hierarchy currently, then display current status of Machine
					if( tenancyIdList.contains(primaryOwnerTenancy.getTenancy_id()) )
					{
						//4.6 Overall Fuel Consumption (in Litres/hr) in the given Period
						//------ This will be 0 Litres
						//--------------------------- 4. END of Set Consumption Details

						//5.2 Finish Engine Hours Life - CMHR of the last received packet from the Machine
						//5.3 Finish Fuel Level% Life - Fuel Level% of the last received packet from the Machine
						Query q = session.createQuery(" select s.parameterId, s.parameterValue from AssetMonitoringDetailEntity s,AssetMonitoringHeaderEntity b" +
								" where s.transactionNumber= b.transactionNumber and " +
								" b.transactionTime= (select max(h.transactionTime) from AssetMonitoringHeaderEntity h " +
								"where h.serialNumber='"+ serNum +"') and s.parameterId in ('4','5')");
						Iterator itrq = q.list().iterator();
						Object[] itrRes=null;
						while(itrq.hasNext())
						{
							itrRes = (Object[]) itrq.next();
							MonitoringParameters paramObj = (MonitoringParameters)itrRes[0];
							String value = null;
							if(itrRes[1]!=null)
								value=itrRes[1].toString();

							//ParameterId 4 corresponds to EngineHours
							if(paramObj.getParameterId()==4 && value!=null)
							{
								double d = Double.parseDouble(value);
								// long l = (long)d;
								implObj.setFinishEngineRunHoursLife(Double.valueOf(df2.format((Double)d)));;
							}
							//ParameterId 5 corresponds to FuelLevelPercentage
							else if(paramObj.getParameterId()==5 && value!=null)
							{
								// 2014-07-02: Fuel Level change : To take the fuel level from the Snapshot table - Suprava
								implObj.setFinishFuelLevelLife(parameterValue);
							}
						}

						//5.4 FuelUsedLitresLife
						Query qw = session.createQuery(" select m.serialNumber, sum(m.fuelUsedWorking) as totalFuelUsedWorking, sum(m.fuelUsedIdle) as totalFuelUsedIdle " +
								" from AssetMonitoringFactDataYearAgg m where m.serialNumber='"+serNum+"'");
						Iterator itrQw = qw.list().iterator();
						Object[] fuelResult =null;
						while(itrQw.hasNext())
						{
							fuelResult = (Object[])itrQw.next();
							if(fuelResult[1]!=null)
								fuelUsedWorkingLife = (Double) fuelResult[1];
							if(fuelResult[2]!=null)
								fuelUsedIdleLife = (Double) fuelResult[2];
							double fuelUsedLitresLife = (fuelUsedWorkingLife + fuelUsedIdleLife);
							implObj.setFuelUsedLitresLife(fuelUsedLitresLife);
						}

						//5.5 Fuel Used in Idle Life
						implObj.setFuelUsedIdleLitresLife(fuelUsedIdleLife);

						//--------------------------- END of 5. Set Consumption Details for the Complete Machine Life
					}
				
				}*/
				if(result[10]!=null)
					fuelUsedWorkingLife = (Double) result[10];
				if(result[11]!=null)
					fuelUsedIdleLife = (Double) result[11];
				double fuelUsedLitresLife = (fuelUsedWorkingLife + fuelUsedIdleLife);
				implObj.setFuelUsedLitresLife(fuelUsedLitresLife);
				implObj.setFuelUsedIdleLitresLife(fuelUsedIdleLife);
				//DefectId:20160105 - added by S Suresh
				if(result[6]!=null)
				{
					TenancyEntity primaryOwnerTenancy = (TenancyEntity)result[6];
				if( tenancyIdList.contains(primaryOwnerTenancy.getTenancy_id()) )
				{
					//5.2 Finish Engine Hours Life - CMHR of the last received packet from the Machine
					//5.3 Finish Fuel Level% Life - Fuel Level% of the last received packet from the Machine
					/*Query q = session.createQuery(" select s.parameterId, s.parameterValue from AssetMonitoringDetailEntity s,AssetMonitoringHeaderEntity b" +
							" where s.transactionNumber= b.transactionNumber and " +
							" b.transactionTime= (select max(h.transactionTime) from AssetMonitoringHeaderEntity h " +
							"where h.serialNumber='"+ serNum +"') and s.parameterId in ('4','5')");
					Iterator itrq = q.list().iterator();
					Object[] itrRes=null;
					while(itrq.hasNext())
					{
						itrRes = (Object[]) itrq.next();
						MonitoringParameters paramObj = (MonitoringParameters)itrRes[0];
						String value = null;
						if(itrRes[1]!=null)
							value=itrRes[1].toString();

						//ParameterId 4 corresponds to EngineHours
						if(paramObj.getParameterId()==4 && value!=null)
						{
							double d = Double.parseDouble(value);
							//long l = (long)d;
							//	implObj.set(d);
							implObj.setFinishEngineRunHoursLife(Double.valueOf(df2.format((Double)d)));
						}
						//ParameterId 5 corresponds to FuelLevelPercentage
						else if(paramObj.getParameterId()==5 && value!=null)
						{
							//DefectId:20140702 Fuel Level change : To take the fuel level from the Snapshot table - Suprava
							implObj.setFinishFuelLevelLife(parameterValue);
						}
					}*/
					
					if(result[1]!=null){
						implObj.setFinishEngineRunHoursLife(Double.valueOf(result[1].toString()));
					}
					if(parameterValue!=null)
						implObj.setFinishFuelLevelLife(parameterValue);
				}

				listImplObj.add(implObj);
			}
			}
			}
			//DefectId:20150316 End
		}

		catch (Exception e) 
		{
			e.printStackTrace();
			fLogger.fatal("Exception :" + e);
		}

		finally 
		{
			//			Keerthi : 14/01/14 : not needed
			//			if (session.getTransaction().isActive()) 
			//			{
			//				session.getTransaction().commit();
			//			}

			if (session.isOpen()) 
			{
				session.flush();
				session.close();
			}

		}

		return listImplObj;
			}

	public double bandCalculation(List<Integer> bandList,
			double EngineRunningBand1, double EngineRunningBand2,
			double EngineRunningBand3, double EngineRunningBand4,
			double EngineRunningBand5, double EngineRunningBand6,
			double EngineRunningBand7, double EngineRunningBand8) {
		Logger fLogger = FatalLoggerClass.logger;
		//Logger bLogger = BusinessErrorLoggerClass.logger;
		Logger iLogger = InfoLoggerClass.logger;
		double computedValue = 0;
		for (int band : bandList) {
			switch (band) {
			case 1:
				computedValue = EngineRunningBand1 + computedValue;
				break;
			case 2:
				computedValue = EngineRunningBand2 + computedValue;
				break;
			case 3:
				computedValue = EngineRunningBand3 + computedValue;
				break;
			case 4:
				computedValue = EngineRunningBand4 + computedValue;
				break;
			case 5:
				computedValue = EngineRunningBand5 + computedValue;
				break;
			case 6:
				computedValue = EngineRunningBand6 + computedValue;
				break;
			case 7:
				computedValue = EngineRunningBand7 + computedValue;
				break;
			case 8:
				computedValue = EngineRunningBand8 + computedValue;
				break;
			default:
				iLogger.info("Invalid Entry!");
			}

		}

		return computedValue;

	}





	// ********************************************END OF
	// MachinePerformanceReportService************************

	/**
	 * 
	 * @param Period
	 *            can be 'Today','Week','Month', 'Quarter', 'Year'
	 * @param machineGroupIdList
	 *            is provided as a list assetGroupId
	 * @param machineProfileIdList
	 *            is provided as a list machineProfileId
	 * @param tenancyIdList
	 *            is provided as a list tenancyId
	 * @param modelIdList
	 *            is provided as a list modelId
	 * @param alertID
	 *            is provided as a list alertID
	 * @param alertTypeId
	 *            is provided as a list alertTypeId
	 * @return listNotifications which return the list of notifications
	 */
	/*
	 * public List<NotificationReportDetailsImpl>
	 * getNotificationReportDetails(String period,List<Integer>
	 * machineGroupIdList,List<Integer> machineProfileIdList,List<Integer>
	 * tenancyIdList,List<Integer> modelIdList,List<Integer>
	 * alertID,List<Integer> alertTypeId) { List<NotificationReportDetailsImpl>
	 * listNotifications=new LinkedList<NotificationReportDetailsImpl>();
	 * infoLogger.info("Entering getNotificationReportDetails()"); long
	 * startTimeTaken=System.currentTimeMillis(); String basicSelectQuery=null;
	 * String basicFromQuery=null; String basicWhereQuery=null; String
	 * finalQuery=null;
	 * 
	 * ListToStringConversion conversionObj = new ListToStringConversion();
	 * String tenancyIdStringList =
	 * conversionObj.getIntegerListString(tenancyIdList).toString();
	 * basicWhereQuery=" where g.Tenancy_Id = d.tenancyId and d.tenancyId in ("
	 * + tenancyIdStringList + " )";
	 * 
	 * 
	 * if(period.equalsIgnoreCase("Today")) { basicFromQuery =
	 * " from NotificationFactEntity_DayAgg g "; basicWhereQuery =
	 * basicWhereQuery + " and g.Time_Key = (select max(Time_Key) from g) ";
	 * 
	 * } else if(period.equalsIgnoreCase("Week")) { basicFromQuery =
	 * " from  notification_fact_weekagg g "; basicWhereQuery = basicWhereQuery
	 * +" and g.TimeCount = (select max(TimeCount) from g) "; }
	 * 
	 * else if(period.equalsIgnoreCase("Month")) { basicFromQuery =
	 * " from  notification_fact_Monthagg g "; basicWhereQuery = basicWhereQuery
	 * +" and g.TimeCount = (select max(TimeCount) from g) "; } else
	 * if(period.equalsIgnoreCase("Quarter")) { basicFromQuery =
	 * " from notification_fact_Quarteragg g "; basicWhereQuery =
	 * basicWhereQuery +" and g.TimeCount = (select max(TimeCount) from g) "; }
	 * 
	 * else if(period.equalsIgnoreCase("Year")) { basicFromQuery =
	 * " from notification_fact_Yearagg g "; basicWhereQuery = basicWhereQuery
	 * +" and g.TimeCount = (select max(TimeCount) from g) ";
	 * 
	 * } basicFromQuery = basicFromQuery
	 * +"JOIN g.Tenancy_Id d JOIN g.MachineGroup_Id b JOIN g.AssetClass_Id c ";
	 * basicSelectQuery=
	 * "select g.Category,g.descriptionType,g.description,g.status,g.value,g.dateRaised,g.location,g.closedBy"
	 * ; finalQuery=basicSelectQuery+basicFromQuery+basicWhereQuery; Session
	 * session = HibernateUtil.getSessionFactory().getCurrentSession();
	 * session.beginTransaction(); try { Query
	 * qry=session.createQuery(finalQuery); Iterator itr=qry.list().iterator();
	 * 
	 * Object result[]=null; while(itr.hasNext()) {
	 * NotificationReportDetailsImpl implmObj=new
	 * NotificationReportDetailsImpl(); result = (Object[]) itr.next();
	 * implmObj.setCategory(result[0].toString());
	 * implmObj.setDescriptionType(result[1].toString());
	 * implmObj.setDescription(result[2].toString());
	 * implmObj.setStatus(result[3].toString());
	 * implmObj.setValue((Integer)result[4]);
	 * implmObj.setDateRaised(result[5].toString());
	 * implmObj.setLocation(result[6].toString());
	 * implmObj.setClosedBy(result[7].toString());
	 * listNotifications.add(implmObj);
	 * 
	 * } long endTimeTaken=System.currentTimeMillis(); long
	 * totalTimeTaken=endTimeTaken-startTimeTaken;
	 * 
	 * infoLogger.info("TotalTimeTaken is   "+totalTimeTaken);
	 * infoLogger.info("Exiting getNotificationReportDetails()"); }
	 * catch(Exception e) {
	 * businessError.error("Hello this is an Business Error message   "
	 * +e.getMessage()); } finally { if(session.getTransaction().isActive()) {
	 * session.getTransaction().commit(); }
	 * 
	 * if(session.isOpen()) { session.flush(); session.close(); }
	 * 
	 * } return listNotifications;
	 * 
	 * }
	 */
	//Logic for Custom Dates (fromDate,toDate) added by Juhi on 14-August-2013 
	/*public List<NotificationReportDetailsImpl> getNotificationReportDetails(String fromDate,String toDate,
			String period, String serialNumber) 
			{
		List<NotificationReportDetailsImpl> listNotifications = new LinkedList<NotificationReportDetailsImpl>();
		infoLogger.info("Entering getNotificationReportDetails()");
		long startTimeTaken = System.currentTimeMillis();
		String basicSelectQuery = null;
		String basicFromQuery = null;
		String basicWhereQuery = null;
		String finalQuery = null;
		String dateClosed=null;
		ListToStringConversion conversionObj = new ListToStringConversion();

		basicWhereQuery = " where g.SerialNumber='" + serialNumber + "'";
		//Logic for Custom Dates (fromDate,toDate) added by Juhi on 14-August-2013 
		if(fromDate == null && toDate==null)
					{
		if ((period.equalsIgnoreCase("Week"))||(period.equalsIgnoreCase("Last Week"))) {
			Date currentDate = new Date();
			DateUtil dateUtilObj = new DateUtil();
			DateUtil dateUtilObj1 = new DateUtil();
			if (period.equalsIgnoreCase("Week")){
				dateUtilObj  = dateUtilObj. getCurrentDateUtility(currentDate);
				int week = dateUtilObj. getWeek();
				int year = dateUtilObj. getYear();
				basicFromQuery = " from  notification_fact_weekagg g ";
				basicWhereQuery = basicWhereQuery+ " and g.TimeCount = "+week+" and g.Year = "+year+"";
			}
			if(period.equalsIgnoreCase("Last Week")){
				dateUtilObj  = dateUtilObj. getPreviousDateUtility(currentDate);
				dateUtilObj1  = dateUtilObj1. getCurrentDateUtility(currentDate);
				int week = dateUtilObj. getWeek();
				int year=0;
				if(dateUtilObj1.getWeek()==1)
					year = dateUtilObj.getYear();
				else
					year = dateUtilObj.getCurrentYear();
				basicFromQuery = " from  notification_fact_weekagg g ";
				basicWhereQuery = basicWhereQuery+ " and g.TimeCount = "+week+" and g.Year = "+year+"";
			}

		}

		else if ((period.equalsIgnoreCase("Month"))||(period.equalsIgnoreCase("Last Month"))) {
			DateUtil dateUtilObj1 = new DateUtil();
			Date currentDate = new Date();
			DateUtil dateUtilObj = new DateUtil();			
			if(period.equalsIgnoreCase("Month")){
				dateUtilObj  = dateUtilObj. getCurrentDateUtility(currentDate);
				int month = dateUtilObj. getMonth ();
				int year = dateUtilObj. getYear();
				basicFromQuery = " from  notification_fact_Monthagg g ";
				basicWhereQuery = basicWhereQuery+ " and g.TimeCount = "+month+" and g.Year = "+year+"";
			}
			if(period.equalsIgnoreCase("Last Month")){
				dateUtilObj  = dateUtilObj. getPreviousDateUtility (currentDate);
				dateUtilObj1  = dateUtilObj1. getCurrentDateUtility(currentDate);

				int month = dateUtilObj. getMonth ();
				int year=0;
				if(dateUtilObj1.getMonth() ==1)
					year = dateUtilObj.getYear();
				else
					year = dateUtilObj.getCurrentYear();
				basicFromQuery = " from  notification_fact_Monthagg g ";
				basicWhereQuery = basicWhereQuery+ " and g.TimeCount = "+month+" and g.Year = "+year+"";
			}

		} 



		else if((period.equalsIgnoreCase("Quarter"))||(period.equalsIgnoreCase("Last Quarter"))) {
			DateUtil dateUtilObj1 = new DateUtil();
			Date currentDate = new Date();
			DateUtil dateUtilObj = new DateUtil();
			if(period.equalsIgnoreCase("Quarter")){
				dateUtilObj  = dateUtilObj. getCurrentDateUtility(currentDate);
				int quarter = dateUtilObj. getQuarter ();
				int year = dateUtilObj. getYear();
				basicFromQuery = " from notification_fact_Quarteragg g ";
				basicWhereQuery = basicWhereQuery+ " and g.TimeCount = "+quarter+" and g.Year = "+year+"";
			}
			if(period.equalsIgnoreCase("Last Quarter")){
				dateUtilObj1  = dateUtilObj1. getCurrentDateUtility(currentDate);

				dateUtilObj  = dateUtilObj. getPreviousDateUtility(currentDate);
				int quarter = dateUtilObj. getQuarter ();
				int year=0;
				if(dateUtilObj1.getQuarter() ==1)
					year = dateUtilObj.getYear();
				else
					year = dateUtilObj.getCurrentYear();
				basicFromQuery = " from notification_fact_Quarteragg g ";
				basicWhereQuery = basicWhereQuery+ " and g.TimeCount = "+quarter+" and g.Year = "+year+"";
			}

		}

		else if ((period.equalsIgnoreCase("Year"))||(period.equalsIgnoreCase("Year")))
		{
			Date currentDate = new Date();
			DateUtil dateUtilObj = new DateUtil();
			if(period.equalsIgnoreCase("Year")){
				dateUtilObj  = dateUtilObj. getCurrentDateUtility(currentDate);
				int year = dateUtilObj. getYear();
				basicFromQuery = " from notification_fact_Yearagg g ";
				basicWhereQuery = basicWhereQuery+ " and g.Year = "+year+"";
			}
			if(period.equalsIgnoreCase("Last Year")){
				dateUtilObj  = dateUtilObj. getPreviousDateUtility(currentDate);
				int year = dateUtilObj. getYear();
				basicFromQuery = " from notification_fact_Yearagg g ";
				basicWhereQuery = basicWhereQuery+ " and g.Year = "+year+"";
			}

		}
					}
		//Logic for Custom Dates (fromDate,toDate) added by Juhi on 14-August-2013 
		else
		{
			DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
			DateFormat dateFormat1 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
			Date fromdate1=null;
			String fromdate2=null;
			String todate2=null;
				try {	

					fromdate1 = (Date)dateFormat.parse(fromDate);		
				String fromdate=dateFormat.format(fromdate1);
				fromdate2=dateFormat1.format(fromdate1);

				Date todate1=(Date)dateFormat.parse(toDate);

				String todate=dateFormat.format(todate1);
				todate2=dateFormat1.format(todate1);


				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				List<String> dateList= new LinkedList<String>();					
				Calendar calendar = Calendar.getInstance();					
				do
				{
					dateList.add(fromdate2);
					calendar.setTime(fromdate1);
					calendar.add(Calendar.DAY_OF_YEAR, 1);
					fromdate1 = calendar.getTime();			
					fromdate2 = dateFormat1.format(fromdate1);


				} while ((fromdate2.compareTo(todate2)) <=0);
				String dateStringList=conversionObj.getStringList(dateList).toString();
				basicFromQuery = " from NotificationFactEntity_DayAgg g";
				basicWhereQuery = basicWhereQuery+ " and g.Time_Key between '"+fromdate2+"' and '"+todate2+"' ";
		}
		//Logic for Custom Dates (fromDate,toDate) added by Juhi on 14-August-2013 

		basicFromQuery = basicFromQuery+ ",NotificationDimensionEntity e, AssetMonitoringDetailEntity a, MonitoringParameters c,AssetMonitoringHeaderEntity d,EventEntity f";
		basicSelectQuery = "select a.parameterValue , c.parameterName,e.Notification_Type_Name,f.eventName,f.eventDescription,f.eventSeverity,d.transactionTime,g.SerialNumber";
		basicWhereQuery = basicWhereQuery+ " and a.parameterId=c.parameterId and a.transactionNumber=d.transactionNumber and a.transactionNumber in(select max(transactionNumber) from AssetMonitoringHeaderEntity b where serialNumber='"+ serialNumber+ "')and c.parameterName in('Latitude','Longitude') and c.parameterId =a.parameterId and e.Notification_Id=f.eventId and f.eventId in(select eventId from AssetEventEntity where serialNumber='"+ serialNumber + "')group by c.parameterName,f.eventName";

		finalQuery = basicSelectQuery + basicFromQuery + basicWhereQuery;

		Session session = HibernateUtil.getSessionFactory().getCurrentSession();
		session.beginTransaction();
		try {

			Query query = session.createQuery(" from AssetEntity where serial_number ='"+serialNumber+"' ");
			Iterator itrt = query.list().iterator();
			AssetEntity asset =null;

			while(itrt.hasNext())
			{
				asset = (AssetEntity)itrt.next();
			}
			//session = HibernateUtil.getSessionFactory().getCurrentSession();
			Query qry1 = session.createQuery(finalQuery);

			Iterator itr1 = qry1.list().iterator();
			NotificationReportDetailsImpl implmObj;
			Object result[] = null;
			while (itr1.hasNext()) {
				result = (Object[]) itr1.next();
				implmObj = new NotificationReportDetailsImpl();
				if(result[0]!=null)
				{
					implmObj.setValue(result[0].toString());
				}

				if(result[1]!=null)
				{
					Query q = session.createQuery(" select a.Address from AssetMonitoringFactDataDayAgg a where " +
							" a.timeKey = (select max(b.timeKey) from AssetMonitoringFactDataDayAgg b where b.serialNumber='"+serialNumber+"' )" +
									" and a.serialNumber='"+serialNumber+"' ");
					Iterator itrtrt = q.list().iterator();
					while(itrtrt.hasNext())
					{
						String address = (String)itrtrt.next();
						implmObj.setLocation(address);
					}


				}

				if(result[2]!=null)
				{
					implmObj.setCategory(result[2].toString());
				}

				if(result[3]!=null)
				{
					implmObj.setAlertName(result[3].toString());
				}

				if(result[4]!=null)
				{
					implmObj.setDescription(result[4].toString());
				}

				if(result[5]!=null)
				{
					implmObj.setStatus(result[5].toString());
				}

				if(result[6]!=null)
				{
					implmObj.setDateRaised(result[6].toString());
				}

				if(serialNumber!=null && asset!=null)
				{
					implmObj.setMachineName(asset.getNick_name());
				}


				if(result[7]!=null)
				{
					implmObj.setSerialNumber(result[7].toString());
				}

				implmObj.setDateClosed(dateClosed);
				listNotifications.add(implmObj);

			}
			long endTimeTaken = System.currentTimeMillis();
			long totalTimeTaken = endTimeTaken - startTimeTaken;

			infoLogger.info("TotalTimeTaken is   " + totalTimeTaken);
			infoLogger.info("Exiting getNotificationReportDetails()");
		} catch (Exception e) {
		//	businessError.error("Hello this is an Business Error message   "
			//		+ e.getMessage());
			e.printStackTrace();
		} finally {
			if (session.getTransaction().isActive()) {
				session.getTransaction().commit();
			}

			if (session.isOpen()) {
				session.flush();
				session.close();
			}

		}
		return listNotifications;

	}*/

	/*public List<NotificationReportDetailsImpl> getNotificationReportDetails(String fromDate,String toDate,
            String serialNumber,String LoginId, List<Integer> TenancyIdList){
      List<NotificationReportDetailsImpl> listNotifications = new LinkedList<NotificationReportDetailsImpl>();
      infoLogger.info("Entering getNotificationReportDetails()");
      long startTimeTaken = System.currentTimeMillis();
      String basicSelectQuery = null;
      String basicFromQuery = null;
      String basicWhereQuery = null;
      String finalQuery = null;
      String dateClosed=null;
      ListToStringConversion conversionObj = new ListToStringConversion();
      NotificationReportDetailsImpl implmObj = null;
      basicWhereQuery = " where g.SerialNumber='" + serialNumber + "'";
       String serialNumberSummaryReport=null;
      Long countSummary=0L;
      String notificationTypeNameSummary=null;
      HashMap<String, Long> countMap = new HashMap<String, Long>();
      HashMap<String, Long> nameCountMapTemp = new HashMap<String, Long>();
      HashMap<String,HashMap<String, Long>> nameCountMap = new HashMap<String,HashMap<String, Long>>();
     //to get individual count of alerts for each VIN....ID20131022...done by smitha on 22nd oct 2013
      if ((period.equals("Week")) || (period.equals("Last Week")) || (period.equals("Month")) || (period.equals("Last Month")) || (period.equals("Quarter")) || (period.equals("Last Quarter")) || (period.equals("Year")) || (period.equals("Last Year"))) {
			List<String> serNumList = new LinkedList<String>();
			serNumList.add(serialNumber);

			List<NotificationSummaryReportImpl> implList = GetNotificationSummaryReportDetails(fromDate,toDate,LoginId,period,TenancyIdList,null,
				 	   null,false,null, false, false,null);

			for (int i = 0; i < implList.size(); i++) {
				NotificationReportDetailsImpl response = new NotificationReportDetailsImpl();
				countSummary=implList.get(i).getCount();
				notificationTypeNameSummary=implList.get(i).getNotificationTypeName();
				serialNumberSummaryReport=implList.get(i).getSerialNumber();
				countMap.put(serialNumberSummaryReport, countSummary);
				nameCountMapTemp=implList.get(i).getNameCount();
				nameCountMap.put(serialNumberSummaryReport, nameCountMapTemp);
			}
		}

      //end .....ID20131022.....done by smitha on 22nd oct 2013

      //Logic for Custom Dates (fromDate,toDate) added by Juhi on 14-August-2013 
      if(fromDate == null && toDate==null)
                        {
      if ((period.equalsIgnoreCase("Week"))||(period.equalsIgnoreCase("Last Week"))) {
            Date currentDate = new Date();
            DateUtil dateUtilObj = new DateUtil();
            DateUtil dateUtilObj1 = new DateUtil();
            if (period.equalsIgnoreCase("Week")){
                  dateUtilObj  = dateUtilObj. getCurrentDateUtility(currentDate);
                  int week = dateUtilObj. getWeek();
                  int year = dateUtilObj. getYear();
                  basicFromQuery = " from  notification_fact_weekagg g ";
                  basicWhereQuery = basicWhereQuery+ " and g.TimeCount = "+week+" and g.Year = "+year+"";
            }
            if(period.equalsIgnoreCase("Last Week")){
                  dateUtilObj  = dateUtilObj. getPreviousDateUtility(currentDate);
                  dateUtilObj1  = dateUtilObj1. getCurrentDateUtility(currentDate);
                  int week = dateUtilObj. getWeek();
                  int year=0;
                  if(dateUtilObj1.getWeek()==1)
                        year = dateUtilObj.getYear();
                  else
                        year = dateUtilObj.getCurrentYear();
                  basicFromQuery = " from  notification_fact_weekagg g ";
                  basicWhereQuery = basicWhereQuery+ " and g.TimeCount = "+week+" and g.Year = "+year+"";
            }

      }

      else if ((period.equalsIgnoreCase("Month"))||(period.equalsIgnoreCase("Last Month"))) {
            DateUtil dateUtilObj1 = new DateUtil();
            Date currentDate = new Date();
            DateUtil dateUtilObj = new DateUtil();                
            if(period.equalsIgnoreCase("Month")){
                  dateUtilObj  = dateUtilObj. getCurrentDateUtility(currentDate);
                  int month = dateUtilObj. getMonth ();
                  int year = dateUtilObj. getYear();
                  basicFromQuery = " from  notification_fact_Monthagg g ";
                  basicWhereQuery = basicWhereQuery+ " and g.TimeCount = "+month+" and g.Year = "+year+"";
            }
            if(period.equalsIgnoreCase("Last Month")){
                  dateUtilObj  = dateUtilObj. getPreviousDateUtility (currentDate);
                  dateUtilObj1  = dateUtilObj1. getCurrentDateUtility(currentDate);

                  int month = dateUtilObj. getMonth ();
                  int year=0;
                  if(dateUtilObj1.getMonth() ==1)
                        year = dateUtilObj.getYear();
                  else
                        year = dateUtilObj.getCurrentYear();
                  basicFromQuery = " from  notification_fact_Monthagg g ";
                  basicWhereQuery = basicWhereQuery+ " and g.TimeCount = "+month+" and g.Year = "+year+"";
            }

      } 



      else if((period.equalsIgnoreCase("Quarter"))||(period.equalsIgnoreCase("Last Quarter"))) {
            DateUtil dateUtilObj1 = new DateUtil();
            Date currentDate = new Date();
            DateUtil dateUtilObj = new DateUtil();
            if(period.equalsIgnoreCase("Quarter")){
                  dateUtilObj  = dateUtilObj. getCurrentDateUtility(currentDate);
                  int quarter = dateUtilObj. getQuarter ();
                  int year = dateUtilObj. getYear();
                  basicFromQuery = " from notification_fact_Quarteragg g ";
                  basicWhereQuery = basicWhereQuery+ " and g.TimeCount = "+quarter+" and g.Year = "+year+"";
            }
            if(period.equalsIgnoreCase("Last Quarter")){
                  dateUtilObj1  = dateUtilObj1. getCurrentDateUtility(currentDate);

                  dateUtilObj  = dateUtilObj. getPreviousDateUtility(currentDate);
                  int quarter = dateUtilObj. getQuarter ();
                  int year=0;
                  if(dateUtilObj1.getQuarter() ==1)
                        year = dateUtilObj.getYear();
                  else
                        year = dateUtilObj.getCurrentYear();
                  basicFromQuery = " from notification_fact_Quarteragg g ";
                  basicWhereQuery = basicWhereQuery+ " and g.TimeCount = "+quarter+" and g.Year = "+year+"";
            }

      }

      else if ((period.equalsIgnoreCase("Year"))||(period.equalsIgnoreCase("Year")))
      {
            Date currentDate = new Date();
            DateUtil dateUtilObj = new DateUtil();
            if(period.equalsIgnoreCase("Year")){
                  dateUtilObj  = dateUtilObj. getCurrentDateUtility(currentDate);
                  int year = dateUtilObj. getYear();
                  basicFromQuery = " from notification_fact_Yearagg g ";
                  basicWhereQuery = basicWhereQuery+ " and g.Year = "+year+"";
            }
            if(period.equalsIgnoreCase("Last Year")){
                  dateUtilObj  = dateUtilObj. getPreviousDateUtility(currentDate);
                  int year = dateUtilObj. getYear();
                  basicFromQuery = " from notification_fact_Yearagg g ";
                  basicWhereQuery = basicWhereQuery+ " and g.Year = "+year+"";
            }

      }
                        }
      //Logic for Custom Dates (fromDate,toDate) added by Juhi on 14-August-2013 
      else
      {
            DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
            DateFormat dateFormat1 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            Date fromdate1=null;
            String fromdate2=null;
            String todate2=null;
                  try { 

                        fromdate1 = (Date)dateFormat.parse(fromDate);         
                  String fromdate=dateFormat.format(fromdate1);
                  fromdate2=dateFormat1.format(fromdate1);

                  Date todate1=(Date)dateFormat.parse(toDate);

                  String todate=dateFormat.format(todate1);
                  todate2=dateFormat1.format(todate1);


                  } catch (ParseException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                  }
                  List<String> dateList= new LinkedList<String>();                              
                  Calendar calendar = Calendar.getInstance();                             
                  do
                  {
                        dateList.add(fromdate2);
                        calendar.setTime(fromdate1);
                        calendar.add(Calendar.DAY_OF_YEAR, 1);
                        fromdate1 = calendar.getTime();                 
                        fromdate2 = dateFormat1.format(fromdate1);


                  } while ((fromdate2.compareTo(todate2)) <=0);
                  String dateStringList=conversionObj.getStringList(dateList).toString();
                  basicFromQuery = " from Notificatioassetmonit4_.Transaction_TimestampnFactEntity_DayAgg g";
                  basicWhereQuery = basicWhereQuery+ " and g.Time_Key between '"+fromdate2+"' and '"+todate2+"' ";
      }
      //Logic for Custom Dates (fromDate,toDate) added by Juhi on 14-August-2013 
      basicFromQuery = basicFromQuery + " ,NotificationDimensionEntity e, AssetMonitoringDetailEntity a, MonitoringParameters c,AssetMonitoringHeaderEntity d,EventEntity f,AssetEventEntity h ";
    basicSelectQuery = "select a.parameterValue , c.parameterName,e.Notification_Type_Name,f.eventName,f.eventDescription,f.eventSeverity,d.transactionTime,g.SerialNumber,h.activeStatus ";
      basicWhereQuery = basicWhereQuery+ " and a.parameterId=c.parameterId and a.transactionNumber=d.transactionNumber and a.transactionNumber = (select max(transactionNumber) from AssetMonitoringHeaderEntity b where serialNumber='"+ serialNumber+ "')and c.parameterName in('Latitude','Longitude') and e.Notification_Id=f.eventId and f.eventId in(select eventId from AssetEventEntity where serialNumber='"+ serialNumber + "') and h.serialNumber = g.SerialNumber and d.transactionTime = h.eventGeneratedTime and f.eventId = h.eventId group by d.transactionTime,f.eventName";


          basicFromQuery = basicFromQuery+ ",NotificationDimensionEntity e, AssetMonitoringDetailEntity a, MonitoringParameters c,AssetMonitoringHeaderEntity d,EventEntity f ";
      basicSelectQuery = "select a.parameterValue , c.parameterName,e.Notification_Type_Name,f.eventName,f.eventDescription,f.eventSeverity,d.transactionTime,g.SerialNumber ";
      basicWhereQuery = basicWhereQuery+ " and a.parameterId=c.parameterId and a.transactionNumber=d.transactionNumber and a.transactionNumber in(select max(transactionNumber) from AssetMonitoringHeaderEntity b where serialNumber='"+ serialNumber+ "')and c.parameterName in('Latitude','Longitude') and e.Notification_Id=f.eventId and f.eventId in(select eventId from AssetEventEntity where serialNumber='"+ serialNumber + "') group by d.transactionTime,f.eventName";

      finalQuery = basicSelectQuery + basicFromQuery + basicWhereQuery;
      String time=null;
      Date date=null;
      String date1=null;
      Session session = HibernateUtil.getSessionFactory().getCurrentSession();
      session.beginTransaction();
      try {

            Query query = session.createQuery(" from AssetEntity where serial_number ='"+serialNumber+"' ");
            Iterator itrt = query.list().iterator();
            AssetEntity asset =null;

            while(itrt.hasNext())
            {
                  asset = (AssetEntity)itrt.next();
            }
            //session = HibernateUtil.getSessionFactory().getCurrentSession();
            Query qry1 = session.createQuery(finalQuery);

            Iterator itr1 = qry1.list().iterator();
//          NotificationReportDetailsImpl implmObj;
            Object result[] = null;
            while (itr1.hasNext()) {
                  result = (Object[]) itr1.next();
                  implmObj = new NotificationReportDetailsImpl();
                  if(result[0]!=null)
                  {
//                      implmObj.setValue(result[0].toString()); status-->open or close
                  }

                  if(result[1]!=null)
                  {
                        Query q = session.createQuery(" select a.Address from AssetMonitoringFactDataDayAgg a where " +
                                    " a.timeKey = (select max(b.timeKey) from AssetMonitoringFactDataDayAgg b where b.serialNumber='"+serialNumber+"' )" +
                                                " and a.serialNumber='"+serialNumber+"' ");
                        Iterator itrtrt = q.list().iterator();
                        while(itrtrt.hasNext())
                        {
                              String address = (String)itrtrt.next();
                              implmObj.setLocation(address);
                        }


                  }

                  if(result[2]!=null)
                  {
                        implmObj.setCategory(result[2].toString());
                  }

                  if(result[3]!=null)
                  {
                        implmObj.setAlertName(result[3].toString());
                  }

                  if(result[4]!=null)
                  {
                        implmObj.setDescription(result[4].toString());
                  }

                  if(result[5]!=null)
                  {
//                      implmObj.setStatus(result[5].toString());
                        implmObj.setSeverity(result[5].toString());
                  }

                  if(result[6]!=null)
                  {
                  implmObj.setDateRaised(result[6].toString());
                        time=result[6].toString();
                        SimpleDateFormat formatter = new SimpleDateFormat("yyyy-mm-dd");
                        date=formatter.parse(time);
                        date1=formatter.format(date);
                  }

                  if(serialNumber!=null && asset!=null)
                  {
                        implmObj.setMachineName(asset.getNick_name());
                  }


                  if(result[7]!=null)
                  {
                	//to get the individual count of alerts for each VIN....ID20131022...done by smitha on oct 22nd 2013
//                	 String serNum= result[7].toString();
                	  	implmObj.setSerialNumber(result[7].toString());

                	  	Set mapSet = (Set) countMap.entrySet();
        				Iterator mapIterator = mapSet.iterator();	
        				while (mapIterator.hasNext()) {
        					Map.Entry mapEntry = (Map.Entry) mapIterator.next(); 
        					String keyValue = (String) mapEntry.getKey(); 
        					Long value = (Long)mapEntry.getValue();
        					if(keyValue.equals(serNum)){
        						implmObj.setCount(value);
        					}
        			}	
        				Set mapSetNameCount = (Set) nameCountMap.entrySet();
        				Iterator mapIteratorNameCount = mapSetNameCount.iterator();	
        				while (mapIteratorNameCount.hasNext()) {
        					Map.Entry mapEntryTemp = (Map.Entry) mapIteratorNameCount.next(); 
        					String keyNameCount = (String) mapEntryTemp.getKey(); 
        					HashMap<String, Long> valueNameCount = (HashMap<String, Long>) mapEntryTemp.getValue();
        					if(keyNameCount.equals(serNum)){
        						implmObj.setNameCount(valueNameCount);
        					}
        			}
        				//ended on oct 22nd 2013...ID20131022
                 }     

                  if(result[8]!=null)
                  {
                        implmObj.setStatus(result[8].toString());
                  }
                  String query1="select h.activeStatus,h.eventGeneratedTime,h.eventSeverity from AssetEventEntity h where h.serialNumber='"+serialNumber+"' and h.eventGeneratedTime like '"+date1+"%'";
                  Iterator itr=session.createQuery(query1).list().iterator();
                  String activeStatus=null;
                  String dateRaised=null;
                  String severity=null;
                  Object[] results = null;            
                  while(itr.hasNext())
                  {
                        results = (Object[]) itr.next();
                        activeStatus=results[0].toString();
                        dateRaised=results[1].toString();
                        severity=results[2].toString();

                        implmObj.setStatus(activeStatus);
                        implmObj.setDateRaised(dateRaised);
                        implmObj.setSeverity(severity);
                  }

                  implmObj.setDateClosed(dateClosed);
                  listNotifications.add(implmObj);
            }

            long endTimeTaken = System.currentTimeMillis();
            long totalTimeTaken = endTimeTaken - startTimeTaken;

            infoLogger.info("TotalTimeTaken is   " + totalTimeTaken);
            infoLogger.info("Exiting getNotificationReportDetails()");
      } catch (Exception e) {
            e.printStackTrace();
      } finally {
            if (session.getTransaction().isActive()) {
                  session.getTransaction().commit();
            }

            if (session.isOpen()) {
                  session.flush();
                  session.close();
            }

      }
      return listNotifications;

} */    


	// ********************************************END OF
	// NotificationReportDetailsService************************
	// ********************START OF ReportMasterList*************************
	public List<ReportMasterListImpl> getReportMasterListService(String loginId) {
		//Logger fLogger = FatalLoggerClass.logger;
		//Logger bLogger = BusinessErrorLoggerClass.logger;
		Logger iLogger = InfoLoggerClass.logger;
		iLogger.info("Entering getReportMasterListService()");
		long startTimeTaken = System.currentTimeMillis();
		List<ReportMasterListImpl> listImpl = new LinkedList<ReportMasterListImpl>();
		Session session = HibernateUtil.getSessionFactory().getCurrentSession();
		session.beginTransaction();
		try {
			ReportMasterListImpl implObj = null;

			Query qery = session.createQuery("from ReportMasterListEntity");
			Iterator itrr = qery.list().iterator();
			while (itrr.hasNext()) {
				implObj = new ReportMasterListImpl();
				ReportMasterListEntity reportDet = (ReportMasterListEntity) itrr
				.next();
				implObj.setReportId(reportDet.getReportId());
				implObj.setReportName(reportDet.getReportName());
				implObj.setReportDescription(reportDet.getReportDescription());

				listImpl.add(implObj);

			}
		} finally {
			if (session.getTransaction().isActive()) {
				session.getTransaction().commit();
			}

			if (session.isOpen()) {
				session.flush();
				session.close();
			}

		}
		long endTimeTaken = System.currentTimeMillis();
		long totalTimeTaken = endTimeTaken - startTimeTaken;

		iLogger.info("totalTimeTaken  " + totalTimeTaken);
		iLogger.info("Exiting getReportMasterListService");

		return listImpl;
	}

	/********************START OF GET REPORT SUBSCRIPTION*************************

	/**
	 * 
	 * @param contactId of specific user
	 * @param reportId, List of Id's under the specific user
	 * @return listOfReportSubscriptionImpl,List of subscribed reports
	 * @throws CustomFault
	 */

	public List<ReportSubscriptionImpl> getreportSubscriptionServiceFinal(String contactId,List<Integer> reportIdList)throws CustomFault	
	{
		
		Logger bLogger = BusinessErrorLoggerClass.logger;
		Logger iLogger = InfoLoggerClass.logger;
		List<ReportSubscriptionImpl> respList = new ArrayList<ReportSubscriptionImpl>();
		long startTime = System.currentTimeMillis();
		Session session = HibernateUtil.getSessionFactory().getCurrentSession();
		session.beginTransaction();  
		Properties prop = new Properties();
		Map<Integer,Integer> catlogMap = new  HashMap<Integer,Integer>();
		ReportSubscriptionImpl impl=null;
		ReportSubscriptionImpl impl1=null;
		try{
			try {
				prop.load(getClass().getClassLoader().getResourceAsStream("remote/wise/resource/properties/configuration.properties"));
			} catch (IOException e) {
				e.printStackTrace();
			}

			Query query1 = session.createQuery("SELECT b1.reportId,b1.reportName,p1.catalogValueId"+" FROM ReportMasterListEntity b1,CatalogValuesEntity p1"+
			" WHERE b1.reportName=p1.catalogValue");
			//query to get all user preferences along with the catalog id
			Query query2 = session.createQuery("SELECT c1.catalogId,c1.catalogValueId"+
					" FROM PreferenceEntity p1, CatalogValuesEntity c1"+
					" WHERE p1.contact='"+contactId+"'"+
			" AND c1.catalogValueId=p1.catalogValueId");
			Iterator iterat = query2.list().iterator();
			Object[] result = null;				
			int reportId=0;
			String reportName=null;
			int catalogValueId=0;
			int catalogId;
			while(iterat.hasNext()){
				result = (Object[]) iterat.next();
				PreferenceCatalogEntity pce = (PreferenceCatalogEntity)result[0];
				catalogId = pce.getCatalogId();
				if(result[1]!=null){
					catalogValueId=(Integer)result[1];			
				}					
				catlogMap.put(catalogValueId, catalogId);
			}
			//iterate over first query and add it to response list
			iterat = query1.list().iterator();
			result = null;
			boolean idExists;
			while(iterat.hasNext()){
				result = (Object[]) iterat.next();
				impl = new ReportSubscriptionImpl();
				if(result[0]!=null){
					reportId = (Integer)result[0];
				}
				if(result[1]!=null){
					reportName =(String)result[1];
				}
				if(result[2]!=null){
					catalogValueId= (Integer)result[2];
				}

				impl.setReportId(reportId);
				impl.setReportName(reportName);
				impl.setWeeklyReportSubscription(false);
				impl.setMonthlyReportSubscription(false);


				if(catlogMap!=null && catlogMap.containsKey(catalogValueId)){
					catalogId = catlogMap.get(catalogValueId);
					if(catalogId==11){
						impl.setWeeklyReportSubscription(true);
					}
					else if(catalogId==12){
						impl.setMonthlyReportSubscription(true);
					}
				}
				idExists=false;
				Iterator<ReportSubscriptionImpl> listIter=respList.iterator();
				while(listIter.hasNext() && !idExists){
					impl1 = listIter.next();
					if(impl1.getReportId()==reportId){//event id already exists in list. so set only boolean values
						idExists = true;		
						if(catlogMap!=null && catlogMap.containsKey(catalogValueId)){
							catalogId = catlogMap.get(catalogValueId);
							if(catalogId==11){
								impl1.setWeeklyReportSubscription(true);
							}
							else if(catalogId==12){
								impl1.setMonthlyReportSubscription(true);
							}
						}
					}
				}		  
				if(!idExists){//event id does not exist. so add the new object here							
					respList.add(impl);
				}						

			}
		}
		catch(Exception e){
			bLogger.error("Error while reading properties file");
			throw new CustomFault("Error while reading properties file");
		}
		finally{
			if(session.getTransaction().isActive()){      
				session.getTransaction().commit();
			}
			if(session.isOpen()){
				session.flush();
				session.close();
			} 
		}
		long endTime=System.currentTimeMillis();
		iLogger.info("Total execution time "+ String.valueOf(endTime-startTime)+ "(ms)");

		return respList;


	}



	/**
	 * 
	 * @param contactId
	 *            is passed to save the reports
	 * @param reportId
	 *            is passed to save the reports based on reportId
	 * @return listOfResponse says that the list of reports are saved.
	 */
	public List<SavedReportImpl> getSavedReportService(List<Integer>reportIdList,List<String>contactIdList)throws CustomFault{
		long startTimeTaken = System.currentTimeMillis();
		
		Logger iLogger = InfoLoggerClass.logger;
		Session session = HibernateUtil.getSessionFactory().openSession();
		session.beginTransaction();
		int reportId=0;
		String reportName=null;
		String reportDescription=null;
		ContactEntity contactId=null;
		String fieldId=null;
		String fieldValue=null;

		List<SavedReportImpl> listOfResponse=new LinkedList<SavedReportImpl>();
		SavedReportImpl impl=null;
		ListToStringConversion conversionObj = new ListToStringConversion();
		String contactIdString = conversionObj.getStringList(contactIdList).toString();
		String reportIdString=conversionObj.getIntegerListString(reportIdList).toString();
		String qry=null;
		if((contactIdList==null)||(contactIdList.isEmpty())){
			throw new CustomFault("Please provide contact id which should not be null");
		}
		try{
			if((contactIdList!=null)&&(reportIdList!=null)){
				qry="select rm.reportId,rm.reportName,rm.reportDescription,sr.contactId,sr.fieldId,sr.fieldValue" +
				" from SavedReportEntity sr,ReportMasterListEntity rm" +
				" where rm.reportId=sr.reportId " +
				" and sr.contactId in ("+contactIdString+")  and rm.reportId in ('"+reportIdString+"')";
				Query query = session.createQuery(qry);
				Iterator iterator=query.list().iterator();
				Object[] result=null;
				while(iterator.hasNext()){
					HashMap<String,String> filterNameFieldValueMap=new HashMap<String,String>();
					result=(Object[])iterator.next();
					if(result[0]!=null){
						reportId=(Integer)result[0];
					}
					if(result[1]!=null){
						reportName=result[1].toString();
					}
					if(result[2]!=null){
						reportDescription=result[2].toString();
					}
					if(result[3]!=null){
						contactId=(ContactEntity)result[3];
					}
					if(result[4]!=null){
						fieldId=result[4].toString();
					}
					if(result[5]!=null){
						fieldValue=result[5].toString();
					}
					filterNameFieldValueMap.put(fieldId, fieldValue);
					impl=new SavedReportImpl();
					impl.setReportId(reportId);
					impl.setReportName(reportName);
					impl.setReportDescription(reportDescription);
					impl.setContactId(contactId.getContact_id());
					impl.setFilterNameFieldValue(filterNameFieldValueMap);
					listOfResponse.add(impl);
				}
			}


			else{
				qry="select rm.reportId,rm.reportName,rm.reportDescription,sr.contactId,sr.fieldId,sr.fieldValue" +
				" from SavedReportEntity sr,ReportMasterListEntity rm" +
				" where rm.reportId=sr.reportId " +
				" and sr.contactId in ("+contactIdString+") ";
				Query query = session.createQuery(qry);
				Iterator iterator=query.list().iterator();
				Object[] result=null;

				while(iterator.hasNext()){
					HashMap<String,String> filterNameFieldValueMap=new HashMap<String,String>();
					result=(Object[])iterator.next();
					if(result[0]!=null){
						reportId=(Integer)result[0];
					}
					if(result[1]!=null){
						reportName=result[1].toString();
					}
					if(result[2]!=null){
						reportDescription=result[2].toString();
					}
					if(result[3]!=null){
						contactId=(ContactEntity)result[3];
					}
					if(result[4]!=null){
						fieldId=result[4].toString();
					}
					if(result[5]!=null){
						fieldValue=result[5].toString();
					}
					filterNameFieldValueMap.put(fieldId, fieldValue);


					impl=new SavedReportImpl();
					impl.setReportId(reportId);
					impl.setReportName(reportName);
					impl.setReportDescription(reportDescription);
					impl.setContactId(contactId.getContact_id());
					impl.setFilterNameFieldValue(filterNameFieldValueMap);
					listOfResponse.add(impl);
				}
			}


		}
		finally {
			if (session.getTransaction().isActive()) {
				session.getTransaction().commit();
			}

			if (session.isOpen()) {
				session.flush();
				session.close();
			}

		}
		long endTimeTaken = System.currentTimeMillis();
		long totalTimeTaken = endTimeTaken - startTimeTaken;
		iLogger.info("totalTimeTaken  " + totalTimeTaken);
		iLogger.info("Exiting the getSavedReportService()");
		return listOfResponse;

	}
	// ********************END OF GET OF SAVE REPORTS*************************


	//******************** START OF SET SAVEDREPORTSERVICE*************************
	public String setSavedReportService(String contactId,Integer reportId,String reportName,HashMap<String,String>FilterNameFieldValue)throws CustomFault{
		//Logger fatalError1 = Logger.getLogger("Entering the setSavedReportService()");
		Logger fLogger = FatalLoggerClass.logger;
		//Logger bLogger = BusinessErrorLoggerClass.logger;
		Logger iLogger = InfoLoggerClass.logger;
		long startTimeTaken = System.currentTimeMillis();
		Session session1 = HibernateUtil.getSessionFactory().openSession();
		session1.beginTransaction();
		DomainServiceImpl DomainService = new DomainServiceImpl();
		ContactEntity contact = DomainService.getContactDetails(contactId);
		if(contact.getContact_id()==null){
			throw new CustomFault("contactId doesn't exist");
		}
		ReportMasterListEntity report = DomainService.getReportDetails(reportId);
		if(report.getReportId()==0){
			throw new CustomFault("reportId doesn't exist");
		}
		Object filter=null;
		String filterString=null;
		Object filterValue =null;
		String filterValueString=null;
		SavedReportEntity savedReportEntity =null;
		Map.Entry me =null;
		try {
			Query qry2 = session1
			.createQuery("from SavedReportEntity where contactId='"
					+ contactId + "' and reportId = '"+reportId+"'");
			Iterator itt2 = qry2.list().iterator();
			if (!itt2.hasNext()) {
				savedReportEntity = new SavedReportEntity();
				if (report != null) {
					savedReportEntity.setReportId(report);
				}
				if (contact != null) {
					savedReportEntity.setContactId(contact);
				}

				Iterator iterator = FilterNameFieldValue.entrySet().iterator();
				while (iterator.hasNext()) {
					me = (Map.Entry) iterator.next();
					filter = me.getKey();
					filterString = filter.toString();
					filterValue = me.getValue();
					filterValueString = filterValue.toString();
					if (filterString != null) {
						savedReportEntity.setFieldId(filterString);
					}
					if (filterValueString != null) {
						savedReportEntity.setFieldValue(filterValueString);
					}
					savedReportEntity.save();
				}

			}
			else{
				savedReportEntity=(SavedReportEntity)itt2.next();
				Iterator iterator=FilterNameFieldValue.entrySet().iterator();
				while(iterator.hasNext()){
					me=(Map.Entry)iterator.next();	            	
					filter=me.getKey();
					filterString=filter.toString();
					filterValue=me.getValue();
					filterValueString=filterValue.toString();
					savedReportEntity.setFieldId(filterString);
					savedReportEntity.setFieldValue(filterValueString);	 

					session1.update(savedReportEntity);	
				}

			}
		} catch (Exception e) {
			fLogger.fatal("Exception :"+e);
		}

		finally {
			if (session1.getTransaction().isActive()) {
				session1.getTransaction().commit();
			}

			if (session1.isOpen()) {
				session1.flush();
				session1.close();
			}

		}
		long endTimeTaken = System.currentTimeMillis();
		long totalTimeTaken = endTimeTaken - startTimeTaken;
		//	Logger fatalError2 = Logger.getLogger("totalTimeTaken  "
		//			+ totalTimeTaken);
		//	Logger fatalError = Logger
		//	.getLogger("Exiting the setSavedReportService()");
		return "SAVE COMPLETED";	

	}
	//END OF SET SAVEDREPORTSERVICE

	public ReportMasterListEntity getContactEntity(int reportId) {
		ReportMasterListEntity reportEntityobj = new ReportMasterListEntity(
				reportId);
		return reportEntityobj;
	}

	// ********************************** Get Machine Activity Details for the required set of VINs for the given Period ********************************************
	/** DefectID: DF20131014 - Rajani Nagaraju - Custom Dates Implementation
	 * DefectId: DF20131022 - Rajani Nagaraju - To display the VINs that has not communicated for the given time period 
	 * This method will return List of Machines with their activity details for the given period
	 * @param fromDate Start Date Period if the report is run for custom date selection
	 * @param toDate End Date Period if the report is run for custom date selection       
	 * @param Period Period can be 'Week','Month', 'Quarter', 'Year','Last Week','Last Month', 'Last Quarter', 'Last Year'
	 * @param MachineGroup_ID List of CustomAssetGroupIds
	 * @param MachineProfile_ID List of AssetGroup_ID
	 * @param Tenancy_ID List of Tenancy_ID for which VIN has to be returned
	 * @param Model_ID List of AssetType_ID
	 * @param MachineGroupType_ID List of Custom Asset Group Type Id
	 * @param LoginId User LoginId
	 * @return machineActivityReportImpl: Returns List of Machines with their activity details
	 */

	//Added custom Dates by Juhi on 12-August-2013
	public List<MachineActivityReportImpl> getMachineActivityReportList(String fromDate,String toDate,String Period, List<Integer> MachineGroup_ID,
			List<Integer> MachineProfile_ID, List<Integer> Tenancy_ID,
			List<Integer> Model_ID, List<Integer> MachineGroupType_ID,
			String LoginId, boolean isGroupingOnAssetGroup ) 
			{

		List<MachineActivityReportImpl> machineActivityReportImpl = new LinkedList<MachineActivityReportImpl>();
		Logger fLogger = FatalLoggerClass.logger;
		Logger bLogger = BusinessErrorLoggerClass.logger;
		Logger iLogger = InfoLoggerClass.logger;
		String basicFromQuery = null;
		String statusQuery=null;
		String basicSelectQuery = null;
		String basicWhereQuery = null;
		String serialNumber=null;
		String finalQuery = null;
		String status=null;
		boolean machineGroup= false;
		String currentStatus=null;
		Timestamp transactionTime2=null;
		long Duration_In_Current_Status=(long)0;

		String basicGroupbyQuery = " group by a.serialNumber ";

		//------ Get Current Date to get the Field - Duration in Current Status
		SimpleDateFormat sp = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		//DefectId: 1430 - Rajani Nagaraju - 20131009 - To get correct data for Duration in current status
		sp.setTimeZone(TimeZone.getTimeZone("GMT"));
		String timeStamp = sp.format(Calendar.getInstance().getTime());
		Timestamp sysDate=Timestamp.valueOf(timeStamp);

		ListToStringConversion conversionObj = new ListToStringConversion();
		Session session = HibernateUtil.getSessionFactory().getCurrentSession();
		session.beginTransaction();
		//------- Get the List of TenancyIds all down the hierarchy
		Tenancy_ID = getSubTenancyIds(Tenancy_ID,session);   
		String tenancyIdStringList = conversionObj.getIntegerListString(Tenancy_ID).toString();


		try
		{
			//Check for Mandatory Parameters
			if (LoginId == null) 
			{
				throw new CustomFault("Please pass a LoginId");
			}
			if (Tenancy_ID == null) {
				bLogger.error("Please pass a Tenancy_ID");
				throw new CustomFault("Please pass a Tenancy_ID");

			}

			//DefectID: DF20131014 - Rajani Nagaraju - Custom Dates Implementation
			if(Period !=null)
			{
				basicSelectQuery = " select a.machineHours as totalMachineLifeHours, a.Address, "+
				" (a.EngineRunningBand1+a.EngineRunningBand2+a.EngineRunningBand3+a.EngineRunningBand4+a.EngineRunningBand5+a.EngineRunningBand6+a.EngineRunningBand7+a.EngineRunningBand8) as machineHours, "+
				" b.tenancyId,b.tenancyName, x, cu.group_id as machineGroupId, cu.group_name as machineGroupName ";

				//Defect ID:1406 (Smitha oct 4th 2013) machine grouping

				basicFromQuery = " from AssetCustomGroupMapping h RIGHT OUTER JOIN h.serial_number x  LEFT OUTER JOIN h.group_id cu," +
				" TenancyDimensionEntity b, ";
				//end Defect ID:1406

				basicWhereQuery = " where a.tenancyId = b.tenacy_Dimension_Id and b.tenancyId in ("+tenancyIdStringList+" ) " +
				" and x.serial_number = a.serialNumber ";

				int year =0;int week = 0; int quarter = 0;int month =0;
				DateUtil thisDate =new DateUtil().getCurrentDateUtility(new Date());
				DateUtil prevDate = new DateUtil().getPreviousDateUtility(new Date());

				if (Period.equalsIgnoreCase("Week")) 
				{
					week =   thisDate.getWeek();
					year = thisDate.getYear();
					//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
					basicFromQuery = basicFromQuery + " AssetMonitoringFactDataWeekAgg a ";
					//end Defect ID:1406
					basicWhereQuery = basicWhereQuery+ " and a.timeCount =  "+week +" and a.year=" + year;
				} 

				else if (Period.equalsIgnoreCase("Last Week")) 
				{
					week =   prevDate.getWeek();
					if(thisDate.getWeek()==1)
					{
						year = prevDate.getYear();
					}

					else
					{
						year = prevDate.getCurrentYear();
					}

					//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
					basicFromQuery = basicFromQuery + " AssetMonitoringFactDataWeekAgg a ";
					//end Defect ID:1406
					basicWhereQuery = basicWhereQuery+ " and a.timeCount =  "+week +" and a.year=" + year;
				}	

				else if (Period.equalsIgnoreCase("Month")) 
				{
					month =   thisDate.getMonth();
					year = thisDate.getYear();

					//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
					basicFromQuery = basicFromQuery + " AssetMonitoringFactDataMonthAgg a ";
					//end Defect ID:1406
					basicWhereQuery = basicWhereQuery+ " and a.timeCount= "+ month + " and a.year=" + year;
				} 

				else if (Period.equalsIgnoreCase("Last Month")) 
				{
					month =  prevDate.getMonth();
					if(thisDate.getMonth()==1)
					{
						year = prevDate.getYear();
					}
					else
					{
						year = prevDate.getCurrentYear();
					}

					//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
					basicFromQuery = basicFromQuery + " AssetMonitoringFactDataMonthAgg a ";
					//end Defect ID:1406
					basicWhereQuery = basicWhereQuery+ " and a.timeCount= "+ month + " and a.year=" + year;
				}

				else if (Period.equalsIgnoreCase("Quarter")) 
				{
					quarter =   thisDate.getQuarter();
					year = thisDate.getYear();

					//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
					basicFromQuery = basicFromQuery + " AssetMonitoringFactDataQuarterAgg a ";
					//end Defect ID:1406
					basicWhereQuery = basicWhereQuery+ " and a.timeCount = "+ quarter + " and a.year=" + year;
				} 

				else if (Period.equalsIgnoreCase("Last Quarter")) 
				{
					quarter = prevDate.getQuarter();
					if(thisDate.getQuarter()==1)
					{
						year = prevDate.getYear();
					}
					else
					{
						year = prevDate.getCurrentYear();
					}

					//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
					basicFromQuery = basicFromQuery + " AssetMonitoringFactDataQuarterAgg a ";
					//end Defect ID:1406
					basicWhereQuery = basicWhereQuery+ " and a.timeCount = "+ quarter + " and a.year=" + year;
				} 

				else if (Period.equalsIgnoreCase("Year")) 
				{
					year = thisDate.getYear();

					//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
					basicFromQuery = basicFromQuery + " AssetMonitoringFactDataYearAgg a ";
					//end Defect ID:1406
					basicWhereQuery = basicWhereQuery+ " and a.year = "+year;
				}

				else if (Period.equalsIgnoreCase("Last Year")) 
				{
					year = prevDate.getYear();

					//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
					basicFromQuery = basicFromQuery + " AssetMonitoringFactDataYearAgg a ";
					//end Defect ID:1406
					basicWhereQuery = basicWhereQuery+ " and a.year = "+year;
				}

				if((isGroupingOnAssetGroup) )
					basicGroupbyQuery = basicGroupbyQuery + ", cu.group_id ";

			}

			//Logic for Custom Dates (fromDate,toDate) added by Juhi on 12-August-2013 
			//DefectID: DF20131014 - Rajani Nagaraju - Custom Dates Implementation
			else
			{
				DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
				String fromdateFormatted=null;
				String todateFormatted=null;

				try 
				{	
					fromdateFormatted= dateFormat.format(dateFormat.parse(fromDate));	
					todateFormatted = dateFormat.format(dateFormat.parse(toDate));	
				} 

				catch (ParseException e) 
				{
					e.printStackTrace();
				}

				if(fromdateFormatted==null || todateFormatted==null)
				{
					throw new CustomFault("Unparsable Date input for Custom dates");
				}

				basicSelectQuery = " select a.machineHours as totalMachineLifeHours, a.Address, "+
				" sum(u.EngineRunningBand1+u.EngineRunningBand2+u.EngineRunningBand3+u.EngineRunningBand4+u.EngineRunningBand5+u.EngineRunningBand6+u.EngineRunningBand7+u.EngineRunningBand8) as machineHours, "+
				" b.tenancyId,b.tenancyName, x, cu.group_id as machineGroupId, cu.group_name as machineGroupName ";

				basicFromQuery = " from AssetCustomGroupMapping h RIGHT OUTER JOIN h.serial_number x  LEFT OUTER JOIN h.group_id cu," +
				" TenancyDimensionEntity b, AssetMonitoringFactDataDayAgg a, AssetMonitoringFactDataDayAgg u ";

				basicWhereQuery = " where a.tenancyId = b.tenacy_Dimension_Id and b.tenancyId in ("+tenancyIdStringList+" ) " +
				" and x.serial_number = a.serialNumber " +
				" and a.serialNumber = u.serialNumber " + 
				" and a.timeKey = (select max(o.timeKey) from AssetMonitoringFactDataDayAgg o where o.serialNumber=a.serialNumber" +
				" and o.timeKey >='"+fromdateFormatted+"' and o.timeKey <= '"+todateFormatted+"')" +
				" and u.timeKey between '"+fromdateFormatted+"' and '"+todateFormatted+"'";

				basicGroupbyQuery = basicGroupbyQuery + ", cu.group_id, a.tenancyId ";

			}

			//Custom Asset Group Filter
			if (!(MachineGroup_ID == null || MachineGroup_ID.isEmpty())) 
			{
				String customAssetGroupStringList = conversionObj.getIntegerListString(MachineGroup_ID).toString();
				basicWhereQuery = basicWhereQuery+ " and cu.group_id in ("+ customAssetGroupStringList + ")";
				machineGroup = true;
			}

			if(machineGroup)
			{
				//Custom Asset Group Type
				if (!(MachineGroupType_ID == null || MachineGroupType_ID.isEmpty())) 
				{
					String machineGroupType_IDStringList = conversionObj.getIntegerListString(MachineGroupType_ID).toString();
					basicWhereQuery = basicWhereQuery + " and cu.asset_group_type in ( "+ machineGroupType_IDStringList + " )";
				}
			}

			//DefectID:DF20131014 - Rajani Nagaraju - DF20131014 - Query modification to return correct resultset
			if ((!(MachineProfile_ID == null || MachineProfile_ID.isEmpty()))	|| (!(Model_ID == null || Model_ID.isEmpty()))) 
			{
				basicFromQuery = basicFromQuery+ " , AssetClassDimensionEntity y ";
				basicWhereQuery = basicWhereQuery	+ " and a.assetClassDimensionId = y.assetClassDimensionId";
			}


			//DefectID:DF20131014 - Rajani Nagaraju - DF20131014 - Query modification to return correct resultset
			if (!(MachineProfile_ID == null || MachineProfile_ID.isEmpty())) 
			{
				String machineProfileIdStringList = conversionObj.getIntegerListString(MachineProfile_ID).toString();
				basicWhereQuery = basicWhereQuery + " and y.assetGroupId in ( "+ machineProfileIdStringList + ") ";

			}			

			//DefectID:DF20131014 - Rajani Nagaraju - DF20131014 - Query modification to return correct resultset
			if (!((Model_ID == null) || (Model_ID.isEmpty()))) 
			{
				String modelIdListStringList = conversionObj.getIntegerListString(Model_ID).toString();
				basicWhereQuery = basicWhereQuery + " and y.assetTypeId in ( "+ modelIdListStringList + " )";

			}

			finalQuery = basicSelectQuery + basicFromQuery + basicWhereQuery + basicGroupbyQuery ;

			//Changes dony by Juhi on 22 july2013 for decimal format
			DecimalFormat df2 = new DecimalFormat("###.#");

			Query query = session.createQuery(finalQuery);
			Object[] result = null;
			Iterator itr = query.list().iterator();

			MachineActivityReportImpl machineImpl =null;
			// DefectId: DF20131014 - Rajani Nagaraju - 20131014 - CustomDate Implementation 
			List<String> serialNumberList = new LinkedList<String>();

			while (itr.hasNext()) 
			{
				result = (Object[]) itr.next();

				serialNumber=null;
				machineImpl = new MachineActivityReportImpl();				

				AssetEntity asset =null;
				if(result[5]!=null)
				{					
					asset = (AssetEntity)result[5];
					serialNumber = asset.getSerial_number().getSerialNumber();
					machineImpl.setSerialNumber(serialNumber);
				}

				// DefectId:DF20131014 - Rajani Nagaraju - 20131014 - CustomDate Implementation 
				if( (!isGroupingOnAssetGroup) && (serialNumberList.contains(serialNumber))) 
				{
					continue;
				}
				else
				{
					serialNumberList.add(serialNumber);
				}

				if(result[0]!=null)
				{
					Double a = (Double) result[0];
					Double b =  a;
					machineImpl.setTotalMachineLifeHours(Double.valueOf(df2.format(b)));
				}

				if(result[1]!=null)
				{
					machineImpl.setLocation(result[1].toString());
				}				

				if(result[2]!=null)
				{
					double m = (Double) result[2];
					double MachineHours =  m;
					machineImpl.setMachineHours(Double.valueOf(df2.format(MachineHours)));
				}

				if(result[3]!=null)
				{
					machineImpl.setTenancy_ID((Integer) result[3]);
				}

				if(result[4]!=null)
				{
					machineImpl.setTenancyName(result[4].toString());
				}	

				if(result[6]!=null)
					machineImpl.setMachineGroup_Id((Integer)result[6]);

				if(result[7]!=null)
					machineImpl.setMachineGroup_Name(result[7].toString());

				//DefectID:DF20131014 - Rajani Nagaraju - 20131014 - Query modification to return correct resultset
				if(asset!=null)
				{
					if(asset.getProductId()!=null && asset.getProductId().getAssetGroupId()!=null)
					{
						machineImpl.setAssetGroup_ID(asset.getProductId().getAssetGroupId().getAsset_group_id());
						machineImpl.setProfileName(asset.getProductId().getAssetGroupId().getAsset_group_name());
					}

					if(asset.getProductId()!=null && asset.getProductId().getAssetTypeId()!=null)
					{
						machineImpl.setAssetTypeId(asset.getProductId().getAssetTypeId().getAsset_type_id());
						machineImpl.setAssetTypeName(asset.getProductId().getAssetTypeId().getAsset_type_name());
					}


				}

				//To get the current Status
				String qry=" select amd.parameterValue from AssetMonitoringDetailEntity amd where " +
				" amd.transactionNumber = (select max(a.transactionNumber) from AssetMonitoringHeaderEntity a where " +
				" a.transactionTime = (select max(a.transactionTime) from a where a.serialNumber in ('"+ serialNumber +"'))) " +
				" and amd.parameterId =(select m.parameterId from MonitoringParameters m where parameterName like 'ENGINE_ON')";
				Query qryyy=session.createQuery(qry);
				Iterator itrrr=qryyy.list().iterator();			
				while(itrrr.hasNext())
				{
					status=(String)itrrr.next();
					if(status!=null)
					{
						//Changes dony by Juhi on 20 july2013 for OFF/ON status
						if(status.equalsIgnoreCase("1"))
						{
							machineImpl.setStatus("Working");
						}
						else
						{
							machineImpl.setStatus("Off");
						}
					}
				}

				//---------------- To get Duration in Current Status
				Query qry4=null;
				if(status.equalsIgnoreCase("0"))
				{
					int present =0;

					statusQuery="select min(amhh.transactionTime) from AssetMonitoringHeaderEntity amhh,AssetMonitoringDetailEntity amdd,MonitoringParameters mp " +
					"where amhh.transactionNumber = amdd.transactionNumber and amhh.serialNumber in ('"+serialNumber+"') and amhh.transactionTime > (select max(amh.transactionTime)" +
					" from AssetMonitoringHeaderEntity amh,AssetMonitoringDetailEntity amd " +
					"where amh.transactionNumber = amd.transactionNumber and amh.transactionTime <=(select max(amh.transactionTime) from amh where amh.serialNumber in ('"+ serialNumber +"')) and amh.serialNumber in ('"+serialNumber+"') and amd.parameterId =(select m.parameterId from MonitoringParameters m where parameterName like 'ENGINE_ON')  and amd.parameterValue = '1') and amdd.parameterId =mp.parameterId and amdd.parameterValue = '0'";
					qry4=session.createQuery(statusQuery);
					List qry4List = qry4.list();
					Iterator itr4=qry4List.iterator();

					//DefectId: 1430 - Rajani Nagaraju - 20131009 - To get correct data for Duration in current status
					while(itr4.hasNext() && qry4List.size()>0 && qry4List.get(0)!=null)
					{						
						present=1;
						transactionTime2=(Timestamp)itr4.next();	
						Duration_In_Current_Status=(long)toDate1(sysDate)/ (1000 * 60)-(long)toDate1(transactionTime2)/ (1000 * 60);
						if(Duration_In_Current_Status!=0L)
						{
							machineImpl.setDuration_in_status(Duration_In_Current_Status);
						}

					}

					//DefectId: 1430 - Rajani Nagaraju - 20131009 - To get correct data for Duration in current status
					if(present==0)
					{
						statusQuery = "select min(transactionTime) from AssetMonitoringHeaderEntity where serialNumber='"+serialNumber+"'";
						Query qry10=session.createQuery(statusQuery);
						Iterator itr10=qry10.list().iterator();
						while(itr10.hasNext())
						{
							transactionTime2=(Timestamp)itr10.next();	
							Duration_In_Current_Status=(long)toDate1(sysDate)/ (1000 * 60)-(long)toDate1(transactionTime2)/ (1000 * 60);
							if(Duration_In_Current_Status!=0L)
							{
								machineImpl.setDuration_in_status(Duration_In_Current_Status);
							}

						}

					}
				}

				else
				{
					int pres=0;

					currentStatus="ON";
					statusQuery="select min(amhh.transactionTime) from AssetMonitoringHeaderEntity amhh,AssetMonitoringDetailEntity amdd,MonitoringParameters mp " +
					"where amhh.transactionNumber = amdd.transactionNumber and amhh.serialNumber in ('"+serialNumber+"') and amhh.transactionTime > (select max(amh.transactionTime)" +
					" from AssetMonitoringHeaderEntity amh,AssetMonitoringDetailEntity amd " +
					"where amh.transactionNumber = amd.transactionNumber and amh.transactionTime <=(select max(amh.transactionTime) from amh where amh.serialNumber in ('"+ serialNumber +"')) and amh.serialNumber in ('"+serialNumber+"') and amd.parameterId =(select m.parameterId from MonitoringParameters m where parameterName like 'ENGINE_ON')  and amd.parameterValue = '0') and amdd.parameterId =mp.parameterId and amdd.parameterValue = '1'";					
					qry4=session.createQuery(statusQuery);
					List qry4List = qry4.list();
					Iterator itr4=qry4List.iterator();

					//DefectId: 1430 - Rajani Nagaraju - 20131009 - To get correct data for Duration in current status
					while(itr4.hasNext() && qry4List.size()>0  && qry4List.get(0)!=null )
					{						
						pres=1;
						transactionTime2=(Timestamp)itr4.next();	

						Duration_In_Current_Status=(long)toDate1(sysDate)/ (1000 * 60)-(long)toDate1(transactionTime2)/ (1000 * 60);
						if(Duration_In_Current_Status!=0L)
						{
							machineImpl.setDuration_in_status(Duration_In_Current_Status);

						}

					}

					//DefectId: 1430 - Rajani Nagaraju - 20131009 - To get correct data for Duration in current status
					if(pres==0)
					{
						statusQuery = "select min(transactionTime) from AssetMonitoringHeaderEntity where serialNumber='"+serialNumber+"'";
						Query qry10=session.createQuery(statusQuery);
						Iterator itr10=qry10.list().iterator();
						while(itr10.hasNext())
						{
							transactionTime2=(Timestamp)itr10.next();	
							Duration_In_Current_Status=(long)toDate1(sysDate)/ (1000 * 60)-(long)toDate1(transactionTime2)/ (1000 * 60);
							if(Duration_In_Current_Status!=0L)
							{
								machineImpl.setDuration_in_status(Duration_In_Current_Status);
							}

						}
					}

				}

				machineActivityReportImpl.add(machineImpl);

			}

			return machineActivityReportImpl;
		} 

		catch(CustomFault e)
		{
			bLogger.error("Custom Fault: "+ e.getFaultInfo());
		}

		catch (Exception e) 
		{
			fLogger.fatal("Fatal Error: "+ e.getMessage());

		} 

		finally 
		{
			if (session.getTransaction().isActive()) 
			{
				session.getTransaction().commit();
			}

			if (session.isOpen()) 
			{
				session.flush();
				session.close();
			}

		}

		return machineActivityReportImpl;
			}

	// *************************************** Get Machine Activity Details for the required set of VINs for the given Period *****************************************


	/**
	 * This method will return List of UnderUtilized Machines for given List of
	 * Tenancy and for filters if provided
	 * DefectID:273 - Modified by Rajani Nagaraju - Query Tweaking
	 * @param Tenancy_ID
	 *            : List of Tenancy_ID
	 * @param Period
	 *            :Period can be 'Today','Week','Month', 'Quarter', 'Year'
	 * @param MachineProfile_ID
	 *            :List of MachineProfile_ID
	 * @param Model_ID
	 *            :List of Model_ID
	 * @param MachineGroupType_ID
	 *            :List of MachineGroupType_ID
	 * @param MachineGroup_ID
	 *            :List of MachineGroup_ID
	 * @return underUtilizedList: Returns List of UnderUtilized Machines
	 * @throws CustomFault
	 *             :custom exception is thrown when Period,Tenancy_ID is not
	 *             specified, Tenancy ID is invalid or not specified
	 */
	
	//DF20160801 @Roopa twaeking the UnderUtilizedMachines query to increase the performance
	public List<UnderUtilizedMachinesImpl> getUnderUtilizedMachinesObj(String loginID,
			List<Integer> Tenancy_ID, String Period,
			List<Integer> MachineProfile_ID, List<Integer> Model_ID,
			List<Integer> MachineGroupType_ID, List<Integer> MachineGroup_ID)
			throws CustomFault {
		Logger fLogger = FatalLoggerClass.logger;
		//Logger bLogger = BusinessErrorLoggerClass.logger;
		Logger iLogger = InfoLoggerClass.logger;
		long startTime = System.currentTimeMillis();
		List<UnderUtilizedMachinesImpl> underUtilizedList = new LinkedList<UnderUtilizedMachinesImpl>();

		String basicFromQuery = null;
		String basicSelectQuery = null;
		String basicWhereQuery = null;
		String orderByQuery = null;
		String finalQuery = null;

		Session session = HibernateUtil.getSessionFactory().openSession();
		//session.beginTransaction();

		ListToStringConversion conversionObj = new ListToStringConversion();
		String tenancyIdStringList = conversionObj.getIntegerListString(Tenancy_ID).toString();

		
		int tenancyId=Tenancy_ID.get(0);

		try {
			//			get the machine groups of logged-in user
			if ((MachineGroupType_ID == null || MachineGroupType_ID.isEmpty())
					&& (MachineGroup_ID == null || MachineGroup_ID.isEmpty())) {

				Query query = session.createQuery("from GroupUserMapping where contact_id='"+ loginID + "'");
				Iterator itr = query.list().iterator();
				MachineGroup_ID = new ArrayList<Integer>();
				while (itr.hasNext()) {
					GroupUserMapping groupUser = (GroupUserMapping) itr.next();
					MachineGroup_ID.add(groupUser.getGroup_id().getGroup_id());
				}
			}
			
              AccountEntity account=null;
              
              
			
            //Df20180129 @Roopa Multiple BP code changes--Taking the list of users that are mapped to given account code, based on Mapping code
			/*Query accountQ = session.createQuery(" select at.account_id from AccountTenancyMapping at where at.tenancy_id="+tenancyId+" ");
			Iterator accItr = accountQ.list().iterator();
			if(accItr.hasNext())
			{
				account = (AccountEntity)accItr.next();
			}*/
              
              List<Integer> accountIdList=new ArrayList<Integer>();
              
              Query accountQ = session.createQuery(" select at.account_id from AccountTenancyMapping at where at.tenancy_id in("+tenancyIdStringList+") ");
  			Iterator accItr = accountQ.list().iterator();
  			while(accItr.hasNext())
  			{
  				account = (AccountEntity)accItr.next();
  				accountIdList.add(account.getAccount_id());
  			}
  			
  			String acccountIdStringList = conversionObj.getIntegerListString(accountIdList).toString();
			
			//			Keerthi : selecting distinct PINs : 11/03/14
			basicSelectQuery = "select distinct(a.serialNumber),"
				+ "(a.EngineRunningBand1+a.EngineRunningBand2+a.EngineRunningBand3+a.EngineRunningBand4+a.EngineRunningBand5+a.EngineRunningBand6+a.EngineRunningBand7+a.EngineRunningBand8) as workingTime ,"
				+ " a.engineOffHours ,"
				+ " (((a.EngineRunningBand1+a.EngineRunningBand2+a.EngineRunningBand3+a.EngineRunningBand4+a.EngineRunningBand5+a.EngineRunningBand6+a.EngineRunningBand7+a.EngineRunningBand8)/24)*100) as workingTimePercentage";

			/*basicWhereQuery = " where a.tenancyId = b.tenacy_Dimension_Id and b.tenancyId in ("
				+ tenancyIdStringList + " )";

			if (Period.equalsIgnoreCase("Today")) {
				basicFromQuery = " from AssetMonitoringFactDataDayAgg a,TenancyDimensionEntity b ,AccountTenancyMapping atm,AssetEntity asset ";
				basicWhereQuery = basicWhereQuery
				+ " and a.timeKey = (select max(timeKey) from AssetMonitoringFactDataDayAgg w where "
				+ " w.serialNumber = a.serialNumber) and atm.tenancy_id in ("
				+ tenancyIdStringList + " ) and atm.account_id=asset.primary_owner_id  and a.serialNumber=asset.serial_number";
				orderByQuery = " order by a.engineOffHours ";
			}*/
			//Df20170620 @Roopa Pointing to right dayagg table
			if (Period.equalsIgnoreCase("Today")) {
					/*basicFromQuery = " from AssetMonitoringFactDataDayAgg_json a, AssetEntity asset ";
					basicWhereQuery = " where asset.primary_owner_id="+account.getAccount_id()+" and a.serialNumber=asset.serial_number and a.timeKey = (select max(timeKey) from AssetMonitoringFactDataDayAgg_json w where "
					+ " w.serialNumber = a.serialNumber)";
					orderByQuery = " order by a.engineOffHours ";*/
				
				basicFromQuery = " from AssetMonitoringFactDataDayAgg_json a, AssetEntity asset ";
				basicWhereQuery = " where asset.primary_owner_id in("+acccountIdStringList+") and a.serialNumber=asset.serial_number and a.timeKey = (select max(timeKey) from AssetMonitoringFactDataDayAgg_json w where "
				+ " w.serialNumber = a.serialNumber)";
				orderByQuery = " order by a.engineOffHours ";
				}

			if (!(MachineGroup_ID == null || MachineGroup_ID.isEmpty())) {

				String MachineGroup_IDStringList = conversionObj
				.getIntegerListString(MachineGroup_ID).toString();
				iLogger.info(" MachineGroup_IDStringList +"
						+ MachineGroup_IDStringList);
				basicFromQuery = basicFromQuery
				+ " ,AssetCustomGroupMapping m,CustomAssetGroupEntity cu";
				basicWhereQuery = basicWhereQuery
				+ " and a.serialNumber=m.serial_number and m.group_id=cu.group_id and  cu.group_id in ( "
				+ MachineGroup_IDStringList + " )";
			}

			finalQuery = basicSelectQuery + basicFromQuery + basicWhereQuery
			+ orderByQuery;
			UnderUtilizedMachinesImpl underUtilizedMachinesImpl = null;
			Query query = session.createQuery(finalQuery);
			Object[] result = null;
			Iterator itr = query.list().iterator();
			DecimalFormat decFormat = new DecimalFormat("####.##");
			while (itr.hasNext()) {
				result = (Object[]) itr.next();
				underUtilizedMachinesImpl = new UnderUtilizedMachinesImpl();
				if (result[0] != null) {
					underUtilizedMachinesImpl.setSerial_no(result[0].toString());
				}
				if (result[1] != null) {
					underUtilizedMachinesImpl.setWorking_Time(Double.valueOf(decFormat.format((Double)(result[1]))));
				}
				if (result[2] != null) {
					underUtilizedMachinesImpl.setEngine_Off_Hours_Perct(Double.valueOf(decFormat.format((Double)(result[2]))));
				}
				if (result[3] != null) {
					underUtilizedMachinesImpl.setWorkingTimePercentage(Double.valueOf(decFormat.format((Double)(result[3]))));
				}
				underUtilizedList.add(underUtilizedMachinesImpl);
			}

			long endTime = System.currentTimeMillis();
			iLogger.info("service time" + (endTime - startTime));

		} catch (Exception e) {
			e.printStackTrace();
			fLogger
			.fatal("Hello this is an Fatal Error. Need immediate Action"
					+ e.getMessage());

		} finally {
			/*if (session.getTransaction().isActive()) {
				session.getTransaction().commit();
			}*/

			if (session.isOpen()) {
				//session.flush();
				session.close();
			}

		}
		return underUtilizedList;
	}

	// ********************START OF SET REPORT
	// SUBSCRIPTION*************************
	public CatalogValuesEntity getCatalogValues(int catalogValueId) {
		CatalogValuesEntity catalogValuesEntity = new CatalogValuesEntity(
				catalogValueId);
		return catalogValuesEntity;
	}

	/**
	 * 
	 * @param contactId is given to set the vales.
	 * @param reportName the name of the report on which the set opration should be done
	 * @param WeeklyReportSubscription is taken as boolean on which the values need to be set on the basis of true value given.
	 * @param monthlyReportSubscription is taken as boolean on which the values need to be set on the basis of true value given.
	 * @return SUCCESS if the values are set successfully
	 */
	public  String setreportSubscriptionService(List<ReportSubscriptionRespContract> respContractList) {

		long startTime = System.currentTimeMillis();List<Integer> newCatalogValueIds =new ArrayList<Integer>();
		Map<Integer,HashMap<Integer,Integer>> catlogMap = new HashMap<Integer, HashMap<Integer,Integer>>();
		Session session = HibernateUtil.getSessionFactory().getCurrentSession();
		session.beginTransaction(); 
		HashMap<Integer,Integer> valueMap = null;
		
		Logger iLogger = InfoLoggerClass.logger;
		try
		{
			List<Integer> reportIdList=new LinkedList<Integer>();
			Iterator itt=respContractList.iterator();
			while(itt.hasNext())
			{
				ReportSubscriptionRespContract cn=(ReportSubscriptionRespContract)itt.next();
				reportIdList.add(cn.getReportId());
			}

			ListToStringConversion conversionObj2 = new ListToStringConversion();
			String reportIdString = conversionObj2.getIntegerListString(reportIdList).toString();

			//			get all event names along with their catalog value ids in hashmap
			Query q = session.createQuery("select e1.reportId,c2.catalogValueId,c2.catalogId from ReportMasterListEntity e1,CatalogValuesEntity c2 where e1.reportId in("+reportIdString+") and e1.reportName=c2.catalogValue");
			Iterator iterat = q.list().iterator(); Object[] result = null;
			while(iterat.hasNext()){
				result = (Object[]) iterat.next();
				PreferenceCatalogEntity pce = (PreferenceCatalogEntity)result[2];
				int catalogId = pce.getCatalogId();
				int catalogValueId=(Integer)result[1];
				int reportId = (Integer)result[0];

				if(catlogMap.containsKey(reportId)){
					valueMap=catlogMap.get((Integer)result[0]);
					if(!valueMap.containsKey(catalogId)){
						valueMap.put(catalogId,catalogValueId );
					}
					catlogMap.remove(reportId);
					catlogMap.put(reportId, valueMap);
				}
				else{
					valueMap = new HashMap<Integer, Integer>();
					valueMap.put(catalogId,catalogValueId );
					catlogMap.put((Integer)result[0], valueMap);
				}
			}

			//iterate over response
			ReportSubscriptionRespContract respObj1 = null;
			Iterator<ReportSubscriptionRespContract> listIter1 = respContractList.iterator();
			String loginId=null;
			while(listIter1.hasNext()){
				respObj1 = listIter1.next();
				loginId = respObj1.getContactId();
				if(respObj1.isWeeklyReportSubscription()){				
					newCatalogValueIds.add(catlogMap.get(respObj1.getReportId()).get(11));

				}
				if(respObj1.isMonthlyReportSubscription()){	
					newCatalogValueIds.add(catlogMap.get(respObj1.getReportId()).get(12));


				}
			}
			//		get all existing catalog id values for user
			List<Integer> existingCatalogIdValues = new ArrayList<Integer>();
			Query qu = session.createQuery("select pe.catalogValueId from PreferenceEntity pe,CatalogValuesEntity cve where pe.contact='"+loginId+"' and pe.catalogValueId = cve.catalogValueId" +
			" and cve.catalogId in (11,12)");
			Iterator itr = qu.list().iterator();
			PreferenceEntity prefEntity = null;
			CatalogValuesEntity cvEntity = null;
			while (itr.hasNext()) {

				cvEntity = (CatalogValuesEntity) itr.next();
				existingCatalogIdValues.add(cvEntity.getCatalogValueId());

			}

			session.close();
			session = HibernateUtil.getSessionFactory().getCurrentSession();
			session.beginTransaction();
			List<Integer> differList1 = new ArrayList<Integer>();
			differList1.addAll(newCatalogValueIds);
			differList1.removeAll(existingCatalogIdValues); //add this list

			Iterator<Integer> iterIds = differList1.iterator();
			cvEntity = null;
			while(iterIds.hasNext()){
				PreferenceEntity pe=new PreferenceEntity();
				pe.setContact(new ContactEntity(loginId));
				cvEntity = new CatalogValuesEntity();
				cvEntity.setCatalogValueId(iterIds.next());
				pe.setCatalogValueId(cvEntity);				
				pe.save();
			}
			if(session!=null && session.isOpen()){
				if(session.getTransaction().isActive())
				{      
					session.getTransaction().commit();
				}
				if(session.isOpen())
				{ session.flush();
				session.close();
				} 
			}		

			session = HibernateUtil.getSessionFactory().getCurrentSession();
			session.beginTransaction();  
			differList1 = new ArrayList<Integer>();
			differList1.addAll(existingCatalogIdValues);
			differList1.removeAll(newCatalogValueIds);//delete these
			ListToStringConversion conversionObj = new ListToStringConversion();
			String catlogValueIds =null;
			if(differList1!=null && differList1.size()>0){

				catlogValueIds = conversionObj.getIntegerListString(differList1).toString();
			}
			//delete these
			Query qu2 = session.createQuery("delete from PreferenceEntity where catalogValueId in ("+ catlogValueIds +") and contact ='"+loginId+"'  ");
			int row1= qu2.executeUpdate();	
		}
		finally
		{
			if(session!=null && session.isOpen()){
				if(session.getTransaction().isActive())
				{      
					session.getTransaction().commit();
				}
				if(session.isOpen())
				{ session.flush();
				session.close();
				} 
			}

		}
		long endTime=System.currentTimeMillis();
		iLogger.info("Total execution time "+ String.valueOf(endTime-startTime)+ "(ms)");
		return "Success";


	}


	public PreferenceCatalogEntity PreferenceCatalogEntity(int catalogId)
	{
		PreferenceCatalogEntity prefcatalogValObj = new PreferenceCatalogEntity(
				catalogId);

		if (prefcatalogValObj != null && prefcatalogValObj.getCatalogId() != 0)

			return prefcatalogValObj;

		else
			return null;
	}
	public CatalogValuesEntity getCatalogValuesEntity(int eventTypeId)

	{

		CatalogValuesEntity catalogValObj=new CatalogValuesEntity(eventTypeId);

		if(catalogValObj!=null && catalogValObj.getCatalogValueId()!=0)

			return catalogValObj;

		else

			return null;

	}


	// END OF SET REPORT SUBSCRIPTION

	/**
	 * method to get machine alerts trend data for specified zones
	 * 
	 * @param tenancy
	 *            id list
	 * @param period
	 * @return MachineAlertsTrendDataImpl
	 */
	public MachineAlertsTrendDataImpl getMachineAlertsTrendData(String fromDate,String toDate,
			List<Integer> tenancyIdList,
			String period) {
		//Logger fLogger = FatalLoggerClass.logger;
		
		Logger iLogger = InfoLoggerClass.logger;
		long startTime = System.currentTimeMillis();
		Session session = HibernateUtil.getSessionFactory().getCurrentSession();
		session.beginTransaction();

		ListToStringConversion conversionObj = new ListToStringConversion();
		String tenancyIdStringList = conversionObj.getIntegerListString(
				tenancyIdList).toString();

		MachineAlertsTrendDataImpl dataObj = new MachineAlertsTrendDataImpl();

		String basicFromQuery = null;
		String basicSelectQuery = null;
		String basicWhereQuery = null;
		String groupByQuery = null;
		String finalQuery = null;
		int year = 0;
		int week = 0;
		int quarter = 0;
		int month = 0;
		DateUtil dateUtil1 = new DateUtil();
		DateUtil thisDate = dateUtil1.getCurrentDateUtility(new Date());
		DateUtil dateUtil2 = new DateUtil();
		DateUtil prevDate = dateUtil2.getPreviousDateUtility(new Date());
		HashMap<Integer, String> zoneMap = new HashMap<Integer, String>();
		List<Integer> dealerIdList = new ArrayList<Integer>();
		HashMap<String, HashMap<String, Long>> trendData = new HashMap<String, HashMap<String, Long>>();
		try {

			// get zone names here
			basicSelectQuery = "SELECT te.tenancy_id,te.tenancy_name FROM TenancyEntity te"
				+ " WHERE te.tenancy_id IN (" + tenancyIdStringList + ")";

			Query query = session.createQuery(basicSelectQuery);
			Iterator iterator = query.list().iterator();
			Object[] result = null;

			String zoneName = null;
			int zoneId = 0;
			while (iterator.hasNext()) {
				result = (Object[]) iterator.next();
				if (result[0] != null) {
					zoneId = (Integer) result[0];
				}
				if (result[1] != null) {
					zoneName = (String) result[1];
				}
				zoneMap.put(zoneId, zoneName);
			}
			// for each zone get dealers here
			Iterator<Integer> zoneIterator = tenancyIdList.iterator();
			while (zoneIterator.hasNext()) {
				zoneId = zoneIterator.next();
				iLogger.info("zone id : " + zoneId);
				basicSelectQuery = "SELECT te.tenancy_id,te.tenancy_name"
					+ " FROM TenancyEntity te"
					+ " WHERE te.parent_tenancy_id = "
					+ zoneId
					+ " AND te.tenancy_type_id =3";
				zoneName = zoneMap.get(zoneId);
				dealerIdList = new ArrayList<Integer>();
				query = session.createQuery(basicSelectQuery);
				Iterator itr = query.list().iterator();
				int dealerId = 0;
				String dealerName = null;
				result = null;
				HashMap<Integer, String> dealerMap = new HashMap<Integer, String>();
				while (itr.hasNext()) {
					result = (Object[]) itr.next();
					if (result[0] != null) {
						dealerId = (Integer) result[0];
						dealerIdList.add(dealerId);
					}
					if (result[1] != null) {
						dealerName = (String) result[1];
					}
					dealerMap.put(dealerId, dealerName);
				}
				if(dealerIdList.size()>0){
					String dealerIdString = conversionObj.getIntegerListString(
							dealerIdList).toString();
					iLogger.info("dealer id string " + dealerIdString);

					basicSelectQuery = "SELECT t1.parentId,SUM(t3.NotificationCount)";
					basicFromQuery = " FROM  TenancyBridgeEntity  t1, TenancyDimensionEntity t2,NotificationDimensionEntity t4, ";
					basicWhereQuery = " WHERE t1.parentId in("
						+ dealerIdString
						+ ") AND t1.childId=t2.tenancyId AND t2.tenacy_Dimension_Id=t3.Tenancy_Id"
						+ " AND t4.Notification_Type_Name in ('Service','Health','Security') AND t4.Notification_Dimension_Id = t3.Notification_Id";
					groupByQuery = " GROUP BY t1.parentId";

					if (fromDate == null && toDate == null) {
						if (period.equalsIgnoreCase("Week")) {
							week = thisDate.getWeek();
							year = thisDate.getYear();
							basicFromQuery = basicFromQuery
							+ " notification_fact_weekagg t3 ";

							basicWhereQuery = basicWhereQuery
							+ " and t3.TimeCount = " + week
							+ " and t3.Year=" + year;
						} else if (period.equalsIgnoreCase("Last Week")) {
							week = prevDate.getWeek();
							if (thisDate.getWeek() == 1) {
								year = prevDate.getYear();
							} else {
								year = prevDate.getCurrentYear();
							}

							basicFromQuery = basicFromQuery
							+ " notification_fact_weekagg t3 ";

							basicWhereQuery = basicWhereQuery
							+ " and t3.TimeCount = " + week
							+ " and t3.Year=" + year;
						}

						else if (period.equalsIgnoreCase("Month")) {
							month = thisDate.getMonth();
							year = thisDate.getYear();
							basicFromQuery = basicFromQuery
							+ " notification_fact_Monthagg t3 ";
							basicWhereQuery = basicWhereQuery
							+ " and t3.TimeCount = " + month
							+ " and t3.Year=" + year;

						} else if (period.equalsIgnoreCase("Last Month")) {
							month = prevDate.getMonth();
							if (thisDate.getMonth() == 1) {
								year = prevDate.getYear();
							} else {
								year = prevDate.getCurrentYear();
							}

							basicFromQuery = basicFromQuery
							+ " notification_fact_Monthagg t3 ";
							basicWhereQuery = basicWhereQuery
							+ " and t3.TimeCount = " + month
							+ " and t3.Year=" + year;
						} else if (period.equalsIgnoreCase("Quarter")) {
							quarter = thisDate.getQuarter();
							year = thisDate.getYear();
							basicFromQuery = basicFromQuery
							+ " notification_fact_Quarteragg t3 ";
							basicWhereQuery = basicWhereQuery
							+ " and t3.TimeCount  = " + quarter
							+ " and t3.Year=" + year;

						} else if (period.equalsIgnoreCase("Last Quarter")) {
							quarter = prevDate.getQuarter();
							if (thisDate.getQuarter() == 1) {
								year = prevDate.getYear();
							} else {
								year = prevDate.getCurrentYear();
							}
							basicFromQuery = basicFromQuery
							+ " notification_fact_Quarteragg t3 ";
							basicWhereQuery = basicWhereQuery
							+ " and t3.TimeCount  = " + quarter
							+ " and t3.Year=" + year;

						} else if (period.equalsIgnoreCase("Year")) {
							year = thisDate.getYear();
							basicFromQuery = basicFromQuery
							+ " notification_fact_Yearagg t3 ";
							basicWhereQuery = basicWhereQuery + " and t3.Year= "
							+ year;
						} else if (period.equalsIgnoreCase("Last Year")) {
							year = prevDate.getYear();
							basicFromQuery = basicFromQuery
							+ " notification_fact_Yearagg t3 ";
							basicWhereQuery = basicWhereQuery + " and t3.Year= "
							+ year;
						}
					} else {
						//						Keerthi : 20/12/2013 : custom date changes
						basicFromQuery = basicFromQuery
						+ " NotificationFactEntity_DayAgg t3 ";
						basicWhereQuery = basicWhereQuery
						+ " and t3.Time_Key between '" + fromDate
						+ "%' and '" + toDate + "%' ";
						//						Commented foll line by Keerthi : 15/10/13 : grouping only by dealer name
						//						groupByQuery = groupByQuery	+ " , t3.Time_Key,t3.Tenancy_Id";
					}
					finalQuery = basicSelectQuery + basicFromQuery
					+ basicWhereQuery + groupByQuery;

					iLogger.info("Query getMachineTrendData: " + finalQuery);

					query = session.createQuery(finalQuery);
					itr = query.list().iterator();
					result = null;
					List<Integer> dealerResultList = new ArrayList<Integer>();
					Long totalAlerts = 0L;
					String dealer = null;

					HashMap<String, Long> dealerData = null, tempDealerData = new HashMap<String, Long>();
					while (itr.hasNext()) {
						result = (Object[]) itr.next();

						if (result[0] != null) {
							dealerId = (Integer) result[0];
							dealerResultList.add((Integer) result[0]);
						}
						if (result[1] != null) {
							totalAlerts = (Long) result[1];
						}
						if (!trendData.containsKey(zoneName)) {
							dealerData = new HashMap<String, Long>();
							dealerData.put(dealerMap.get(dealerId), totalAlerts);
							trendData.put(zoneName, dealerData);
						} else if (trendData.containsKey(zoneName)) {
							dealerData = trendData.get(zoneName);
							dealerData.put(dealerMap.get(dealerId), totalAlerts);
							trendData.remove(zoneName);
							trendData.put(zoneName, dealerData);
						}
					}
					// set zero for other dealers
					Iterator<Integer> iterDealer = dealerIdList.iterator();
					while (iterDealer.hasNext()) {
						dealerId = iterDealer.next();
						if (!dealerResultList.contains(dealerId)) {
							tempDealerData = trendData.get(zoneName);
							if (tempDealerData == null) {
								tempDealerData = new HashMap<String, Long>();
							}
							tempDealerData.put(dealerMap.get(dealerId), 0l);
							trendData.remove(zoneName);
							trendData.put(zoneName, tempDealerData);
						}
					}
				}

			}
			dataObj.setTrendData(trendData);

		} finally {
			if (session.getTransaction().isActive()) {
				session.getTransaction().commit();
			}
			if (session.isOpen()) {
				session.flush();
				session.close();
			}
		}
		long endTime = System.currentTimeMillis();
		iLogger.info("Total execution time "
				+ String.valueOf(endTime - startTime) + "(ms)");

		return dataObj;

	}

	/**
	 * method to get machine alerts trend data for all zones
	 * 
	 * @param period
	 * @return List<MachineAlertsTrendDataImpl>
	 */
	public List<MachineAlertsTrendDataImpl> getMachineAlertsTrendDataForAllZones(String fromDate,String toDate,
			List<Integer> tenancyIdList, String period) {
		
		Logger iLogger = InfoLoggerClass.logger;
		long startTime = System.currentTimeMillis();
		Session session = HibernateUtil.getSessionFactory().getCurrentSession();
		session.beginTransaction();

		ListToStringConversion conversionObj = new ListToStringConversion();
		String tenancyIdStringList = conversionObj.getIntegerListString(tenancyIdList).toString();

		MachineAlertsTrendDataImpl dataObj = new MachineAlertsTrendDataImpl();
		List<MachineAlertsTrendDataImpl> machineTrendDataList = new ArrayList<MachineAlertsTrendDataImpl>();
		String basicFromQuery = null;
		String basicSelectQuery = null;
		String basicWhereQuery = null;
		String groupByQuery = null;
		String orderByQuery = null;
		String finalQuery = null;
		int year =0;int week = 0; int quarter = 0;int month =0;
		DateUtil dateUtil1 = new DateUtil();
		DateUtil thisDate =dateUtil1.getCurrentDateUtility(new Date());
		DateUtil dateUtil2 = new DateUtil();
		DateUtil prevDate = dateUtil2.getPreviousDateUtility(new Date());
		//		Keerthi : 11/09/14 : y-axis of the graph : names in asc order for all graphs
		TreeMap<String, Integer> zoneMap = new TreeMap<String, Integer>();
		TreeMap<String, Long> resultMap = new TreeMap<String, Long>();
		try {
			//get zone names here
			basicSelectQuery ="SELECT te.tenancy_id,te.tenancy_name FROM TenancyEntity te" +
			" WHERE te.tenancy_id IN ("+tenancyIdStringList+")";

			Query query = session.createQuery(basicSelectQuery);
			Iterator iterator = query.list().iterator();
			Object[] result = null;

			String zoneName = null;
			int zoneId=0;

			while(iterator.hasNext()){
				result = (Object[])iterator.next();
				if(result[0]!=null){
					zoneId =(Integer)result[0];
				}
				if(result[1]!=null){
					zoneName =(String)result[1];
				}
				zoneMap.put(zoneName, zoneId);
			}
			basicSelectQuery = "SELECT t1.parentId,SUM(t3.NotificationCount),t5.tenancy_name";
			basicFromQuery = " FROM  TenancyBridgeEntity  t1, TenancyDimensionEntity t2 ,NotificationDimensionEntity t4 , TenancyEntity t5,";
			basicWhereQuery = " WHERE t1.parentId in ("+tenancyIdStringList+") AND t1.parentId=t5.tenancy_id AND t1.childId=t2.tenancyId AND t2.tenacy_Dimension_Id=t3.Tenancy_Id"
			+ " AND t4.Notification_Type_Name in ('Service','Health','Security') AND t4.Notification_Dimension_Id = t3.Notification_Id";
			groupByQuery = " GROUP BY t1.parentId";
			orderByQuery = " ORDER BY t5.tenancy_name";
			if(fromDate == null && toDate==null){

				if (period.equalsIgnoreCase("Week")) {
					week =   thisDate.getWeek();
					year = thisDate.getYear();
					basicFromQuery = basicFromQuery+" notification_fact_weekagg t3 ";

					basicWhereQuery = basicWhereQuery	+ " and t3.TimeCount = "+week +" and t3.Year="+year;
				}
				else if (period.equalsIgnoreCase("Last Week")) {
					week =  prevDate.getWeek();
					if(thisDate.getWeek()==1){
						year = prevDate.getYear();
					}else{
						year = prevDate.getCurrentYear();
					}

					basicFromQuery = basicFromQuery+" notification_fact_weekagg t3 ";

					basicWhereQuery = basicWhereQuery	+ " and t3.TimeCount = "+week+" and t3.Year="+year;
				}

				else if (period.equalsIgnoreCase("Month")) {
					month =  thisDate.getMonth();
					year = thisDate.getYear();
					basicFromQuery = basicFromQuery+" notification_fact_Monthagg t3 ";
					basicWhereQuery = basicWhereQuery	+ " and t3.TimeCount = "	+ month+" and t3.Year="+year;

				}
				else if (period.equalsIgnoreCase("Last Month")) {
					month =  prevDate.getMonth();
					if( thisDate.getMonth()==1){
						year = prevDate.getYear();
					}else{
						year = prevDate.getCurrentYear();
					}

					basicFromQuery = basicFromQuery+" notification_fact_Monthagg t3 ";
					basicWhereQuery = basicWhereQuery	+ " and t3.TimeCount = "	+ month+" and t3.Year="+year;				
				}
				else if (period.equalsIgnoreCase("Quarter")) {
					quarter =  thisDate.getQuarter();
					year = thisDate.getYear();
					basicFromQuery = basicFromQuery+" notification_fact_Quarteragg t3 ";
					basicWhereQuery = basicWhereQuery	+ " and t3.TimeCount  = " +quarter+" and t3.Year="+year;

				}
				else if (period.equalsIgnoreCase("Last Quarter")) {
					quarter = prevDate.getQuarter();
					if(thisDate.getQuarter()==1){
						year = prevDate.getYear();
					}else{
						year = prevDate.getCurrentYear();
					}
					basicFromQuery = basicFromQuery+" notification_fact_Quarteragg t3 ";
					basicWhereQuery = basicWhereQuery	+ " and t3.TimeCount  = " +quarter+" and t3.Year="+year;

				}
				else if (period.equalsIgnoreCase("Year")) {
					year = thisDate.getYear();
					basicFromQuery = basicFromQuery+" notification_fact_Yearagg t3 ";
					basicWhereQuery = basicWhereQuery	+ " and t3.Year= "+year;
				}
				else if (period.equalsIgnoreCase("Last Year")) {
					year = prevDate.getYear();
					basicFromQuery = basicFromQuery+" notification_fact_Yearagg t3 ";
					basicWhereQuery = basicWhereQuery	+ " and t3.Year= "+year;
				}
			}
			else
			{
				//				Keerthi : 20/12/2013 : custom date changes
				basicFromQuery = basicFromQuery+" NotificationFactEntity_DayAgg t3 ";
				basicWhereQuery = basicWhereQuery+ " and t3.Time_Key between '"+fromDate+"%' and '"+toDate+"%' ";
				//					Commented foll line by Keerthi : 15/10/13 : grouping only by zone name
				//					groupByQuery = groupByQuery+" , t3.Time_Key,t3.Tenancy_Id";
			}

			finalQuery = basicSelectQuery + basicFromQuery + basicWhereQuery
			+ groupByQuery+orderByQuery;

			//			infoLogger.info("Query getMachineTrendData: " + finalQuery);

			query = session.createQuery(finalQuery);
			Iterator itr = query.list().iterator();
			result = null;
			Long totalAlerts = 0L;zoneName=null;zoneId = 0; 
			while (itr.hasNext()) {

				result = (Object[]) itr.next();
				dataObj = new MachineAlertsTrendDataImpl();
				if (result[0] != null) {
					zoneId = (Integer)result[0];
				}
				if (result[1] != null) {
					totalAlerts = (Long) result[1];
				}
				if (result[2] != null) {
					zoneName = (String) result[2];
				}
				resultMap.put(zoneName, totalAlerts);
			}

			//			iterate zone map and add values to list
			for(String zone: zoneMap.keySet()){
				dataObj = new MachineAlertsTrendDataImpl();
				if(resultMap.containsKey(zone)){					
					dataObj.setZoneName(zone);
					dataObj.setTotalAlerts(resultMap.get(zone));
				}
				else{
					dataObj.setZoneName(zone);
					dataObj.setTotalAlerts(0l);
				}
				machineTrendDataList.add(dataObj);
			}
		} finally {
			if (session.getTransaction().isActive()) {
				session.getTransaction().commit();
			}
			if (session.isOpen()) {
				session.flush();
				session.close();
			}
		}
		long endTime = System.currentTimeMillis();
		iLogger.info("Total execution time "
				+ String.valueOf(endTime - startTime) + "(ms)");

		return machineTrendDataList;
	}


	/**
	 * method to get machine hour meter trend data for specified zones
	 * 
	 * @param tenancy
	 *            id list
	 * @param period
	 * @return MachineHourMeterTrendDataReportImpl
	 */

	public MachineHourMeterTrendDataReportImpl getMachineHourMeterTrendData(String fromDate,String toDate,
			List<Integer> tenancyIdList, String period) {
		Logger fLogger = FatalLoggerClass.logger;
		//Logger bLogger = BusinessErrorLoggerClass.logger;
		Logger iLogger = InfoLoggerClass.logger;
		long startTime = System.currentTimeMillis();
		Session session = HibernateUtil.getSessionFactory().getCurrentSession();
		session.beginTransaction();

		ListToStringConversion conversionObj = new ListToStringConversion();
		String tenancyIdStringList = conversionObj.getIntegerListString(
				tenancyIdList).toString();

		MachineHourMeterTrendDataReportImpl dataObj = new MachineHourMeterTrendDataReportImpl();

		String basicFromQuery = null;
		String basicSelectQuery = null;
		String basicWhereQuery = null;
		String groupByQuery = null;
		String finalQuery = null;
		int year = 0;
		int week = 0;
		int quarter = 0;
		int month = 0, zoneId = 0;
		DateUtil dateUtil1 = new DateUtil();
		DateUtil thisDate = dateUtil1.getCurrentDateUtility(new Date());
		DateUtil dateUtil2 = new DateUtil();
		DateUtil prevDate = dateUtil2.getPreviousDateUtility(new Date());
		List<Integer> dealerIdList = null;
		HashMap<String, HashMap<String, Double>> trendData = new HashMap<String, HashMap<String, Double>>();
		HashMap<Integer, String> zoneMap = new HashMap<Integer, String>();
		DecimalFormat decimalFormat = new DecimalFormat("###.#");
		try {


			// get zone names here
			basicSelectQuery = "SELECT te.tenancy_id,te.tenancy_name FROM TenancyEntity te"
				+ " WHERE te.tenancy_id IN ("
				+ tenancyIdStringList
				+ ")";

			Query query = session.createQuery(basicSelectQuery);
			Iterator iterator = query.list().iterator();
			Object[] result = null;

			String zoneName = null;

			while (iterator.hasNext()) {
				result = (Object[]) iterator.next();
				if (result[0] != null) {
					zoneId = (Integer) result[0];
				}
				if (result[1] != null) {
					zoneName = (String) result[1];
				}
				zoneMap.put(zoneId, zoneName);
			}

			// for each zone get dealers here
			Iterator<Integer> zoneIterator = tenancyIdList.iterator();
			while (zoneIterator.hasNext()) {
				zoneId = zoneIterator.next();
				basicSelectQuery = "SELECT te.tenancy_id,te.tenancy_name"
					+ " FROM TenancyEntity te"
					+ " WHERE te.parent_tenancy_id = "
					+ zoneId
					+ " AND te.tenancy_type_id =3";
				zoneName = zoneMap.get(zoneId);
				dealerIdList = new ArrayList<Integer>();
				query = session.createQuery(basicSelectQuery);
				Iterator itr = query.list().iterator();
				result = null;
				int dealerId = 0;
				String dealerName = null;
				HashMap<Integer, String> dealerMap = new HashMap<Integer, String>();
				while (itr.hasNext()) {
					result = (Object[]) itr.next();
					if (result[0] != null) {
						dealerId = (Integer) result[0];
						dealerIdList.add((Integer) result[0]);
					}
					if (result[1] != null) {
						dealerName = (String) result[1];
					}
					dealerMap.put(dealerId, dealerName);
				}
				if(dealerIdList.size()>0){
					String dealerIdString = conversionObj.getIntegerListString(
							dealerIdList).toString();
					iLogger.info("dealer id string " + dealerIdString);
					//					Keerthi : 20/12/2013 : machine hour changes
					basicSelectQuery = "SELECT t1.parentId,SUM(t3.EngineRunningBand1+t3.EngineRunningBand2+t3.EngineRunningBand3+t3.EngineRunningBand4+t3.EngineRunningBand5" +
					"+t3.EngineRunningBand6+t3.EngineRunningBand7+t3.EngineRunningBand8)";
					basicFromQuery = " FROM  TenancyBridgeEntity  t1, TenancyDimensionEntity t2 , ";
					basicWhereQuery = " WHERE t1.parentId in ("
						+ dealerIdString
						+ ") AND t1.childId=t2.tenancyId AND t2.tenacy_Dimension_Id=t3.tenancyId";
					groupByQuery = " GROUP BY t1.parentId ";

					if (fromDate == null && toDate == null) {
						if (period.equalsIgnoreCase("Week")) {
							week = thisDate.getWeek();
							year = thisDate.getYear();
							basicFromQuery = basicFromQuery
							+ " AssetMonitoringFactDataWeekAgg t3 ";

							basicWhereQuery = basicWhereQuery
							+ " and t3.timeCount = " + week
							+ " and t3.year=" + year;
						} else if (period.equalsIgnoreCase("Last Week")) {
							week = prevDate.getWeek();
							if (thisDate.getWeek() == 1) {
								year = prevDate.getYear();
							} else {
								year = prevDate.getCurrentYear();
							}

							basicFromQuery = basicFromQuery
							+ " AssetMonitoringFactDataWeekAgg t3 ";

							basicWhereQuery = basicWhereQuery
							+ " and t3.timeCount = " + week
							+ " and t3.year=" + year;
						}

						else if (period.equalsIgnoreCase("Month")) {
							month = thisDate.getMonth();
							year = thisDate.getYear();
							basicFromQuery = basicFromQuery
							+ " AssetMonitoringFactDataMonthAgg t3 ";
							basicWhereQuery = basicWhereQuery
							+ " and t3.timeCount = " + month
							+ " and t3.year=" + year;

						} else if (period.equalsIgnoreCase("Last Month")) {
							month = prevDate.getMonth();
							if (thisDate.getMonth() == 1) {
								year = prevDate.getYear();
							} else {
								year = prevDate.getCurrentYear();
							}

							basicFromQuery = basicFromQuery
							+ " AssetMonitoringFactDataMonthAgg t3 ";
							basicWhereQuery = basicWhereQuery
							+ " and t3.timeCount = " + month
							+ " and t3.year=" + year;
						} else if (period.equalsIgnoreCase("Quarter")) {
							quarter = thisDate.getQuarter();
							year = thisDate.getYear();
							basicFromQuery = basicFromQuery
							+ " AssetMonitoringFactDataQuarterAgg t3 ";
							basicWhereQuery = basicWhereQuery
							+ " and t3.timeCount  = " + quarter
							+ " and t3.year=" + year;

						} else if (period.equalsIgnoreCase("Last Quarter")) {
							quarter = prevDate.getQuarter();
							if (thisDate.getQuarter() == 1) {
								year = prevDate.getYear();
							} else {
								year = prevDate.getCurrentYear();
							}
							basicFromQuery = basicFromQuery
							+ " AssetMonitoringFactDataQuarterAgg t3 ";
							basicWhereQuery = basicWhereQuery
							+ " and t3.timeCount  = " + quarter
							+ " and t3.year=" + year;

						} else if (period.equalsIgnoreCase("Year")) {
							year = thisDate.getYear();
							basicFromQuery = basicFromQuery
							+ " AssetMonitoringFactDataYearAgg t3 ";
							basicWhereQuery = basicWhereQuery + " and t3.year= "
							+ year;
						} else if (period.equalsIgnoreCase("Last Year")) {
							year = prevDate.getYear();
							basicFromQuery = basicFromQuery
							+ " AssetMonitoringFactDataYearAgg t3 ";
							basicWhereQuery = basicWhereQuery + " and t3.year= "
							+ year;
						}
					}
					else {
						//						Keerthi : 20/12/2013 : custom date changes
						basicFromQuery = basicFromQuery
						+ " AssetMonitoringFactDataDayAgg t3 ";
						basicWhereQuery = basicWhereQuery
						+ " and t3.timeKey between '" + fromDate
						+ "%' and '" + toDate + "%' ";
						//						Commented foll line by Keerthi : 15/10/13 : grouping only by dealer name
						//						groupByQuery = groupByQuery + " , t3.timeKey,t3.tenancyId";
					}
					finalQuery = basicSelectQuery + basicFromQuery
					+ basicWhereQuery + groupByQuery;

					iLogger.info("Query getMachineTrendData: " + finalQuery);

					query = session.createQuery(finalQuery);
					itr = query.list().iterator();
					result = null;

					Double machineHours = 0.0D;

					List<Integer> dealerResultList = new ArrayList<Integer>();

					HashMap<String, Double> dealerData = null;
					HashMap<String, Double> tempDealerData = null;
					while (itr.hasNext()) {
						result = (Object[]) itr.next();

						if (result[0] != null) {
							dealerId = (Integer) result[0];
							dealerResultList.add((Integer) result[0]);
						}
						if (result[1] != null) {
							//							Keerthi : 20/12/2013 : roundig off
							machineHours = (Double.valueOf(decimalFormat.format((Double) result[1])));
						}
						tempDealerData = trendData.get(zoneName);
						if (tempDealerData == null) {
							tempDealerData = new HashMap<String, Double>();
						}
						tempDealerData.put(dealerMap.get(dealerId), machineHours);
						trendData.remove(zoneName);
						trendData.put(zoneName, tempDealerData);

					}

					// set zero for other dealers
					Iterator<Integer> iterDealer = dealerIdList.iterator();
					while (iterDealer.hasNext()) {
						dealerId = iterDealer.next();
						if (!dealerResultList.contains(dealerId)) {
							tempDealerData = trendData.get(zoneName);
							if (tempDealerData == null) {
								tempDealerData = new HashMap<String, Double>();
							}
							tempDealerData.put(dealerMap.get(dealerId), 0.0D);
							trendData.remove(zoneName);
							trendData.put(zoneName, tempDealerData);
						}
					}
				}


			}

			dataObj.setTrendData(trendData);

		} finally {
			if (session.getTransaction().isActive()) {
				session.getTransaction().commit();
			}
			if (session.isOpen()) {
				session.flush();
				session.close();
			}
		}
		long endTime = System.currentTimeMillis();
		iLogger.info("Total execution time "
				+ String.valueOf(endTime - startTime) + "(ms)");

		return dataObj;

	}

	/**
	 * method to get machine hour meter trend data for all zones
	 * 
	 * @param period
	 * @return List<MachineHourMeterTrendDataReportImpl>
	 */
	public List<MachineHourMeterTrendDataReportImpl> getMachineTrendDataForAllZones(List<Integer> tenancyIdList,String fromDate,String toDate,
			String period) {

		long startTime = System.currentTimeMillis();
		Session session = HibernateUtil.getSessionFactory().getCurrentSession();
		session.beginTransaction();
		Logger fLogger = FatalLoggerClass.logger;
		//Logger bLogger = BusinessErrorLoggerClass.logger;
		Logger iLogger = InfoLoggerClass.logger;
		List<MachineHourMeterTrendDataReportImpl> machineTrendDataList = null;
		ListToStringConversion conversionObj = new ListToStringConversion();
		String tenancyIdStringList = conversionObj.getIntegerListString(tenancyIdList).toString();
		List<Integer> resultedTenancyIdList = new ArrayList<Integer>();
		String basicFromQuery = null;
		String basicSelectQuery = null;
		String basicWhereQuery = null;
		String groupByQuery = null;
		String finalQuery = null;
		String orderByQuery = null;
		int year =0;int week = 0; int quarter = 0;int month =0;
		DateUtil dateUtil1 = new DateUtil();
		DateUtil thisDate =dateUtil1.getCurrentDateUtility(new Date());
		DateUtil dateUtil2 = new DateUtil();
		DateUtil prevDate = dateUtil2.getPreviousDateUtility(new Date());
		//		Keerthi : 11/09/14 : y-axis of the graph : names in asc order for all graphs
		TreeMap<String, Integer> zoneMap = new TreeMap<String, Integer>();
		TreeMap<String, Double> resultMap = new TreeMap<String, Double>();
		DecimalFormat decimalFormat = new DecimalFormat("###.#");
		try {

			//get zone names here			
			basicSelectQuery ="SELECT te.tenancy_id,te.tenancy_name FROM TenancyEntity te" +
			" WHERE te.tenancy_id IN ("+tenancyIdStringList+")";

			Query query = session.createQuery(basicSelectQuery);
			Iterator iterator = query.list().iterator();
			Object[] result = null;

			String zoneName = null;
			int zoneId=0;

			while(iterator.hasNext()){
				result = (Object[])iterator.next();
				if(result[0]!=null){
					zoneId =(Integer)result[0];
				}
				if(result[1]!=null){
					zoneName =(String)result[1];
				}
				zoneMap.put(zoneName, zoneId);
			}

			basicSelectQuery = "SELECT t1.parentId,SUM(t3.EngineRunningBand1+t3.EngineRunningBand2+t3.EngineRunningBand3+t3.EngineRunningBand4+t3.EngineRunningBand5" +
			"+t3.EngineRunningBand6+t3.EngineRunningBand7+t3.EngineRunningBand8),t4.tenancy_name";
			basicFromQuery = " FROM  TenancyBridgeEntity  t1, TenancyDimensionEntity t2 ,TenancyEntity t4, ";
			basicWhereQuery = " WHERE t1.parentId in ("+tenancyIdStringList+") AND t1.parentId=t4.tenancy_id AND t1.childId=t2.tenancyId AND t2.tenacy_Dimension_Id=t3.tenancyId";
			groupByQuery = " GROUP BY t1.parentId ";
			orderByQuery = " ORDER BY t4.tenancy_name";

			if(fromDate == null && toDate==null)
			{
				if (period.equalsIgnoreCase("Week")) {
					week =   thisDate.getWeek();
					year = thisDate.getYear();
					basicFromQuery = basicFromQuery+" AssetMonitoringFactDataWeekAgg t3 ";

					basicWhereQuery = basicWhereQuery	+ " and t3.timeCount = "+week +" and t3.year="+year;
				}
				else if (period.equalsIgnoreCase("Last Week")) {
					week =  prevDate.getWeek();
					if( thisDate.getWeek()==1){
						year = prevDate.getYear();
					}else{
						year = prevDate.getCurrentYear();
					}

					basicFromQuery = basicFromQuery+" AssetMonitoringFactDataWeekAgg t3 ";

					basicWhereQuery = basicWhereQuery	+ " and t3.timeCount = "+week+" and t3.year="+year;
				}

				else if (period.equalsIgnoreCase("Month")) {
					month =  thisDate.getMonth();
					year = thisDate.getYear();
					basicFromQuery = basicFromQuery+" AssetMonitoringFactDataMonthAgg t3 ";
					basicWhereQuery = basicWhereQuery	+ " and t3.timeCount = "	+ month+" and t3.year="+year;

				}
				else if (period.equalsIgnoreCase("Last Month")) {
					month =  prevDate.getMonth();
					if(thisDate.getMonth()==1){
						year = prevDate.getYear();
					}else{
						year = prevDate.getCurrentYear();
					}

					basicFromQuery = basicFromQuery+" AssetMonitoringFactDataMonthAgg t3 ";
					basicWhereQuery = basicWhereQuery	+ " and t3.timeCount = "	+ month+" and t3.year="+year;				
				}
				else if (period.equalsIgnoreCase("Quarter")) {
					quarter =  thisDate.getQuarter();
					year = thisDate.getYear();
					basicFromQuery = basicFromQuery+" AssetMonitoringFactDataQuarterAgg t3 ";
					basicWhereQuery = basicWhereQuery	+ " and t3.timeCount  = " +quarter+" and t3.year="+year;

				}
				else if (period.equalsIgnoreCase("Last Quarter")) {
					quarter = prevDate.getQuarter();
					if(thisDate.getQuarter()==1){
						year = prevDate.getYear();
					}else{
						year = prevDate.getCurrentYear();
					}
					basicFromQuery = basicFromQuery+" AssetMonitoringFactDataQuarterAgg t3 ";
					basicWhereQuery = basicWhereQuery	+ " and t3.timeCount  = " +quarter+" and t3.year="+year;

				}
				else if (period.equalsIgnoreCase("Year")) {
					year = thisDate.getYear();
					basicFromQuery = basicFromQuery+" AssetMonitoringFactDataYearAgg t3 ";
					basicWhereQuery = basicWhereQuery	+ " and t3.year= "+year;
				}
				else if (period.equalsIgnoreCase("Last Year")) {
					year = prevDate.getYear();
					basicFromQuery = basicFromQuery+" AssetMonitoringFactDataYearAgg t3 ";
					basicWhereQuery = basicWhereQuery	+ " and t3.year= "+year;
				}
			}
			else{	
				basicFromQuery = basicFromQuery+" AssetMonitoringFactDataDayAgg t3 ";
				basicWhereQuery = basicWhereQuery+ " and t3.timeKey between '"+fromDate+"%' and '"+toDate+"%' ";
			}

			finalQuery = basicSelectQuery + basicFromQuery + basicWhereQuery
			+ groupByQuery;

			iLogger.info("Query getMachineTrendData: " + finalQuery);

			query = session.createQuery(finalQuery);
			Iterator itr = query.list().iterator();
			result = null;
			machineTrendDataList = new ArrayList<MachineHourMeterTrendDataReportImpl>();
			MachineHourMeterTrendDataReportImpl dataObj = null;
			zoneId = 0; zoneName = null;
			Double totalAlerts = 0.0D;
			while (itr.hasNext()) {
				result = (Object[]) itr.next();
				if (result[0] != null) {
					zoneId = (Integer)result[0];
				}
				if (result[1] != null) {
					totalAlerts = Double.valueOf(decimalFormat.format((Double)result[1]));
				}
				if (result[2] != null) {
					zoneName = (String)result[2];
				}
				resultMap.put(zoneName, totalAlerts);
			}

			//			iterate zone map and add values to list
			for(String zone: zoneMap.keySet()){
				dataObj = new MachineHourMeterTrendDataReportImpl();
				if(resultMap.containsKey(zone)){					
					dataObj.setZoneName(zone);
					dataObj.setTotalMachineHours(resultMap.get(zone));
				}
				else{
					dataObj.setZoneName(zone);
					dataObj.setTotalMachineHours(0.0D);
				}
				machineTrendDataList.add(dataObj);
			}
		} finally {
			if (session.getTransaction().isActive()) {
				session.getTransaction().commit();
			}
			if (session.isOpen()) {
				session.flush();
				session.close();
			}
		}
		long endTime = System.currentTimeMillis();
		iLogger.info("Total execution time "
				+ String.valueOf(endTime - startTime) + "(ms)");

		return machineTrendDataList;

	}

	/**
	 * method to get machine RPM Band trend data for specified zones
	 * 
	 * @param tenancy
	 *            id list
	 * @param period
	 * @return MachineRPMBandDataImpl
	 */
	public MachineRPMBandDataImpl getMachineRPMBandTrendData(String fromDate,String toDate,
			List<Integer> tenancyIdList, String period) {

		long startTime = System.currentTimeMillis();
		Session session = HibernateUtil.getSessionFactory().getCurrentSession();
		session.beginTransaction();

		MachineRPMBandDataImpl dataObj = new MachineRPMBandDataImpl();
		
		Logger iLogger = InfoLoggerClass.logger;
		String basicFromQuery = null;
		String basicSelectQuery = null;
		String basicWhereQuery = null;
		String groupByQuery = null;
		String finalQuery = null;
		int year =0;int week = 0; int quarter = 0;int month =0;
		DateUtil dateUtil1 = new DateUtil();
		DateUtil thisDate =dateUtil1.getCurrentDateUtility(new Date());
		DateUtil dateUtil2 = new DateUtil();
		DateUtil prevDate = dateUtil2.getPreviousDateUtility(new Date());		
		Map<Integer, String> zoneMap = new HashMap<Integer, String>();
		List<Integer> dealerIdList = null;
		Map<String, HashMap<String, String>> trendData = new HashMap<String, HashMap<String,String>>();
		try {

			if(tenancyIdList!=null && tenancyIdList.size()>0){
				ListToStringConversion conversionObj = new ListToStringConversion();
				String tenancyIdStringList = conversionObj.getIntegerListString(
						tenancyIdList).toString();
				// get zone names here
				basicSelectQuery = "SELECT te.tenancy_id,te.tenancy_name FROM TenancyEntity te"
					+ " WHERE te.tenancy_id IN ("
					+ tenancyIdStringList
					+ ")";

				Query query = session.createQuery(basicSelectQuery);
				Iterator iterator = query.list().iterator();
				Object[] result = null;

				String zoneName = null;
				int zoneId = 0;
				while (iterator.hasNext()) {
					result = (Object[]) iterator.next();
					if (result[0] != null) {
						zoneId = (Integer) result[0];
					}
					if (result[1] != null) {
						zoneName = (String) result[1];
					}
					zoneMap.put(zoneId, zoneName);
				}

				// for each zone get dealers here
				Iterator<Integer> zoneIterator = tenancyIdList.iterator();
				while (zoneIterator.hasNext()) {
					zoneId = zoneIterator.next();
					basicSelectQuery = "SELECT te.tenancy_id,te.tenancy_name"
						+ " FROM TenancyEntity te"
						+ " WHERE te.parent_tenancy_id = "
						+ zoneId
						+ " AND te.tenancy_type_id =3";
					zoneName = zoneMap.get(zoneId);
					dealerIdList = new ArrayList<Integer>();
					query = session.createQuery(basicSelectQuery);
					Iterator itr = query.list().iterator();
					result = null;
					int dealerId = 0;
					String dealerName = null;
					Map<Integer, String> dealerMap = new HashMap<Integer, String>();
					while (itr.hasNext()) {
						result = (Object[]) itr.next();
						if (result[0] != null) {
							dealerId = (Integer) result[0];
							dealerIdList.add((Integer) result[0]);
						}
						if (result[1] != null) {
							dealerName = (String) result[1];
						}
						dealerMap.put(dealerId, dealerName);
					}
					if(dealerIdList.size()>0){
						String dealerIdString = conversionObj.getIntegerListString(
								dealerIdList).toString();
						iLogger.info("dealer id string " + dealerIdString);

						basicSelectQuery = "SELECT t1.parentId,SUM(t3.EngineRunningBand1),SUM(t3.EngineRunningBand2),SUM(t3.EngineRunningBand3),SUM(t3.EngineRunningBand4)," +
						" SUM(t3.EngineRunningBand5),SUM(t3.EngineRunningBand6),SUM(t3.EngineRunningBand7),SUM(t3.EngineRunningBand8)";
						basicFromQuery = " FROM  TenancyBridgeEntity  t1, TenancyDimensionEntity t2 , ";
						basicWhereQuery = " WHERE t1.parentId in ("+dealerIdString+") AND t1.childId=t2.tenancyId AND t2.tenacy_Dimension_Id=t3.tenancyId";
						groupByQuery = " GROUP BY t1.parentId";

						if(fromDate == null && toDate==null){
							if (period.equalsIgnoreCase("Week")) {
								week =   thisDate.getWeek();
								year = thisDate.getYear();
								basicFromQuery = basicFromQuery+" AssetMonitoringFactDataWeekAgg t3 ";

								basicWhereQuery = basicWhereQuery	+ " and t3.timeCount = "+week +" and t3.year="+year;
							}
							else if (period.equalsIgnoreCase("Last Week")) {
								week =  prevDate.getWeek();
								if(thisDate.getWeek()==1){
									year = prevDate.getYear();
								}else{
									year = prevDate.getCurrentYear();
								}

								basicFromQuery = basicFromQuery+" AssetMonitoringFactDataWeekAgg t3 ";

								basicWhereQuery = basicWhereQuery	+ " and t3.timeCount = "+week+" and t3.year="+year;
							}

							else if (period.equalsIgnoreCase("Month")) {
								month =  thisDate.getMonth();
								year = thisDate.getYear();
								basicFromQuery = basicFromQuery+" AssetMonitoringFactDataMonthAgg t3 ";
								basicWhereQuery = basicWhereQuery	+ " and t3.timeCount = "	+ month+" and t3.year="+year;

							}
							else if (period.equalsIgnoreCase("Last Month")) {
								month =  prevDate.getMonth();
								if(thisDate.getMonth()==1){
									year = prevDate.getYear();
								}else{
									year = prevDate.getCurrentYear();
								}

								basicFromQuery = basicFromQuery+" AssetMonitoringFactDataMonthAgg t3 ";
								basicWhereQuery = basicWhereQuery	+ " and t3.timeCount = "	+ month+" and t3.year="+year;				
							}
							else if (period.equalsIgnoreCase("Quarter")) {
								quarter =  thisDate.getQuarter();
								year = thisDate.getYear();
								basicFromQuery = basicFromQuery+" AssetMonitoringFactDataQuarterAgg t3 ";
								basicWhereQuery = basicWhereQuery	+ " and t3.timeCount  = " +quarter+" and t3.year="+year;

							}
							else if (period.equalsIgnoreCase("Last Quarter")) {
								quarter = prevDate.getQuarter();
								if(thisDate.getQuarter()==1){
									year = prevDate.getYear();
								}else{
									year = prevDate.getCurrentYear();
								}
								basicFromQuery = basicFromQuery+" AssetMonitoringFactDataQuarterAgg t3 ";
								basicWhereQuery = basicWhereQuery	+ " and t3.timeCount  = " +quarter+" and t3.year="+year;

							}
							else if (period.equalsIgnoreCase("Year")) {
								year = thisDate.getYear();
								basicFromQuery = basicFromQuery+" AssetMonitoringFactDataYearAgg t3 ";
								basicWhereQuery = basicWhereQuery	+ " and t3.year= "+year;
							}
							else if (period.equalsIgnoreCase("Last Year")) {
								year = prevDate.getYear();
								basicFromQuery = basicFromQuery+" AssetMonitoringFactDataYearAgg t3 ";
								basicWhereQuery = basicWhereQuery	+ " and t3.year= "+year;
							}
						}
						else
						{
							//						Keerthi : 20/12/2013 : custom date changes
							basicFromQuery = basicFromQuery+" AssetMonitoringFactDataDayAgg t3 ";
							basicWhereQuery = basicWhereQuery+ " and t3.timeKey between '"+fromDate+"%' and '"+toDate+"%' ";
							//							Commented foll line by Keerthi : 15/10/13 : grouping only by dealer name
							//							groupByQuery = groupByQuery+" , t3.timeKey,t3.tenancyId";
						}


						finalQuery = basicSelectQuery + basicFromQuery + basicWhereQuery
						+ groupByQuery;

						iLogger.info("Query getMachineTrendData: " + finalQuery);

						query = session.createQuery(finalQuery);
						itr = query.list().iterator();
						result = null;

						String dealer = null;			
						Map<String, Double> dealerData = null;
						int maxIdleRPMBand=0,maxWorkingRPMBand=0;
						HashMap<String, String> tempDealerData = null;
						String rpmBandString=null;
						List<Integer> dealerResultList = new ArrayList<Integer>();
						double EngineRunningBand1Sum =0d;
						double EngineRunningBand2Sum =0d;
						double EngineRunningBand3Sum =0d;
						double EngineRunningBand4Sum =0d;
						double EngineRunningBand5Sum =0d;
						double EngineRunningBand6Sum =0d;
						double EngineRunningBand7Sum =0d;
						double EngineRunningBand8Sum =0d;

						ArrayList<Double> rpmBandList = null;
						while (itr.hasNext()) {
							result = (Object[]) itr.next();

							if (result[0] != null) {
								dealerId = (Integer) result[0];
								iLogger.info("Dealer : "+dealerMap.get(dealerId));
								dealerResultList.add(dealerId);
							}
							rpmBandList = new ArrayList<Double>();
							if(result[1]!=null){
								EngineRunningBand1Sum=(Double) result[1];
								rpmBandList.add(0,EngineRunningBand1Sum);
							}
							if(result[2]!=null){
								EngineRunningBand2Sum=(Double) result[2];
								rpmBandList.add(1,EngineRunningBand2Sum);
							}
							if(result[3]!=null){
								EngineRunningBand3Sum=(Double) result[3];	
								rpmBandList.add(2,EngineRunningBand3Sum);
							}
							if(result[4]!=null){
								EngineRunningBand4Sum=(Double) result[4];
								rpmBandList.add(3,EngineRunningBand4Sum);
							}
							if(result[5]!=null){
								EngineRunningBand5Sum=(Double) result[5];
								rpmBandList.add(4,EngineRunningBand5Sum);
							}
							if(result[6]!=null){
								EngineRunningBand6Sum=(Double) result[6];
								rpmBandList.add(5,EngineRunningBand6Sum);
							}
							if(result[7]!=null){
								EngineRunningBand7Sum=(Double) result[7];
								rpmBandList.add(6,EngineRunningBand7Sum);
							}
							if(result[8]!=null){
								EngineRunningBand8Sum=(Double) result[8];
								rpmBandList.add(7,EngineRunningBand8Sum);
							}	

							iLogger.info("zone name  : "+zoneMap.get(zoneId));
							iLogger.info("EngineRunningBand1Sum = "+EngineRunningBand1Sum+" EngineRunningBand2Sum = "+EngineRunningBand2Sum+" EngineRunningBand3Sum = "+EngineRunningBand3Sum +
									" EngineRunningBand4Sum = "+EngineRunningBand4Sum+" EngineRunningBand5Sum = "+EngineRunningBand5Sum+" EngineRunningBand6Sum = "+EngineRunningBand6Sum +
									" EngineRunningBand7Sum = "+EngineRunningBand7Sum+" EngineRunningBand8Sum = "+EngineRunningBand8Sum);

							maxIdleRPMBand=maxEngineRunningBand(rpmBandList,"idle");                        
							maxWorkingRPMBand =maxEngineRunningBand(rpmBandList,"working"); 

							rpmBandString = new String(maxIdleRPMBand+","+maxWorkingRPMBand);
							iLogger.info("maxIdleRPMBand = "+maxIdleRPMBand +" maxWorkingRPMBand = "+maxWorkingRPMBand);

							tempDealerData = trendData.get(zoneName);
							if (tempDealerData == null) {
								tempDealerData = new HashMap<String, String>();
							}
							tempDealerData.put(dealerMap.get(dealerId),rpmBandString);
							trendData.remove(zoneName);
							trendData.put(zoneName,tempDealerData);
						}
						// set zero for other dealers
						Iterator<Integer> iterDealer = dealerIdList.iterator();
						while (iterDealer.hasNext()) {
							dealerId = iterDealer.next();
							if (!dealerResultList.contains(dealerId)) {
								tempDealerData = trendData.get(zoneName);
								if (tempDealerData == null) {
									tempDealerData = new HashMap<String, String>();
								}
								rpmBandString = new String(0+","+0);
								tempDealerData.put(dealerMap.get(dealerId),rpmBandString);
								trendData.remove(zoneName);
								trendData.put(zoneName,tempDealerData);
							}
						}

					}
				}

				dataObj.setTrendData(trendData);
			}		
		} finally {
			if (session.getTransaction().isActive()) {
				session.getTransaction().commit();
			}
			if (session.isOpen()) {
				session.flush();
				session.close();
			}
		}
		long endTime = System.currentTimeMillis();
		iLogger.info("Total execution time "
				+ String.valueOf(endTime - startTime) + "(ms)");

		return dataObj;

	}

	/**
	 * method to get machine hour meter trend data for all zones
	 * 
	 * @param period
	 * @return List<MachineRPMBandDataImpl>
	 */
	public List<MachineRPMBandDataImpl> getMachineRPMBandTrendDataForAllZones(String fromDate,String toDate,
			List<Integer> tenancyIdList, String period) {
		
		Logger iLogger = InfoLoggerClass.logger;
		long startTime = System.currentTimeMillis();
		Session session = HibernateUtil.getSessionFactory().getCurrentSession();
		session.beginTransaction();

		ListToStringConversion conversionObj = new ListToStringConversion();
		String tenancyIdStringList = conversionObj.getIntegerListString(tenancyIdList).toString();

		List<MachineRPMBandDataImpl> machineTrendDataList = null;

		String basicFromQuery = null;
		String basicSelectQuery = null;
		String basicWhereQuery = null;
		String groupByQuery = null;
		String orderByQuery = null;
		String finalQuery = null;
		int year =0;int week = 0; int quarter = 0;int month =0;
		DateUtil dateUtil1 = new DateUtil();
		DateUtil thisDate =dateUtil1.getCurrentDateUtility(new Date());
		DateUtil dateUtil2 = new DateUtil();
		DateUtil prevDate = dateUtil2.getPreviousDateUtility(new Date());

		try {

			//get zone names here
			basicSelectQuery ="SELECT te.tenancy_id,te.tenancy_name FROM TenancyEntity te" +
			" WHERE te.tenancy_id IN ("+tenancyIdStringList+")";

			Query query = session.createQuery(basicSelectQuery);
			Iterator iterator = query.list().iterator();
			Object[] result = null;

			String zoneName = null;
			int zoneId=0;
			//			Keerthi : 11/09/14 : y-axis of the graph : names in asc order for all graphs
			TreeMap<String, Integer> zoneMap = new TreeMap<String,Integer>();
			TreeMap<String, List<Integer>> resultMap = new TreeMap<String, List<Integer>>();
			List<Integer> bandList = null;
			while(iterator.hasNext()){
				result = (Object[])iterator.next();
				if(result[0]!=null){
					zoneId =(Integer)result[0];
				}
				if(result[1]!=null){
					zoneName =(String)result[1];
				}
				zoneMap.put(zoneName, zoneId);
			}
			basicSelectQuery = "SELECT t1.parentId,SUM(t3.EngineRunningBand1),SUM(t3.EngineRunningBand2),SUM(t3.EngineRunningBand3),SUM(t3.EngineRunningBand4)," +
			" SUM(t3.EngineRunningBand5),SUM(t3.EngineRunningBand6),SUM(t3.EngineRunningBand7),SUM(t3.EngineRunningBand8),t4.tenancy_name";
			basicFromQuery = " FROM  TenancyBridgeEntity  t1, TenancyDimensionEntity t2 , TenancyEntity t4,";
			basicWhereQuery = " WHERE t1.parentId in ("+tenancyIdStringList+") AND t1.parentId=t4.tenancy_id AND t1.childId=t2.tenancyId AND t2.tenacy_Dimension_Id=t3.tenancyId";
			groupByQuery = " GROUP BY t1.parentId";
			orderByQuery = " ORDER BY t4.tenancy_name";
			if(fromDate == null && toDate==null){
				if (period.equalsIgnoreCase("Week")) {			
					week =   thisDate.getWeek();
					year = thisDate.getYear();
					basicFromQuery = basicFromQuery+" AssetMonitoringFactDataWeekAgg t3 ";

					basicWhereQuery = basicWhereQuery	+ " and t3.timeCount = "+week +" and t3.year="+year;
				}
				else if (period.equalsIgnoreCase("Last Week")) {
					week =  prevDate.getWeek();
					if(thisDate.getWeek()==1){
						year = prevDate.getYear();
					}else{
						year = prevDate.getCurrentYear();
					}

					basicFromQuery = basicFromQuery+" AssetMonitoringFactDataWeekAgg t3 ";

					basicWhereQuery = basicWhereQuery	+ " and t3.timeCount = "+week+" and t3.year="+year;
				}

				else if (period.equalsIgnoreCase("Month")) {
					month =  thisDate.getMonth();
					year = thisDate.getYear();
					basicFromQuery = basicFromQuery+" AssetMonitoringFactDataMonthAgg t3 ";
					basicWhereQuery = basicWhereQuery	+ " and t3.timeCount = "	+ month+" and t3.year="+year;

				}
				else if (period.equalsIgnoreCase("Last Month")) {
					month =  prevDate.getMonth();
					if(thisDate.getMonth()==1){
						year = prevDate.getYear();
					}else{
						year = prevDate.getCurrentYear();
					}

					basicFromQuery = basicFromQuery +" AssetMonitoringFactDataMonthAgg t3 ";
					basicWhereQuery = basicWhereQuery	+ " and t3.timeCount = "	+ month+" and t3.year="+year;				
				}
				else if (period.equalsIgnoreCase("Quarter")) {
					quarter =  thisDate.getQuarter();
					year = thisDate.getYear();
					basicFromQuery = basicFromQuery+" AssetMonitoringFactDataQuarterAgg t3 ";
					basicWhereQuery = basicWhereQuery	+ " and t3.timeCount  = " +quarter+" and t3.year="+year;

				}
				else if (period.equalsIgnoreCase("Last Quarter")) {
					quarter = prevDate.getQuarter();
					if(thisDate.getQuarter()==1){
						year = prevDate.getYear();
					}else{
						year = prevDate.getCurrentYear();
					}
					basicFromQuery = basicFromQuery+" AssetMonitoringFactDataQuarterAgg t3 ";
					basicWhereQuery = basicWhereQuery	+ " and t3.timeCount  = " +quarter+" and t3.year="+year;

				}
				else if (period.equalsIgnoreCase("Year")) {
					year = thisDate.getYear();
					basicFromQuery = basicFromQuery+" AssetMonitoringFactDataYearAgg t3 ";
					basicWhereQuery = basicWhereQuery	+ " and t3.year= "+year;
				}
				else if (period.equalsIgnoreCase("Last Year")) {
					year = prevDate.getYear();
					basicFromQuery = basicFromQuery+" AssetMonitoringFactDataYearAgg t3 ";
					basicWhereQuery = basicWhereQuery	+ " and t3.year= "+year;
				}
			}
			else
			{
				//				Keerthi : 20/12/2013 : custom date changes
				basicFromQuery = basicFromQuery+" AssetMonitoringFactDataDayAgg t3 ";
				basicWhereQuery = basicWhereQuery+ " and t3.timeKey between '"+fromDate+"%' and '"+toDate+"%' ";
				//					Commented foll line by Keerthi : 15/10/13 : grouping only by zone name
				//					groupByQuery = groupByQuery+" , t3.timeKey,t3.tenancyId";
			}

			finalQuery = basicSelectQuery + basicFromQuery + basicWhereQuery
			+ groupByQuery+orderByQuery;

			iLogger.info("Query getMachineTrendData: " + finalQuery);

			query = session.createQuery(finalQuery);
			Iterator itr = query.list().iterator();
			result = null;
			machineTrendDataList = new ArrayList<MachineRPMBandDataImpl>();
			MachineRPMBandDataImpl dataObj = null;
			int maxIdleRPMBand = 0;
			int maxWorkingRPMBand = 0;
			double EngineRunningBand1Sum =0d;
			double EngineRunningBand2Sum =0d;
			double EngineRunningBand3Sum =0d;
			double EngineRunningBand4Sum =0d;
			double EngineRunningBand5Sum =0d;
			double EngineRunningBand6Sum =0d;
			double EngineRunningBand7Sum =0d;
			double EngineRunningBand8Sum =0d;

			ArrayList<Double> rpmBandList = null;
			zoneId = 0; zoneName = null;
			while (itr.hasNext()) {
				result = (Object[]) itr.next();

				if (result[0] != null) {
					zoneId = (Integer) result[0];
				}
				rpmBandList = new ArrayList<Double>();
				if(result[1]!=null){
					EngineRunningBand1Sum=(Double) result[1];
					rpmBandList.add(0,EngineRunningBand1Sum);
				}
				if(result[2]!=null){
					EngineRunningBand2Sum=(Double) result[2];
					rpmBandList.add(1,EngineRunningBand2Sum);
				}
				if(result[3]!=null){
					EngineRunningBand3Sum=(Double) result[3];	
					rpmBandList.add(2,EngineRunningBand3Sum);
				}
				if(result[4]!=null){
					EngineRunningBand4Sum=(Double) result[4];
					rpmBandList.add(3,EngineRunningBand4Sum);
				}
				if(result[5]!=null){
					EngineRunningBand5Sum=(Double) result[5];
					rpmBandList.add(4,EngineRunningBand5Sum);
				}
				if(result[6]!=null){
					EngineRunningBand6Sum=(Double) result[6];
					rpmBandList.add(5,EngineRunningBand6Sum);
				}
				if(result[7]!=null){
					EngineRunningBand7Sum=(Double) result[7];
					rpmBandList.add(6,EngineRunningBand7Sum);
				}
				if(result[8]!=null){
					EngineRunningBand8Sum=(Double) result[8];
					rpmBandList.add(7,EngineRunningBand8Sum);
				}	
				if(result[9]!=null){
					zoneName = (String)result[9];
				}

				/*infoLogger.info("EngineRunningBand1Sum = "+EngineRunningBand1Sum+" EngineRunningBand2Sum = "+EngineRunningBand2Sum+" EngineRunningBand3Sum = "+EngineRunningBand3Sum +
				" EngineRunningBand4Sum = "+EngineRunningBand4Sum+" EngineRunningBand5Sum = "+EngineRunningBand5Sum+" EngineRunningBand6Sum = "+EngineRunningBand6Sum +
				" EngineRunningBand7Sum = "+EngineRunningBand7Sum+" EngineRunningBand8Sum = "+EngineRunningBand8Sum);*/

				maxIdleRPMBand=maxEngineRunningBand(rpmBandList,"idle");                        
				maxWorkingRPMBand =maxEngineRunningBand(rpmBandList,"working"); 

				//				infoLogger.info("maxIdleRPMBand = "+maxIdleRPMBand +" maxWorkingRPMBand = "+maxWorkingRPMBand);
				bandList = new ArrayList<Integer>();
				bandList.add(0,maxIdleRPMBand);bandList.add(1,maxWorkingRPMBand);
				resultMap.put(zoneName, bandList);
			}
			//			iterate zone map and add values to list
			for(String zone: zoneMap.keySet()){
				dataObj = new MachineRPMBandDataImpl();
				if(resultMap.containsKey(zone)){					
					dataObj.setZoneName(zone);
					bandList = null;
					bandList = resultMap.get(zone);
					if(bandList!=null){
						dataObj.setMaxIdleRPMBand(bandList.get(0));
						dataObj.setMaxWorkingRPMBand(bandList.get(1));
					}
					else{
						dataObj.setMaxIdleRPMBand(0);
						dataObj.setMaxWorkingRPMBand(0);
					}
				}
				else{
					dataObj.setZoneName(zone);
					dataObj.setMaxIdleRPMBand(0);
					dataObj.setMaxWorkingRPMBand(0);
				}
				machineTrendDataList.add(dataObj);
			}

		} finally {
			if (session.getTransaction().isActive()) {
				session.getTransaction().commit();
			}
			if (session.isOpen()) {
				session.flush();
				session.close();
			}
		}
		long endTime = System.currentTimeMillis();
		iLogger.info("Total execution time "
				+ String.valueOf(endTime - startTime) + "(ms)");

		return machineTrendDataList;

	}

	/**
	 * method to get machine service due/over due count for all tenancies under
	 * logged-in tenancy id.
	 * 
	 * @param loggedInTenancyId
	 * @return list
	 *//*
	//DefectId:839 - Rajani Nagaraju - 20131216 - To enable Machine Movement between tenancies
	public List<MachineServiceDueOverDueImpl> getMachineServiceDueOverDueCount(List<Integer> tenancyIdList,List<Integer> machineGroupIdList,
			List<Integer> machineProfileIdList,	List<Integer> modelIdList) 
			{//Re-Imeplemented whole Logic by Juhi on 27-09-2013 for Defect Id:1372
		//Logger fatalError = Logger.getLogger("fatalErrorLogger");
		List<MachineServiceDueOverDueImpl> impLlist=new LinkedList<MachineServiceDueOverDueImpl>();
		
		Logger iLogger = InfoLoggerClass.logger;
		Logger fLogger = FatalLoggerClass.logger;
		
		Session session = HibernateUtil.getSessionFactory().getCurrentSession();
		session.beginTransaction();

		try
		{
			//DF20140108 - Rajani Nagaraju - To take LoginTenancyId as a list and not an integer
			ListToStringConversion conversion = new ListToStringConversion();
			String loggedInTenancyId = conversion.getIntegerListString(tenancyIdList).toString();

			String basicFromQuery = null;
			String basicSelectQuery = null;
			String basicWhereQuery = null;
			String groupByQuery = null;
			String finalQuery = null;

			int year =0;int week = 0; int quarter = 0;int month =0;
			DateUtil dateUtil1 = new DateUtil();
			DateUtil thisDate =dateUtil1.getCurrentDateUtility(new Date());
			DateUtil dateUtil2 = new DateUtil();
			DateUtil prevDate = dateUtil2.getPreviousDateUtility(new Date());
			//added by smitha on 21st Aug 2013
			List<Integer> subTenancyIdList = new ArrayList<Integer>();
			//Addedd @2014-09-09 Suprava 
			List<Integer> dealerIdList1=new LinkedList<Integer>();
			//DF20140108 - Rajani Nagaraju - To take LoginTenancyId as a list and not an integer
			//String tenancyQuery = "select t1.childId,t1.parentId FROM  TenancyBridgeEntity  t1 WHERE t1.parentId in("+ loggedInTenancyId+")";
			//String tenancyQuery = "select t1.childId,t1.parentId FROM  TenancyBridgeEntity  t1 WHERE t1.parentId in("+ loggedInTenancyId+") and t1.childId not in ("+loggedInTenancyId+")";
			String tenancyQuery = "select t1.childId,t.parent_tenancy_id FROM  TenancyBridgeEntity  t1 ,TenancyEntity t WHERE t1.parentId in("+ loggedInTenancyId+") and t1.childId=t.tenancy_id and t.tenancy_type_id=4";
			Query queryy = session.createQuery(tenancyQuery);
			Iterator itr1 = queryy.list().iterator();
			Object[] resultTenancy = null;
			while(itr1.hasNext()){	
				resultTenancy = (Object[]) itr1.next();
				int childId=(Integer) resultTenancy[0];
				if (resultTenancy[0] != null) {
					subTenancyIdList.add((Integer) resultTenancy[0]);
					//	System.out.println("subTenancyIdList"+subTenancyIdList);
				}
				//					infoLogger.info("childId");
				//Adder DealerId to dealerId List
				if (resultTenancy[1] != null){
					TenancyEntity dealerId=(TenancyEntity) resultTenancy[1];
					dealerIdList1.add(dealerId.getTenancy_id());
					//	System.out.println("dealerIdList:"+dealerIdList);
				}

			}			

			// Commenting the below code as the condition is added in where cluase in the above query
			//DF20140108 - Rajani Nagaraju - To take LoginTenancyId as a list and not an integer
			if(subTenancyIdList.contains(Integer.parseInt(loggedInTenancyId))){				
				int index = subTenancyIdList.indexOf(Integer.parseInt(loggedInTenancyId));				
				subTenancyIdList.remove(index);				
			}

			if(subTenancyIdList.size()>0){//Keerthi : 16/07/14 : checking for sub tenancy ids
				//			infoLogger.info("dealerIdList");
				ListToStringConversion conversionObj = new ListToStringConversion();
				String tenancyIdStringList = conversionObj.getIntegerListString(subTenancyIdList).toString();
				String tenancyIdString = conversionObj.getIntegerListString(dealerIdList1).toString();
				//System.out.println("tenancyIdStringList"+tenancyIdStringList);

				Query dealerQuery=session.createQuery("select t.tenancy_id from TenancyEntity t where t.tenancy_type_id=3 and t.tenancy_id in ("+tenancyIdString+")");
				Iterator dealerIterator=dealerQuery.list().iterator();
				List<Integer> dealerIdList=new LinkedList<Integer>();
				if(dealerQuery.list().size()>0)
				{
					while(dealerIterator.hasNext())
					{
						dealerIdList.add((Integer)dealerIterator.next());
					}
				}
				if(dealerIdList!=null){

					//DefectID: 1925 - Rajani Nagaraju - 20140226 - Summary and detail report not matching.. Same VIN was getting counted twice under different tenancy	
					List<String> dueVinList = new LinkedList<String>();
					List<String> overDueVinLlist = new LinkedList<String>();

					for(int i=0;i<dealerIdList.size();i++)
					{
						//System.out.println("dealerIdList"+dealerIdList);
						MachineServiceDueOverDueImpl dataObj = new MachineServiceDueOverDueImpl();
					//	Query customerQuery=session.createQuery("select t.tenancy_id ,t.parent_tenancy_id from TenancyEntity t where t.parent_tenancy_id="+dealerIdList.get(i)+" and t.tenancy_type_id=4 and t.tenancy_id in ("+tenancyIdStringList+") group by t.tenancy_id");
						String dealerAccountType ="Dealer";
						String customerAccountType ="Customer";
						Query customerQuery=session.createQuery("select aos2.accountId ,aos1.accountId from AssetOwnerSnapshotEntity aos1,AssetOwnerSnapshotEntity aos2,AccountTenancyMapping atm where atm.tenancy_id="+dealerIdList.get(i)+" and aos1.accountId=atm.account_id and aos1.accountType='"+dealerAccountType+"' and aos1.serialNumber=aos2.serialNumber and aos2.accountType='"+customerAccountType+"' group by aos2.serialNumber");
						Iterator customerIterator=customerQuery.list().iterator();
						Object resultObj[]=null;
						String dealerName=null;
						String dealerTenancyId=null;
						//List<Integer> customerTenancyIdList=new LinkedList<Integer>();
						List<Integer> customerAccountIdList=new LinkedList<Integer>();
						if(customerQuery.list().size()!=0)
							//if(queryy.list().size()!=0)
						{
							while(customerIterator.hasNext())
							{ 
								resultObj=(Object[])customerIterator.next();
								//int customerAccountId=(Integer)resultObj[0];
								AccountEntity account_id=(AccountEntity)resultObj[0];
								//	int parentTenancyId=(Integer)resultObj[1];
								//customerTenancyIdList.add(customerTenancyId);
								customerAccountIdList.add(account_id.getAccount_id());
								//System.out.println("customerTenancyIdList"+customerTenancyIdList);
							}	

							//if(customerTenancyIdList!=null)
							if(customerAccountIdList!=null)
							{
								//String customerTenancyIdStringList = conversionObj.getIntegerListString(customerTenancyIdList).toString();

								Query accountQuery=session.createQuery("select a.account_id,a.tenancy_id from AccountTenancyMapping a where a.tenancy_id in("+customerTenancyIdStringList+")");
								Iterator accountIterator = accountQuery.list().iterator();
								Object result[]=null;
								long serviceduecount=0l;
								long serviceoverduecount=0l;

								List<Integer> accountids=new LinkedList<Integer>();
								while(accountIterator.hasNext())
								{
									//						infoLogger.info("account_id***");

									result=(Object[])accountIterator.next();
									AccountEntity account_id=(AccountEntity)result[0];
									TenancyEntity tenancy_id=(TenancyEntity)result[1];
									accountids.add(account_id.getAccount_id());
								}
								//serviceduecount
								//String accountidsStringList = conversionObj.getIntegerListString(accountids).toString();
								//DefectId:20151014 @ Suprava 
								iLogger.info("serviceduecount****");
								long serviceduecount=0l;
								long serviceoverduecount=0l;
                                String accountidsStringList = conversionObj.getIntegerListString(customerAccountIdList).toString();

								//	Query assetQuery=session.createQuery("select count(distinct(a.serialNumber)) from AssetEventEntity a ,AssetAccountMapping b where a.serialNumber=b.serialNumber and b.accountId ="+account_id.getAccount_id()+"  and a.activeStatus=1 and a.assetEventId in (1,2)");


								select distinct(z.Serial_Number),s.group_id,s.group_name,p.asset_group_id,p.asset_type_id,p.product_id
						from custom_asset_group_member a RIGHT OUTER JOIN asset as x on a.Serial_Number=x.Serial_Number LEFT OUTER JOIN custom_asset_group as s on a.Group_ID = s.Group_ID,asset_event z ,asset_owners b,products p 
						where z.serial_Number=b.serial_Number and b.account_Id in (1003)  and z.active_Status=1 and z.event_Id in (1,2) and x.serial_number=z.serial_Number and p.product_id= x.product_id 


								//						Query assetQuery=session.createQuery("select distinct(a.serialNumber) from AssetEventEntity a ,AssetAccountMapping b where a.serialNumber=b.serialNumber and b.accountId in ("+accountidsStringList+")  and a.activeStatus=1 and a.eventId in (1,2) ");
								//added by smitha on oct 14th 2013[grouping in summary report Internal Defect 20131014 request contract change]
								String selectQuery = null;
								String fromQuery = null;
								String whereQuery = null;
								String finalQuery2 = null;
								selectQuery = " select distinct(a.serialNumber) ";
								fromQuery =" from AssetCustomGroupMapping w RIGHT OUTER JOIN w.serial_number x  LEFT OUTER JOIN w.group_id s , AssetEventEntity a , AssetOwnerSnapshotEntity b ";
								whereQuery = " where a.serialNumber = b.serialNumber and b.accountId in ("+accountidsStringList+")  and a.activeStatus=1 and a.eventId in (1,2) and x.serial_number=a.serialNumber ";
								if (!(machineGroupIdList == null || machineGroupIdList.isEmpty())) 
								{
									String customAssetGroupStringList = conversionObj.getIntegerListString(machineGroupIdList).toString();
									whereQuery = whereQuery	+ " and s.group_id in ("+ customAssetGroupStringList + ")";
								}

								if ((!(machineProfileIdList == null || machineProfileIdList.isEmpty()))	|| (!(modelIdList == null || modelIdList.isEmpty()))) 
								{
									fromQuery = fromQuery+ " , ProductEntity p ";
									whereQuery = whereQuery	+ " and x.productId = p.productId ";

								}

								if (!(machineProfileIdList == null || machineProfileIdList.isEmpty())) 
								{
									String machineProfileIdStringList = conversionObj.getIntegerListString(machineProfileIdList).toString();
									whereQuery = whereQuery + " and p.assetGroupId in ( "+ machineProfileIdStringList + ") ";
								}

								if (!(modelIdList == null || modelIdList.isEmpty())) 
								{
									String modelIdStringList = conversionObj.getIntegerListString(modelIdList).toString();
									whereQuery = whereQuery + " and p.assetTypeId in ( "+ modelIdStringList + " )";
								}

								//DefectID: 1925 - Rajani Nagaraju - 20140226 - Summary and detail report not matching.. Same VIN was getting counted twice under different tenancy
								if(dueVinList.size()>0)
								{
									String dueVinListAsString = new ListToStringConversion().getStringList(dueVinList).toString();
									whereQuery = whereQuery +  " and a.serialNumber not in ("+dueVinListAsString+")";
								}

								finalQuery2 =  selectQuery + fromQuery + whereQuery;

								Query assetQuery = session.createQuery(finalQuery2);

								//						Query assetQuery=session.createQuery("select distinct(a.serialNumber) from AssetEventEntity a ,AssetAccountMapping b where a.serialNumber=b.serialNumber and b.accountId in ("+accountidsStringList+")  and a.activeStatus=1 and a.eventId in (1,2) ");
								List servicedueList = assetQuery.list();
								Iterator servicedueIterator=servicedueList.iterator();

								if(servicedueIterator.hasNext())
								{
									iLogger.info("serviceduecount");

									serviceduecount=servicedueList.size();
									dataObj.setMachineCountDueForService(serviceduecount);
								}

								//DefectID: 1925 - Rajani Nagaraju - 20140226 - Summary and detail report not matching.. Same VIN was getting counted twice under different tenancy
								while(servicedueIterator.hasNext() && servicedueList.size()!=0 && servicedueList.get(0)!=null)
								{
									AssetEntity serNum = (AssetEntity)servicedueIterator.next();
									dueVinList.add(serNum.getSerial_number().getSerialNumber());
								}

								//serviceoverduecount
								//Query serviceoverduecountQuery=session.createQuery("select count(distinct(a.serialNumber)) from AssetEventEntity a ,AssetAccountMapping b where a.serialNumber=b.serialNumber and b.accountId ="+account_id.getAccount_id()+"  and a.activeStatus=1 and a.assetEventId in (3)");
								String selectQueryOverDue = null;
								String fromQueryOverDue = null;
								String whereQueryOverDue = null;
								String finalQueryOverDue = null;
								selectQueryOverDue = " select distinct(a.serialNumber) ";
								fromQueryOverDue =" from AssetCustomGroupMapping w RIGHT OUTER JOIN w.serial_number x  LEFT OUTER JOIN w.group_id s , AssetEventEntity a , AssetOwnerSnapshotEntity b ";
								whereQueryOverDue = " where a.serialNumber = b.serialNumber and b.accountId in ("+accountidsStringList+")  and a.activeStatus=1 and a.eventId in (3) and x.serial_number=a.serialNumber ";
								if (!(machineGroupIdList == null || machineGroupIdList.isEmpty())) 
								{
									String customAssetGroupStringList = conversionObj.getIntegerListString(machineGroupIdList).toString();
									whereQueryOverDue = whereQueryOverDue	+ " and s.group_id in ("+ customAssetGroupStringList + ")";
								}

								if ((!(machineProfileIdList == null || machineProfileIdList.isEmpty()))	|| (!(modelIdList == null || modelIdList.isEmpty()))) 
								{
									fromQueryOverDue = fromQueryOverDue+ " , ProductEntity p ";
									whereQueryOverDue = whereQueryOverDue	+ " and x.productId = p.productId ";

								}

								if (!(machineProfileIdList == null || machineProfileIdList.isEmpty())) 
								{
									String machineProfileIdStringList = conversionObj.getIntegerListString(machineProfileIdList).toString();
									whereQueryOverDue = whereQueryOverDue + " and p.assetGroupId in ( "+ machineProfileIdStringList + ") ";
								}

								if (!(modelIdList == null || modelIdList.isEmpty())) 
								{
									String modelIdStringList = conversionObj.getIntegerListString(modelIdList).toString();
									whereQueryOverDue = whereQueryOverDue + " and p.assetTypeId in ( "+ modelIdStringList + " )";
								}

								//DefectID: 1925 - Rajani Nagaraju - 20140226 - Summary and detail report not matching.. Same VIN was getting counted twice under different tenancy
								if(overDueVinLlist.size()>0)
								{
									String overDueVinListAsString = new ListToStringConversion().getStringList(overDueVinLlist).toString();
									whereQueryOverDue = whereQueryOverDue +  " and a.serialNumber not in ("+overDueVinListAsString+")";
								}

								finalQueryOverDue =  selectQueryOverDue + fromQueryOverDue + whereQueryOverDue;
								//						Query serviceoverduecountQuery=session.createQuery("select distinct(a.serialNumber) from AssetEventEntity a ,AssetAccountMapping b where a.serialNumber=b.serialNumber and b.accountId in ("+accountidsStringList+")  and a.activeStatus=1 and a.eventId in (3)");
								Query serviceoverduecountQuery=session.createQuery(finalQueryOverDue);
								List serviceoverduecountList = serviceoverduecountQuery.list();
								Iterator serviceoverduecountIterator=serviceoverduecountList.iterator();
								if(serviceoverduecountIterator.hasNext())
								{
									serviceoverduecount=serviceoverduecountList.size();
									dataObj.setMachineCountOverdueForService(serviceoverduecount);

								}

								//DefectID: 1925 - Rajani Nagaraju - 20140226 - Summary and detail report not matching.. Same VIN was getting counted twice under different tenancy
								while(serviceoverduecountIterator.hasNext() && serviceoverduecountList.size()!=0 && serviceoverduecountList.get(0)!=null)
								{
									AssetEntity serNumEnt = (AssetEntity)serviceoverduecountIterator.next();
									overDueVinLlist.add(serNumEnt.getSerial_number().getSerialNumber());
								}

								//ended by smitha on oct 14th 2013[grouping in summary report Internal Defect 20131014 request contract change]
								iLogger.info("tenancyName***");
								Query tenancynameQuery=session.createQuery("select tenancy_name from TenancyEntity where tenancy_id="+dealerIdList.get(i)+"");
								Iterator tenancynameIterator=tenancynameQuery.list().iterator();
								if(tenancynameIterator.hasNext())
								{
									iLogger.info("tenancyName");
									dealerName=(String)tenancynameIterator.next();
									dataObj.setDealerName(dealerName);
								}
								impLlist.add(dataObj);
							}
						}
						else
						{
							continue;
						}


					}

					//ended @2014-09-09 Suprava 

					//ended on 21st Aug 2013

						basicSelectQuery = "SELECT t2.tenancyName,t4.Notification_Name,SUM(t3.NotificationCount), t4.Notification_Id ";
			basicFromQuery = " FROM  TenancyBridgeEntity  t1, TenancyDimensionEntity t2 ,NotificationDimensionEntity t4  ";
			basicWhereQuery = " WHERE t1.parentId in("
//					+ loggedInTenancyId
					+tenancyIdStringList
					+ ") AND t1.childId=t2.tenancyId AND t2.tenacy_Dimension_Id=t3.Tenancy_Id"
//					+ " AND t4.Notification_Name in ('The machine is approaching service','Machine is overdue for service')";
					+ " AND t4.Notification_Id in (1,2,3)";
			groupByQuery = " GROUP BY t1.childId,t4.Notification_Id ";
					 
					//	basicFromQuery = basicFromQuery + " ,NotificationFactEntity_DayAgg t3 ";
					//basicWhereQuery = basicWhereQuery+ " and t3.Time_Key = (select max(Time_Key) from NotificationFactEntity_DayAgg) ";
					//Added notification_fact_Yearagg to get the summary details changes done by Suprava on 12th Aug 2013 dedect id:646
						year = prevDate.getYear();
			basicFromQuery = basicFromQuery + " ,notification_fact_Yearagg t3 ";
			basicWhereQuery = basicWhereQuery+ " and t3.Year = (select max(Year) from notification_fact_Yearagg) ";
					if (period.equalsIgnoreCase("Today")) {
				basicFromQuery = basicFromQuery
						+ " ,NotificationFactEntity_DayAgg t3 ";
				basicWhereQuery = basicWhereQuery
						+ " and t3.Time_Key = (select max(Time_Key) from t3) ";
			} else if (period.equalsIgnoreCase("Week")) {
				basicFromQuery = basicFromQuery
						+ " ,notification_fact_weekagg t3 ";
				basicWhereQuery = basicWhereQuery
						+ " and t3.TimeCount = (select max(TimeCount) from t3) ";
			} else if (period.equalsIgnoreCase("Month")) {
				basicFromQuery = basicFromQuery
						+ " ,notification_fact_Monthagg t3 ";
				basicWhereQuery = basicWhereQuery
						+ " and t3.TimeCount = (select max(TimeCount) from t3) ";
			} else if (period.equalsIgnoreCase("Quarter")) {
				basicFromQuery = basicFromQuery
						+ " ,notification_fact_Quarteragg t3 ";
				basicWhereQuery = basicWhereQuery
						+ " and t3.TimeCount = (select max(TimeCount) from t3) ";
			} else if (period.equalsIgnoreCase("Year")) {
				basicFromQuery = basicFromQuery
						+ " ,notification_fact_Yearagg t3 ";
				basicWhereQuery = basicWhereQuery
						+ " and t3.TimeCount = (select max(TimeCount) from t3) ";
			}

					if (period.equalsIgnoreCase("Week")) {
				week =   thisDate.getWeek();
				year = thisDate.getYear();
				basicFromQuery = basicFromQuery+" notification_fact_weekagg t3 ";

				basicWhereQuery = basicWhereQuery	+ " and t3.TimeCount = "+week +" and t3.Year="+year;
			}
			else if (period.equalsIgnoreCase("Last Week")) {
				week =  prevDate.getWeek();
				if(week==1){
					year = prevDate.getYear();
				}else{
					year = prevDate.getCurrentYear();
				}

				basicFromQuery = basicFromQuery+" notification_fact_weekagg t3 ";

				basicWhereQuery = basicWhereQuery	+ " and t3.TimeCount = "+week+" and t3.Year="+year;
			}

			else if (period.equalsIgnoreCase("Month")) {
				month =  thisDate.getMonth();
				year = thisDate.getYear();
				basicFromQuery = basicFromQuery+" notification_fact_Monthagg t3 ";
				basicWhereQuery = basicWhereQuery	+ " and t3.TimeCount = "	+ month+" and t3.Year="+year;

			}
			else if (period.equalsIgnoreCase("Last Month")) {
				month =  prevDate.getMonth();
				if(month==1){
					year = prevDate.getYear();
				}else{
					year = prevDate.getCurrentYear();
				}

				basicFromQuery = basicFromQuery+" notification_fact_Monthagg t3 ";
				basicWhereQuery = basicWhereQuery	+ " and t3.TimeCount = "	+ month+" and t3.Year="+year;				
			}
			else if (period.equalsIgnoreCase("Quarter")) {
				quarter =  thisDate.getQuarter();
				year = thisDate.getYear();
				basicFromQuery = basicFromQuery+" notification_fact_Quarteragg t3 ";
				basicWhereQuery = basicWhereQuery	+ " and t3.TimeCount  = " +quarter+" and t3.Year="+year;

			}
			else if (period.equalsIgnoreCase("Last Quarter")) {
				quarter = prevDate.getQuarter();
				if(quarter==1){
					year = prevDate.getYear();
				}else{
					year = prevDate.getCurrentYear();
				}
				basicFromQuery = basicFromQuery+" notification_fact_Quarteragg t3 ";
				basicWhereQuery = basicWhereQuery	+ " and t3.TimeCount  = " +quarter+" and t3.Year="+year;

			}
			else if (period.equalsIgnoreCase("Year")) {
				year = thisDate.getYear();
				basicFromQuery = basicFromQuery+" notification_fact_Yearagg t3 ";
				basicWhereQuery = basicWhereQuery	+ " and t3.Year= "+year;
			}
			else if (period.equalsIgnoreCase("Last Year")) {
				year = prevDate.getYear();
				basicFromQuery = basicFromQuery+" notification_fact_Yearagg t3 ";
				basicWhereQuery = basicWhereQuery	+ " and t3.Year= "+year;
			}

								finalQuery = basicSelectQuery + basicFromQuery + basicWhereQuery+ groupByQuery;

			infoLogger.info("Query getMachineTrendData: " + finalQuery);

			Query query = session.createQuery(finalQuery);
			Iterator itr = query.list().iterator();
			String notificationName = null;
			int notificationId=0;
			Object[] result = null;
			HashMap<String, HashMap<Integer, Long>> dealerMachineCountData = new HashMap<String, HashMap<Integer, Long>>();
			HashMap<Integer, Long> dealerData = null;

			String dealerName = null;
			Long notificationCount = 0L;
			dataObj = new MachineServiceDueOverDueImpl();
			while (itr.hasNext()) {
				result = (Object[]) itr.next();

				if (result[0] != null) {
					dealerName = (String) result[0];
				}
				if (result[1] != null) {
					notificationName = (String) result[1];
				}
				if (result[2] != null) {
					notificationCount = (Long) result[2];
				}

				if(result[3]!=null)
				{
					EventEntity event = (EventEntity)result[3];
					notificationId= event.getEventId();
				}
				if (!dealerMachineCountData.containsKey(dealerName)) {
					dealerData = new HashMap<Integer, Long>();
					dealerData.put(notificationId, notificationCount);
					dealerMachineCountData.put(dealerName, dealerData);
				} else if (dealerMachineCountData.containsKey(dealerName)) {
					dealerData = dealerMachineCountData.get(dealerName);
					dealerData.put(notificationId, notificationCount);
					dealerMachineCountData.remove(dealerName);
					dealerMachineCountData.put(dealerName, dealerData);
				}
			}

			dataObj.setDealerMachineCountData(dealerMachineCountData);

				} 
			}
			else{//Keerthi: 16/07/14 : checking for sub tenancy ids exists or not
				iLogger.info("No child tenancys found for "+loggedInTenancyId+ " in MachineServiceDueOverDueReportService");
			}
		}
		catch(Exception e)
		{
			e.printStackTrace();
			fLogger.fatal("Exception :"+e);
		}

		finally 
		{
			if (session.getTransaction().isActive()) {
				session.getTransaction().commit();
			}
			if (session.isOpen()) {
				session.flush();
				session.close();
			}
		}

		return impLlist;

			}
*/
	
	
	//New Query implementation for service due over due machine count added by S Suresh on 26-nov-2015
    
    /**
    * method to get machine service due/over due count for all tenancies under
    * logged-in tenancy id.
    * 
     * @param loggedInTenancyId
    * @return list
    */
    public List<MachineServiceDueOverDueImpl> getMachineServiceDueOverDueCount(List<Integer> tenancyIdList,List<Integer> machineGroupIdList,
                  List<Integer> machineProfileIdList,      List<Integer> modelIdList) 
                  {//Re-Imeplemented whole Logic by Juhi on 27-09-2013 for Defect Id:1372
           //Logger fatalError = Logger.getLogger("fatalErrorLogger");
           List<MachineServiceDueOverDueImpl> impLlist=new LinkedList<MachineServiceDueOverDueImpl>();
           
           Logger iLogger = InfoLoggerClass.logger;
           Logger fLogger = FatalLoggerClass.logger;
           
           Session session = HibernateUtil.getSessionFactory().getCurrentSession();
           session.beginTransaction();

           try
           {
                  //DF20140108 - Rajani Nagaraju - To take LoginTenancyId as a list and not an integer
                  ListToStringConversion conversion = new ListToStringConversion();
                  String loggedInTenancyId = conversion.getIntegerListString(tenancyIdList).toString();

                  String basicFromQuery = null;
                  String basicSelectQuery = null;
                  String basicWhereQuery = null;
                  String groupByQuery = null;
                  String finalQuery = null;

                  int year =0;
                  
                  List<String> dealerIdList1=new LinkedList<String>();
                  
                  String accountType = "Customer";
                  Calendar cal = Calendar.getInstance();
                  year = cal.get(Calendar.YEAR);
                  basicSelectQuery = "select count(distinct yearagg.serialNumber),ae.eventSeverity,p_acc.account_name ";

                  basicFromQuery = "from AssetOwnerSnapshotEntity aos,AssetOwnerSnapshotEntity aos1," +
                                                                        "AssetEventEntity ae,AssetMonitoringFactDataYearAgg yearagg,AccountTenancyMapping a_t," +
                                                                        "AccountTenancyMapping a_t1,TenancyDimensionEntity td," +
                                                                        "AccountEntity acc,AccountEntity p_acc ";
                                                                        
                  basicWhereQuery = "where a_t1.tenancy_id in ("+loggedInTenancyId+") and " +
                                                                                        "aos.accountId = a_t1.account_id and " +
                                                                                        "aos1.serialNumber = aos.serialNumber and " +
                                                                                        "aos1.accountType = '"+accountType+"' and " +
                                                                                        "ae.serialNumber = aos1.serialNumber and " +
                                                                                        "acc.account_id = aos1.accountId and " +
                                                                                        "p_acc.account_id = acc.parent_account_id and " +
                                                                                        "a_t.account_id = aos1.accountId and " +
                                                                                         "td.tenancyId = a_t.tenancy_id and " +
                                                                                         "yearagg.serialNumber = aos1.serialNumber and " +
                                                                                        "yearagg.tenancyId = td.tenacy_Dimension_Id and " +
                                                                                        "yearagg.year="+year+" and " +
                                                                                        "ae.activeStatus =1 and " +
                                                                                        "ae.eventId in (1,2,3) ";
                                                                                        
                  String basicGroupQuery = "group by ae.eventSeverity,p_acc.account_name ";
                  String basicorderQuery = "order by p_acc.account_name,ae.eventSeverity";
                  
                   
                   finalQuery = basicSelectQuery+basicFromQuery+basicWhereQuery+basicGroupQuery+basicorderQuery;
                  Query dueOverdueCountQuery = session.createQuery(finalQuery);
                  Iterator dueOverdueCountItr = dueOverdueCountQuery.list().iterator();
                  
                   String commonDealerName = "";
                  Object[] result = null;
                  MachineServiceDueOverDueImpl implObj = new MachineServiceDueOverDueImpl();
                  Map<String,Long> dealerToDueCount = new HashMap<String, Long>();
                  Map<String,Long> dealerToOverDueCount = new HashMap<String, Long>();
                  boolean redFlag = false;
                  boolean yellowFlag = false;
                  boolean flag = true;
                  while(dueOverdueCountItr.hasNext())
                  {
                        result = (Object[])dueOverdueCountItr.next();
                        if(((String)result[1]).equals("YELLOW"))
                        {
                               dealerToDueCount.put((String)result[2], (Long)result[0]);
                        }
                        else if(((String)result[1]).equals("RED"))
                        {
                               dealerToOverDueCount.put((String)result[2], (Long)result[0]);
                        }
                        if(!commonDealerName.equals((String)result[2]))
                        {
                               commonDealerName = (String)result[2];
                               dealerIdList1.add((String)result[2]);
                        }
                               
                  }
                  
                   for(String dealer : dealerIdList1)
                  {
                        implObj = new MachineServiceDueOverDueImpl();
                        implObj.setDealerName(dealer);
                        if(dealerToDueCount.containsKey(dealer))
                        {
                               implObj.setMachineCountDueForService(dealerToDueCount.get(dealer));
                        }
                        if(dealerToOverDueCount.containsKey(dealer))
                        {
                               implObj.setMachineCountOverdueForService(dealerToOverDueCount.get(dealer));
                        }
                        impLlist.add(implObj);
                  }
           }
           catch(Exception e)
           {
                  e.printStackTrace();
                  fLogger.fatal("Exception :"+e);
           }

           finally 
           {
                  if (session.getTransaction().isActive()) {
                        session.getTransaction().commit();
                  }
                  if (session.isOpen()) {
                        session.flush();
                        session.close();
                  }
           }

           return impLlist;

                  }
    
    
    //-----------------------------------------------------------------


	//=================================================================
	//-----------------------------------------------------------------

	public List<NotificationSummaryReportImpl> GetNotificationSummaryReportDetails(String fromDate,String toDate,String LoginId, String Period, List<Integer> TenancyIdList, List<Integer> MachineGroupIdList,
			List<Integer> MachineProfileIdList,boolean machineGroup,List<Integer> ModelidList,boolean machineProfile,boolean model,List<Integer> alertTypeIdList,List<Integer> loginTenancyIdList){

		long startTime = System.currentTimeMillis();
		Session session = HibernateUtil.getSessionFactory().openSession();
		session.beginTransaction();
		Logger fLogger = FatalLoggerClass.logger;
		//Logger bLogger = BusinessErrorLoggerClass.logger;
		Logger iLogger = InfoLoggerClass.logger;
		iLogger.info("Entering the method GetNotificationSummaryReportDetails");
		List<NotificationSummaryReportImpl> ImplList = new LinkedList<NotificationSummaryReportImpl>();
		HashMap<String,Long> nameCount=new HashMap<String, Long>();
		List<String> serialNumberList=new LinkedList<String>();


		//Defect id:1406 Added by Juhi on 31-oct-2013 Parameters for total
		long securityTotal=0l;
		long healthTotal=0l;
		long utilizationTotal=0l;
		long landmarkTotal=0l;
		long servicesTotal=0l;
		long totalNotification=0l;

		//DefectId: DF20131213 - Smitha - To display the VINs that has not communicated for the given time period 
		SimpleDateFormat dateFrmt = new SimpleDateFormat("yyyy-MM-dd");
		String lastDateInPeriod=null;
		String startDateInPeriod=null;

		HashMap<String,ArrayList<String>> serNoOtherValueMap=new HashMap<String, ArrayList<String>>();
		HashMap<String, HashMap<String,Long>> serNoTypeCountMap=new HashMap<String, HashMap<String,Long>>();
		String notificationTypName=null;
		Long count=(long)0;
		String serialNumber1=null;
		String serialNumber=String.valueOf(0);
		String tenancyName=null;
		String nickName=null;
		String assetGroupName=null;
		int tenancyId=0; 
		int assetGroupId=0;
		int assetTypeId=0;
		String assetTypeName=null;
		String tenancyId1=null;
		String assetGroupId1=null;
		String assetTypeId1=null;
		//DefectId:20150224 @Suprava DealerName New Parameter Added
		String dealerName =null;
		String finalQuery = null;                                     
		NotificationSummaryReportImpl impl = null;
		String basicSelectQuery=null;
		String basicWhereQuery=null;
		String basicFromQuery=null;
		HashMap<String, AssetCustomGroupMapping> serGroupMap=new HashMap<String,AssetCustomGroupMapping>();

		try{
			//Defect ID:1406 - Smitha - 20131213
			//Smitha....DefectID:20131226....to get the correct notification count for a VIN...code change in group by clause.
			String groupBy=" GROUP BY e.Notification_Type_Name, a.SerialNumber, c.group_id ";

			Calendar c=Calendar.getInstance();
			int currentYear = c.get(Calendar.YEAR);
			ListToStringConversion conversionObj = new ListToStringConversion();
		//	TenancyIdList = getSubTenancyIds(TenancyIdList,session);    
			String tenancyIdStringList = conversionObj.getIntegerListString(TenancyIdList).toString();
			String loginTenIdListString = conversionObj.getIntegerListString(loginTenancyIdList).toString();;

			basicSelectQuery="select e.Notification_Type_Name,sum(a.NotificationCount), a.SerialNumber," +
			" f.nick_name,g.tenancyName,d.assetGroupName,g.tenancyId,d.assetGroupId,d.assetTypeId,d.assetTypeName, c.group_id as machineGroupId, c.group_name as machineGroupName " +
			//DefectID:1406 - Juhi  2013-October-30 
			", ten.tenancy_id as mgTenancy ," +
			//DefectId:20150224 @ Suprava Delaer As a new parameter Added
			"g.parentTenancyName,g.tenancyTypeId "; 
			
			//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
			basicFromQuery = " from AssetCustomGroupMapping w RIGHT OUTER JOIN w.serial_number x LEFT OUTER JOIN w.group_id c " +
			//DefectID:1406 - Juhi  2013-October-30 - MachineGrouping issue in Reports and sending Report Totals information
			"LEFT OUTER JOIN c.tenancy_id ten,";
			//end Defect ID:1406
			basicWhereQuery = " where a.Tenancy_Id = g.tenacy_Dimension_Id and t.parentId in ( " + tenancyIdStringList +" ) and g.tenancyId=t.childId " +
			" and a.Notification_Id=e.Notification_Dimension_Id " +
			" and a.SerialNumber =f.serial_number" +
			" and a.AssetClass_Id = d.assetClassDimensionId and x.serial_number = a.SerialNumber" ;

			//Custom Dates (fromDate,toDate) added by Juhi on 14-August-2013 
			if(fromDate == null && toDate==null)
			{
				if ((Period.equalsIgnoreCase("Week"))||(Period.equalsIgnoreCase("Last Week"))) {
					Date currentDate = new Date();
					DateUtil dateUtilObj = new DateUtil();
					DateUtil dateUtilObj1 = new DateUtil();
					if (Period.equalsIgnoreCase("Week")){
						dateUtilObj  = dateUtilObj. getCurrentDateUtility(currentDate);
						int week = dateUtilObj. getWeek();
						int year = dateUtilObj. getYear();

						basicFromQuery = basicFromQuery + " notification_fact_weekagg a ";

						basicWhereQuery = basicWhereQuery+ " and a.TimeCount = "+week+" and a.Year = "+year+"";

						//DefectId: DF20131213 - Smitha - To display the VINs that has not communicated for the given time period 
						//get the Last Day 
						Calendar cal = Calendar.getInstance();
						lastDateInPeriod = dateFrmt.format(cal.getTime());
						//get the first day of the week
						cal.set(Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek());
						startDateInPeriod=  dateFrmt.format(cal.getTime());

					}
					if(Period.equalsIgnoreCase("Last Week")){
						dateUtilObj  = dateUtilObj. getPreviousDateUtility(currentDate);
						dateUtilObj1  = dateUtilObj1. getCurrentDateUtility(currentDate);
						int week = dateUtilObj. getWeek();
						int year=0;
						if(dateUtilObj1.getWeek()==1)
							year = dateUtilObj.getYear();
						else
							year = dateUtilObj.getCurrentYear();

						basicFromQuery = basicFromQuery + " notification_fact_weekagg a ";

						basicWhereQuery = basicWhereQuery+ " and a.TimeCount = "+week+" and a.Year = "+year+"";

						//DefectId: DF20131213 - Smitha - To display the VINs that has not communicated for the given time period 
						//get the Last Day of Previous Week
						Calendar cal = Calendar.getInstance();
						int i = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
						cal.add(Calendar.DATE, -i - 7);
						cal.add(Calendar.DATE, 6);
						lastDateInPeriod = dateFrmt.format(cal.getTime());
						//get the First Day of Previous Week
						cal = Calendar.getInstance();
						int j = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
						cal.add(Calendar.DATE, -j - 7);
						cal.set(Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek());
						startDateInPeriod=  dateFrmt.format(cal.getTime());

					}
				}
				else if ((Period.equalsIgnoreCase("Month"))||(Period.equalsIgnoreCase("Last Month"))) { DateUtil dateUtilObj1 = new DateUtil();
				Date currentDate = new Date();
				DateUtil dateUtilObj = new DateUtil();   
				if(Period.equalsIgnoreCase("Month")){
					dateUtilObj  = dateUtilObj. getCurrentDateUtility(currentDate);
					int month = dateUtilObj. getMonth ();
					int year = dateUtilObj. getYear();

					basicFromQuery = basicFromQuery + " notification_fact_Monthagg a ";

					basicWhereQuery = basicWhereQuery+ " and a.TimeCount = "+month+" and a.Year = "+year+"";

					//DefectId: DF20131213 - Smitha - To display the VINs that has not communicated for the given time period 
					//get the Last Day 
					Calendar cal = Calendar.getInstance();
					lastDateInPeriod = dateFrmt.format(cal.getTime());
					//get the First Day of current Month
					String mon = month+"";
					if(mon.length()<2)
						mon="0"+mon;
					startDateInPeriod=year+"-"+mon+"-"+"01";

				}
				if(Period.equalsIgnoreCase("Last Month")){
					dateUtilObj1  = dateUtilObj1. getCurrentDateUtility(currentDate);
					dateUtilObj  = dateUtilObj. getPreviousDateUtility (currentDate);
					int month = dateUtilObj. getMonth ();
					int year=0;
					if(dateUtilObj1.getMonth() ==1)
						year = dateUtilObj.getYear();
					else
						year = dateUtilObj.getCurrentYear();

					basicFromQuery = basicFromQuery + " notification_fact_Monthagg a ";

					basicWhereQuery = basicWhereQuery+ " and a.TimeCount = "+month+" and a.Year = "+year+"";

					//DefectId: DF20131213 - Smitha - To display the VINs that has not communicated for the given time period 
					//Get the Last Day of previous Month
					Calendar cal = Calendar.getInstance();
					cal.set(Calendar.DATE, 1);
					cal.add(Calendar.DAY_OF_MONTH, -1);
					lastDateInPeriod = dateFrmt.format(cal.getTime());
					//get the First Day of Previous Month
					String mon = month+"";
					if(mon.length()<2)
						mon="0"+mon;
					startDateInPeriod=year+"-"+mon+"-"+"01";

				}
				} 
				else if((Period.equalsIgnoreCase("Quarter"))||(Period.equalsIgnoreCase("Last Quarter"))) { 

					DateUtil dateUtilObj1 = new DateUtil();
					Date currentDate = new Date();
					DateUtil dateUtilObj = new DateUtil();
					if(Period.equalsIgnoreCase("Quarter")){
						dateUtilObj  = dateUtilObj. getCurrentDateUtility(currentDate);
						int quarter = dateUtilObj. getQuarter ();
						int year = dateUtilObj. getYear();

						basicFromQuery = basicFromQuery + " notification_fact_Quarteragg a ";

						basicWhereQuery = basicWhereQuery+ " and a.TimeCount = "+quarter+" and a.Year = "+year+"";

						//DefectId: DF20131213 - Smitha - To display the VINs that has not communicated for the given time period 
						//get the Last Day 
						Calendar cal = Calendar.getInstance();
						lastDateInPeriod = dateFrmt.format(cal.getTime());
						//get the first Date of current quarter
						switch(quarter) 
						{
						case 3 : 
							startDateInPeriod = year+"-07-01";
							break;
							// return July 01
						case 2 :
							startDateInPeriod = year+"-04-01";
							break;
							// return April 01
						case 1 :
							startDateInPeriod = year+"-01-01";
							break;
							// return Jan 01
						case 4 : 
							startDateInPeriod = year+"-10-01";
							break;
							// return Oct 01
						}

					}
					if(Period.equalsIgnoreCase("Last Quarter")){
						dateUtilObj1  = dateUtilObj1. getCurrentDateUtility(currentDate);
						dateUtilObj  = dateUtilObj. getPreviousDateUtility(currentDate);
						int quarter = dateUtilObj. getQuarter ();
						int year=0;
						if(dateUtilObj1.getQuarter() ==1)
							year = dateUtilObj.getYear();
						else
							year = dateUtilObj.getCurrentYear();

						basicFromQuery = basicFromQuery + " notification_fact_Quarteragg a ";

						basicWhereQuery = basicWhereQuery+ " and a.TimeCount = "+quarter+" and a.Year = "+year+"";

						//DefectId: DF20131213 - Smitha - To display the VINs that has not communicated for the given time period 
						//get the last day of previous quarter
						switch(quarter) 
						{
						case 3 : 
							lastDateInPeriod = year+"-09-30";
							break;
							// return September 30
						case 2 :
							lastDateInPeriod = year+"-06-30";
							break;
							// return June 30
						case 1 :
							lastDateInPeriod = year+"-03-31";
							break;
							// return March 31
						case 4 : 
							lastDateInPeriod = year+"-12-31";
							break;
							// return December 31
						}
						//get the first Date of Previous quarter
						switch(quarter) 
						{
						case 3 : 
							startDateInPeriod = year+"-07-01";
							break;
							// return July 01
						case 2 :
							startDateInPeriod = year+"-04-01";
							break;
							// return April 01
						case 1 :
							startDateInPeriod = year+"-01-01";
							break;
							// return Jan 01
						case 4 : 
							startDateInPeriod = year+"-10-01";
							break;
							// return Oct 01
						}

					}
				}
				else if ((Period.equalsIgnoreCase("Year"))||(Period.equalsIgnoreCase("Last Year")))
				{
					Date currentDate = new Date();
					DateUtil dateUtilObj = new DateUtil();
					if(Period.equalsIgnoreCase("Year")){
						dateUtilObj  = dateUtilObj. getCurrentDateUtility(currentDate);
						int year = dateUtilObj. getYear();

						basicFromQuery = basicFromQuery + " notification_fact_Yearagg a ";

						basicWhereQuery = basicWhereQuery+ " and a.Year = "+year+"";

						//DefectId: DF20131213 - Smitha - To display the VINs that has not communicated for the given time period 
						//get the Last Day 
						Calendar cal = Calendar.getInstance();
						lastDateInPeriod = dateFrmt.format(cal.getTime());
						//get the First day of current Year
						startDateInPeriod=year+"-01"+"-01";

					}
					if(Period.equalsIgnoreCase("Last Year")){
						dateUtilObj  = dateUtilObj. getPreviousDateUtility(currentDate);
						int year = dateUtilObj. getYear();

						basicFromQuery = basicFromQuery + " notification_fact_Yearagg a ";

						basicWhereQuery = basicWhereQuery+ " and a.Year = "+year+"";

						//DefectId: DF20131213 - Smitha - To display the VINs that has not communicated for the given time period 
						//get the Last day of previous Year
						lastDateInPeriod=year+"-12-31";
						//get the First day of Previous Year 
						startDateInPeriod=year+"-01"+"-01";

					}
				}
			}
			//Logic for Custom Dates (fromDate,toDate) added by Juhi on 14-August-2013 
			else
			{                                            
				basicFromQuery = basicFromQuery + " NotificationFactEntity_DayAgg a";
				//end Defect ID:1406
				basicWhereQuery = basicWhereQuery+ " and a.Time_Key between '"+fromDate+"%' and '"+toDate+"%' ";
				//                                                                commented by Keerthi :31/12/13 
				//                                                                groupBy=groupBy+" , a.Time_Key,a.Tenancy_Id";
				//DefectID's:1736 and 1406 and 1924 -----Smitha----- filterig based on machine grouping,machine profile and model id.
				startDateInPeriod=fromDate;
				lastDateInPeriod=toDate;
			}
			//Logic for Custom Dates (fromDate,toDate) added by Juhi on 14-August-2013 
			basicFromQuery = basicFromQuery+" , TenancyDimensionEntity g , NotificationDimensionEntity e , AssetEntity f,AssetClassDimensionEntity d,TenancyBridgeEntity t  ";

			if (!(MachineGroupIdList == null || MachineGroupIdList.isEmpty())) {
				String customAssetGroupStringList = conversionObj
				.getIntegerListString(MachineGroupIdList).toString();
				basicWhereQuery = basicWhereQuery + " and c.group_id in ("
				+ customAssetGroupStringList + ")";
			}

			if (!((MachineProfileIdList == null) || (MachineProfileIdList.isEmpty()))) {
				//DefectID's:1736 and 1406 and 1924 -----Smitha----- filterig based on machine grouping,machine profile and model id.
				machineProfile = true;
				String machineProfileIdListStringList = conversionObj.getIntegerListString(MachineProfileIdList).toString();
				basicWhereQuery = basicWhereQuery + " and d.assetGroupId in ("+ machineProfileIdListStringList + ")";
			}
			if (!((ModelidList == null) || (ModelidList.isEmpty()))) {
				//DefectID's:1736 and 1406 and 1924 -----Smitha----- filterig based on machine grouping,machine profile and model id.
				model=true;
				String modelIdListStringList = conversionObj.getIntegerListString(ModelidList).toString();
				basicWhereQuery = basicWhereQuery + " and d.assetTypeId in ("+ modelIdListStringList + ")";
			}
			//added by smitha on july 24th...Defect id 800 and 1041

			if (!((alertTypeIdList == null) || (alertTypeIdList.isEmpty()))) {
				String alertTypeIdStringList = conversionObj.getIntegerListString(alertTypeIdList).toString();
				basicWhereQuery = basicWhereQuery + " and e.Notification_Type_Id in ("+ alertTypeIdStringList +")";
			}

			//ended on july 24th....Defect id 800 and 1041
			finalQuery = basicSelectQuery + basicFromQuery + basicWhereQuery + groupBy + " order by a.SerialNumber ";                                    
			Query query = session.createQuery(finalQuery);
			String machineGroupName=null;
			int machineGroupId=0;
			Iterator itr = query.list().iterator();
			Object[] result=null;
			Object[] resultNCVins=null, actualOwnerVINListObj = null;
			//DefectID:1406 - Juhi  2013-October-30 - MachineGrouping issue in Reports and sending Report Totals information
			List<String> otherMachineGroupVins = new LinkedList<String>();
			List<String> serialNumbersList = new LinkedList<String>();
			//code change done juhi 3dec
			HashMap<String,String> ser_NotificationMap=new HashMap<String,String>();
			List<String> ser_notificationList = new LinkedList<String>();
			List<String> ser_notificationNameList = new LinkedList<String>();
			Set<String> landmarkSet = new HashSet<String>();
			//Outer:
			while(itr.hasNext())
			{           

				result = (Object[]) itr.next();
				serialNumber=null;


				if(result[0]!=null){
					notificationTypName=result[0].toString();
				}
				if(result[1]!=null){
					count=(Long)result[1];
				}

				if(result[2]!=null){
					serialNumber=result[2].toString();
				}                                                                                   

				if(result[4]!=null){
					tenancyName=result[4].toString();
				}
				if(result[3]!=null){
					nickName=result[3].toString();
				}
				if(result[5]!=null){
					assetGroupName=result[5].toString();
				}
				if(result[6]!=null){
					tenancyId=(Integer)result[6];
					tenancyId1=String.valueOf(tenancyId);
				}
				if(result[7]!=null){
					assetGroupId=(Integer)result[7];
					assetGroupId1=String.valueOf(assetGroupId);
				}
				if(result[8]!=null){
					assetTypeId=(Integer)result[8];
					assetTypeId1=String.valueOf(assetTypeId);
				}
				if(result[9]!=null){
					assetTypeName=result[9].toString();
				}
				//DefectId:20150224 @ Suprava Dealer As a new parameter Added
				TenancyEntity tenancyEntity =null;
				if(result[14]!=null)
						{
							int tenancyTypeId =(Integer) result[14];
							//If the Machine is with customer Get the parentTeancyId
							if(tenancyTypeId==4)
							{
								dealerName =result[13].toString();
							}
							//If the Machine is with Dealer
							else if(tenancyTypeId==3) 
							{
								if(result[4]!=null)
								{
									dealerName =(String)result[4];
							    }
							}
							else
							{
								dealerName ="No Dealer Taggging";
							}
						
						}


				ArrayList<String> otherValueList=new ArrayList<String>();
				int index=0;
				otherValueList.add(index++,tenancyId1);
				otherValueList.add(index++,tenancyName);
				otherValueList.add(index++,nickName);
				otherValueList.add(index++,assetGroupId1);
				otherValueList.add(index++,assetGroupName);
				otherValueList.add(index++,assetTypeId1);
				otherValueList.add(index++,assetTypeName);
				otherValueList.add(index++, dealerName);

				if(!serNoOtherValueMap.containsKey(serialNumber))
				{
					serNoOtherValueMap.put(serialNumber, otherValueList);
				}
				HashMap<String,Long> typeCount=new HashMap<String, Long>();
				if(notificationTypName!=null && !notificationTypName.equalsIgnoreCase("Landmark")){//skipping landmark alerts
					if((!serNoTypeCountMap.containsKey(serialNumber)))
					{
						typeCount.put(notificationTypName, count);
						serNoTypeCountMap.put(serialNumber,typeCount);

					}
					else
					{
						typeCount=serNoTypeCountMap.get(serialNumber);
						typeCount.put(notificationTypName,count);
						serNoTypeCountMap.remove(serialNumber);
						serNoTypeCountMap.put(serialNumber,typeCount);
					}
				}
				else{
					landmarkSet.add(serialNumber);
				}
				//added by smitha on Dec 13th 2013...DefectID:20131213...for machine grouping logic
				if(machineGroup)
				{
					Query mgQuery=null;
					if (!(MachineGroupIdList == null || MachineGroupIdList.isEmpty())) 
					{
						String customAssetGroupStringList = conversionObj.getIntegerListString(MachineGroupIdList).toString();
						mgQuery = session.createQuery(" select a from AssetCustomGroupMapping a, CustomAssetGroupEntity b " +
								"where serial_number='"+serialNumber+"' and a.group_id=b.group_id and b.level=2 and b.active_status=1 and b.tenancy_id in ("+loginTenIdListString+")" +
								" and b.group_id in ("+customAssetGroupStringList+")");
					}

					else
					{
						mgQuery = session.createQuery(" select a from AssetCustomGroupMapping a, CustomAssetGroupEntity b " +
								"where serial_number='"+serialNumber+"' and a.group_id=b.group_id and b.level=2 and b.active_status=1 and b.tenancy_id in ("+loginTenIdListString+")");
					}
					Iterator mgItr = mgQuery.list().iterator();
					int firstIteration =0;
					while(mgItr.hasNext())
					{
						AssetCustomGroupMapping mgVinMapping = (AssetCustomGroupMapping)mgItr.next();
						serGroupMap.put(serialNumber,mgVinMapping);
					}
				} 
				//ended.....DefectID:20131213...for machine grouping logic
			}
			//Keerthi : 30/05/2014 : to date is changed to todate+23:59:59
			DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
			DateFormat dateFormat1 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
			Date fromdate1=null;
			String fromdate2=null;
			String todate2=null; 
			if(!(startDateInPeriod == null && lastDateInPeriod==null))
			{           	


				try {	

					fromdate1 = (Date)dateFormat.parse(startDateInPeriod);		
					String fromdate=dateFormat.format(fromdate1);
					fromdate2=dateFormat1.format(fromdate1);					
					Date todate1=(Date)dateFormat.parse(lastDateInPeriod);				
					String todate=dateFormat.format(todate1);
					todate2=dateFormat1.format(todate1);	
					todate2=dateFormat.format((Date)dateFormat.parse(todate2))+" 23:59:59";
				} catch (ParseException e) {
					e.printStackTrace();
				}						
			}   
			//Keerthi : 24/12/2013 : get landmark count for PINs separately
			HashMap<String,Long> typeCountMap=null;
			TreeMap<String,Long> landmarkCountMap = getLandmarkCount(landmarkSet, loginTenancyIdList, fromdate2, todate2, session);
			if(landmarkCountMap!=null){
				for (String PIN : landmarkCountMap.keySet()) {
					iLogger.info("PIN "+PIN+" Count "+landmarkCountMap.get(PIN));
					if(serNoTypeCountMap!=null){
						if(serNoTypeCountMap.containsKey(PIN)){
							typeCountMap=serNoTypeCountMap.get(PIN);
							typeCountMap.put("Landmark", landmarkCountMap.get(PIN));
							serNoTypeCountMap.put(PIN, typeCountMap);
						}
						else{
							typeCountMap = new HashMap<String, Long>();
							typeCountMap.put("Landmark", landmarkCountMap.get(PIN));
							serNoTypeCountMap.put(PIN, typeCountMap);
						}
					}

				}

			}
			ArrayList<String> otherValuesList =null;
			for (String entry : serNoOtherValueMap.keySet()) {                     
				otherValuesList = serNoOtherValueMap.get(entry);
				impl = new NotificationSummaryReportImpl();
				impl.setSerialNumber(entry);
				int tenancyIdint=Integer.parseInt(otherValuesList.get(0));
				impl.setTenancyId(tenancyIdint);
				impl.setNotificationTypeName(notificationTypName);
				impl.setCount(count);
				impl.setTenancy_name(otherValuesList.get(1));
				impl.setNickName(otherValuesList.get(2));    
				int assetGroupIdint=Integer.parseInt(otherValuesList.get(3));
				impl.setAssetGroupId(assetGroupIdint);
				impl.setAssetGroupName(otherValuesList.get(4));
				int assetTypeIdint=Integer.parseInt(otherValuesList.get(3));
				int modelIdint=Integer.parseInt(otherValuesList.get(5));
				impl.setAssetTypeId(assetTypeIdint);
				String assetTypeName1=otherValuesList.get(6);
				impl.setAssetTypeName(assetTypeName1);
				//DefectId:20150220 @ Suprava Delaer As a new parameter Added
				String dealer_Name =otherValuesList.get(7);
				impl.setDealerName(dealer_Name);
				impl.setNameCount(serNoTypeCountMap.get(entry));
				//DefectID:1406 - Juhi  2013-October-31 
				serialNumberList.add(entry);

				HashMap<String,Long> temphashmap=serNoTypeCountMap.get(entry);
				//Roopa null check
				if(temphashmap!=null){
				for (Map.Entry keyEntry : temphashmap.entrySet()) 
				{ 
					String noticificationName=(String)keyEntry.getKey();
					if(noticificationName.equalsIgnoreCase("Security"))
					{
						securityTotal=securityTotal+ (Long)keyEntry.getValue();
					}
					else if(noticificationName.equalsIgnoreCase("Health"))
					{
						healthTotal=healthTotal+ (Long)keyEntry.getValue();
					}
					else if(noticificationName.equalsIgnoreCase("Utilization"))
					{
						utilizationTotal=utilizationTotal+ (Long)keyEntry.getValue();
					}
					else if(noticificationName.equalsIgnoreCase("Landmark"))
					{
						landmarkTotal=landmarkTotal+ (Long)keyEntry.getValue();
					}
					else if(noticificationName.equalsIgnoreCase("Service") || noticificationName.equalsIgnoreCase("Services"))
					{
						servicesTotal=servicesTotal+ (Long)keyEntry.getValue();
					}

				}
				}


				ImplList.add(impl);
				//added by smitha on Dec 13th 2013...DefectID:20131213...for machine grouping logic
				for(String serNo:serGroupMap.keySet()){
					AssetCustomGroupMapping group = serGroupMap.get(serNo);
					if(entry.equalsIgnoreCase(serNo)){
						impl = new NotificationSummaryReportImpl();

						impl.setMachineGroupId(group.getGroup_id().getGroup_id());
						impl.setMachineGroupName(group.getGroup_id().getGroup_name());
						impl.setSerialNumber(serNo);
						impl.setTenancyId(tenancyIdint);
						impl.setCount(count);
						impl.setTenancy_name(otherValuesList.get(1));
						impl.setNickName(otherValuesList.get(2)); 
						impl.setAssetGroupId(assetGroupIdint);
						impl.setAssetGroupName(otherValuesList.get(4));
						impl.setAssetTypeId(assetTypeIdint);
						impl.setAssetTypeName(assetTypeName1);
						//DefectId:20150220 @ Suprava Delaer As a new parameter Added
						impl.setDealerName(dealer_Name);
						impl.setNameCount(serNoTypeCountMap.get(entry));
						impl.setNotificationTypeName(notificationTypName);

						ImplList.add(impl);
					}
				}
				//ended.....DefectID:20131213...for machine grouping logic
			}

			//DefectId: DF20131213 - Smitha - To display the VINs that has not communicated for the given time period 
			Query ownerListQuery = session.createQuery(" select distinct c.serialNumber , b.tenancy_id " +
					" from TenancyBridgeEntity a, AccountTenancyMapping b, AssetAccountMapping c " +
					" where a.childId= b.tenancy_id " +
					" and b.account_id= c.accountId " +
					" and a.parentId in ("+tenancyIdStringList+") and" +
					" ( (c.ownershipStartDate between '"+startDateInPeriod+"' and '"+lastDateInPeriod+"') OR " +
					"   (c.ownershipStartDate = ( select max(y.ownershipStartDate) from AssetAccountMapping y " +
					" where y.serialNumber= c.serialNumber" +
					" and y.ownershipStartDate <='"+startDateInPeriod+"')" +
					"    )" +
			" )");
			Iterator ownerListItr = ownerListQuery.list().iterator();
			List<String> actualOwnerVINList = new LinkedList<String>();
			AssetEntity assetList = null;
			TenancyEntity tenancyList = null;
			String tempSer = null;
			HashMap<String, TenancyEntity> serTenancyMap = new HashMap<String, TenancyEntity>();
			HashMap<String, AssetEntity> serAssetMap = new HashMap<String, AssetEntity>();
			while(ownerListItr.hasNext())
			{
				impl = new NotificationSummaryReportImpl();
				actualOwnerVINListObj  = (Object[]) ownerListItr.next();
				/*AssetEntity assetList = (AssetEntity)ownerListItr.next();
          			actualOwnerVINList.add(assetList.getSerial_number().getSerialNumber());*/
				if(actualOwnerVINListObj[0]!=null){
					assetList = (AssetEntity)actualOwnerVINListObj[0];
					tempSer = assetList.getSerial_number().getSerialNumber();
					if(!actualOwnerVINList.contains(tempSer)){
						actualOwnerVINList.add(tempSer);
						serAssetMap.put(tempSer, assetList);
					}        				
				}
				if(actualOwnerVINListObj[1]!=null){
					tenancyList = (TenancyEntity)actualOwnerVINListObj[1];
					serTenancyMap.put(tempSer, tenancyList);
				}
			}
			//Get only the List of VINs which has not communicated for the Given period
			actualOwnerVINList.removeAll(serialNumberList);
			String actualOwnerVinListString = conversionObj.getStringList(actualOwnerVINList).toString();
			if(machineGroup){                            		                              		
				//          		Query nCVINsGroupIDQuery = session.createQuery(" select m.group_id , m.serial_number , c.group_name from AssetCustomGroupMapping m, CustomAssetGroupEntity c where m.serial_number in ("+actualOwnerVinListString+") and m.group_id=c.group_id" );
				Query nCVINsGroupIDQuery = session.createQuery(" select m.group_id , m.serial_number , c.group_name from AssetCustomGroupMapping m LEFT OUTER JOIN m.group_id c where m.serial_number in ("+actualOwnerVinListString+") and c.level=2 and c.active_status=1 and c.tenancy_id in ("+loginTenIdListString+")");

				Iterator nCVINsGroupIDItr = nCVINsGroupIDQuery.list().iterator();
				CustomAssetGroupEntity group=null;
				AssetEntity asset=null;
				String serNumGroup = null;
				List<String> serNumGroupList = new LinkedList<String>();
				List<String> VINncgList = new LinkedList<String>();
				while(nCVINsGroupIDItr.hasNext())
				{
					impl = new NotificationSummaryReportImpl();
					resultNCVins = (Object[]) nCVINsGroupIDItr.next();

					if(resultNCVins[1]!=null){
						asset = (AssetEntity)resultNCVins[1];
						impl.setSerialNumber(asset.getSerial_number().getSerialNumber());
						serNumGroup = asset.getSerial_number().getSerialNumber();
						serNumGroupList.add(serNumGroup);
					}       			
					if(resultNCVins[0]!=null){
						group=(CustomAssetGroupEntity)resultNCVins[0];
						//DefectID's:1736 and 1406 and 1924 -----Smitha----- filterig based on machine grouping,machine profile and model id.
						if (!(MachineGroupIdList == null || MachineGroupIdList.isEmpty())) {
							if(MachineGroupIdList.contains(group.getGroup_id())){
								impl.setMachineGroupId(group.getGroup_id());
							}
						}else{
							impl.setMachineGroupId(group.getGroup_id());
						}          				         				
					}

					if(resultNCVins[2]!=null){
						//DefectID's:1736 and 1406 and 1924 -----Smitha----- filterig based on machine grouping,machine profile and model id.
						if (!(MachineGroupIdList == null || MachineGroupIdList.isEmpty())) {
							if(MachineGroupIdList.contains(group.getGroup_id())){
								impl.setMachineGroupName((String)resultNCVins[2]);
							} 
						}else {
							impl.setMachineGroupName((String)resultNCVins[2]);
						}          				         				
					}

					if(group!=null){
						if(group.getTenancy_id()!=null){
							impl.setTenancyId(group.getTenancy_id().getTenancy_id());
							impl.setTenancy_name(group.getTenancy_id().getTenancy_name());
							//DefectId:20150224 @ Suprava Delaer As a new parameter Added
							if(group.getTenancy_id().getTenancy_type_id().getTenancy_type_id()==4)
							{
								impl.setDealerName(group.getTenancy_id().getParent_tenancy_id().getParent_tenancy_name());
							}
							else if(group.getTenancy_id().getTenancy_type_id().getTenancy_type_id()==3)
							{
								impl.setDealerName(group.getTenancy_id().getTenancy_name());
							}
							else
							{
								impl.setDealerName("No Dealer Tagging");
							}
							//End DefectId:20150224 
						}
					}

					impl.setCount(0L);

					if(asset!=null){
						impl.setNickName(asset.getNick_name()); 
						if(asset.getProductId()!=null && asset.getProductId().getAssetGroupId()!=null){
							//DefectID's:1736 and 1406 and 1924 -----Smitha----- filterig based on machine grouping,machine profile and model id.
							if(machineProfile){
								if (!(MachineProfileIdList == null || MachineProfileIdList.isEmpty())) {
									if(MachineProfileIdList.contains(asset.getProductId().getAssetGroupId().getAsset_group_id())){
										impl.setAssetGroupId(asset.getProductId().getAssetGroupId().getAsset_group_id());
										impl.setAssetGroupName(asset.getProductId().getAssetGroupId().getAsset_group_name()); 
									}  
								}
							} else {
								impl.setAssetGroupId(asset.getProductId().getAssetGroupId().getAsset_group_id());
								impl.setAssetGroupName(asset.getProductId().getAssetGroupId().getAsset_group_name());
							}         				         				 
						}
						if(asset.getProductId()!=null && asset.getProductId().getAssetTypeId()!=null)
						{
							//DefectID's:1736 and 1406 and 1924 -----Smitha----- filterig based on machine grouping,machine profile and model id.
							if(model){
								if (!(ModelidList == null || ModelidList.isEmpty())) {
									if(ModelidList.contains(asset.getProductId().getAssetTypeId().getAsset_type_id())){
										impl.setAssetTypeId(asset.getProductId().getAssetTypeId().getAsset_type_id());
										impl.setAssetTypeName(asset.getProductId().getAssetTypeId().getAsset_type_name());
									} 
								}
							} else{
								impl.setAssetTypeId(asset.getProductId().getAssetTypeId().getAsset_type_id());
								impl.setAssetTypeName(asset.getProductId().getAssetTypeId().getAsset_type_name());
							}         				       				
						}
					}                
					impl.setNameCount(null);
					impl.setNotificationTypeName(null);

					ImplList.add(impl);

				}  
				//smitha..DefectID:20131220....to get the remaining non communicated VIN's for which the machine groups are not assigned under that tenancyID
				for(String sNUmber : actualOwnerVINList){
					if(!serNumGroupList.contains(sNUmber)){
						VINncgList.add(sNUmber);
					}          			
				}           		
				for(String sNUM : VINncgList){
					impl = new NotificationSummaryReportImpl();
					for(String key :serAssetMap.keySet()){
						if(key.equals(sNUM)){
							if(serAssetMap.get(key)!=null){
								impl.setNickName(serAssetMap.get(key).getNick_name());
								if(serAssetMap.get(key).getProductId()!=null && serAssetMap.get(key).getProductId().getAssetGroupId()!=null){
									//DefectID's:1736 and 1406 and 1924 -----Smitha----- filterig based on machine grouping,machine profile and model id.
									if(machineProfile){
										if (!(MachineProfileIdList == null || MachineProfileIdList.isEmpty())) {
											if(MachineProfileIdList.contains(serAssetMap.get(key).getProductId().getAssetGroupId().getAsset_group_id())){
												impl.setAssetGroupId(serAssetMap.get(key).getProductId().getAssetGroupId().getAsset_group_id());
												impl.setAssetGroupName(serAssetMap.get(key).getProductId().getAssetGroupId().getAsset_group_name());
											}
										}
									} else {
										impl.setAssetGroupId(serAssetMap.get(key).getProductId().getAssetGroupId().getAsset_group_id());
										impl.setAssetGroupName(serAssetMap.get(key).getProductId().getAssetGroupId().getAsset_group_name());
									}        							 
								}
								if(serAssetMap.get(key).getProductId()!=null && serAssetMap.get(key).getProductId().getAssetTypeId()!=null){
									//DefectID's:1736 and 1406 and 1924 -----Smitha----- filterig based on machine grouping,machine profile and model id.
									if(model){
										if (!(ModelidList == null || ModelidList.isEmpty())) {
											if(ModelidList.contains(serAssetMap.get(key).getProductId().getAssetTypeId().getAsset_type_id())){
												impl.setAssetTypeId(serAssetMap.get(key).getProductId().getAssetTypeId().getAsset_type_id());
												impl.setAssetTypeName(serAssetMap.get(key).getProductId().getAssetTypeId().getAsset_type_name());
											}
										}
									} else {
										impl.setAssetTypeId(serAssetMap.get(key).getProductId().getAssetTypeId().getAsset_type_id());
										impl.setAssetTypeName(serAssetMap.get(key).getProductId().getAssetTypeId().getAsset_type_name());
									}        							
								}
							}					
						}										
					}          			
					impl.setCount(0L);
					impl.setMachineGroupId(0);
					impl.setMachineGroupName(null);
					impl.setNameCount(null);          			
					impl.setNotificationTypeName(null);
					impl.setSerialNumber(sNUM);
					for(String key :serTenancyMap.keySet()){
						if(key.equals(sNUM)){
							if(serTenancyMap.get(key)!=null){
								impl.setTenancy_name(serTenancyMap.get(key).getTenancy_name());
								impl.setTenancyId(serTenancyMap.get(key).getTenancy_id());	
								//DefectId:20150224 @ Suprava Delaer As a new parameter Added
								if(serTenancyMap.get(key).getTenancy_type_id().getTenancy_type_id()==4)
								{
									impl.setDealerName(serTenancyMap.get(key).getParent_tenancy_id().getParent_tenancy_name());
								}
								else if(serTenancyMap.get(key).getTenancy_type_id().getTenancy_type_id()==3)
								{
									impl.setDealerName(serTenancyMap.get(key).getTenancy_name());
								}
								else
								{
									impl.setDealerName("No Dealer Tagging");
								}
								//End DefectId:20150224
							}        					
						}										
					}          			
					ImplList.add(impl);
				}
			}
			else {
				//Smitha...DefectID:20131220...to get the non communicated VIN's without machine group checked 
				for(String ser : actualOwnerVINList){
					impl = new NotificationSummaryReportImpl();

					for(String key :serAssetMap.keySet()){
						if(key.equals(ser)){
							if(serAssetMap.get(key)!=null){
								impl.setNickName(serAssetMap.get(key).getNick_name());
								if(serAssetMap.get(key).getProductId()!=null && serAssetMap.get(key).getProductId().getAssetGroupId()!=null){
									//DefectID's:1736 and 1406 and 1924 -----Smitha----- filterig based on machine grouping,machine profile and model id.
									if(machineProfile){
										if (!(MachineProfileIdList == null || MachineProfileIdList.isEmpty())) {
											if(MachineProfileIdList.contains(serAssetMap.get(key).getProductId().getAssetGroupId().getAsset_group_id())){
												impl.setAssetGroupId(serAssetMap.get(key).getProductId().getAssetGroupId().getAsset_group_id());
												impl.setAssetGroupName(serAssetMap.get(key).getProductId().getAssetGroupId().getAsset_group_name());
											}
										}
									} else {
										impl.setAssetGroupId(serAssetMap.get(key).getProductId().getAssetGroupId().getAsset_group_id());
										impl.setAssetGroupName(serAssetMap.get(key).getProductId().getAssetGroupId().getAsset_group_name());
									}        							
								}
								if(serAssetMap.get(key).getProductId()!=null && serAssetMap.get(key).getProductId().getAssetTypeId()!=null){
									//DefectID's:1736 and 1406 and 1924 -----Smitha----- filterig based on machine grouping,machine profile and model id.
									if(model){
										if (!(ModelidList == null || ModelidList.isEmpty())) {
											if(ModelidList.contains(serAssetMap.get(key).getProductId().getAssetTypeId().getAsset_type_id())){
												impl.setAssetTypeId(serAssetMap.get(key).getProductId().getAssetTypeId().getAsset_type_id());
												impl.setAssetTypeName(serAssetMap.get(key).getProductId().getAssetTypeId().getAsset_type_name());
											}
										}
									} else {
										impl.setAssetTypeId(serAssetMap.get(key).getProductId().getAssetTypeId().getAsset_type_id());
										impl.setAssetTypeName(serAssetMap.get(key).getProductId().getAssetTypeId().getAsset_type_name());
									}        							
								}
							}					
						}										
					}          			
					impl.setCount(0L);
					impl.setMachineGroupId(0);
					impl.setMachineGroupName(null);
					impl.setNameCount(null);          			
					impl.setNotificationTypeName(null);
					impl.setSerialNumber(ser);
					for(String key :serTenancyMap.keySet()){
						if(key.equals(ser)){
							if(serTenancyMap.get(key)!=null){
								impl.setTenancy_name(serTenancyMap.get(key).getTenancy_name());
								impl.setTenancyId(serTenancyMap.get(key).getTenancy_id());	
								//DefectId:20150224 @ Suprava Delaer As a new parameter Added
								if(serTenancyMap.get(key).getTenancy_type_id().getTenancy_type_id()==4)
								{
									impl.setDealerName(serTenancyMap.get(key).getParent_tenancy_id().getParent_tenancy_name());
								}
								else if(serTenancyMap.get(key).getTenancy_type_id().getTenancy_type_id()==3)
								{
									impl.setDealerName(serTenancyMap.get(key).getTenancy_name());
								}
								else
								{
									impl.setDealerName("No Dealer Tagging");
								}
								//End DefectId:20150224
							}        					
						}										
					}          			
					ImplList.add(impl);

				}
			}
			//ended----DefectId: DF20131213 - Smitha - Non Communicated VIN's

			//DefectID's:1736 and 1406 and 1924 -----Smitha----- filterig based on machine grouping,machine profile and model id.
			List<NotificationSummaryReportImpl> tempImpList = new LinkedList<NotificationSummaryReportImpl>();          		  
			Iterator iterResult = ImplList.iterator();
			while (iterResult.hasNext()) {
				tempImpList.add((NotificationSummaryReportImpl)iterResult.next());
			}
			NotificationSummaryReportImpl resultlist = null;
			iterResult = tempImpList.iterator();
			while (iterResult.hasNext()) {
				if (iterResult != null) {
					resultlist = (NotificationSummaryReportImpl) iterResult.next();
					if(machineProfile){
						if(resultlist.getAssetGroupId()==0){
							ImplList.remove(resultlist);
						}
					}
					if (!(MachineGroupIdList == null || MachineGroupIdList.isEmpty())) {
						if(machineGroup){
							if(resultlist.getMachineGroupId()==0){
								ImplList.remove(resultlist);
							}
						}
					}
					if(model){
						if(resultlist.getAssetTypeId()==0){
							ImplList.remove(resultlist);
						}
					}
				}
			}

			//DefectID:1406 - Juhi  2013-October-31 
			HashMap<String,Long> totalhashmap=new HashMap<String,Long>();
			NotificationSummaryReportImpl impl1 = new NotificationSummaryReportImpl();
			totalhashmap.put("Security", securityTotal);
			totalhashmap.put("Health", healthTotal);
			totalhashmap.put("Utilization", utilizationTotal);
			totalhashmap.put("Landmark", landmarkTotal);
			totalhashmap.put("Service", servicesTotal);
			totalhashmap.put("NotificationTotal",(securityTotal+healthTotal+utilizationTotal+landmarkTotal+servicesTotal));
			serNoTypeCountMap.put("Total",totalhashmap);

			impl1.setNameCount(serNoTypeCountMap.get("Total"));
			impl1.setSerialNumber("Summary");
			ImplList.add(impl1);
			iLogger.info("securityTotal"+securityTotal+"healthTotal"+healthTotal+"utilizationTotal"+utilizationTotal+"landmarkTotal"+landmarkTotal+"servicesTotal"+servicesTotal);
		}

		catch (Exception e) 
		{
			e.printStackTrace();
			fLogger.fatal("Exception: "+ e.getMessage());
		} 

		finally 
		{
			if (session.getTransaction().isActive()) 
			{
				session.getTransaction().commit();
			}

			if (session.isOpen()) 
			{
				session.flush();
				session.close();
			}

		}

		return ImplList;
}


	//******************************************************************


	//---------------------------------------------------------------

	public int maxEngineRunningBand(ArrayList<Double> rpmBandList,String bandType){
		int maxValue = 0;
		if(bandType.equalsIgnoreCase("idle")){		    		
			if(rpmBandList.get(0)>=rpmBandList.get(1)){
				maxValue = 1;
			}
			else{
				maxValue =2;
			}
		}
		else if(bandType.equalsIgnoreCase("working")){
			ArrayList<Double> arrayListMax = new ArrayList<Double>();
			arrayListMax.add(rpmBandList.get(2));
			arrayListMax.add(rpmBandList.get(3));
			arrayListMax.add(rpmBandList.get(4));
			arrayListMax.add(rpmBandList.get(5));
			arrayListMax.add(rpmBandList.get(6));
			arrayListMax.add(rpmBandList.get(7));
			maxValue = rpmBandList.indexOf(Collections.max(arrayListMax))+1;
		}
		return maxValue;

	}


	//-------------------------------------------------- Get Landmark Activity Details ---------------------------------------------------------- 
	/** This method gets the Activity details of various machines under the given Landmark
	 * @param period Specifies the time period for which the report has to be laid out
	 * @param landmarkIdList Specifies the list of Landamarks for which the machine activity is to be returned
	 * @param landmarkCategoryIdList Specifies the list of Landamark Categories for which the machine activity is to be returned
	 * @return Returns the Machine Activity details under various landmarks
	 */
	//Logic for Custom Dates (fromDate,toDate) added by Juhi on 21-August-2013 
	public List<LandmarkActivityReportImpl> getLandmarkActivityDetails(
			String fromDate,String toDate,String period, List<Integer> landmarkIdList, 
			List<Integer> landmarkCategoryIdList, String loginId, int loginTenancyId,List<Integer> machineGroupIdList)
			{
		List<LandmarkActivityReportImpl> responseObj =  new LinkedList<LandmarkActivityReportImpl>();
		LandmarkActivityReportImpl response = null;
		// Logger businessError = Logger.getLogger("businessErrorLogger");
		// Logger fatalError = Logger.getLogger("fatalErrorLogger");
		Logger fLogger = FatalLoggerClass.logger;
		Logger bLogger = BusinessErrorLoggerClass.logger;
		//Logger iLogger = InfoLoggerClass.logger;
		Session session = HibernateUtil.getSessionFactory().getCurrentSession();
		session.beginTransaction();

		try
		{
			ListToStringConversion conversionObj = new ListToStringConversion();
			ContactEntity userContact = null;
			String customDateSelectQuery = null;
			//Get the Login user contact details
			Query contactQuery = session.createQuery(" from ContactEntity where contact_id='"+loginId+"' ");
			Iterator contactItr = contactQuery.list().iterator();
			while(contactItr.hasNext())
			{
				userContact = (ContactEntity)contactItr.next();
			}

			//Validate the user LoginId
			if(userContact==null || userContact.getContact_id()==null)
			{
				throw new CustomFault("Invalid LoginId");
			}

			//DefectId:839 - Rajani Nagaraju - 20140108 - To enable Machine Movement between tenancies
			//Since  the landmark is always associated with the tenancy that has been first created, take the tenancy with least tenancyID
			Query tenancyQuery = session.createQuery(" from TenancyEntity a where a.tenancyCode= (select b.tenancyCode from TenancyEntity b where b.tenancy_id='"+loginTenancyId+"')" +
			" order by a.tenancy_id ");
			Iterator tenancyItr = tenancyQuery.list().iterator();
			if(tenancyItr.hasNext())
			{
				TenancyEntity tenancy =  (TenancyEntity)tenancyItr.next();
				loginTenancyId = tenancy.getTenancy_id();
			}

			//	    	 Keerthi : Defect ID : 1406 : Grouping changes
			/*String selectQuery = " select z.landmarkDimensionId, z.serialNumber, z.noOfArrivals, z.noOfDepartures, z.totalDurationAtLandmark, " +
	    	 		" z.longestDurationAtLandmark, d.nick_name, s.group_id as machineGroupId, s.group_name as machineGroupName ";
	    	//Defect ID:1406 (Smitha oct 4th 2013) machine grouping
	    	 String fromQuery = " from AssetCustomGroupMapping w RIGHT OUTER JOIN w.serial_number x  LEFT OUTER JOIN w.group_id s,";
	    	 fromQuery = fromQuery + " LandmarkDimensionEntity b, TenancyDimensionEntity c , AssetEntity d ";
	    	//end Defect ID:1406
	    	 String whereQuery = " where z.landmarkDimensionId = b.landMarkDimensionId and z.tenacyDimensionId = c.tenacy_Dimension_Id " +
	    	 		" and c.tenancyId ="+loginTenancyId+" and z.serialNumber = d.serial_number and x.serial_number = z.serialNumber ";
	    	 String groupby = " group by z.serialNumber,z.landmarkDimensionId ";//added by smitha on 5th Sept 2013
			 */	    	 
			/*select d.LandMark_Dimension_ID, d.landmark_category_id, d.landmark_id, 
	 		d.landmark_name, d.Landmark_Category_Name, 
	 		z.serial_Number, z.number_Of_Arrivals, z.number_Of_Departures, 
	 		z.total_Duration_At_Landmark, z.longest_Duration_At_Landmark

	 from landmark_aggregate_fact_data_quarteragg z
	 	right outer join landmark_dimension as d 
	 		on z.LandMark_Dimension_ID=d.LandMark_Dimension_ID

	 where d.landmark_id in 
	 			(select a.landmark_id 
	 			from landmark a, landmark_catagory b
	 			where a.Landmark_Category_ID = b.Landmark_Category_ID
	 			and b.Tenancy_ID=102
	 			and a.landmark_id in (55,56)
	 			and b.Landmark_Category_ID in (40,44)
	 			)

	 order by d.landmark_category_id, d.landmark_id;*/
			boolean querySelected=false;
			String landmarkIntegerList = conversionObj.getIntegerListString(landmarkIdList).toString();
			String landmarkCategoryIntegerList = conversionObj.getIntegerListString(landmarkCategoryIdList).toString();

			//	    	 String selectQuery = "select b.landMarkDimensionId,b.landMarkCategoryId,b.landMarkId,d.landMarkName,d.landMarkCategoryName,z.serialNumber, z.noOfArrivals, z.noOfDepartures, z.totalDurationAtLandmark,z.longestDurationAtLandmark, d.nick_name ";
			String selectQuery = "select b.landmarkDimensionId,b.landMarkId,b.landMarkName,b.landMarkCategoryId,b.landMarkCategoryName,z.serialNumber, z.noOfArrivals, z.noOfDepartures, z.totalDurationAtLandmark,z.longestDurationAtLandmark ";
			String fromQuery = " from ";
			String whereQuery = " where ";
			if((landmarkIdList==null && landmarkCategoryIdList==null)){
				//DF:20131220 ------Juhi---- Code change z.landmarkDimensionId
				//	    	 whereQuery = whereQuery + " z.landmarkDimensionId in (select l.Landmark_id from LandmarkEntity l,LandmarkCategoryEntity c where l.Landmark_Category_ID=c.Landmark_Category_ID and c.Tenancy_ID = "+loginTenancyId+")";
				//DefectID:20140106 and 20140108------Smitha----- Code Change in where query to return the correct data when search filter is applied and to match the filter input.	    		 
				whereQuery = whereQuery + " b.landmarkDimensionId in (select d.landmarkDimensionId from LandmarkDimensionEntity d where d.landMarkId in (select l.Landmark_id from LandmarkEntity l,LandmarkCategoryEntity c where l.Landmark_Category_ID=c.Landmark_Category_ID and c.Tenancy_ID = "+loginTenancyId+" and l.ActiveStatus=1 and c.ActiveStatus=1))";
			}

			else if(landmarkIdList!=null &&  landmarkCategoryIdList==null ){
				if(landmarkIdList.size()>0){
					//DefectID:20140106------Smitha----- Code Change in where query to return the correct data when search filter is applied.
					whereQuery = whereQuery + " b.landmarkDimensionId in (select d.landmarkDimensionId from LandmarkDimensionEntity d where d.landMarkId in (select l.Landmark_id from LandmarkEntity l,LandmarkCategoryEntity c where l.Landmark_Category_ID=c.Landmark_Category_ID and c.Tenancy_ID = "+loginTenancyId+" and l.Landmark_id in ("+landmarkIntegerList+") and l.ActiveStatus=1 and c.ActiveStatus=1 ))";
				}	    		  
			}else if(landmarkCategoryIdList!=null && landmarkIdList==null){
				if(landmarkCategoryIdList.size()>0){
					//DefectID:20140106------Smitha----- Code Change in where query to return the correct data when search filter is applied.
					whereQuery = whereQuery + " b.landmarkDimensionId in (select d.landmarkDimensionId from LandmarkDimensionEntity d where d.landMarkId in (select l.Landmark_id from LandmarkEntity l,LandmarkCategoryEntity c where l.Landmark_Category_ID=c.Landmark_Category_ID and c.Tenancy_ID = "+loginTenancyId+" and c.Landmark_Category_ID in ("+landmarkCategoryIntegerList+") and l.ActiveStatus=1 and c.ActiveStatus=1))";
				}	    		 	 
			}
			else {
				//DefectID:20140106------Smitha----- Code Change in where query to return the correct data when search filter is applied.
				whereQuery = whereQuery + " b.landmarkDimensionId in (select d.landmarkDimensionId from LandmarkDimensionEntity d where d.landMarkId in (select l.Landmark_id from LandmarkEntity l,LandmarkCategoryEntity c where l.Landmark_Category_ID=c.Landmark_Category_ID and c.Tenancy_ID = "+loginTenancyId+" and l.Landmark_id in ("+landmarkIntegerList+") and c.Landmark_Category_ID in ("+landmarkCategoryIntegerList+") and l.ActiveStatus=1 and c.ActiveStatus=1))";
			}
			//ID20131021....ordering based on landmark category,landmark id and serial number...done by smitha on oct 21st 2013
			String orderby = " order by b.landMarkCategoryId, b.landMarkId,z.serialNumber ";
			int year =0;int week = 0; int quarter = 0;int month =0;
			//For input Period: Week, Month, Quarter, Year
			DateUtil dateUtil1 = new DateUtil();
			DateUtil thisDate =dateUtil1.getCurrentDateUtility(new Date());

			//For input period: Last Week, Last Month, Last Quarter, Last Year
			DateUtil dateUtil2 = new DateUtil();
			DateUtil prevDate = dateUtil2.getPreviousDateUtility(new Date());
			//Logic for Custom Dates (fromDate,toDate) added by Juhi on 21-August-2013 
			if(fromDate == null && toDate==null)
			{	
				if (period.equalsIgnoreCase("Week")) 
				{
					week =   thisDate.getWeek();
					year = thisDate.getYear();

					//	    		 fromQuery = fromQuery+" ,LandmarkFactEntity_WeekAgg z ";
					fromQuery = fromQuery+" LandmarkFactEntity_WeekAgg z ";
					whereQuery = whereQuery	+ " and ((z.timeCount = "+week+" and z.year="+year+") or (z.serialNumber = null)) ";
				}

				else if (period.equalsIgnoreCase("Last Week")) 
				{
					week =  prevDate.getWeek();
					if(thisDate.getWeek()==1)
					{
						year = prevDate.getYear();
					}
					else
					{
						year = prevDate.getCurrentYear();
					}

					//	    		 fromQuery = fromQuery+" , LandmarkFactEntity_WeekAgg z ";
					fromQuery = fromQuery+" LandmarkFactEntity_WeekAgg z ";
					whereQuery = whereQuery	+ " and ((z.timeCount = "+week+" and z.year="+year+") or (z.serialNumber = null)) ";
				}

				else if (period.equalsIgnoreCase("Month")) 
				{
					month =  thisDate.getMonth();
					year = thisDate.getYear();

					//	    		 fromQuery = fromQuery+" , LandmarkFactEntity_MonthAgg z ";
					fromQuery = fromQuery+" LandmarkFactEntity_MonthAgg z ";
					whereQuery = whereQuery	+ " and ((z.timeCount = "+ month+" and z.year="+year+") or (z.serialNumber = null)) ";
				}

				else if (period.equalsIgnoreCase("Last Month")) 
				{
					month =  prevDate.getMonth();
					if(thisDate.getMonth()==1)
					{
						year = prevDate.getYear();
					}
					else
					{
						year = prevDate.getCurrentYear();
					}

					//	    		 fromQuery = fromQuery+" , LandmarkFactEntity_MonthAgg z ";
					fromQuery = fromQuery+" LandmarkFactEntity_MonthAgg z ";
					whereQuery = whereQuery	+ " and ((z.timeCount = "+ month+" and z.year="+year+") or (z.serialNumber = null)) ";				
				}

				else if (period.equalsIgnoreCase("Quarter")) 
				{
					quarter =  thisDate.getQuarter();
					year = thisDate.getYear();

					//	    		 fromQuery = fromQuery+" , LandmarkFactEntity_QuarterAgg z ";
					fromQuery = fromQuery+" LandmarkFactEntity_QuarterAgg z ";
					whereQuery = whereQuery	+ " and ((z.timeCount  = " +quarter+" and z.year="+year+") or (z.serialNumber = null))";
				}

				else if (period.equalsIgnoreCase("Last Quarter")) 
				{
					quarter = prevDate.getQuarter();
					if(thisDate.getQuarter()==1)
					{
						year = prevDate.getYear();
					}
					else
					{
						year = prevDate.getCurrentYear();
					}

					//	    		 fromQuery = fromQuery+" , LandmarkFactEntity_QuarterAgg z ";
					fromQuery = fromQuery+" LandmarkFactEntity_QuarterAgg z ";
					whereQuery = whereQuery	+ " and ((z.timeCount  = " +quarter+" and z.year="+year+") or (z.serialNumber = null))";
				}


				else if (period.equalsIgnoreCase("Year")) 
				{
					year = thisDate.getYear();

					//	    		 fromQuery = fromQuery+" , LandmarkFactEntity_YearAgg z ";
					fromQuery = fromQuery+" LandmarkFactEntity_YearAgg z ";
					whereQuery = whereQuery	+ " and ((z.year="+year+") or (z.serialNumber = null))";
				}

				else if (period.equalsIgnoreCase("Last Year")) 
				{
					year = prevDate.getYear();

					//	    		 fromQuery = fromQuery+" , LandmarkFactEntity_YearAgg z ";
					fromQuery = fromQuery+" LandmarkFactEntity_YearAgg z ";
					whereQuery = whereQuery	+ " and ((z.year="+year+") or (z.serialNumber = null))";
				}
			}
			//Logic for Custom Dates (fromDate,toDate) added by Juhi on 21-August-2013 
			else
			{
				DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat dateFormat1 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
				Date fromdate1=null;
				String fromdate2=null;
				String todate2=null;
				try {	

					fromdate1 = (Date)dateFormat.parse(fromDate);		
					String fromdate=dateFormat.format(fromdate1);
					fromdate2=dateFormat1.format(fromdate1);

					Date todate1=(Date)dateFormat.parse(toDate);

					String todate=dateFormat.format(todate1);
					todate2=dateFormat1.format(todate1);


				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				List<String> dateList= new LinkedList<String>();					

				String dateStringList=conversionObj.getStringList(dateList).toString();
				//Smitha....DefectID:20131223....to match the count getting from period and  custom dates.
				querySelected=true;
				customDateSelectQuery = "select b.landmarkDimensionId,b.landMarkId,b.landMarkName,b.landMarkCategoryId,b.landMarkCategoryName,z.serialNumber, sum(z.noOfArrivals), sum(z.noOfDepartures), sum(z.totalDurationAtLandmark),max(z.longestDurationAtLandmark) ";
				//					fromQuery =fromQuery+  " , LandmarkFactEntity_DayAgg z";
				fromQuery =fromQuery+  " LandmarkFactEntity_DayAgg z";
				//DefectID:20140107-----Smitha-----to match the count between custom dates and period and to return the correct data.
				whereQuery = whereQuery+ " and (z.serialNumber = null or z.time_key between '"+fromdate2+"' and '"+todate2+"')";
			}
			//Logic for Custom Dates (fromDate,toDate) added by Juhi on 21-August-2013 

			/* if( ! (landmarkIdList==null || landmarkIdList.isEmpty()))
	    	 {
	    		 String landmarkIntegerList = conversionObj.getIntegerListString(landmarkIdList).toString();
	    		 whereQuery = whereQuery +" and b.landMarkId in ("+landmarkIntegerList+") ";
	    	 }


	    	 if( ! (landmarkCategoryIdList==null || landmarkCategoryIdList.isEmpty()))
	    	 {
	    		 String landmarkCategoryIntegerList = conversionObj.getIntegerListString(landmarkCategoryIdList).toString();
	    		 whereQuery = whereQuery +" and b.landMarkCategoryId in ("+landmarkCategoryIntegerList+") ";
	    	 }*/

			List<String> userAccessibleVINlist = new LinkedList<String>();
			boolean groupUser = false;

			if (! ( (userContact.getIs_tenancy_admin()==1) || 
					(userContact.getRole().getRole_name().equalsIgnoreCase("Customer Care")) ||
					(userContact.getRole().getRole_name().equalsIgnoreCase("Admin"))
			) )
			{ 

				//get the list of VINs the user is accessible to
				List<CustomAssetGroupEntity> customAssetGroupList = new LinkedList<CustomAssetGroupEntity>();
				Query groupUserQuery = session.createQuery(" from GroupUserMapping where contact_id = '"+loginId+"'");
				Iterator groupUserItr = groupUserQuery.list().iterator();
				while(groupUserItr.hasNext())
				{
					GroupUserMapping groupUserEntity = (GroupUserMapping)groupUserItr.next();
					customAssetGroupList.add(groupUserEntity.getGroup_id());
					groupUser= true;
				}

				if(! (customAssetGroupList==null || customAssetGroupList.isEmpty()))
				{
					Query customGroupAssets = session.createQuery(" from AssetCustomGroupMapping where group_id in (:list) ").setParameterList("list", customAssetGroupList);
					Iterator customAssetGroupItr = customGroupAssets.list().iterator();

					while(customAssetGroupItr.hasNext())
					{
						AssetCustomGroupMapping assetCustomGroup = (AssetCustomGroupMapping)customAssetGroupItr.next();

						if( !(userAccessibleVINlist.contains(assetCustomGroup.getSerial_number().getSerial_number().getSerialNumber())) )
							userAccessibleVINlist.add(assetCustomGroup.getSerial_number().getSerial_number().getSerialNumber());
					}
				}
			}

			if(groupUser==true)
			{
				if(!(userAccessibleVINlist.isEmpty()))
				{
					String serialNumberStringList = conversionObj.getStringList(userAccessibleVINlist).toString();
					whereQuery = whereQuery+ " and z.serialNumber in ("+serialNumberStringList+") ";
				}

				else
				{
					return responseObj;
				}
			}

			fromQuery = fromQuery + " RIGHT OUTER JOIN z.landmarkDimensionId b ";
			//added by smitha on Aug 27th 2013
			if( ! (machineGroupIdList==null || machineGroupIdList.isEmpty()))
			{
				selectQuery = selectQuery + " ,y.group_id as machineGroupId, y.group_name as machineGroupName ";
				fromQuery = fromQuery + ",AssetCustomGroupMapping x,CustomAssetGroupEntity y";
				String machineGroupIntegerList = conversionObj.getIntegerListString(machineGroupIdList).toString();
				whereQuery = whereQuery +" and z.serialNumber = x.serial_number and x.group_id = y.group_id and y.group_id in ("+machineGroupIntegerList+") ";
			}

			//ended on Aug 27th 2013

			//	 String finalQueryString = selectQuery + fromQuery + whereQuery + groupby;
			//DF:20131220 ------Juhi---- Code change added group by

			//Smitha.....DefectID:20131224.....code change in group bu clause
			String finalQueryString = null;

			if(querySelected==true){
				finalQueryString = customDateSelectQuery + fromQuery + whereQuery + "group by z.serialNumber, b.landMarkId "+ orderby ;
			}else{
				finalQueryString = selectQuery + fromQuery + whereQuery + "group by z.serialNumber, b.landMarkId "+ orderby ;
			}

			Query landmarkActivityQuery = session.createQuery(finalQueryString);
			Iterator landmarkActivityItr = landmarkActivityQuery.list().iterator();
			Object[] result = null;
			int landmarkDimensionId=0;
			String serialNumber=null;
			String nickName=null;
			while(landmarkActivityItr.hasNext())
			{
				response = new LandmarkActivityReportImpl();

				result = (Object[])landmarkActivityItr.next();	    		 

				if(result[0]!=null)
				{
					landmarkDimensionId=(Integer)result[0];
					/*LandmarkDimensionEntity landmarkDimension = (LandmarkDimensionEntity) result[0];
	    			 response.setLandmarkId(landmarkDimension.getLandMarkId());
	    			 response.setLandMarkName(landmarkDimension.getLandMarkName());
	    			 response.setLandmarkCategoryId(landmarkDimension.getLandMarkCategoryId());
	    			 response.setLandMarkCategoryName(landmarkDimension.getLandMarkCategoryName());*/
				}
				if(result[1]!=null){
					response.setLandmarkId((Integer)result[1]);
				}
				if(result[2]!=null){
					response.setLandMarkName(result[2].toString());
				}
				if(result[3]!=null){
					response.setLandmarkCategoryId((Integer)result[3]);
				}
				if(result[4]!=null){
					response.setLandMarkCategoryName(result[4].toString());
				}
				//DefectID:20140107-----Smitha-----to remove the VIN's which are having null value and to return the correct data.
				if(result[5]==null){
					continue;
				}
				else {
					serialNumber=result[5].toString();
					response.setSerialNumber(result[5].toString());
				}   		 

				//Smitha....DefectID:20131224...to match the total count between period and custom dates
				if(result[6] != null)
				{
					int numOfArrInInt =0;
					try
					{
						long numOfArr = (Long)result[6];
						numOfArrInInt = (int)numOfArr;
					}
					catch(ClassCastException e)
					{
						numOfArrInInt = (Integer)result[6];
					}
					response.setNumberOfArrivals(numOfArrInInt);
				}

				//Smitha....DefectID:20131224...to match the total count between period and custom dates
				if(result[7] !=null)
				{
					int numOfDepInInt =0;
					try
					{
						long numOfDep = (Long)result[7];
						numOfDepInInt = (int)numOfDep;
					}
					catch(ClassCastException e)
					{
						numOfDepInInt = (Integer)result[7];
					}
					// response.setNumberOfdepartures((Integer)result[7]);
					response.setNumberOfdepartures(numOfDepInInt);
				}
				if(result[8] != null)
				{
					//Changes Done by Juhi on 21 August 2013 Long to Integer 
					Integer totalDuration = ((Long) result[8]).intValue();
					//Total Duaration in DB will be stored in Seconds. Convert the same to minutes and then set the response Obj
					int totalDurationInMinutes = totalDuration/60;
					response.setTotalDurationAtLandmarkInMinutes(totalDurationInMinutes);
				}

				if(result[9] != null)
				{
					//Changes Done by Juhi on 21 August 2013 Long to Integer 
					Integer longestDuration = ((Long)result[9]).intValue();
					//Longest Duaration will be stored as Seconds in DB. Convert the same to minutes and then set the response Obj
					int longestDurationInMinutes = longestDuration/60;
					response.setLongestDurationAtLandmarkInMinutes(longestDurationInMinutes);
				}
				if(serialNumber!=null){
					/*String nickNameQuery = "select d.nick_name from AssetEntity d where d.serial_number = '"
						+ serialNumber
						+ " '";
					Query nickNameQuery1 = session.createQuery(nickNameQuery);
					Iterator nickNameQueryItr = nickNameQuery1.list().iterator();
					while(nickNameQueryItr.hasNext()){
						nickName= nickNameQueryItr.next().toString();
						if(nickName!=null){
							response.setNickname(nickName);
						}	    	    		 
					}*/
					//DefectId:20150225 @Suprava DealerName Added as new Parameter
					String nickNameQuery = "select d.nick_name,atm.tenancy_id from AssetEntity d,AccountTenancyMapping atm where d.serial_number = '"
						+ serialNumber+ "' and d.primary_owner_id=atm.account_id";
					Query nickNameQuery1 = session.createQuery(nickNameQuery);
					Iterator nickNameQueryItr = nickNameQuery1.list().iterator();
					while(nickNameQueryItr.hasNext()){
						result = (Object[])nickNameQueryItr.next();
						if(result[0]!=null){
							response.setNickname(nickName);
						}
						TenancyEntity tenancyEntity=null;
						if(result[1]!=null){
							tenancyEntity =(TenancyEntity)result[1];
							if(tenancyEntity.getTenancy_type_id().getTenancy_type_id()==4)
							{
							    response.setDealerName(tenancyEntity.getParent_tenancy_name());
							}
							else if(tenancyEntity.getTenancy_type_id().getTenancy_type_id()==3)
							{
								response.setDealerName(tenancyEntity.getTenancy_name());
							}
							else
							{
								response.setDealerName("No Dealer Tagging");
							}
						}
					}
				}
				//DefectId:20150225 end
				if( ! (machineGroupIdList==null || machineGroupIdList.isEmpty())){
					if(result[10] !=null)
					{
						response.setMachineGroupId((Integer)result[10]);
					}

					if(result[11] !=null)
					{
						response.setMachineGroupName(result[11].toString());
					}
				}
				responseObj.add(response);
			}
			/*//added by smitha on oct 15th 2013[to display the machines which have not communicated .... Internal Defect 20131014]
				Set mapSet = (Set) calledSerNumMap.entrySet();
				Iterator mapIterator = mapSet.iterator();	
				while (mapIterator.hasNext()) {
					Map.Entry mapEntry = (Map.Entry) mapIterator.next(); 
					String keyValue = (String) mapEntry.getKey(); 
					int value = (Integer)mapEntry.getValue();
					AllSerNumList.add(keyValue);

			}	

				int tenancyId=0;
				String tenancyName2=null;
				Integer groupID1=0;
				String groupName2=null;
				 Iterator iterSerialNoList = AllSerNumList.iterator();
				 for (String serialNo : AllSerNumList) {
				if(!tempSerNumList.contains(serialNo))	{
					response = new LandmarkActivityReportImpl();
					response.setAverageFuelConsumption(0.0d);
					response.setEngineOff(0l);
					response.setFuelused(0.0d);
					response.setFuelUsedInIdle(0.0d);
					response.setIdleTime(0.0d);
					groupID1=serGroupID.get(serialNo);
					if(groupID1!=0){
						response.setMachineGroupIdList(groupID1);
					}else{
						response.setMachineGroupIdList(0);
					}

					groupName2=GroupData.get(groupID1);
					if(groupName2!="" || groupName2!=null){
						response.setMachineGroupName(groupName2);
					}else {
						response.setMachineGroupName(null);
					}

					response.setMachineHours(0.0d);
					response.setMachineName(null);
					response.setMachineProfile(0);
					response.setModelIdList(0);					
					response.setModelName(null);
					response.setPowerBandhigh(0.0d);
					response.setPowerBandLow(0.0d);
					response.setPowerBandMedium(0.0d);
					response.setProfile(null);
					response.setSerialNumber(serialNo);
					tenancyId=calledSerNumMap.get(serialNo);
					response.setTenanctIdList(tenancyId);
					tenancyName2=TenancyData.get(tenancyId);
					response.setTenancyName(tenancyName2);
					response.setTotalMachineLifeHours(0l);
					response.setWorkingTime(0.0d);
					responseObj.add(response);
				}
				}
				//ended on oct 15th 2013[to display the machines which have not communicated .... Internal Defect 20131014] 
			 */	     }

		catch(CustomFault e)
		{
			bLogger.error("Custom Fault: "+ e.getFaultInfo());
		}

		catch(Exception e)
		{
			e.printStackTrace();
			fLogger.fatal("Exception :"+e);
		}

		finally
		{
			if(session.getTransaction().isActive())
			{
				session.getTransaction().commit();
			}

			if(session.isOpen())
			{
				session.flush();
				session.close();
			}

		}


		return responseObj;
			}
	public List<ReportMailSubscriptionListRespContract> getUsersSubscribed(String frequencyType){
		List<ReportMailSubscriptionListRespContract> mailSubscribers = null;
		Logger fLogger = FatalLoggerClass.logger;
		//Logger bLogger = BusinessErrorLoggerClass.logger;
		Logger iLogger = InfoLoggerClass.logger;
		String finalQuery = "SELECT pe.contact,cve.catalogValue,ce.primary_email_id ,atm.tenancy_id,rmle.reportId"
			+" FROM PreferenceCatalogEntity pce,CatalogValuesEntity cve,PreferenceEntity pe,"
			+" ContactEntity ce,AccountContactMapping acm, AccountTenancyMapping atm,ReportMasterListEntity rmle"
			+" WHERE  pce.catalogName like '%"+frequencyType+"%'"
			+" AND pce.catalogId = cve.catalogId AND cve.catalogValueId = pe.catalogValueId"
			+" AND cve.catalogValue = rmle.reportName" 
			+" AND pe.contact = ce.contact_id AND ce.contact_id=acm.contact_id AND acm.account_id = atm.account_id"
			+" ORDER BY pe.contact";
		long startTime = System.currentTimeMillis();
		Session session = HibernateUtil.getSessionFactory().getCurrentSession();
		session.beginTransaction();
		try{

			Query query = session.createQuery(finalQuery);
			Iterator usersIter = query.list().iterator();
			Object[] result = null;String contactId=null,reportName = null,primaryEmailId = null;
			int reportId = 0;
			ReportMailSubscriptionListRespContract responseObj = null;
			int tenancyId = 0,tenancyTypeId=0;
			while(usersIter.hasNext())
			{
				//DFJCB0202: 20150623 - Start - Rajani Nagaraju - Since these are not reinitialized for every iteration, if emailId for a user is null,
				//Emails are getting sent to previous user email id and hence customer getting emails for other machines as well
				contactId=null;
				primaryEmailId = null;
				//DFJCB0202: 20150623 - End
				
				if(mailSubscribers==null){
					mailSubscribers = new ArrayList<ReportMailSubscriptionListRespContract>(); 
				}

				result = (Object[])usersIter.next();

				if(result[0]!= null){
					contactId = ((ContactEntity)result[0]).getContact_id();
				}
				if(result[1]!= null){
					reportName = (String)result[1];
				}
				if(result[2]!= null){
					primaryEmailId = (String)result[2];
				}
				if(result[3]!=null){
					tenancyId = ((TenancyEntity)result[3]).getTenancy_id();
					tenancyTypeId = ((TenancyEntity)result[3]).getTenancy_type_id().getTenancy_type_id();
				}
				if(result[4]!=null){
					reportId = (Integer)result[4];
				}

				responseObj = new ReportMailSubscriptionListRespContract();
				
				//DFJCB0202: 20150623 - Start - Rajani Nagaraju - Adding to the subscriber list only if contactid and emailid is not null
				if(contactId !=null && primaryEmailId != null)
				{
					iLogger.info("contact id :"+contactId);
					responseObj.setContactId(contactId);
					responseObj.setPrimaryEmailId(primaryEmailId);
					responseObj.setReportName(reportName);
					responseObj.setReportId(reportId);
					responseObj.setTenancyId(tenancyId);
					responseObj.setTenancyTypeId(tenancyTypeId);
	
					mailSubscribers.add(responseObj);
				}
				//DFJCB0202: 20150623 - End

			}
		}
		catch(Exception e){
			e.printStackTrace();
		}
		finally {
			if (session.getTransaction().isActive()) {
				session.getTransaction().commit();
			}
			if (session.isOpen()) {
				session.flush();
				session.close();
			}
		}
		long endTime = System.currentTimeMillis();
		iLogger.info("Total execution time "+ String.valueOf(endTime - startTime) + "(ms)");


		return mailSubscribers;
	}
	//--------------------------------------------------END of Get Landmark Activity Details ----------------------------------------------------------

	public String sendMailToReportSubscribedUser(String toEmailId,String LoginId,String reportName, String frequencyType,boolean attachment,String reportsPath){
		String message =null;
		EmailTemplate emailTemplate = null;
		Logger fLogger = FatalLoggerClass.logger;
		//Logger bLogger = BusinessErrorLoggerClass.logger;
		Logger iLogger = InfoLoggerClass.logger;
		try{
			String subject = "Your "+frequencyType +" Report for "+reportName;
			StringBuffer body = new StringBuffer();
			body.append("Hello "+LoginId+",\n\n");
			if(attachment){
				body.append("Please find attachment for "+frequencyType+" report for "+reportName+". \n\n");				
			}
			else{
				body.append("No data found for "+frequencyType+" report for "+reportName+". \n\n");			
			}
			body.append("This mail you are getting since you are subscribed for "+frequencyType +" report for this.\n\n");
			body.append("With regards, \n");
			body.append("JCB LiveLink Team.");

			if(attachment){
				emailTemplate = new EmailTemplate(toEmailId,subject,body.toString(),reportsPath);
			}
			else{
				emailTemplate = new EmailTemplate(toEmailId,subject,body.toString(),null);
			}
			//new EmailHandler().handleEmail("jms/queue/emailQ", emailTemplate,0);
			//DF20171016 - KO369761 : Changed SMSQ Service from Hornet to Kafka Queue.
			new EmailHandler().handleEmailInKafka("EmailQueue", emailTemplate,0);
			message =frequencyType +" "+reportName+" has been sent to user "+ LoginId+ " !";
			iLogger.info(frequencyType +" "+reportName+" has been sent to user "+ LoginId+ " !");
		}
		catch (Exception e) {
			e.printStackTrace();
			message ="Failed while sending email to user !!";
			fLogger.error("Failed while sending email to user !!" + e.getMessage());

		}
		return message;
	}
	public String sendReportSubscriptionMails(String frequencyType){
		String message =null;
		
		Logger iLogger = InfoLoggerClass.logger;
		//get the contact id list, emailids, tenancyid, report names		
		List<ReportMailSubscriptionListRespContract> responseList = getUsersSubscribed(frequencyType);
		ReportMailSubscriptionListRespContract obj = null;
		String reportName = null,emailId = null,contactId=null,newFrequencyType=null;int reportId = 0;int tenancyId=0,tenancyTypeId =0;;
		boolean attachment = false;
		//if its weekly make it to last week, if its monthly make it to last month
		if (frequencyType.equalsIgnoreCase("Weekly")){
			newFrequencyType ="Last Week";
		}
		if (frequencyType.equalsIgnoreCase("Monthly")){
			//TODO change it to Last Month
			newFrequencyType ="Last Month";
		}
		String reportsPath=null,reportsDir=null;
		Properties prop1 = new Properties();
		try{
			prop1.load(getClass().getClassLoader().getResourceAsStream("remote/wise/resource/properties/configuration.properties"));
			//			reportsPath= prop1.getProperty("reportsPath");
			//			reportsDir = prop1.getProperty("reportsDir");

			if (prop1.getProperty("deployenvironment").equalsIgnoreCase("SIT")) {
				reportsPath= prop1.getProperty("reportsPath");
				reportsDir = prop1.getProperty("reportsDir");
			} else if (prop1.getProperty("deployenvironment").equalsIgnoreCase("DEV")) {
				reportsPath= prop1.getProperty("reportsPath");
				reportsDir = prop1.getProperty("reportsDir");
			} else if (prop1.getProperty("deployenvironment").equalsIgnoreCase("QA")) {
				reportsPath= prop1.getProperty("reportsPath");
				reportsDir = prop1.getProperty("reportsDir");
			} else if (prop1.getProperty("deployenvironment").equalsIgnoreCase("PROD")) {
				reportsPath= prop1.getProperty("reportsPath_PROD");
				reportsDir = prop1.getProperty("reportsDir_PROD");
			} else {
				reportsPath= prop1.getProperty("reportsPath");
				reportsDir = prop1.getProperty("reportsDir");
			}

		}
		catch(Exception e){
			e.printStackTrace();
		}

		if(responseList!=null){
			Iterator userIter = responseList.iterator();
			List<Integer> tenancyIdList = null;
			while(userIter.hasNext()){
				obj = (ReportMailSubscriptionListRespContract) userIter.next();
				iLogger.info("contact id  : "+obj.getContactId());
				iLogger.info("report name : "+obj.getReportName());
				iLogger.info("email id    : "+obj.getPrimaryEmailId());
				iLogger.info("tenancy id  : "+obj.getTenancyId());
				iLogger.info("tenancy type id  : "+obj.getTenancyTypeId());

				contactId = obj.getContactId();
				reportName = obj.getReportName();
				reportId = obj.getReportId();
				emailId = obj.getPrimaryEmailId();
				tenancyId = obj.getTenancyId();
				tenancyTypeId = obj.getTenancyTypeId();
				List<Integer> zoneList = new ArrayList<Integer>();
				if(tenancyId != 0){
					tenancyIdList = new ArrayList<Integer>();
					tenancyIdList.add(tenancyId);
				}
				attachment = false;
				switch(reportId){

				case 1 : 
					MachineHoursServiceReportReqContract reqObj = new MachineHoursServiceReportReqContract();
					reqObj.setTenancyIdList(tenancyIdList);
					try{
						List<MachineHoursServiceReportRespContract> response = new MachineHoursServiceReportImpl().getMachineHoursService(reqObj);
						//send response to export to excel method and invoke sendmail method
						if(response != null && !response.isEmpty()){	
							iLogger.info(contactId+" MachineHoursServiceReport list size is : "+response.size());
							attachment = true;
							createWorksheetForMachineHoursReport(response,reportsPath,reportsDir);
						}
						else{
							iLogger.info(contactId+" MachineHoursServiceReport No data found !!!");
						}
						sendMailToReportSubscribedUser(emailId,contactId,reportName,frequencyType,attachment,reportsPath);

						//
					}
					catch(Exception e){
						e.printStackTrace();
					}

					break;
				case 2 :MachineServiceDueOverDueReqContract reqObj1 = new MachineServiceDueOverDueReqContract();

				reqObj1.setPeriod(newFrequencyType);
				//DefectId:839 - Rajani Nagaraju - 20131216 - To enable Machine Movement between tenancies
				//reqObj1.setLoggedInTenancyId(String.valueOf(tenancyId));
				reqObj1.setLoggedInTenancyId(tenancyIdList);
				DueOverDueReportReqContract reqObj2 = new DueOverDueReportReqContract();
				reqObj2.setTenancyIdList(tenancyIdList);
				reqObj2.setLoginId(contactId);

				try{
					List<MachineServiceDueOverDueRespContract> response1 = new MachineServiceDueOverDueImpl().getMachineServiceDueOverDueCount(reqObj1);
					List<DueOverDueReportRespContract> response2 = new DueOverDueReportImpl().getDueOverDueMachines(reqObj2);
					reqObj2.setOverdueReport(true);
					List<DueOverDueReportRespContract> response3 = new DueOverDueReportImpl().getDueOverDueMachines(reqObj2);
					if(response1 != null && !response1.isEmpty()){	
						iLogger.info(contactId+" MachineServiceDueOverDue list size is : "+response1.size());
						attachment = true;
						createWorksheetForMachineServiceDueOverDueReport(response1,response2,response3,reportsPath,reportsDir);
					}	
					else{
						iLogger.info(contactId+" MachineServiceDueOverDue No data found !!!");
					}
					sendMailToReportSubscribedUser(emailId,contactId,reportName,frequencyType,attachment,reportsPath);
				}
				catch(Exception e){
					e.printStackTrace();
				} 
				break;
				case 4 : FleetSummaryReportReqContract fleetObj = new FleetSummaryReportReqContract();
				fleetObj.setTenanctIdList(tenancyIdList);
				fleetObj.setPeriod(newFrequencyType);
				try{
					List<FleetSummaryReportRespContract> response=new FleetSummaryReporImpl().getFleetSummaryReportService(fleetObj);
					if(response != null && !response.isEmpty()){		
						iLogger.info(contactId+" FleetSummaryReport list size is : "+response.size());
						attachment = true;
						createWorksheetForFleetSummaryReport(response,reportsPath,reportsDir);
					}	
					else{
						iLogger.info(contactId+" FleetSummaryReport No data found !!!");
					}
					sendMailToReportSubscribedUser(emailId,contactId,reportName,frequencyType,attachment,reportsPath);
				}

				catch(Exception e){
					e.printStackTrace();
				}
				break;

				case 5 : MachineHoursReportReqContract hourReportObj = new MachineHoursReportReqContract();
				hourReportObj.setTenancyIdList(tenancyIdList);
				hourReportObj.setPeriod(newFrequencyType);
				//				Keerthi : 04/09/14: set login tenancy id list 
				hourReportObj.setLoginTenancyIdList(tenancyIdList);
				try{
					List<MachineHoursReportRespContract> listResponse =new MachineHoursReportImpl().getMachineHoursReportService(hourReportObj);
					if(listResponse != null && !listResponse.isEmpty()){	
						iLogger.info(contactId+" MachineHoursReport list size is : "+listResponse.size());
						attachment = true;
						createWorksheetForMachineUsageHoursSummaryReport(listResponse,reportsPath,reportsDir);
					}	
					else{
						iLogger.info(contactId+" MachineHoursReport No data found !!!");
					}
					sendMailToReportSubscribedUser(emailId,contactId,reportName,frequencyType,attachment,reportsPath);
				}
				catch(Exception e){
					e.printStackTrace();
				}
				break;
				case 6 :  MachinePerformanceReportReqContract perObj= new MachinePerformanceReportReqContract();
				perObj.setTenancyIdList(tenancyIdList);
				perObj.setPeriod(newFrequencyType);
				try{
					List<MachinePerformanceReportRespContract> response=new MachinePerformanceReportImpl().getMachPerformanceReport(perObj);
					if(response != null && !response.isEmpty()){	
						iLogger.info(contactId+" MachinePerformanceReport list size is : "+response.size());
						attachment = true;
						createWorksheetForMachinePerformanceReport(response,reportsPath,reportsDir);
					}	
					else{
						iLogger.info(contactId+" MachinePerformanceReport No data found !!!");
					}
					sendMailToReportSubscribedUser(emailId,contactId,reportName,frequencyType,attachment,reportsPath);
				}
				catch(Exception e){
					e.printStackTrace();
				}	

				break;
				case 7 :  UtilizationSummaryReportReqContract utlizObj = new UtilizationSummaryReportReqContract();
				utlizObj.setPeriod(newFrequencyType);
				utlizObj.setTenancyIdList(tenancyIdList);
				utlizObj.setLoginId(contactId);
				//				Keerthi : 04/09/14 : set login tenancy id list
				utlizObj.setLoginTenancyIdList(tenancyIdList);
				try{

					List<UtilizationSummaryReportRespContract> response = new UtilizationSummaryReportImpl().getMachineUtilizationSummary(utlizObj);
					if(response != null && !response.isEmpty()){	
						iLogger.info(contactId+" UtilizationSummaryReport list size is : "+response.size());
						attachment = true;
						createWorksheetForUtilizationReport(response,reportsPath,reportsDir);
					}	
					else{
						iLogger.info(contactId+" UtilizationSummaryReport No data found !!!");
					}
					sendMailToReportSubscribedUser(emailId,contactId,reportName,frequencyType,attachment,reportsPath);
				}
				catch(Exception e){
					e.printStackTrace();
				}	
				break;
				case 8 :  MachineActivityReportReqContract activityObj = new MachineActivityReportReqContract();
				activityObj.setTenancy_ID(tenancyIdList);
				activityObj.setLoginId(contactId);
				activityObj.setPeriod(newFrequencyType);
				try{
					List<MachineActivityReportRespContract> respObj = new MachineActivityReportImpl().getMachineActivityReport(activityObj);
					if(respObj != null && !respObj.isEmpty()){	
						iLogger.info(contactId+" MachineActivityReport list size is : "+respObj.size());
						attachment = true;
						createWorksheetForMachineActivityReport(respObj,reportsPath,reportsDir);
					}	
					else{
						iLogger.info(contactId+" MachineActivityReport No data found !!!");
					}
					sendMailToReportSubscribedUser(emailId,contactId,reportName,frequencyType,attachment,reportsPath);
				}
				catch(Exception e){
					e.printStackTrace();
				}	 
				break;
				case 9 :  
					List<MachineHourMeterTrendDataReportRespContract> response1 = null;
					List<MachineRPMBandDataReportRespContract> response2 =null;
					List<MachineAlertsTrendDataRespContract> response3 =null;
					//for machine treand data check for tenancy type id
					//if its 1(HO), get all zones
					try{
						if(tenancyTypeId==1){
							DealersUnderZoneReqContract req = new DealersUnderZoneReqContract();
							req.setLoginId(contactId);
							req.setLoginTenancyId(tenancyId);
							List<DealersUnderZoneRespContract> resp = new DealersUnderZoneImpl().getDealers(req);	
							if(resp!=null && resp.size()>0){
								for(int i=0; i<resp.size(); i++){
									zoneList.add(resp.get(i).getZoneId());
								}
							}
						}
						else if(tenancyTypeId==2){
							zoneList.add(tenancyId);
						}
						else{//send mail : no data found
							sendMailToReportSubscribedUser(emailId,contactId,reportName,frequencyType,false,reportsPath);
						}
						if(tenancyTypeId == 1 ||tenancyTypeId == 2 ){
							MachineHourMeterTrendDataReportReqContract req1 = new MachineHourMeterTrendDataReportReqContract();
							req1.setTenancyIdList(zoneList);
							req1.setPeriod(newFrequencyType);
							MachineRPMBandDataReportReqContract req2 = new MachineRPMBandDataReportReqContract();
							req2.setTenancyIdList(zoneList);
							req2.setPeriod(newFrequencyType);
							MachineAlertsTrendDataReqContract req3 = new MachineAlertsTrendDataReqContract();
							req3.setTenancyIdList(zoneList);
							req3.setPeriod(newFrequencyType);
							if(tenancyTypeId == 1){
								response1= new MachineHourMeterTrendDataReportImpl().getMachineTrendDataForAllZones(req1);
								response2 = new MachineRPMBandDataImpl().getMachineRPMBandDataForAllZones(req2);
								response3 = new MachineAlertsTrendDataImpl().getMachineAlertsForAllZones(req3);
							}
							else if(tenancyTypeId == 2){
								response1= new MachineHourMeterTrendDataReportImpl().getMachineHourMeterTrendData(req1);
								response2 = new MachineRPMBandDataImpl().getMachineRPMBandTrendData(req2);
								response3 = new MachineAlertsTrendDataImpl().getMachineAlertsTrendData(req3);
							}
							iLogger.info(contactId+" MachineHourMeterTrendDataReport response 1 list size "+response1.size());
							iLogger.info(contactId+" MachineHourMeterTrendDataReport response 2 list size "+response2.size());
							iLogger.info(contactId+" MachineHourMeterTrendDataReport response 3 list size "+response3.size());

							attachment = true;
							createWorksheetForTrendDataReport(response1,response2,response3,reportsPath,reportsDir,tenancyTypeId);
							sendMailToReportSubscribedUser(emailId,contactId,reportName,frequencyType,true,reportsPath);
						}

					}



					catch(Exception e){
						e.printStackTrace();
					}

					break;
				case 10 :  NotificationSummaryReportReqContract notificObj = new NotificationSummaryReportReqContract();
				notificObj.setPeriod(newFrequencyType);
				notificObj.setTenancyIdList(tenancyIdList);
				notificObj.setLoginId(contactId);
				notificObj.setLoginTenancyIdList(tenancyIdList);
				try{
					List<NotificationSummaryReportRespContract> respObj = new NotificationSummaryReportImpl().GetNotificationSummaryDetails(notificObj);
					if(respObj != null && !respObj.isEmpty()){	
						iLogger.info(contactId+" NotificationSummaryReport list size is : "+respObj.size());
						attachment = true;
						createWorksheetForNotificationSummaryReport(respObj,reportsPath,reportsDir);
					}	
					else{
						iLogger.info(contactId+" NotificationSummaryReport No data found !!!");
					}
					sendMailToReportSubscribedUser(emailId,contactId,reportName,frequencyType,attachment,reportsPath);
				}
				catch(Exception e){
					e.printStackTrace();
				}
				break;
				case 11 :  LandmarkActivityReportReqContract landmarkObj = new LandmarkActivityReportReqContract();
				landmarkObj.setLoginTenancyId(tenancyId);
				landmarkObj.setLoginId(contactId);
				landmarkObj.setPeriod(newFrequencyType);
				try{
					List<LandmarkActivityReportRespContract> response = new LandmarkActivityReportImpl().getLandmarkActivityReport(landmarkObj);

					if(response != null && !response.isEmpty()){	
						iLogger.info(contactId+" LandmarkActivityReport list size is : "+response.size());
						attachment = true;
						createWorksheetForLandmarkActivityReport(response,reportsPath,reportsDir);
					}	
					else{
						iLogger.info(contactId+" LandmarkActivityReport No data found !!!");
					}
					sendMailToReportSubscribedUser(emailId,contactId,reportName,frequencyType,attachment,reportsPath);
				}
				catch(Exception e){
					e.printStackTrace();
				}
				break;

				}

			}
		}

		return message;
	}

	public WritableSheet createWorksheetForMachineHoursReport(List<MachineHoursServiceReportRespContract> response,String reportsPath,String reportsDir){
		WritableSheet workSheet = null;
		
		Logger iLogger = InfoLoggerClass.logger;
		try{	 
			WorkbookSettings ws = new WorkbookSettings();

			//			delete all existing files
			File file = new File(reportsDir);     
			String[] myFiles;       
			if(file.isDirectory()){   
				myFiles = file.list();   
				for (int i=0; i<myFiles.length; i++) {   
					File myFile = new File(file, myFiles[i]);    
					myFile.delete();   
				}   
			}     


			WritableWorkbook workbook = Workbook.createWorkbook(new File(reportsPath), ws);


			workSheet = workbook.createSheet("Machine Hours Report" ,0);
			WritableFont normalFont = new WritableFont(WritableFont.createFont("Calibri"),
					WritableFont.DEFAULT_POINT_SIZE,
					WritableFont.BOLD,  false,UnderlineStyle.NO_UNDERLINE);
			WritableCellFormat normalFormat = new WritableCellFormat(normalFont);       
			normalFormat.setAlignment(jxl.format.Alignment.JUSTIFY);
			normalFormat.setVerticalAlignment(VerticalAlignment.CENTRE);
			normalFormat.setBackground(jxl.format.Colour.BLUE_GREY);
			normalFormat.setWrap(false);
			normalFormat.setBorder(jxl.format.Border.ALL, jxl.format.BorderLineStyle.THIN,
					jxl.format.Colour.BLACK);

			workSheet.addCell(new jxl.write.Label(0,0,"Machine",normalFormat));

			workSheet.addCell(new jxl.write.Label(1,0,"Scedule Name",normalFormat));

			workSheet.addCell(new jxl.write.Label(2,0,"Total Machine Life Hours",normalFormat));
			workSheet.addCell(new jxl.write.Label(3,0,"Last Service Name",normalFormat));
			workSheet.addCell(new jxl.write.Label(4,0,"Service Date",normalFormat));
			workSheet.addCell(new jxl.write.Label(5,0,"Last Service Hours",normalFormat));
			workSheet.addCell(new jxl.write.Label(6,0,"Next Service Name",normalFormat));
			workSheet.addCell(new jxl.write.Label(7,0,"Hours To Next Service",normalFormat));
			workSheet.addCell(new jxl.write.Label(8,0,"Approximate Service Date",normalFormat));
			workSheet.addCell(new jxl.write.Label(9,0,"Location",normalFormat));
			workSheet.addCell(new jxl.write.Label(10,0,"Status",normalFormat));

			WritableCellFormat normalFormat1 = new WritableCellFormat(normalFont);

			normalFormat1.setAlignment(jxl.format.Alignment.JUSTIFY);
			normalFormat1.setVerticalAlignment(VerticalAlignment.CENTRE);

			normalFormat1.setBorder(jxl.format.Border.ALL, jxl.format.BorderLineStyle.THIN,
					jxl.format.Colour.BLACK);
			String serialNumber = null;
			int row= 1;long TotalMachineLifeHours=0l;	
			Iterator<MachineHoursServiceReportRespContract> responseIter = response.iterator();
			MachineHoursServiceReportRespContract respObj = null;
			while(responseIter.hasNext()){
				respObj  = responseIter.next();
				serialNumber = respObj.getSerialNumber();
				iLogger.info("serial no.  "+serialNumber);
				workSheet.addCell(new jxl.write.Label(0,row,serialNumber,normalFormat1));
				workSheet.addCell(new jxl.write.Label(1,row,respObj.getScheduleName(),normalFormat1));
				workSheet.addCell(new jxl.write.Label(2,row,String.valueOf(respObj.getTotalMachineLifeHours()),normalFormat1));
				workSheet.addCell(new jxl.write.Label(3,row,respObj.getServiceName(),normalFormat1));
				workSheet.addCell(new jxl.write.Label(4,row,respObj.getServiceDate(),normalFormat1));
				workSheet.addCell(new jxl.write.Label(5,row,String.valueOf(respObj.getLastServiceHour()),normalFormat1));
				workSheet.addCell(new jxl.write.Label(6,row,respObj.getNextService(),normalFormat1));
				if(respObj.getHoursToNextService()<0){
					workSheet.addCell(new jxl.write.Label(7,row,"("+String.valueOf(Math.abs(respObj.getHoursToNextService()))+")",normalFormat1));
				}
				else{
					workSheet.addCell(new jxl.write.Label(7,row,String.valueOf(respObj.getHoursToNextService()),normalFormat1));
				}

				workSheet.addCell(new jxl.write.Label(8,row,respObj.getApproximateServiceDate(),normalFormat1));
				workSheet.addCell(new jxl.write.Label(9,row,respObj.getLocation(),normalFormat1));
				if(respObj.getStatus()!=null){
					if(respObj.getStatus().equals("0")){
						workSheet.addCell(new jxl.write.Label(10,row,"Dormant",normalFormat1));
					}
					else if(respObj.getStatus().equals("1")){
						workSheet.addCell(new jxl.write.Label(10,row,"Operational",normalFormat1));
					}
				}

				++row;
			}

			workbook.write();
			workbook.close();
		}
		catch(Exception e){
			e.printStackTrace();
		}
		return workSheet;
	}
	public WritableSheet createWorksheetForMachineServiceDueOverDueReport(List<MachineServiceDueOverDueRespContract> response1,List<DueOverDueReportRespContract> response2,List<DueOverDueReportRespContract> response3,String reportsPath,String reportsDir){
		
		Logger iLogger = InfoLoggerClass.logger;
		WritableSheet workSheet1 = null;
		WorkbookSettings ws = new WorkbookSettings();
		WritableWorkbook workbook = null;
		try{	 
			workbook = Workbook.createWorkbook(new File(reportsPath), ws);

			//			delete all existing files
			File file = new File(reportsDir); 
			String[] myFiles;       
			if(file.isDirectory()){   
				myFiles = file.list();   
				for (int i=0; i<myFiles.length; i++) {   
					File myFile = new File(file, myFiles[i]);    
					myFile.delete();   
				}   
			}     






			WritableFont normalFont = new WritableFont(WritableFont.createFont("Calibri"),
					WritableFont.DEFAULT_POINT_SIZE,
					WritableFont.BOLD,  false,UnderlineStyle.NO_UNDERLINE);
			WritableCellFormat normalFormat = new WritableCellFormat(normalFont);       
			normalFormat.setAlignment(jxl.format.Alignment.JUSTIFY);
			normalFormat.setVerticalAlignment(VerticalAlignment.CENTRE);
			normalFormat.setBackground(jxl.format.Colour.BLUE_GREY);
			normalFormat.setWrap(false);
			normalFormat.setBorder(jxl.format.Border.ALL, jxl.format.BorderLineStyle.THIN,
					jxl.format.Colour.BLACK);      

			WritableCellFormat normalFormat1 = new WritableCellFormat(normalFont);

			normalFormat1.setAlignment(jxl.format.Alignment.JUSTIFY);
			normalFormat1.setVerticalAlignment(VerticalAlignment.CENTRE);

			normalFormat1.setBorder(jxl.format.Border.ALL, jxl.format.BorderLineStyle.THIN,
					jxl.format.Colour.BLACK);
			String serialNumber = null;
			//1st worksheet
			workSheet1 = workbook.createSheet("ServiceDueOverDue" ,0);
			workSheet1.addCell(new jxl.write.Label(0,0,"Dealer Name",normalFormat));          
			workSheet1.addCell(new jxl.write.Label(1,0,"No. of Machines due for Service",normalFormat));         
			workSheet1.addCell(new jxl.write.Label(2,0,"No. of Machines under Service Overdue",normalFormat));

			int row= 1;long TotalMachineLifeHours=0l;	
			Iterator responseIter = response1.iterator();
			MachineServiceDueOverDueRespContract respObj = null;
			DueOverDueReportRespContract respObj2 =null;
			while(responseIter.hasNext()){
				respObj  = (MachineServiceDueOverDueRespContract)responseIter.next(); 
				iLogger.info("summary - dealer name "+respObj.getDealerName() );
				workSheet1.addCell(new jxl.write.Label(0,row,respObj.getDealerName(),normalFormat1));
				workSheet1.addCell(new jxl.write.Label(1,row,String.valueOf(respObj.getMachineCountDueForService()),normalFormat1));
				workSheet1.addCell(new jxl.write.Label(2,row,String.valueOf(respObj.getMachineCountOverdueForService()),normalFormat1));

				++row;
			}
			row = row +1;
			//2nd due
			workSheet1.addCell(new jxl.write.Label(0,row,"DUE",normalFormat)); 
			row = row +1;
			workSheet1.addCell(new jxl.write.Label(0,row,"Machine",normalFormat));          
			workSheet1.addCell(new jxl.write.Label(1,row,"Model",normalFormat));         
			workSheet1.addCell(new jxl.write.Label(2,row,"Total Machine Life Hours",normalFormat));
			workSheet1.addCell(new jxl.write.Label(3,row,"Service Schedule",normalFormat));
			workSheet1.addCell(new jxl.write.Label(4,row,"Service Name",normalFormat));
			workSheet1.addCell(new jxl.write.Label(5,row,"Planned Service Date",normalFormat));
			workSheet1.addCell(new jxl.write.Label(6,row,"Planned Service Hours",normalFormat));
			workSheet1.addCell(new jxl.write.Label(7,row,"Due By Hours",normalFormat));
			workSheet1.addCell(new jxl.write.Label(8,row,"Due By Days",normalFormat));
			workSheet1.addCell(new jxl.write.Label(9,row,"Customer Name",normalFormat));
			workSheet1.addCell(new jxl.write.Label(10,row,"Customer Number",normalFormat));
			workSheet1.addCell(new jxl.write.Label(11,row,"Dealer Name",normalFormat));          
			workSheet1.addCell(new jxl.write.Label(12,row,"Dealer Contact",normalFormat));
			workSheet1.addCell(new jxl.write.Label(13,row,"Operator Name",normalFormat));
			workSheet1.addCell(new jxl.write.Label(14,row,"Operator Number",normalFormat));
			row = row+1;

			responseIter = response2.iterator();
			while(responseIter.hasNext()){
				respObj2  = (DueOverDueReportRespContract)responseIter.next(); 
				iLogger.info("due - machine name "+respObj2.getMachineName() );
				workSheet1.addCell(new jxl.write.Label(0,row,respObj2.getSerialNumber(),normalFormat1));
				workSheet1.addCell(new jxl.write.Label(1,row,respObj2.getMachineProfileName(),normalFormat1));
				workSheet1.addCell(new jxl.write.Label(2,row,String.valueOf(respObj2.getTotalMachineHours()),normalFormat1));
				workSheet1.addCell(new jxl.write.Label(3,row,respObj2.getScheduleName(),normalFormat1));
				workSheet1.addCell(new jxl.write.Label(4,row,respObj2.getServiceName(),normalFormat1));
				workSheet1.addCell(new jxl.write.Label(5,row,respObj2.getPlannedServiceDate(),normalFormat1));
				workSheet1.addCell(new jxl.write.Label(6,row,String.valueOf(respObj2.getPlannedServiceHours()),normalFormat1));
				workSheet1.addCell(new jxl.write.Label(7,row,String.valueOf(respObj2.getDueOrOverDueHours()),normalFormat1));
				workSheet1.addCell(new jxl.write.Label(8,row,String.valueOf(respObj2.getDueOrOverDueDays()),normalFormat1));
				workSheet1.addCell(new jxl.write.Label(9,row,respObj2.getCustomerName(),normalFormat1));
				workSheet1.addCell(new jxl.write.Label(10,row,respObj2.getCustomerContactNumber(),normalFormat1));
				workSheet1.addCell(new jxl.write.Label(11,row,respObj2.getDealerName(),normalFormat1));
				workSheet1.addCell(new jxl.write.Label(12,row,respObj2.getDealerContactNumber(),normalFormat1));
				workSheet1.addCell(new jxl.write.Label(13,row,respObj2.getOperatorName(),normalFormat1));
				workSheet1.addCell(new jxl.write.Label(14,row,respObj2.getOperatorContactNumber(),normalFormat1));


				++row;
			}
			//3rd over due
			row = row +1;
			workSheet1.addCell(new jxl.write.Label(0,row,"OVER DUE",normalFormat)); 
			row = row +1;
			workSheet1.addCell(new jxl.write.Label(0,row,"Machine",normalFormat));          
			workSheet1.addCell(new jxl.write.Label(1,row,"Model",normalFormat));         
			workSheet1.addCell(new jxl.write.Label(2,row,"Total Machine Life Hours",normalFormat));
			workSheet1.addCell(new jxl.write.Label(3,row,"Service Schedule",normalFormat));
			workSheet1.addCell(new jxl.write.Label(4,row,"Service Name",normalFormat));
			workSheet1.addCell(new jxl.write.Label(5,row,"Planned Service Date",normalFormat));
			workSheet1.addCell(new jxl.write.Label(6,row,"Planned Service Hours",normalFormat));
			workSheet1.addCell(new jxl.write.Label(7,row,"Due By Hours",normalFormat));
			workSheet1.addCell(new jxl.write.Label(8,row,"Due By Days",normalFormat));
			workSheet1.addCell(new jxl.write.Label(9,row,"Customer Name",normalFormat));
			workSheet1.addCell(new jxl.write.Label(10,row,"Customer Number",normalFormat));
			workSheet1.addCell(new jxl.write.Label(11,row,"Dealer Name",normalFormat));          
			workSheet1.addCell(new jxl.write.Label(12,row,"Dealer Contact",normalFormat));
			workSheet1.addCell(new jxl.write.Label(13,row,"Operator Name",normalFormat));
			workSheet1.addCell(new jxl.write.Label(14,row,"Operator Number",normalFormat));
			row = row+1;
			responseIter = response3.iterator();
			while(responseIter.hasNext()){
				respObj2  = (DueOverDueReportRespContract)responseIter.next(); 
				iLogger.info("overdue - machine name "+respObj2.getMachineName() );
				workSheet1.addCell(new jxl.write.Label(0,row,respObj2.getSerialNumber(),normalFormat1));
				workSheet1.addCell(new jxl.write.Label(1,row,respObj2.getMachineProfileName(),normalFormat1));
				workSheet1.addCell(new jxl.write.Label(2,row,String.valueOf(respObj2.getTotalMachineHours()),normalFormat1));
				workSheet1.addCell(new jxl.write.Label(3,row,respObj2.getScheduleName(),normalFormat1));
				workSheet1.addCell(new jxl.write.Label(4,row,respObj2.getServiceName(),normalFormat1));
				workSheet1.addCell(new jxl.write.Label(5,row,respObj2.getPlannedServiceDate(),normalFormat1));
				workSheet1.addCell(new jxl.write.Label(6,row,String.valueOf(respObj2.getPlannedServiceHours()),normalFormat1));
				workSheet1.addCell(new jxl.write.Label(7,row,String.valueOf(respObj2.getDueOrOverDueHours()),normalFormat1));
				workSheet1.addCell(new jxl.write.Label(8,row,String.valueOf(respObj2.getDueOrOverDueDays()),normalFormat1));
				workSheet1.addCell(new jxl.write.Label(9,row,respObj2.getCustomerName(),normalFormat1));
				workSheet1.addCell(new jxl.write.Label(10,row,respObj2.getCustomerContactNumber(),normalFormat1));
				workSheet1.addCell(new jxl.write.Label(11,row,respObj2.getDealerName(),normalFormat1));
				workSheet1.addCell(new jxl.write.Label(12,row,respObj2.getDealerContactNumber(),normalFormat1));
				workSheet1.addCell(new jxl.write.Label(13,row,respObj2.getOperatorName(),normalFormat1));
				workSheet1.addCell(new jxl.write.Label(14,row,respObj2.getOperatorContactNumber(),normalFormat1));


				++row;
			}



			workbook.write();
			workbook.close();
		}
		catch(Exception e){
			e.printStackTrace();
		}
		return workSheet1;
	}

	public WritableSheet createWorksheetForFleetSummaryReport(List<FleetSummaryReportRespContract> response,String reportsPath,String reportsDir){
		WritableSheet workSheet = null;
	
		Logger iLogger = InfoLoggerClass.logger;
		try{	 
			WorkbookSettings ws = new WorkbookSettings();

			//			delete all existing files
			File file = new File(reportsDir); 
			String[] myFiles;       
			if(file.isDirectory()){   
				myFiles = file.list();   
				for (int i=0; i<myFiles.length; i++) {   
					File myFile = new File(file, myFiles[i]);    
					myFile.delete();   
				}   
			}     


			WritableWorkbook workbook = Workbook.createWorkbook(new File(reportsPath), ws);


			workSheet = workbook.createSheet("Fleet Summary" ,0);
			WritableFont normalFont = new WritableFont(WritableFont.createFont("Calibri"),
					WritableFont.DEFAULT_POINT_SIZE,
					WritableFont.BOLD,  false,UnderlineStyle.NO_UNDERLINE);
			WritableCellFormat normalFormat = new WritableCellFormat(normalFont);       
			normalFormat.setAlignment(jxl.format.Alignment.JUSTIFY);
			normalFormat.setVerticalAlignment(VerticalAlignment.CENTRE);
			normalFormat.setBackground(jxl.format.Colour.BLUE_GREY);
			normalFormat.setWrap(false);
			normalFormat.setBorder(jxl.format.Border.ALL, jxl.format.BorderLineStyle.THIN,
					jxl.format.Colour.BLACK);

			workSheet.addCell(new jxl.write.Label(0,0,"Machine",normalFormat));

			workSheet.addCell(new jxl.write.Label(1,0,"Profile",normalFormat));

			workSheet.addCell(new jxl.write.Label(2,0,"Total Machine Life Hours",normalFormat));
			workSheet.addCell(new jxl.write.Label(3,0,"Machine Hours",normalFormat));
			workSheet.addCell(new jxl.write.Label(4,0,"Engine Off(%)",normalFormat));
			workSheet.addCell(new jxl.write.Label(5,0,"Idle Time(%)",normalFormat));
			workSheet.addCell(new jxl.write.Label(6,0,"Working Time(%)",normalFormat));
			workSheet.addCell(new jxl.write.Label(7,0,"Power Band Low",normalFormat));
			workSheet.addCell(new jxl.write.Label(8,0,"Power Band Medium",normalFormat));
			workSheet.addCell(new jxl.write.Label(9,0,"Power Band High",normalFormat));
			workSheet.addCell(new jxl.write.Label(10,0,"Fuel Used In Idle(Liters)",normalFormat));
			workSheet.addCell(new jxl.write.Label(11,0,"Fuel Used(Liters)",normalFormat));
			workSheet.addCell(new jxl.write.Label(12,0,"Average Fuel Consumption(Liters)",normalFormat));

			WritableCellFormat normalFormat1 = new WritableCellFormat(normalFont);

			normalFormat1.setAlignment(jxl.format.Alignment.JUSTIFY);
			normalFormat1.setVerticalAlignment(VerticalAlignment.CENTRE);

			normalFormat1.setBorder(jxl.format.Border.ALL, jxl.format.BorderLineStyle.THIN,
					jxl.format.Colour.BLACK);
			int row= 1;long TotalMachineLifeHours=0l;	
			Iterator<FleetSummaryReportRespContract> responseIter = response.iterator();
			FleetSummaryReportRespContract respObj = null;
			double engineOff=0.0D;
			double working=0d,idle=0d,pbLow,pbHigh,pbMed;
			double total=0d;
			while(responseIter.hasNext()){
				respObj  = responseIter.next();
				iLogger.info("fleet summary - machine name "+respObj.getMachineName());
				workSheet.addCell(new jxl.write.Label(0,row,respObj.getSerialNumber(),normalFormat1));
				workSheet.addCell(new jxl.write.Label(1,row,respObj.getProfile(),normalFormat1));
				workSheet.addCell(new jxl.write.Label(2,row,String.valueOf(respObj.getTotalMachineLifeHours()),normalFormat1));
				workSheet.addCell(new jxl.write.Label(3,row,String.valueOf(respObj.getMachineHours()),normalFormat1));
				engineOff =respObj.getEngineOff(); working = respObj.getWorkingTime(); idle = respObj.getIdleTime();
				total = engineOff+working+idle;  
				if(total!=0d){
					workSheet.addCell(new jxl.write.Label(4,row,String.valueOf(Math.ceil(engineOff*100/total)),normalFormat1));
					workSheet.addCell(new jxl.write.Label(5,row,String.valueOf(Math.ceil(idle*100/total)),normalFormat1));
					workSheet.addCell(new jxl.write.Label(6,row,String.valueOf(Math.ceil(working*100/total)),normalFormat1));
				}
				else{
					workSheet.addCell(new jxl.write.Label(4,row,"0",normalFormat1));
					workSheet.addCell(new jxl.write.Label(5,row,"0",normalFormat1));
					workSheet.addCell(new jxl.write.Label(6,row,"0",normalFormat1));
				}
				pbLow = respObj.getPowerBandLow();	pbMed=respObj.getPowerBandMedium();	pbHigh = respObj.getPowerBandhigh();
				total = pbLow+pbMed+pbHigh;      
				if(total!=0d){
					workSheet.addCell(new jxl.write.Label(7,row,String.valueOf(Math.ceil(pbLow*100/total)),normalFormat1));
					workSheet.addCell(new jxl.write.Label(8,row,String.valueOf(Math.ceil(pbMed*100/total)),normalFormat1));
					workSheet.addCell(new jxl.write.Label(9,row,String.valueOf(Math.ceil(pbHigh*100/total)),normalFormat1));
				}
				else{
					workSheet.addCell(new jxl.write.Label(7,row,"0",normalFormat1));
					workSheet.addCell(new jxl.write.Label(8,row,"0",normalFormat1));
					workSheet.addCell(new jxl.write.Label(9,row,"0",normalFormat1));
				}

				workSheet.addCell(new jxl.write.Label(10,row,String.valueOf(respObj.getFuelUsedInIdle()),normalFormat1));
				workSheet.addCell(new jxl.write.Label(11,row,String.valueOf(respObj.getFuelused()),normalFormat1));
				workSheet.addCell(new jxl.write.Label(12,row,String.valueOf(respObj.getAverageFuelConsumption()),normalFormat1));
				++row;
			}

			workbook.write();
			workbook.close();
		}
		catch(Exception e){
			e.printStackTrace();
		}
		return workSheet;
	}


	public WritableSheet createWorksheetForMachineUsageHoursSummaryReport(List<MachineHoursReportRespContract> response,String reportsPath,String reportsDir){
		WritableSheet workSheet = null;
		
		Logger iLogger = InfoLoggerClass.logger;
		try{	 
			WorkbookSettings ws = new WorkbookSettings();

			//			delete all existing files
			File file = new File(reportsDir);   
			String[] myFiles;       
			if(file.isDirectory()){   
				myFiles = file.list();   
				for (int i=0; i<myFiles.length; i++) {   
					File myFile = new File(file, myFiles[i]);    
					myFile.delete();   
				}   
			}     


			WritableWorkbook workbook = Workbook.createWorkbook(new File(reportsPath), ws);


			workSheet = workbook.createSheet("Machine Usage Hours" ,0);
			WritableFont normalFont = new WritableFont(WritableFont.createFont("Calibri"),
					WritableFont.DEFAULT_POINT_SIZE,
					WritableFont.BOLD,  false,UnderlineStyle.NO_UNDERLINE);
			WritableCellFormat normalFormat = new WritableCellFormat(normalFont);       
			normalFormat.setAlignment(jxl.format.Alignment.JUSTIFY);
			normalFormat.setVerticalAlignment(VerticalAlignment.CENTRE);
			normalFormat.setBackground(jxl.format.Colour.BLUE_GREY);
			normalFormat.setWrap(false);
			normalFormat.setBorder(jxl.format.Border.ALL, jxl.format.BorderLineStyle.THIN,
					jxl.format.Colour.BLACK);

			workSheet.addCell(new jxl.write.Label(0,0,"Machine",normalFormat));        
			workSheet.addCell(new jxl.write.Label(1,0,"Total Machine Life Hours",normalFormat));
			workSheet.addCell(new jxl.write.Label(2,0,"Machine Hours(In Period)",normalFormat));        
			workSheet.addCell(new jxl.write.Label(3,0,"Status",normalFormat));
			workSheet.addCell(new jxl.write.Label(4,0,"Duration In Status",normalFormat));
			workSheet.addCell(new jxl.write.Label(5,0,"Last Engine Run",normalFormat));
			workSheet.addCell(new jxl.write.Label(6,0,"Last Reported",normalFormat));
			workSheet.addCell(new jxl.write.Label(7,0,"Location",normalFormat));

			WritableCellFormat normalFormat1 = new WritableCellFormat(normalFont);

			normalFormat1.setAlignment(jxl.format.Alignment.JUSTIFY);
			normalFormat1.setVerticalAlignment(VerticalAlignment.CENTRE);

			normalFormat1.setBorder(jxl.format.Border.ALL, jxl.format.BorderLineStyle.THIN,
					jxl.format.Colour.BLACK);
			int row= 1;long TotalMachineLifeHours=0l;	
			Iterator<MachineHoursReportRespContract> responseIter = response.iterator();
			MachineHoursReportRespContract respObj = null;
			long duration=0l,hour=0l;int min=0;
			while(responseIter.hasNext()){
				respObj  = responseIter.next();
				iLogger.info("MachineUsageHours "+respObj.getMachineName());
				workSheet.addCell(new jxl.write.Label(0,row,respObj.getSerialNumber(),normalFormat1));
				workSheet.addCell(new jxl.write.Label(1,row,String.valueOf(respObj.getTotalMachineHours()),normalFormat1));
				workSheet.addCell(new jxl.write.Label(2,row,String.valueOf(respObj.getMachineHours()),normalFormat1));
				if(respObj.getStatus()!=null){
					if(respObj.getStatus().equals("0")){
						workSheet.addCell(new jxl.write.Label(3,row,"Dormant",normalFormat1));
					}
					else if(respObj.getStatus().equals("1")){
						workSheet.addCell(new jxl.write.Label(3,row,"Operational",normalFormat1));
					}
				}
				duration = respObj.getDurationInCurrentStatus();
				hour = duration/60;
				min = (int) (duration%60);
				workSheet.addCell(new jxl.write.Label(4,row,String.valueOf(hour+"h "+min+"m"),normalFormat1));
				workSheet.addCell(new jxl.write.Label(5,row,String.valueOf(respObj.getLastEngineRun()),normalFormat1));
				workSheet.addCell(new jxl.write.Label(6,row,String.valueOf(respObj.getLastReported()),normalFormat1));
				workSheet.addCell(new jxl.write.Label(7,row,respObj.getLocation(),normalFormat1));

				++row;
			}

			workbook.write();
			workbook.close();
		}
		catch(Exception e){
			e.printStackTrace();
		}
		return workSheet;
	}
	public WritableSheet createWorksheetForMachinePerformanceReport(List<MachinePerformanceReportRespContract> response,String reportsPath,String reportsDir){
		WritableSheet workSheet = null;
		
		Logger iLogger = InfoLoggerClass.logger;
		try{	 
			WorkbookSettings ws = new WorkbookSettings();
			//			delete all existing files
			File file = new File(reportsDir);   
			String[] myFiles;       
			if(file.isDirectory()){   
				myFiles = file.list();   
				for (int i=0; i<myFiles.length; i++) {   
					File myFile = new File(file, myFiles[i]);    
					myFile.delete();   
				}   
			}     


			WritableWorkbook workbook = Workbook.createWorkbook(new File(reportsPath), ws);


			workSheet = workbook.createSheet("Machine Performance" ,0);
			WritableFont normalFont = new WritableFont(WritableFont.createFont("Calibri"),
					WritableFont.DEFAULT_POINT_SIZE,
					WritableFont.BOLD,  false,UnderlineStyle.NO_UNDERLINE);
			WritableCellFormat normalFormat = new WritableCellFormat(normalFont);       
			normalFormat.setAlignment(jxl.format.Alignment.JUSTIFY);
			normalFormat.setVerticalAlignment(VerticalAlignment.CENTRE);
			normalFormat.setBackground(jxl.format.Colour.BLUE_GREY);
			normalFormat.setWrap(false);
			normalFormat.setBorder(jxl.format.Border.ALL, jxl.format.BorderLineStyle.THIN,
					jxl.format.Colour.BLACK);      

			WritableCellFormat normalFormat1 = new WritableCellFormat(normalFont);

			normalFormat1.setAlignment(jxl.format.Alignment.JUSTIFY);
			normalFormat1.setVerticalAlignment(VerticalAlignment.CENTRE);

			normalFormat1.setBorder(jxl.format.Border.ALL, jxl.format.BorderLineStyle.THIN,
					jxl.format.Colour.BLACK);
			int row= 1;long TotalMachineLifeHours=0l;	
			Iterator<MachinePerformanceReportRespContract> responseIter = response.iterator();
			MachinePerformanceReportRespContract respObj = null;

			workSheet.addCell(new jxl.write.Label(0,0,"Machine",normalFormat));     
			workSheet.addCell(new jxl.write.Label(1,0,"Profile",normalFormat));   
			workSheet.addCell(new jxl.write.Label(2,0,"Engine Off",normalFormat));
			workSheet.addCell(new jxl.write.Label(3,0,"Engine On",normalFormat));
			workSheet.addCell(new jxl.write.Label(4,0,"Working Time",normalFormat));
			workSheet.addCell(new jxl.write.Label(5,0,"Idle Time",normalFormat));
			workSheet.addCell(new jxl.write.Label(6,0,"Power Band Low",normalFormat));
			workSheet.addCell(new jxl.write.Label(7,0,"Power Band Medium",normalFormat));
			workSheet.addCell(new jxl.write.Label(8,0,"Power Band High",normalFormat));

			workSheet.addCell(new jxl.write.Label(9,0,"Starting Engine Hours",normalFormat));

			workSheet.addCell(new jxl.write.Label(10,0,"Finish Engine Hours",normalFormat));
			workSheet.addCell(new jxl.write.Label(11,0,"Fuel Used Liters",normalFormat));
			workSheet.addCell(new jxl.write.Label(12,0,"Fuel Used Idle Liters",normalFormat));
			workSheet.addCell(new jxl.write.Label(13,0,"Finish Fuel Level %",normalFormat));
			workSheet.addCell(new jxl.write.Label(14,0,"Overall Fuel Consumption Liters/Hr",normalFormat));
			while(responseIter.hasNext()){



				respObj  = responseIter.next();
				iLogger.info("Machineperformance "+respObj.getSerialNumber());

				workSheet.addCell(new jxl.write.Label(0,row,respObj.getSerialNumber(),normalFormat1));
				workSheet.addCell(new jxl.write.Label(1,row,String.valueOf(respObj.getAsset_group_name()),normalFormat1));
				workSheet.addCell(new jxl.write.Label(2,row,String.valueOf(respObj.getEngineOff()),normalFormat1));
				workSheet.addCell(new jxl.write.Label(3,row,String.valueOf(respObj.getEngineOn()),normalFormat1));
				workSheet.addCell(new jxl.write.Label(4,row,String.valueOf(respObj.getWorkingTime()),normalFormat1));
				workSheet.addCell(new jxl.write.Label(5,row,String.valueOf(respObj.getIdleTime()),normalFormat1));
				workSheet.addCell(new jxl.write.Label(6,row,String.valueOf(respObj.getPowerBandLow()),normalFormat1));
				workSheet.addCell(new jxl.write.Label(7,row,String.valueOf(respObj.getPowerBandMedium()),normalFormat1));
				workSheet.addCell(new jxl.write.Label(8,row,String.valueOf(respObj.getPowerBandHigh()),normalFormat1));

				workSheet.addCell(new jxl.write.Label(9,row,String.valueOf(respObj.getStartingEngineRunHours()),normalFormat1));
				workSheet.addCell(new jxl.write.Label(10,row,String.valueOf(respObj.getFinishEngineRunHours()),normalFormat1));
				workSheet.addCell(new jxl.write.Label(11,row,String.valueOf(respObj.getFuelUsedLitres()),normalFormat1));
				workSheet.addCell(new jxl.write.Label(12,row,String.valueOf(respObj.getFuelUsedIdleLitres()),normalFormat1));
				workSheet.addCell(new jxl.write.Label(13,row,String.valueOf(respObj.getFinishFuelLevel()),normalFormat1));
				workSheet.addCell(new jxl.write.Label(14,row,String.valueOf(respObj.getOverallFuelConsumptionLitres()),normalFormat1));


				++row;
			}

			workbook.write();
			workbook.close();
		}
		catch(Exception e){
			e.printStackTrace();
		}
		return workSheet;

	}

	public WritableSheet createWorksheetForMachineActivityReport(List<MachineActivityReportRespContract> response,String reportsPath,String reportsDir){
		WritableSheet workSheet = null;
		Logger iLogger = InfoLoggerClass.logger;
		try{	 
			WorkbookSettings ws = new WorkbookSettings();
			//			delete all existing files
			File file = new File(reportsDir);   
			String[] myFiles;       
			if(file.isDirectory()){   
				myFiles = file.list();   
				for (int i=0; i<myFiles.length; i++) {   
					File myFile = new File(file, myFiles[i]);    
					myFile.delete();   
				}   
			}     


			WritableWorkbook workbook = Workbook.createWorkbook(new File(reportsPath), ws);


			workSheet = workbook.createSheet("Machine Activity" ,0);
			WritableFont normalFont = new WritableFont(WritableFont.createFont("Calibri"),
					WritableFont.DEFAULT_POINT_SIZE,
					WritableFont.BOLD,  false,UnderlineStyle.NO_UNDERLINE);
			WritableCellFormat normalFormat = new WritableCellFormat(normalFont);       
			normalFormat.setAlignment(jxl.format.Alignment.JUSTIFY);
			normalFormat.setVerticalAlignment(VerticalAlignment.CENTRE);
			normalFormat.setBackground(jxl.format.Colour.BLUE_GREY);
			normalFormat.setWrap(false);
			normalFormat.setBorder(jxl.format.Border.ALL, jxl.format.BorderLineStyle.THIN,
					jxl.format.Colour.BLACK);

			workSheet.addCell(new jxl.write.Label(0,0,"Machine",normalFormat));        
			workSheet.addCell(new jxl.write.Label(1,0,"Total Machine Life Hours",normalFormat));
			workSheet.addCell(new jxl.write.Label(2,0,"Machine Hours",normalFormat));
			workSheet.addCell(new jxl.write.Label(3,0,"Status",normalFormat));
			workSheet.addCell(new jxl.write.Label(4,0,"Duration In Status",normalFormat));
			workSheet.addCell(new jxl.write.Label(5,0,"Location",normalFormat));

			WritableCellFormat normalFormat1 = new WritableCellFormat(normalFont);

			normalFormat1.setAlignment(jxl.format.Alignment.JUSTIFY);
			normalFormat1.setVerticalAlignment(VerticalAlignment.CENTRE);

			normalFormat1.setBorder(jxl.format.Border.ALL, jxl.format.BorderLineStyle.THIN,
					jxl.format.Colour.BLACK);
			int row= 1;long TotalMachineLifeHours=0l;	
			Iterator<MachineActivityReportRespContract> responseIter = response.iterator();
			MachineActivityReportRespContract respObj = null;
			long duration=0l,hour=0l;int min=0;
			while(responseIter.hasNext()){
				respObj  = responseIter.next();
				iLogger.info("Machine activity"+respObj.getSerialNumber());
				workSheet.addCell(new jxl.write.Label(0,row,respObj.getSerialNumber(),normalFormat1));
				workSheet.addCell(new jxl.write.Label(1,row,String.valueOf(respObj.getTotalMachineLifeHours()),normalFormat1));
				workSheet.addCell(new jxl.write.Label(2,row,String.valueOf(respObj.getMachineHours()),normalFormat1));
				workSheet.addCell(new jxl.write.Label(3,row,String.valueOf(respObj.getStatus()),normalFormat1));
				duration = respObj.getDuration_in_status();
				hour = duration/60;
				min = (int) (duration%60);
				workSheet.addCell(new jxl.write.Label(4,row,String.valueOf(hour+"h "+min+"m"),normalFormat1));
				workSheet.addCell(new jxl.write.Label(5,row,respObj.getLocation(),normalFormat1));


				++row;
			}

			workbook.write();
			workbook.close();
		}
		catch(Exception e){
			e.printStackTrace();
		}
		return workSheet;
	}

	public WritableSheet createWorksheetForLandmarkActivityReport(List<LandmarkActivityReportRespContract> response,String reportsPath,String reportsDir){
		WritableSheet workSheet = null;
		
		Logger iLogger = InfoLoggerClass.logger;
		try{	 
			WorkbookSettings ws = new WorkbookSettings();
			//			delete all existing files
			File file = new File(reportsDir);   
			String[] myFiles;       
			if(file.isDirectory()){   
				myFiles = file.list();   
				for (int i=0; i<myFiles.length; i++) {   
					File myFile = new File(file, myFiles[i]);    
					myFile.delete();   
				}   
			}     


			WritableWorkbook workbook = Workbook.createWorkbook(new File(reportsPath), ws);


			workSheet = workbook.createSheet("Landmark Activity" ,0);
			WritableFont normalFont = new WritableFont(WritableFont.createFont("Calibri"),
					WritableFont.DEFAULT_POINT_SIZE,
					WritableFont.BOLD,  false,UnderlineStyle.NO_UNDERLINE);
			WritableCellFormat normalFormat = new WritableCellFormat(normalFont);       
			normalFormat.setAlignment(jxl.format.Alignment.JUSTIFY);
			normalFormat.setVerticalAlignment(VerticalAlignment.CENTRE);
			normalFormat.setBackground(jxl.format.Colour.BLUE_GREY);
			normalFormat.setWrap(false);
			normalFormat.setBorder(jxl.format.Border.ALL, jxl.format.BorderLineStyle.THIN,
					jxl.format.Colour.BLACK);

			workSheet.addCell(new jxl.write.Label(0,0,"Machine",normalFormat));        
			workSheet.addCell(new jxl.write.Label(1,0,"Number of Arrivals",normalFormat));
			workSheet.addCell(new jxl.write.Label(2,0,"Number of Departures",normalFormat));
			workSheet.addCell(new jxl.write.Label(3,0,"Total Duration at Landmark in Mins",normalFormat));
			workSheet.addCell(new jxl.write.Label(4,0,"Longest Duration at Landmark in Mins",normalFormat));

			WritableCellFormat normalFormat1 = new WritableCellFormat(normalFont);

			normalFormat1.setAlignment(jxl.format.Alignment.JUSTIFY);
			normalFormat1.setVerticalAlignment(VerticalAlignment.CENTRE);

			normalFormat1.setBorder(jxl.format.Border.ALL, jxl.format.BorderLineStyle.THIN,
					jxl.format.Colour.BLACK);
			int row= 1;long TotalMachineLifeHours=0l;	
			Iterator<LandmarkActivityReportRespContract> responseIter = response.iterator();
			LandmarkActivityReportRespContract respObj = null;
			while(responseIter.hasNext()){
				respObj  = responseIter.next();
				iLogger.info("landmark activity "+respObj.getSerialNumber());
				workSheet.addCell(new jxl.write.Label(0,row,respObj.getSerialNumber(),normalFormat1));
				workSheet.addCell(new jxl.write.Label(1,row,String.valueOf(respObj.getNumberOfArrivals()),normalFormat1));
				workSheet.addCell(new jxl.write.Label(2,row,String.valueOf(respObj.getNumberOfdepartures()),normalFormat1));
				workSheet.addCell(new jxl.write.Label(3,row,String.valueOf(respObj.getTotalDurationAtLandmarkInMinutes()),normalFormat1));
				workSheet.addCell(new jxl.write.Label(4,row,String.valueOf(respObj.getLongestDurationAtLandmarkInMinutes()),normalFormat1));


				++row;
			}

			workbook.write();
			workbook.close();
		}
		catch(Exception e){
			e.printStackTrace();
		}
		return workSheet;
	}

	public WritableSheet createWorksheetForNotificationSummaryReport(List<NotificationSummaryReportRespContract> response,String reportsPath,String reportsDir){
		WritableSheet workSheet = null;
		
		Logger iLogger = InfoLoggerClass.logger;
		try{	 
			WorkbookSettings ws = new WorkbookSettings();
			//			delete all existing files
			File file = new File(reportsDir);   
			String[] myFiles;       
			if(file.isDirectory()){   
				myFiles = file.list();   
				for (int i=0; i<myFiles.length; i++) {   
					File myFile = new File(file, myFiles[i]);    
					myFile.delete();   
				}   
			}     


			WritableWorkbook workbook = Workbook.createWorkbook(new File(reportsPath), ws);


			workSheet = workbook.createSheet("Usage Alerts" ,0);
			WritableFont normalFont = new WritableFont(WritableFont.createFont("Calibri"),
					WritableFont.DEFAULT_POINT_SIZE,
					WritableFont.BOLD,  false,UnderlineStyle.NO_UNDERLINE);
			WritableCellFormat normalFormat = new WritableCellFormat(normalFont);       
			normalFormat.setAlignment(jxl.format.Alignment.JUSTIFY);
			normalFormat.setVerticalAlignment(VerticalAlignment.CENTRE);
			normalFormat.setBackground(jxl.format.Colour.BLUE_GREY);
			normalFormat.setWrap(false);
			normalFormat.setBorder(jxl.format.Border.ALL, jxl.format.BorderLineStyle.THIN,
					jxl.format.Colour.BLACK);

			workSheet.addCell(new jxl.write.Label(0,0,"Machine",normalFormat));        
			workSheet.addCell(new jxl.write.Label(1,0,"Health",normalFormat));
			workSheet.addCell(new jxl.write.Label(2,0,"Services",normalFormat));
			workSheet.addCell(new jxl.write.Label(3,0,"Security",normalFormat));
			workSheet.addCell(new jxl.write.Label(4,0,"Landmark",normalFormat));
			workSheet.addCell(new jxl.write.Label(5,0,"Utilization",normalFormat));


			WritableCellFormat normalFormat1 = new WritableCellFormat(normalFont);

			normalFormat1.setAlignment(jxl.format.Alignment.JUSTIFY);
			normalFormat1.setVerticalAlignment(VerticalAlignment.CENTRE);

			normalFormat1.setBorder(jxl.format.Border.ALL, jxl.format.BorderLineStyle.THIN,
					jxl.format.Colour.BLACK);
			int row= 0;long TotalMachineLifeHours=0l;	
			Iterator<NotificationSummaryReportRespContract> responseIter = response.iterator();
			NotificationSummaryReportRespContract respObj = null;
			String typeName=null,prevSerNo = null;
			while(responseIter.hasNext()){
				respObj  = responseIter.next();
				typeName = respObj.getNotificationTypeName();

				iLogger.info("usage alerts "+respObj.getSerialNumber());
				if(respObj.getSerialNumber()!=prevSerNo){
					++row;
					workSheet.addCell(new jxl.write.Label(0,row,respObj.getSerialNumber(),normalFormat1));

				}
				iLogger.info("count "+respObj.getCount());
				if(typeName !=null && typeName.equals("Health")){
					workSheet.addCell(new jxl.write.Label(1,row,String.valueOf(respObj.getCount()),normalFormat1));
				}
				if(typeName !=null && typeName.equals("Services")){

					workSheet.addCell(new jxl.write.Label(2,row,String.valueOf(respObj.getCount()),normalFormat1));
				}
				if(typeName !=null && typeName.equals("Security")){
					workSheet.addCell(new jxl.write.Label(3,row,String.valueOf(respObj.getCount()),normalFormat1));
				}
				if(typeName !=null && typeName.equals("Landmark")){
					workSheet.addCell(new jxl.write.Label(4,row,String.valueOf(respObj.getCount()),normalFormat1));
				}
				if(typeName !=null && typeName.equals("Utilization")){
					workSheet.addCell(new jxl.write.Label(5,row,String.valueOf(respObj.getCount()),normalFormat1));
				}

				prevSerNo = respObj.getSerialNumber();


			}

			workbook.write();
			workbook.close();
		}
		catch(Exception e){
			e.printStackTrace();
		}
		return workSheet;
	}

	public WritableSheet createWorksheetForUtilizationReport(List<UtilizationSummaryReportRespContract> response,String reportsPath,String reportsDir){
		WritableSheet workSheet = null;
	
		Logger iLogger = InfoLoggerClass.logger;
		try{	 
			WorkbookSettings ws = new WorkbookSettings();
			//			delete all existing files
			File file = new File(reportsDir);   
			String[] myFiles;       
			if(file.isDirectory()){   
				myFiles = file.list();   
				for (int i=0; i<myFiles.length; i++) {   
					File myFile = new File(file, myFiles[i]);    
					myFile.delete();   
				}   
			}     


			WritableWorkbook workbook = Workbook.createWorkbook(new File(reportsPath), ws);


			workSheet = workbook.createSheet("Machine Utilization" ,0);
			WritableFont normalFont = new WritableFont(WritableFont.createFont("Calibri"),
					WritableFont.DEFAULT_POINT_SIZE,
					WritableFont.BOLD,  false,UnderlineStyle.NO_UNDERLINE);
			WritableCellFormat normalFormat = new WritableCellFormat(normalFont);       
			normalFormat.setAlignment(jxl.format.Alignment.JUSTIFY);
			normalFormat.setVerticalAlignment(VerticalAlignment.CENTRE);
			normalFormat.setBackground(jxl.format.Colour.BLUE_GREY);
			normalFormat.setWrap(false);
			normalFormat.setBorder(jxl.format.Border.ALL, jxl.format.BorderLineStyle.THIN,
					jxl.format.Colour.BLACK);

			workSheet.addCell(new jxl.write.Label(0,0,"Machine",normalFormat));        
			workSheet.addCell(new jxl.write.Label(1,0,"Engine Run Duration",normalFormat));
			workSheet.addCell(new jxl.write.Label(2,0,"Engine Off Duration",normalFormat));
			workSheet.addCell(new jxl.write.Label(3,0,"Machine Utilizatioj",normalFormat));


			WritableCellFormat normalFormat1 = new WritableCellFormat(normalFont);

			normalFormat1.setAlignment(jxl.format.Alignment.JUSTIFY);
			normalFormat1.setVerticalAlignment(VerticalAlignment.CENTRE);

			normalFormat1.setBorder(jxl.format.Border.ALL, jxl.format.BorderLineStyle.THIN,
					jxl.format.Colour.BLACK);
			int row= 1;long TotalMachineLifeHours=0l;	
			Iterator<UtilizationSummaryReportRespContract> responseIter = response.iterator();
			UtilizationSummaryReportRespContract respObj = null;
			while(responseIter.hasNext()){
				respObj  = responseIter.next();
				iLogger.info("utilization "+respObj.getSerialNumber()); 	
				workSheet.addCell(new jxl.write.Label(0,row,respObj.getSerialNumber(),normalFormat1)); 		
				workSheet.addCell(new jxl.write.Label(1,row,String.valueOf(respObj.getEngineRunDurationInMin()),normalFormat1));
				workSheet.addCell(new jxl.write.Label(2,row,String.valueOf(respObj.getEngineOffDurationInMin()),normalFormat1));
				workSheet.addCell(new jxl.write.Label(3,row,String.valueOf(respObj.getMachineUtilizationPercentage()),normalFormat1));
				++row;

			}

			workbook.write();
			workbook.close();
		}
		catch(Exception e){
			e.printStackTrace();
		}
		return workSheet;
	}

	public WritableSheet createWorksheetForTrendDataReport(List<MachineHourMeterTrendDataReportRespContract> response1,List<MachineRPMBandDataReportRespContract> response2,List<MachineAlertsTrendDataRespContract> response3,String reportsPath,String reportsDir,int tenancyTypeId){
		WritableSheet workSheet = null;
		
		Logger iLogger = InfoLoggerClass.logger;
		try{	 
			WorkbookSettings ws = new WorkbookSettings();
			//			delete all existing files
			File file = new File(reportsDir);   
			String[] myFiles;       
			if(file.isDirectory()){   
				myFiles = file.list();   
				for (int i=0; i<myFiles.length; i++) {   
					File myFile = new File(file, myFiles[i]);    
					myFile.delete();   
				}   
			}     


			WritableWorkbook workbook = Workbook.createWorkbook(new File(reportsPath), ws);


			workSheet = workbook.createSheet("Usage Alerts" ,0);
			WritableFont normalFont = new WritableFont(WritableFont.createFont("Calibri"),
					WritableFont.DEFAULT_POINT_SIZE,
					WritableFont.BOLD,  false,UnderlineStyle.NO_UNDERLINE);
			WritableCellFormat normalFormat = new WritableCellFormat(normalFont);       
			normalFormat.setAlignment(jxl.format.Alignment.JUSTIFY);
			normalFormat.setVerticalAlignment(VerticalAlignment.CENTRE);
			normalFormat.setBackground(jxl.format.Colour.BLUE_GREY);
			normalFormat.setWrap(false);
			normalFormat.setBorder(jxl.format.Border.ALL, jxl.format.BorderLineStyle.THIN,
					jxl.format.Colour.BLACK);

			if(tenancyTypeId==1){
				workSheet.addCell(new jxl.write.Label(0,0,"Zone",normalFormat));  
			}
			else if(tenancyTypeId==2){
				workSheet.addCell(new jxl.write.Label(0,0,"Dealer",normalFormat));  
			}         
			workSheet.addCell(new jxl.write.Label(1,0,"Machine Alerts",normalFormat));

			if(tenancyTypeId==1){
				workSheet.addCell(new jxl.write.Label(3,0,"Zone",normalFormat));  
			}
			else if(tenancyTypeId==2){
				workSheet.addCell(new jxl.write.Label(3,0,"Dealer",normalFormat));  
			}

			workSheet.addCell(new jxl.write.Label(4,0,"Machine Hours",normalFormat));

			if(tenancyTypeId==1){
				workSheet.addCell(new jxl.write.Label(6,0,"Zone",normalFormat));  
			}
			else if(tenancyTypeId==2){
				workSheet.addCell(new jxl.write.Label(6,0,"Dealer",normalFormat));  
			}

			workSheet.addCell(new jxl.write.Label(7,0,"Max. Idle RPM Band",normalFormat));
			workSheet.addCell(new jxl.write.Label(8,0,"Max. Working RPM Band",normalFormat));


			WritableCellFormat normalFormat1 = new WritableCellFormat(normalFont);

			normalFormat1.setAlignment(jxl.format.Alignment.JUSTIFY);
			normalFormat1.setVerticalAlignment(VerticalAlignment.CENTRE);

			normalFormat1.setBorder(jxl.format.Border.ALL, jxl.format.BorderLineStyle.THIN,
					jxl.format.Colour.BLACK);
			int row= 1;	

			MachineHourMeterTrendDataReportRespContract respObj1 = null;
			MachineRPMBandDataReportRespContract respObj2 = null;
			MachineAlertsTrendDataRespContract respObj3 = null;

			Iterator<MachineHourMeterTrendDataReportRespContract> responseIter1 = response1.iterator();
			Iterator<MachineRPMBandDataReportRespContract> responseIter2 = response2.iterator();
			Iterator<MachineAlertsTrendDataRespContract> responseIter3 = response3.iterator();

			if(tenancyTypeId==1){
				row =1;

				while(responseIter3.hasNext()){
					respObj3  = responseIter3.next();

					workSheet.addCell(new jxl.write.Label(0,row,respObj3.getZoneName(),normalFormat1)); 		
					workSheet.addCell(new jxl.write.Label(1,row,String.valueOf(respObj3.getTotalAlerts()),normalFormat1));
					++row;

				}
				row =1;
				while(responseIter1.hasNext()){
					respObj1  = responseIter1.next();

					workSheet.addCell(new jxl.write.Label(3,row,respObj1.getZoneName(),normalFormat1)); 		
					workSheet.addCell(new jxl.write.Label(4,row,String.valueOf(respObj1.getMachineHours()),normalFormat1));
					++row;

				}
				row =1;
				while(responseIter2.hasNext()){
					respObj2  = responseIter2.next();

					workSheet.addCell(new jxl.write.Label(6,row,respObj2.getZoneName(),normalFormat1)); 		
					workSheet.addCell(new jxl.write.Label(7,row,String.valueOf(respObj2.getMaxIdleRPMBand()),normalFormat1));
					workSheet.addCell(new jxl.write.Label(8,row,String.valueOf(respObj2.getMaxWorkingRPMBand()),normalFormat1));
					++row;

				}

			}
			else if(tenancyTypeId==2){
				row =1;

				while(responseIter3.hasNext()){
					respObj3  = responseIter3.next();
					HashMap<String, Long> dealerData = respObj3.getDealerData();
					for (String dealerName: dealerData.keySet()) {
						workSheet.addCell(new jxl.write.Label(0,row,dealerName,normalFormat1)); 		
						workSheet.addCell(new jxl.write.Label(1,row,String.valueOf(dealerData.get(dealerName)),normalFormat1));
						++row;
					}


				}
				row =1;
				while(responseIter1.hasNext()){
					respObj1  = responseIter1.next();
					HashMap<String, Double> dealerData =  respObj1.getDealerData();
					for (String dealerName: dealerData.keySet()) {
						workSheet.addCell(new jxl.write.Label(3,row,dealerName,normalFormat1)); 		
						workSheet.addCell(new jxl.write.Label(4,row,String.valueOf(dealerData.get(dealerName)),normalFormat1));
						++row;
					}


				}
				row =1;
				String rpmBandString = null;
				String[] rpmBands = null;
				while(responseIter2.hasNext()){
					respObj2  = responseIter2.next();
					Map<String, String> dealerDataMap =  respObj2.getDealerData();
					for (String dealerName: dealerDataMap.keySet()) {
						workSheet.addCell(new jxl.write.Label(6,row,dealerName,normalFormat1)); 		
						rpmBandString =dealerDataMap.get(dealerName);
						if(rpmBandString!=null){
							rpmBands = rpmBandString.split(",");
							workSheet.addCell(new jxl.write.Label(7,row,rpmBands[0],normalFormat1));
							workSheet.addCell(new jxl.write.Label(8,row,rpmBands[1],normalFormat1));
							++row;
						}


					}


				}

			}


			workbook.write();
			workbook.close();
		}
		catch(Exception e){
			e.printStackTrace();
		}
		return workSheet;
	}
	
	//DF20160711 @Roopa for Updating service detail report via executor service
	
	/*public void setServiceDetailsViaExecutor()
	{
		
		  Logger fLogger = FatalLoggerClass.logger;
		  
		  Logger iLogger = InfoLoggerClass.logger;
		//START NEW LOGIC
		
                int segmentID=this.segementID_Thread;
				Session session = HibernateUtil.getSessionFactory().openSession();
				session.beginTransaction();

				
				try
				{
					
					iLogger.info("setServiceDetailsViaExecutor::"+"Select customer machines from asset");
					Query assetQuery=session.createQuery(" select a.serial_number " + 
				" from AssetEntity a, AssetOwnerSnapshotEntity aos " +
				" where a.segmentId="+segmentID+" and " +
				" a.active_status = 1 and " +
				" a.serial_number = aos.serialNumber and " +
				" aos.accountType='Customer' ");					
					
					
					Query assetQuery=session.createQuery(" select a.serial_number " + 
							" from AssetEntity a, AssetOwnerSnapshotEntity aos " +
							" where a.segmentId=0 and " +
							" a.active_status = 1 and " +
							"a.serial_number = 'HAR3DXSSA01868954' and " +
							" a.serial_number = aos.serialNumber and " +
							" aos.accountType='Customer' ");
					
					Iterator assetItr=assetQuery.list().iterator();
					
					while(assetItr.hasNext()){
						AssetControlUnitEntity acu=(AssetControlUnitEntity)assetItr.next();
						
						String assetID=acu.getSerialNumber();
						iLogger.info("Running segment "+segmentID+" for assetID"+assetID);
						//iLogger.info("assetID::"+assetID);
						
						ServiceDetailsReportEntity reportEntity=null;
						
						if(session==null || ! (session.isOpen() ))
						{
							session = HibernateUtil.getSessionFactory().openSession();
							session.beginTransaction();
						}
						
						
						
						Query query = session.createQuery(" from ServiceDetailsReportEntity where serialNumber='"+assetID+"'");
						Iterator itr = query.list().iterator();
						
						//update ServiceDetailsReportEntity for the given VIN
						if(itr.hasNext()){
							
							reportEntity=(ServiceDetailsReportEntity)itr.next();
							
							//Get the Last service History details of the VIN
							
							Query serviceHistoryQuery = session.createQuery(" select b.serviceName, " +
									" a.serviceDate, " +
									" a.CMH " +
									" from ServiceHistoryEntity a, ServiceScheduleEntity b " +
									" where a.serviceScheduleId = b.serviceScheduleId and " +
									" serviceDate = (select max(serviceDate) from " +
									" ServiceHistoryEntity where serialNumber='"+assetID+"') and serialNumber='"+assetID+"'");
							Iterator serviceHistoryItr = serviceHistoryQuery.list().iterator();
							Object[] result =null;
							while(serviceHistoryItr.hasNext())
							{
								result = (Object[]) serviceHistoryItr.next();
								if(result[0]!=null)
									reportEntity.setLastServiceName(result[0].toString());
								if(result[1]!=null)
									reportEntity.setLastServiceDate((Timestamp)result[1]);
								if(result[2]!=null)
									reportEntity.setLastServiceHours(result[2].toString());
							}
							
							
							List<AssetServiceScheduleImpl> implResponse=new ServiceScheduleNewBO2().getServiceScheduleNew(assetID);
							


							for(int i=0; i<implResponse.size(); i++)
							{
								if(implResponse.get(i).getHoursToNextService()!=null)
								{
									reportEntity.setServiceScheduleName(implResponse.get(i).getScheduleName());
									
									reportEntity.setNextServiceName(implResponse.get(i).getServiceName());
			
									Timestamp nextScheduledDate = Timestamp.valueOf(implResponse.get(i).getScheduledDate());
									reportEntity.setNextServiceDate(nextScheduledDate);
			
									reportEntity.setNextServiceHours(String.valueOf(implResponse.get(i).getEngineHoursSchedule()));
			
									reportEntity.setEventId(implResponse.get(i).getEventId());
									
									
									
								}
							}
							
							
							//Get the Current Engine hours of the machine via AMS DAL Layer
							Query engineHourQuery = session.createQuery(" select b.parameterValue from " +
									" AssetMonitoringDetailEntity b, MonitoringParameters c, AssetMonitoringSnapshotEntity ams where " +
									" ams.transactionNumber = b.transactionNumber and " +
									" b.parameterId = c.parameterId and" +
									" ams.serialNumber ='"+assetID+"' and " +
							        " c.parameterId = (select max(y.parameterId) from MonitoringParameters y where y.parameterName like 'Hour%')");
							Iterator engineHourItr = engineHourQuery.list().iterator();
							while(engineHourItr.hasNext())
							{
								String currentEngineHour = (String)engineHourItr.next();
								reportEntity.setTotalEngineHours(currentEngineHour);
							}
							
							iLogger.debug("Start Select from AssetMonitoringSnapshot");

                           String txnKey="setServiceDetailsViaExecutor";
							List<AmsDAO> snapshotObj=new ArrayList<AmsDAO> ();

							DynamicAMS_DAL amsDaoObj=new DynamicAMS_DAL();

							snapshotObj=amsDaoObj.getAMSData(txnKey, assetID);

							iLogger.debug(txnKey+"::"+"AMS:persistDetailsToDynamicMySql::AMS DAL::getAMSData Size:"+snapshotObj.size());
							
							if(snapshotObj.size()>0){
								
								//parameters format in AMS
								//String currParam= LAT|LONG|Enginestatus|Machinehours|ExternalBatteryVoltage|HCT|LOP|InternalBatteryLow
								
							String parameters=snapshotObj.get(0).getParameters();
							String [] currParamList=parameters.split("\\|", -1);
							
							reportEntity.setTotalEngineHours(currParamList[3]);
							}
							
			
							//Set the last updated date
							reportEntity.setLastUpdated(new Timestamp((new Date()).getTime()));
							
							if(session==null || ! (session.isOpen() ))
							{
								session = HibernateUtil.getSessionFactory().openSession();
								session.beginTransaction();
							}
							
							session.update(reportEntity);
							
							}
						//end updating into ServiceDetailsReportEntity
						
						ServiceDetailsReportEntity newreportEntity=null;
						//insert the new record into ServiceDetailsReportEntity
						if(reportEntity==null){
							
							if(session==null || ! (session.isOpen() ))
							{
								session = HibernateUtil.getSessionFactory().openSession();
								session.beginTransaction();
							}
							
							newreportEntity= new ServiceDetailsReportEntity();
							
							newreportEntity.setSerialNumber(assetID);
							
							
							//Get the Last service History details of the VIN
							
							Query serviceHistoryQuery = session.createQuery(" select b.serviceName, " +
									" a.serviceDate, " +
									" a.CMH " +
									" from ServiceHistoryEntity a, ServiceScheduleEntity b " +
									" where a.serviceScheduleId = b.serviceScheduleId and " +
									" serviceDate = (select max(serviceDate) from " +
									" ServiceHistoryEntity where serialNumber='"+assetID+"') and serialNumber='"+assetID+"'");
							Iterator serviceHistoryItr = serviceHistoryQuery.list().iterator();
							Object[] result =null;
							while(serviceHistoryItr.hasNext())
							{
								result = (Object[]) serviceHistoryItr.next();
								if(result[0]!=null)
									newreportEntity.setLastServiceName(result[0].toString());
								if(result[1]!=null)
									newreportEntity.setLastServiceDate((Timestamp)result[1]);
								if(result[2]!=null)
									newreportEntity.setLastServiceHours(result[2].toString());
							}
							
							
							List<AssetServiceScheduleImpl> implResponse=new ServiceScheduleNewBO2().getServiceSchedule(assetID);
							


							for(int i=0; i<implResponse.size(); i++)
							{
								if(implResponse.get(i).getHoursToNextService()!=null)
								{
									newreportEntity.setServiceScheduleName(implResponse.get(i).getScheduleName());
			
									newreportEntity.setNextServiceName(implResponse.get(i).getServiceName());
			
									Timestamp nextScheduledDate = Timestamp.valueOf(implResponse.get(i).getScheduledDate());
									newreportEntity.setNextServiceDate(nextScheduledDate);
			
									newreportEntity.setNextServiceHours(String.valueOf(implResponse.get(i).getEngineHoursSchedule()));
			
									newreportEntity.setEventId(implResponse.get(i).getEventId());
								}
							}
							
							
							//Get the Current Engine hours of the machine via AMS DAL layer
							Query engineHourQuery = session.createQuery(" select b.parameterValue from " +
									" AssetMonitoringDetailEntity b, MonitoringParameters c, AssetMonitoringSnapshotEntity ams where " +
									" ams.transactionNumber = b.transactionNumber and " +
									" b.parameterId = c.parameterId and" +
									" ams.serialNumber='"+assetID+"' and " +
							        " c.parameterId = (select max(y.parameterId) from MonitoringParameters y where y.parameterName like 'Hour%')");
							Iterator engineHourItr = engineHourQuery.list().iterator();
							while(engineHourItr.hasNext())
							{
								String currentEngineHour = (String)engineHourItr.next();
								newreportEntity.setTotalEngineHours(currentEngineHour);
							}
							
							iLogger.debug("Start Select from AssetMonitoringSnapshot");

	                           String txnKey="setServiceDetailsViaExecutor";
								List<AmsDAO> snapshotObj=new ArrayList<AmsDAO> ();

								DynamicAMS_DAL amsDaoObj=new DynamicAMS_DAL();

								snapshotObj=amsDaoObj.getAMSData(txnKey, assetID);

								iLogger.debug(txnKey+"::"+"AMS:persistDetailsToDynamicMySql::AMS DAL::getAMSData Size:"+snapshotObj.size());
								
								if(snapshotObj.size()>0){
									
									//parameters format in AMS
									//String currParam= LAT|LONG|Enginestatus|Machinehours|ExternalBatteryVoltage|HCT|LOP|InternalBatteryLow
									
								String parameters=snapshotObj.get(0).getParameters();
								String [] currParamList=parameters.split("\\|", -1);
								
								newreportEntity.setTotalEngineHours(currParamList[3]);
								}
			
							//Set the last updated date
							newreportEntity.setLastUpdated(new Timestamp((new Date()).getTime()));
							
							if(session==null || ! (session.isOpen() ))
							{
								session = HibernateUtil.getSessionFactory().openSession();
								session.beginTransaction();
							}
							
							session.save(newreportEntity);	
						
							
						}
						//end inserting new record into ServiceDetailsReportEntity
						
					}
					
				}

				catch(Exception e)
				{ 
					e.printStackTrace();
					fLogger.fatal("Exception :"+e);
					if (session.isOpen()) 
					{
						session.clear();
					}
					if (session.isOpen()) 
					{
						session.close();
					}
				}

				finally
				{
					try
					{
						if (session.getTransaction().isActive()) 
							session.getTransaction().commit();
					}
					
					catch(Exception e)
					{
						fLogger.fatal(e);
					}

					finally
					{
						if (session!=null && session.isOpen()) 
						{
							session.flush();
							session.close();
						}
					}

				}

				
				//END NEW LOGIC
	}
*/

	
/*	public void setServiceDetailsViaExecutor()
	{
		
		  Logger fLogger = FatalLoggerClass.logger;
		  
		  Logger iLogger = InfoLoggerClass.logger;
		//START NEW LOGIC
		
                int segmentID=this.segementID_Thread;
                Session session = HibernateUtil.getSessionFactory().openSession();
				session.beginTransaction();

				
				
				Session session2 = null;
				
				
					session2 = HibernateUtil.getSessionFactory().openSession();
					
					
					
				
				int loopCounter = 1;
				String txnKey="setServiceDetailsViaExecutor";
				
				try
				{
					
					iLogger.info("setServiceDetailsViaExecutor::"+"Select customer machines from asset");
					iLogger.info("1");
					Query assetQuery=session.createQuery(" select a.serial_number " + 
				" from AssetEntity a, AssetOwnerSnapshotEntity aos " +
				" where a.segmentId="+segmentID+" and " +
				" a.active_status = 1 and " +
				" a.serial_number = aos.serialNumber and " +
				" aos.accountType='Customer' ");
					
					
					Query assetQuery=session.createQuery(" select a.serial_number " + 
							" from AssetEntity a, AssetOwnerSnapshotEntity aos " +
							" where a.segmentId=27 and " +
							" a.active_status = 1 and " +
							//"a.serial_number = 'HAR3DXSSP01878649' and " +
							" a.serial_number = aos.serialNumber and " +
							" aos.accountType='Customer' ");
					
					Iterator assetItr=assetQuery.list().iterator();
					Transaction tx = session2.beginTransaction();
					while(assetItr.hasNext()){
						if(!tx.isActive()){
							session2.beginTransaction();
						}
						String lastServiceName = null;
						Timestamp lastServiceDate = null;
						String lastServiceHours = null;
						String nextServiceName = null;
						Timestamp nextServiceDate = null;
						String nextServiceHours = null;
						String machineHours = null;
						String nextScheduleName = null;
						int eventID = 0;
								
						AssetControlUnitEntity acu=(AssetControlUnitEntity)assetItr.next();
						
						String assetID=acu.getSerialNumber();
						iLogger.info(txnKey+" Running segment "+segmentID+" for assetID"+assetID);
						//System.out.println(txnKey+" Running segment "+segmentID+" for assetID"+assetID);
						//iLogger.info("assetID::"+assetID);
						//System.out.println("loopCounter "+loopCounter);
						//ServiceDetailsReportEntity reportEntity=null;
						
						if(session==null || ! (session.isOpen() ))
						{
							session = HibernateUtil.getSessionFactory().openSession();
							session.beginTransaction();
						}
						
						
						
						Query query = session.createQuery(" from ServiceDetailsReportEntity where serialNumber='"+assetID+"'");
						Iterator itr = query.list().iterator();
						
						//update ServiceDetailsReportEntity for the given VIN
						//if(itr.hasNext()){
							
							//reportEntity=(ServiceDetailsReportEntity)itr.next();
							
							//Get the Last service History details of the VIN
							
							Query serviceHistoryQuery = session.createQuery(" select b.serviceName, " +
									" a.serviceDate, " +
									" a.CMH " +
									" from ServiceHistoryEntity a, ServiceScheduleEntity b " +
									" where a.serviceScheduleId = b.serviceScheduleId and " +
									" serviceDate = (select max(serviceDate) from " +
									" ServiceHistoryEntity where serialNumber='"+assetID+"') and serialNumber='"+assetID+"'");
							Iterator serviceHistoryItr = serviceHistoryQuery.list().iterator();
							Object[] result =null;
							while(serviceHistoryItr.hasNext())
							{
								result = (Object[]) serviceHistoryItr.next();
								if(result[0]!=null)
								{
									lastServiceName = result[0].toString();
								}
									//reportEntity.setLastServiceName(result[0].toString());
								if(result[1]!=null){
									lastServiceDate = (Timestamp)result[1];
								}
									//reportEntity.setLastServiceDate((Timestamp)result[1]);
								if(result[2]!=null)
								{
									lastServiceHours = result[2].toString();
								}
									//reportEntity.setLastServiceHours(result[2].toString());
							}
							if(session !=null){
								session.close();
							}
							
							List<AssetServiceScheduleImpl> implResponse=new ServiceScheduleNewBO2().getServiceScheduleNew(assetID);
							iLogger.info(txnKey+" segment "+segmentID+" for assetID"+assetID+" getServiceScheduleNew size :"+implResponse.size());
							//System.out.println(txnKey+" segment "+segmentID+" for assetID"+assetID+" getServiceScheduleNew size :"+implResponse.size());
							

							for(int i=0; i<implResponse.size(); i++)
							{
								if(implResponse.get(i).getHoursToNextService()!=null)
								{
									
									nextScheduleName = implResponse.get(i).getScheduleName();
									
									nextServiceName = implResponse.get(i).getServiceName();
									
									nextServiceDate = Timestamp.valueOf(implResponse.get(i).getScheduledDate());
									
									nextServiceHours = String.valueOf(implResponse.get(i).getEngineHoursSchedule());
									
									eventID = implResponse.get(i).getEventId();
									
									reportEntity.setServiceScheduleName(implResponse.get(i).getScheduleName());
									
									reportEntity.setNextServiceName(implResponse.get(i).getServiceName());
			
									Timestamp nextScheduledDate = Timestamp.valueOf(implResponse.get(i).getScheduledDate());
									reportEntity.setNextServiceDate(nextScheduledDate);
			
									reportEntity.setNextServiceHours(String.valueOf(implResponse.get(i).getEngineHoursSchedule()));
			
									reportEntity.setEventId(implResponse.get(i).getEventId());
									
									
									
								}
							}
							
							
							//Get the Current Engine hours of the machine via AMS DAL Layer
							Query engineHourQuery = session.createQuery(" select b.parameterValue from " +
									" AssetMonitoringDetailEntity b, MonitoringParameters c, AssetMonitoringSnapshotEntity ams where " +
									" ams.transactionNumber = b.transactionNumber and " +
									" b.parameterId = c.parameterId and" +
									" ams.serialNumber ='"+assetID+"' and " +
							        " c.parameterId = (select max(y.parameterId) from MonitoringParameters y where y.parameterName like 'Hour%')");
							Iterator engineHourItr = engineHourQuery.list().iterator();
							while(engineHourItr.hasNext())
							{
								String currentEngineHour = (String)engineHourItr.next();
								reportEntity.setTotalEngineHours(currentEngineHour);
							}
							
							iLogger.debug("Start Select from AssetMonitoringSnapshot");

                          // String txnKey="setServiceDetailsViaExecutor";
							List<AmsDAO> snapshotObj=new ArrayList<AmsDAO> ();

							DynamicAMS_DAL amsDaoObj=new DynamicAMS_DAL();

							snapshotObj=amsDaoObj.getAMSData(txnKey, assetID);

							//iLogger.debug(txnKey+"::"+"AMS:persistDetailsToDynamicMySql::AMS DAL::getAMSData Size:"+snapshotObj.size());
							
							if(snapshotObj.size()>0){
								
								//parameters format in AMS
								//String currParam= LAT|LONG|Enginestatus|Machinehours|ExternalBatteryVoltage|HCT|LOP|InternalBatteryLow
								
							String parameters=snapshotObj.get(0).getParameters();
							String [] currParamList=parameters.split("\\|", -1);
							
							machineHours = currParamList[3];
							//reportEntity.setTotalEngineHours(machineHours);
							//}
							
							//String faultInsertStmt = "insert into fault_statements(serial_number,time_key,fault_details) values(?,?,?)";
							
							
							if (session2 == null || !session2.isOpen()){
								if(session2 == null)
									iLogger.debug("Session2 - null ");
								else
									iLogger.debug("Session2 - DirtySession ");
								session2 = HibernateUtil.getSessionFactory().openSession();
								
								
								session2.beginTransaction();
							}
							
							
							if(session==null || ! (session.isOpen() ))
							{
								session = HibernateUtil.getSessionFactory().openSession();
								session.beginTransaction();
							}
							Query query = session2.createQuery(" from ServiceDetailsReportEntity where serialNumber='"+assetID+"'");
							Iterator itr = query.list().iterator();
							if(session !=null){
								session.close();
							}
							boolean update = false;
							if(itr.hasNext())
							{
								
								//update = true;
								ServiceDetailsReportEntity reportEntity=(ServiceDetailsReportEntity)itr.next();
								reportEntity.setLastServiceName(lastServiceName);
								
								reportEntity.setLastServiceDate(lastServiceDate);
						
								reportEntity.setLastServiceHours(lastServiceHours);
								
								reportEntity.setServiceScheduleName(nextScheduleName);
								
								reportEntity.setNextServiceName(nextServiceName);
		
								//Timestamp nextScheduledDate = Timestamp.valueOf(implResponse.get(i).getScheduledDate());
								reportEntity.setNextServiceDate(nextServiceDate);
		
								reportEntity.setNextServiceHours(nextServiceHours);
		
								reportEntity.setEventId(eventID);
								reportEntity.setTotalEngineHours(machineHours);
							
							//Set the last updated date
								reportEntity.setLastUpdated(new Timestamp((new Date()).getTime()));
								iLogger.info(txnKey+" update segment "+segmentID+" for assetID"+assetID);
								
								if (session2 ==null ||  session2.isDirty()){
									session2 = HibernateUtil.getSessionFactory().openSession();
									iLogger.debug("Session2 - DirtySession2 for assetID"+assetID);
									session2.beginTransaction();
								}
								if(! (session2.isOpen() ))
								{
									session2 = HibernateUtil.getSessionFactory().getCurrentSession();
									session2.beginTransaction();
								}
								session2.update(reportEntity);
							//	session2.flush();
							}
							else{
								
								ServiceDetailsReportEntity reportEntity = new ServiceDetailsReportEntity();
								reportEntity.setSerialNumber(assetID);
								reportEntity.setLastServiceName(lastServiceName);
								
								reportEntity.setLastServiceDate(lastServiceDate);
						
								reportEntity.setLastServiceHours(lastServiceHours);
								
								reportEntity.setServiceScheduleName(nextScheduleName);
								
								reportEntity.setNextServiceName(nextServiceName);
		
								//Timestamp nextScheduledDate = Timestamp.valueOf(implResponse.get(i).getScheduledDate());
								reportEntity.setNextServiceDate(nextServiceDate);
		
								reportEntity.setNextServiceHours(nextServiceHours);
		
								reportEntity.setEventId(eventID);
								reportEntity.setTotalEngineHours(machineHours);
							
							//Set the last updated date
								reportEntity.setLastUpdated(new Timestamp((new Date()).getTime()));
								iLogger.info(txnKey+" insert segment "+segmentID+" for assetID"+assetID);
								if (session2 ==null||  session2.isDirty()){
									session2 = HibernateUtil.getSessionFactory().openSession();
									iLogger.debug("Session2 - DirtySession3");
									session2.beginTransaction();
								}
								if( ! (session2.isOpen() ))
								{
									session2 = HibernateUtil.getSessionFactory().openSession();
									session2.beginTransaction();
								}
								session2.save(reportEntity);	
								
							//	session2.flush();
							}
							
							
								
							
							if(session==null || ! (session.isOpen() ))
							{
								session = HibernateUtil.getSessionFactory().openSession();
								session.beginTransaction();
							}
							
							if(update){
								iLogger.info(txnKey+" update segment "+segmentID+" for assetID"+assetID);
								session.update(reportEntity);
							}
							else{
								iLogger.info(txnKey+" insert segment "+segmentID+" for assetID"+assetID);
								session.save(reportEntity);	
							}
								
							
							if(((loopCounter++)%100 == 0)){
								if (session2 != null && session2.isOpen() && session2.getTransaction().isActive()) {
									iLogger.info(txnKey+" commiting for segment "+segmentID+" at assetID"+assetID);
									//System.out.println(txnKey+" commiting for segment "+segmentID+" at assetID"+assetID);
									session2.flush();
									//session2.clear();
									if(!tx.wasCommitted())
										tx.commit();
									//session2.close();
							}
								//break;
									//session.getTransaction().commit();
								
							}
							
							
							
						//end updating into ServiceDetailsReportEntity
						
						ServiceDetailsReportEntity newreportEntity=null;
						//insert the new record into ServiceDetailsReportEntity
						if(reportEntity==null){
							
							if(session==null || ! (session.isOpen() ))
							{
								session = HibernateUtil.getSessionFactory().openSession();
								session.beginTransaction();
							}
							
							newreportEntity= new ServiceDetailsReportEntity();
							
							newreportEntity.setSerialNumber(assetID);
							
							
							//Get the Last service History details of the VIN
							
							Query serviceHistoryQuery = session.createQuery(" select b.serviceName, " +
									" a.serviceDate, " +
									" a.CMH " +
									" from ServiceHistoryEntity a, ServiceScheduleEntity b " +
									" where a.serviceScheduleId = b.serviceScheduleId and " +
									" serviceDate = (select max(serviceDate) from " +
									" ServiceHistoryEntity where serialNumber='"+assetID+"') and serialNumber='"+assetID+"'");
							Iterator serviceHistoryItr = serviceHistoryQuery.list().iterator();
							Object[] result =null;
							while(serviceHistoryItr.hasNext())
							{
								result = (Object[]) serviceHistoryItr.next();
								if(result[0]!=null)
									newreportEntity.setLastServiceName(result[0].toString());
								if(result[1]!=null)
									newreportEntity.setLastServiceDate((Timestamp)result[1]);
								if(result[2]!=null)
									newreportEntity.setLastServiceHours(result[2].toString());
							}
							
							
							List<AssetServiceScheduleImpl> implResponse=new ServiceScheduleNewBO2().getServiceSchedule(assetID);
							


							for(int i=0; i<implResponse.size(); i++)
							{
								if(implResponse.get(i).getHoursToNextService()!=null)
								{
									newreportEntity.setServiceScheduleName(implResponse.get(i).getScheduleName());
			
									newreportEntity.setNextServiceName(implResponse.get(i).getServiceName());
			
									Timestamp nextScheduledDate = Timestamp.valueOf(implResponse.get(i).getScheduledDate());
									newreportEntity.setNextServiceDate(nextScheduledDate);
			
									newreportEntity.setNextServiceHours(String.valueOf(implResponse.get(i).getEngineHoursSchedule()));
			
									newreportEntity.setEventId(implResponse.get(i).getEventId());
								}
							}
							
							
							//Get the Current Engine hours of the machine via AMS DAL layer
							Query engineHourQuery = session.createQuery(" select b.parameterValue from " +
									" AssetMonitoringDetailEntity b, MonitoringParameters c, AssetMonitoringSnapshotEntity ams where " +
									" ams.transactionNumber = b.transactionNumber and " +
									" b.parameterId = c.parameterId and" +
									" ams.serialNumber='"+assetID+"' and " +
							        " c.parameterId = (select max(y.parameterId) from MonitoringParameters y where y.parameterName like 'Hour%')");
							Iterator engineHourItr = engineHourQuery.list().iterator();
							while(engineHourItr.hasNext())
							{
								String currentEngineHour = (String)engineHourItr.next();
								newreportEntity.setTotalEngineHours(currentEngineHour);
							}
							
							iLogger.debug("Start Select from AssetMonitoringSnapshot");

	                           String txnKey="setServiceDetailsViaExecutor";
								List<AmsDAO> snapshotObj=new ArrayList<AmsDAO> ();

								DynamicAMS_DAL amsDaoObj=new DynamicAMS_DAL();

								snapshotObj=amsDaoObj.getAMSData(txnKey, assetID);

								iLogger.debug(txnKey+"::"+"AMS:persistDetailsToDynamicMySql::AMS DAL::getAMSData Size:"+snapshotObj.size());
								
								if(snapshotObj.size()>0){
									
									//parameters format in AMS
									//String currParam= LAT|LONG|Enginestatus|Machinehours|ExternalBatteryVoltage|HCT|LOP|InternalBatteryLow
									
								String parameters=snapshotObj.get(0).getParameters();
								String [] currParamList=parameters.split("\\|", -1);
								
								newreportEntity.setTotalEngineHours(currParamList[3]);
								}
			
							//Set the last updated date
							newreportEntity.setLastUpdated(new Timestamp((new Date()).getTime()));
							
							if(session==null || ! (session.isOpen() ))
							{
								session = HibernateUtil.getSessionFactory().openSession();
								session.beginTransaction();
							}
							
							session.save(newreportEntity);	
						
							
						}
						//end inserting new record into ServiceDetailsReportEntity
						
					}
					if (session2 != null && session2.isOpen() && session2.getTransaction().isActive()) {
						iLogger.info(txnKey+" outside while loop for segment "+segmentID+" at assetID");
						//System.out.println(txnKey+" commiting for segment "+segmentID+" at assetID"+assetID);
						session2.flush();
					//	session2.clear();
						if(!tx.wasCommitted())
							tx.commit();
				}
				}

				
				}catch(Exception e)
				{ 
					e.printStackTrace();
					fLogger.fatal(txnKey+" exception in segment "+segmentID+" caused by "+e.getMessage());
					fLogger.fatal("Exception :"+e);
					if (session != null && session.isOpen()) 
					{
						session.clear();
					}
					if (session != null && session.isOpen()) 
					{
						session.close();
					}
					
					if (session2 != null && session2.isOpen()) 
					{
						session2.clear();
					}
					if (session2 != null && session2.isOpen()) 
					{
						session2.close();
					}
				}

				finally
				{
					try
					{
						if (session2 != null && session2.isOpen() && session2.getTransaction().isActive()) {
							//System.out.println("inside commit");
							session2.getTransaction().commit();
						}
					}
					
					catch(Exception e)
					{
						fLogger.fatal(e);
					}

					finally
					{
						if (session!=null && session.isOpen()) 
						{
							session.flush();
							session.close();
						}
						if (session2!=null && session2.isOpen()) 
						{
							//session.flush();
							session2.close();
						}

					}
					if (session!=null && session.isOpen()) 
					{
						//session.flush();
						session.close();
					}
					if (session2!=null && session2.isOpen()) 
					{
						//session.flush();
						session2.close();
					}

				}

				
				//END NEW LOGIC
	}*/

	
	public void setServiceDetailsViaExecutor()
	{
		
		  Logger fLogger = FatalLoggerClass.logger;
		  
		  Logger iLogger = InfoLoggerClass.logger;
		  iLogger.info("***** ReportDeatils ::: setServiceDetailsViaExecutor *********** :: START");
		  Connection prodConnection = null;
			Statement statement = null;
			ResultSet rs = null;
			PreparedStatement ps = null;
			PreparedStatement psUpdate = null;
		//START NEW LOGIC
		
              int segmentID=this.segementID_Thread;
            //DF20191021 - Rajani Nagaraju - Extended Warranty Changes - START
              String serialNumber = this.serialNumber;
            //DF20191021 - Rajani Nagaraju - Extended Warranty Changes - END
              Session session = HibernateUtil.getSessionFactory().openSession();
				session.beginTransaction();

				
				
				/*Session session2 = null;
				
				
					session2 = HibernateUtil.getSessionFactory().openSession();*/
					
					
				String assetID =null;
				
				int loopCounter = 1;
				String txnKey="setServiceDetailsViaExecutor";
				DateFormat dateStr = new SimpleDateFormat("yyyy-MM-dd hh:MM:ss");
				 Calendar cal = Calendar.getInstance();
				try
				{
					
						ConnectMySQL connMySql = new ConnectMySQL();
						prodConnection = connMySql.getConnection();
						
						statement = prodConnection.createStatement();
						prodConnection.setAutoCommit(false);
						
					iLogger.info("setServiceDetailsViaExecutor::"+"Select customer machines from asset");
					
					
					Query assetQuery=session.createQuery(" select a.serial_number " + 
				" from AssetEntity a, AssetOwnerSnapshotEntity aos " +
				" where a.segmentId="+segmentID+" and " +
				" a.active_status = 1 and " +
				" a.serial_number = aos.serialNumber and " +
				" aos.accountType='Customer' ");
					
					iLogger.info("***** ReportDeatils ::: assetQuery ***********" + assetQuery);
					
					//DF20191021 - Rajani Nagaraju - Extended Warranty Changes - START
					if(serialNumber != null)
					{
						assetQuery=session.createQuery(" select a.serial_number " + 
								" from AssetEntity a, AssetOwnerSnapshotEntity aos " +
								" where a.active_status = 1 and " +
								" a.serial_number = aos.serialNumber and " +
								" aos.accountType='Customer' and a.serial_number='"+serialNumber+"' ");
						
						iLogger.info("***** ReportDeatils ::: assetQuery :: !serialNumber null ***********" + assetQuery);
					}
					//DF20191021 - Rajani Nagaraju - Extended Warranty Changes - END
					
					String insertStatement = "insert into service_details_report values(?,?,?,?,?,?,?,?,?,?,?,?,?)";
					/*Shajesh : 20210727 : Setting value for   last service schedule ID and Next_Service_Schedule_ID for service_details_report*/
					String updateStatement = "UPDATE service_details_report "+   //Serial_Number` = {Serial_Number: },
					"SET "+						
					"Service_Schedule_Name = ?,"+
					"Last_Service_Name = ?,"+
					"Last_Service_Date =?,"+
					"Last_Service_Hours = ?,"+
					"Next_Service_Name = ?,"+
					"Next_Service_Date = ?,"+
					"Next_Service_Hours = ?,"+
					"Last_Updated = ?,"+
					"Event_ID = ?,"+
					"Total_Engine_Hours = ?,"+
					"Last_Service_Schedule_ID = ?,"+
					"Next_Service_Schedule_ID = ? "+
					"WHERE Serial_Number = ?";
					psUpdate = prodConnection.prepareStatement(updateStatement);
					ps = prodConnection.prepareStatement(insertStatement);
					
					iLogger.info("**********  insertStatement   **************** "+insertStatement);
					iLogger.info("**********  updateStatement   **************** "+updateStatement);
					/*Query assetQuery=session.createQuery(" select a.serial_number " + 
							" from AssetEntity a, AssetOwnerSnapshotEntity aos " +
							" where a.segmentId=27 and " +
							" a.active_status = 1 and " +
							//"a.serial_number = 'HAR3DXSSP01878649' and " +
							" a.serial_number = aos.serialNumber and " +
							" aos.accountType='Customer' ");*/
					int update_Count = 1;
					int insert_Count = 1;
					Iterator assetItr=assetQuery.list().iterator();
					//Transaction tx = session2.beginTransaction();
					while(assetItr.hasNext()){
						/*if(!tx.isActive()){
							session2.beginTransaction();
						}*/
						String lastServiceName = null;
						Timestamp lastServiceDate = null;
						String lastServiceHours = null;
						String nextServiceName = null;
						Timestamp nextServiceDate = null;
						String nextServiceHours = null;
						String machineHours = null;
						String nextScheduleName = null;
						String last_Service_Schedule_ID = null;
						String next_Service_Schedule_ID = null;
						int eventID = 0;
								
						AssetControlUnitEntity acu=(AssetControlUnitEntity)assetItr.next();
						
						assetID=acu.getSerialNumber();
						iLogger.info(txnKey+" Running segment "+segmentID+" for assetID"+assetID);
						//System.out.println(txnKey+" Running segment "+segmentID+" for assetID"+assetID+"loopCounter "+loopCounter);
						//iLogger.info("assetID::"+assetID);
						//System.out.println("loopCounter "+loopCounter);
						//ServiceDetailsReportEntity reportEntity=null;
						
						if(session==null || ! (session.isOpen() ))
						{
							session = HibernateUtil.getSessionFactory().openSession();
							session.beginTransaction();
						}
						
						
						
						/*Query query = session.createQuery(" from ServiceDetailsReportEntity where serialNumber='"+assetID+"'");
						Iterator itr = query.list().iterator();*/
						
						//update ServiceDetailsReportEntity for the given VIN
						//if(itr.hasNext()){
							
							//reportEntity=(ServiceDetailsReportEntity)itr.next();
							
							//Get the Last service History details of the VIN
						/*Shajesh : 20210727 : selecting  last service schedule id for service_details_report*/
							Query serviceHistoryQuery = session.createQuery(" select b.serviceName, " +
									" a.serviceDate, " +
									" a.CMH ," +
									" b.serviceScheduleId " + 
									" from ServiceHistoryEntity a, ServiceScheduleEntity b " +
									" where a.serviceScheduleId = b.serviceScheduleId and " +
									" serviceDate = (select max(serviceDate) from " +
									" ServiceHistoryEntity where serialNumber='"+assetID+"') and serialNumber='"+assetID+"'");
							
							iLogger.info("**********  ReportDeatils ::: serviceHistoryQuery   **************** "+serviceHistoryQuery);
							Iterator serviceHistoryItr = serviceHistoryQuery.list().iterator();
							Object[] result =null;
							while(serviceHistoryItr.hasNext())
							{
								result = (Object[]) serviceHistoryItr.next();
								if(result[0]!=null)
								{
									lastServiceName = result[0].toString();
								}
									//reportEntity.setLastServiceName(result[0].toString());
								if(result[1]!=null){
									lastServiceDate = (Timestamp)result[1];
								}
									//reportEntity.setLastServiceDate((Timestamp)result[1]);
								if(result[2]!=null)
								{
									lastServiceHours = result[2].toString();
								}
									//reportEntity.setLastServiceHours(result[2].toString());
								
								/*Shajesh : 20210727 : Adding last service schedule id for service_details_report*/
								if(result[3]!=null){
									last_Service_Schedule_ID = result[3].toString();
								}
								iLogger.info("**********  ReportDeatils ::: last_Service_Schedule_ID   **************** "+last_Service_Schedule_ID);
							}
							if(session !=null){
								session.close();
							}
							iLogger.info("**********  ReportDeatils ::: Before ServiceScheduleNewBO2 calling  ****************  ");
							List<AssetServiceScheduleImpl> implResponse=new ServiceScheduleNewBO2().getServiceScheduleNew(assetID);
							iLogger.info(txnKey+" segment "+segmentID+" for assetID"+assetID+" getServiceScheduleNew size :"+implResponse.size());
							//System.out.println(txnKey+" segment "+segmentID+" for assetID"+assetID+" getServiceScheduleNew size :"+implResponse.size());
							iLogger.info("**********  ReportDeatils ::: After ServiceScheduleNewBO2 call  ****************  ");

							for(int i=0; i<implResponse.size(); i++)
							{
								if(implResponse.get(i).getHoursToNextService()!=null)
								{
									
									nextScheduleName = implResponse.get(i).getScheduleName();
									
									nextServiceName = implResponse.get(i).getServiceName();
									
									/*Shajesh : 20210727 : getting  last service schedule id for service_details_report*/
									
									next_Service_Schedule_ID =  String.valueOf(implResponse.get(i).getServiceScheduleId());
									
									iLogger.info("**********  ReportDeatils ::: After ServiceScheduleNewBO2 call ::: next_Service_Schedule_ID  ****************  " + next_Service_Schedule_ID);
									
									nextServiceDate = Timestamp.valueOf(implResponse.get(i).getScheduledDate());
									
									nextServiceHours = String.valueOf(implResponse.get(i).getEngineHoursSchedule());
									
									eventID = implResponse.get(i).getEventId();
									
									/*reportEntity.setServiceScheduleName(implResponse.get(i).getScheduleName());
									
									reportEntity.setNextServiceName(implResponse.get(i).getServiceName());
			
									Timestamp nextScheduledDate = Timestamp.valueOf(implResponse.get(i).getScheduledDate());
									reportEntity.setNextServiceDate(nextScheduledDate);
			
									reportEntity.setNextServiceHours(String.valueOf(implResponse.get(i).getEngineHoursSchedule()));
			
									reportEntity.setEventId(implResponse.get(i).getEventId());*/
									
									
									
								}
							}
							
							
							
							
//							iLogger.debug("Start Select from AssetMonitoringSnapshot");

                       
							boolean update = false;String currentMachineHours = null;
							rs = statement.executeQuery("select * from service_details_report where Serial_Number = '"+assetID+"'");
							if(rs.next()){
								iLogger.info(" **** setting update value as true*******");
								update = true;
								//System.out.println("inside segemnt "+segmentID+" select * from service_details_report where Serial_Number = '"+assetID+"'");
							}
//							Keerthi : 2017.02.09 : populating currentMachineHours with current machine hours of VIN
							//String query = "select substring_index(substring_index(parameters,'|',4),'|',-1) as CMH from asset_monitoring_snapshot_new where Serial_Number = '"+assetID+"'";							
							
							//DF20170621 @Roopa Taking cmh from the latest ams table(json column).
							String query = "select TRIM(BOTH '\"' FROM TxnData -> '$.CMH') as CMH from asset_monitoring_snapshot where Serial_Number = '"+assetID+"'";							
							
							rs = statement.executeQuery(query);
							while(rs.next()){
								currentMachineHours = rs.getString("CMH");
							}
							iLogger.info(txnKey+":"+assetID+": CMH query :"+query+"-- CMH:"+currentMachineHours);
							//String insertStatement = "insert into service_details_report values(?,?,?,?,?,?,?,?,?,?)";
							//ps = prodConnection.prepareStatement(insertStatement);
							
							
							if(update){
								//System.out.println("segment "+segmentID+" update_Count:"+update_Count++);
								//psUpdate = prodConnection.prepareStatement(updateStatement);
								
								System.out.println("************* if(update)*********************");
								psUpdate.setString(13,assetID);
								psUpdate.setString(1,nextScheduleName );
								psUpdate.setString(2, lastServiceName);
								psUpdate.setTimestamp(3, lastServiceDate);
								psUpdate.setString(4, lastServiceHours);
								psUpdate.setString(5, nextServiceName);
								
								psUpdate.setTimestamp(6, nextServiceDate);
								psUpdate.setString(7, nextServiceHours);
								//ps.setString(8, "2018.8");
								cal = Calendar.getInstance();
								psUpdate.setTimestamp(8,  new Timestamp(cal.getTimeInMillis()));
								psUpdate.setInt(9, eventID);
								psUpdate.setString(10, currentMachineHours);								
								/*Shajesh : 20210727 : Updating last service schedule id and next_Service_Schedule_ID  for service_details_report*/
								iLogger.info("CHECK********last_Service_Schedule_ID******************   " + last_Service_Schedule_ID);
								if(last_Service_Schedule_ID!=null){
								psUpdate.setInt(11, Integer.parseInt(last_Service_Schedule_ID));
								}else{
									psUpdate.setInt(11, 0);	
								}
								iLogger.info("CHECK********next_Service_Schedule_ID******************   " + next_Service_Schedule_ID);
								if(next_Service_Schedule_ID!=null){
								psUpdate.setInt(12, Integer.parseInt(next_Service_Schedule_ID));
								}
								else{
									psUpdate.setInt(12, 0);
								}
								
								//psUpdate.setString(10, currentMachineHours);
								
								psUpdate.addBatch();
							}
							else
							{
								System.out.println("************* else(update)*********************");
								//System.out.println("insert_Count"+insert_Count++);
								ps.setString(1,assetID);
								ps.setString(2, nextScheduleName);
								ps.setString(3, lastServiceName);
								ps.setTimestamp(4, lastServiceDate);
								ps.setString(5, lastServiceHours);
								ps.setString(6, nextServiceName);
								
								ps.setTimestamp(7, nextServiceDate);
								ps.setString(8, nextServiceHours);
								//ps.setString(9, "2018.8");
								cal = Calendar.getInstance();
								ps.setTimestamp(9,  new Timestamp(cal.getTimeInMillis()));
								ps.setInt(10, eventID);
								ps.setString(11, currentMachineHours);
								/*Shajesh : 20210727 : Updating last service schedule id and next_Service_Schedule_ID  for service_details_report*/
							    System.out.println("last_Service_Schedule_ID"+last_Service_Schedule_ID);
								if(last_Service_Schedule_ID!=null){
									ps.setInt(12, Integer.parseInt(last_Service_Schedule_ID));
								}else{
									ps.setInt(12, 0);
								}
								
								System.out.println("next_Service_Schedule_ID"+next_Service_Schedule_ID);
								if(next_Service_Schedule_ID!=null){
									ps.setInt(13, Integer.parseInt(next_Service_Schedule_ID));
								}
								else{
									ps.setInt(13, 0);
								}
								ps.addBatch();
							}
							
							
							if(((loopCounter++)%200 == 0)){
								
								
							try{

								//System.out.println(timeKey+"roww:"+row);
								//long iteratorEnd = System.currentTimeMillis();
								
								if(update){
									long preparedStmtStart = System.currentTimeMillis();
									iLogger.info("inside executing batch updations");
									
									//System.out.println("inside executing batch updations");
									int[] updateCount = psUpdate.executeBatch();
								//	System.out.println("updated count for segment "+segmentID+" are :"+updateCount.length);
									iLogger.info("updated count for segment "+segmentID+" are :"+updateCount.length);
									System.out.println("************* psUpdate ::: insertCount*********************" + updateCount);
									psUpdate.clearBatch();
									long preparedStmtEnd = System.currentTimeMillis();
									iLogger.info(txnKey+" executing batch updations for 100 records in "+(preparedStmtEnd-preparedStmtStart));
								}
								long preparedStmtStart = System.currentTimeMillis();
								//System.out.println("inside executing batch insertions");
								int[] insertCount = ps.executeBatch();
								System.out.println("************* ps ::: insertCount*********************" + insertCount);
								//System.out.println("insert count for segment "+segmentID+" are :"+insertCount.length);
								iLogger.info("insert count for segment "+segmentID+" are :"+insertCount.length);
								/*if(db2Connection.isClosed())
									db2Connection = new ConnectMySQL().getProdDb2Connection();
								db2Connection.commit();*/
								ps.clearBatch();
								prodConnection.commit();
								long preparedStmtEnd = System.currentTimeMillis();
								iLogger.info(txnKey+" executing batch insertions for 100 records in "+(preparedStmtEnd-preparedStmtStart));
								}catch(BatchUpdateException bue){
									bue.printStackTrace();
									iLogger.info(txnKey+" exception in batch execution "+bue.getMessage());
								}
							
								//break;
								}
							
				
							}
					if(ps!=null || psUpdate!=null){
						if(ps!=null){
							int[] insertCount = ps.executeBatch();
							//System.out.println("insert count for segment "+segmentID+" are :"+insertCount.length);
							
							ps.clearBatch();
							
						}
						if(psUpdate!=null){
							int[] insertCount = psUpdate.executeBatch();
							//System.out.println("insert count for segment "+segmentID+" are :"+insertCount.length);
							
							psUpdate.clearBatch();
							//prodConnection.commit();
						}
						prodConnection.commit();
						}
					
				}
				catch (SQLException e) {

					e.printStackTrace();
					fLogger.fatal(txnKey+":"+assetID+":SQL Exception in fetching data from mysql::"+e.getMessage());
				} 
				catch(Exception e)
				{ 
					e.printStackTrace();
					fLogger.fatal(txnKey+" exception in segment "+segmentID+" caused by "+e.getMessage());
					fLogger.fatal("Exception :"+e);
					if (session != null && session.isOpen()) 
					{
						session.clear();
					}
					if (session != null && session.isOpen()) 
					{
						session.close();
					}
					
					
				}

				finally
				{
					
					if (session!=null && session.isOpen()) 
					{
						//session.flush();
						session.close();
					}
					if(rs!=null)
						try {
							rs.close();
						} catch (SQLException e1) {
							e1.printStackTrace();
						}

					if(statement!=null)
						try {
							statement.close();
						} catch (SQLException e1) {
							// TODO Auto-generated catch block
							e1.printStackTrace();
						}

					if (prodConnection != null) {
						try {
							prodConnection.close();
						} catch (SQLException e) {
							e.printStackTrace();
						}
					}

				}


	
				
				//END NEW LOGIC
	}
	
	
	
	//********************************************* Set the Service Details for all VINs *********************************************
	/** DefectId: 1400 - Rajani Nagaraju - 20131003 - To improve the Performance of Service- Machine hours  
	 * DefectID: DF20131230 - Rajani Nagaraju - To update the data into asset event based on Service Date to determine the service alert
	 * This method sets the service details of all VINs for which the service schedule is defined
	 * @return Returns the processing status String
	 */
	
	//DF20160711 @Roopa for Updating service detail report via executor service
	public String setServiceDetails()
	{
		
		 Logger iLogger = InfoLoggerClass.logger;

	      Logger fLogger = FatalLoggerClass.logger;

	      ExecutorService executors = null;

	      Future<String> taskResult = null;

	      CompletionService<String> taskCompletionService = null;

	    

	      int maxNoOfThreads = 0;

	      try {

	            Callable<String> callable = null;
	            Session session = HibernateUtil.getSessionFactory().openSession();
	            
	            try{

		     
	            //STEP 2 : getting max segmentID from asset table ,NO. of Threads = No. of Segments

	            Query maxSegmentQuery = session.createQuery("select max(segmentId) from AssetEntity"); 

	            Iterator itr = maxSegmentQuery.list().iterator();

	            if(itr.hasNext()){

	                maxNoOfThreads = (Integer) itr.next();
	                iLogger.info("setServiceDetails::maxNoOfThreads ::"+maxNoOfThreads);
               }
	            
	            }
	            catch(Exception e){
	            	e.printStackTrace();
	            	 return "FAILURE";
	            }
	            finally{
	            	
	            	if (session!=null && session.isOpen()) 
					{
					session.close();
					}
	            }

	            if(maxNoOfThreads!=0)

	            {

	                  executors = Executors.newFixedThreadPool(maxNoOfThreads);

	                  taskCompletionService = new ExecutorCompletionService<String>(executors);

	            }


	            int segementIDThread = 0;

	          
	            while(segementIDThread <= maxNoOfThreads ){

	                   callable = new ReportDetailsBO(segementIDThread);
	                		   
	                		   //setServiceDetailsViaExecutor(segementIDThread);

	                    taskCompletionService.submit(callable);

	                     segementIDThread++;
	                   
	                 }
	            
              for(int i=1;i<=maxNoOfThreads;i++){

	                  taskResult = taskCompletionService.take();

	                  if(taskResult.get() != null){

	                	  iLogger.info("setServiceDetails::"+"Thread "+i+" has succefully completed and returned "+taskResult.get());

	                  }

	            }

	            executors.shutdown();

	            iLogger.info("setServiceDetails::Exiting from the multithread:");

	            executors.awaitTermination(Long.MAX_VALUE, TimeUnit.MILLISECONDS);

	           

	      }

	     

	      catch(Exception e){

	            e.printStackTrace();
	            return "FAILURE";

	      }

	     
   return "SUCCESS";
		
		
		//START OLD LOGIC
		/*
		String status = "SUCCESS";
		Logger fLogger = FatalLoggerClass.logger;
		
		Session session = HibernateUtil.getSessionFactory().getCurrentSession();
		session.beginTransaction();

		try
		{
			SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");

			EventDetailsBO eventDetails = new EventDetailsBO();

			//STEP1: Update the service details for the VINs that is already present in reporting table 
			Query query = session.createQuery(" from ServiceDetailsReportEntity ");
			Iterator itr = query.list().iterator();
			//DF20150405 - Rajani Nagaraju - Batch update of the records which would otherwise expire the session
			int rowUpdateCounter=0;
			
			while(itr.hasNext())
			{
				rowUpdateCounter++;
				
				try
				{
					ServiceDetailsReportEntity reportEntity = (ServiceDetailsReportEntity) itr.next();
	
					String serialNumber = reportEntity.getSerialNumber();
	
					//Get the Last service History details of the VIN
					ServiceHistoryEntity serviceHistoryObj = null;
					Query serviceHistoryQuery = session.createQuery(" select b.serviceName, " +
							" a.serviceDate " +
							" from ServiceHistoryEntity a, ServiceScheduleEntity b " +
							" where a.dbmsPartCode = b.dbmsPartCode and " +
							" serviceDate = (select max(serviceDate) from " +
							" ServiceHistoryEntity where serialNumber='"+serialNumber+"') and serialNumber='"+serialNumber+"'");
					Iterator serviceHistoryItr = serviceHistoryQuery.list().iterator();
					Object[] result =null;
					while(serviceHistoryItr.hasNext())
					{
						result = (Object[]) serviceHistoryItr.next();
						if(result[0]!=null)
							reportEntity.setLastServiceName(result[0].toString());
						if(result[1]!=null)
							reportEntity.setLastServiceDate((Timestamp)result[1]);
					}

					if(result!=null)
					{
						String servicedDate = sdf.format((Timestamp)result[1]);
						//Get the Last_Service_hour - Engine hour of the machine when the machine got serviced
						Query amdQuery = session.createQuery(" select b.parameterValue from AssetMonitoringHeaderEntity a, AssetMonitoringDetailEntity b," +
								" MonitoringParameters q " +
								" where a.transactionNumber = b.transactionNumber " +
								" and b.parameterId = q.parameterId " +
								" and a.serialNumber='"+serialNumber+"'" +
								" and a.transactionTime = ( select max(c.transactionTime) from AssetMonitoringHeaderEntity c " +
								" where c.serialNumber='"+serialNumber+"' and c.transactionTime <= '"+servicedDate+"') " +
						" and q.parameterName like 'Hour%'");
						Iterator amdItr = amdQuery.list().iterator();
						while(amdItr.hasNext())
						{
							String machineHour = (String)amdItr.next();
							reportEntity.setLastServiceHours(machineHour);
						}
					}


					//Get the Next Scheduled service for the VIN
					//List<AssetServiceScheduleImpl> implResponse=new ServiceDetailsBO2().getAssetServiceScheduleBO(serialNumber);
					//DF20140612 - Rajani Nagaraju - Calling the Updated Class for service alert details
					List<AssetServiceScheduleImpl> implResponse=new ServiceScheduleNewBO2().getServiceSchedule(serialNumber);
					if(! (session.isOpen() ))
					{
						session = HibernateUtil.getSessionFactory().getCurrentSession();
						session.getTransaction().begin();
					}


					for(int i=0; i<implResponse.size(); i++)
					{
						if(implResponse.get(i).getHoursToNextService()!=null)
						{
							reportEntity.setServiceScheduleName(implResponse.get(i).getScheduleName());
	
							reportEntity.setNextServiceName(implResponse.get(i).getServiceName());
	
							Timestamp nextScheduledDate = Timestamp.valueOf(implResponse.get(i).getScheduledDate());
							reportEntity.setNextServiceDate(nextScheduledDate);
	
							reportEntity.setNextServiceHours(String.valueOf(implResponse.get(i).getEngineHoursSchedule()));
	
							reportEntity.setEventId(implResponse.get(i).getEventId());
	
							//DefectID: DF20131230 - Rajani Nagaraju - To update the data into asset event based on Service Date to determine the service alert
							//Only if the Next Service is in Due/OverDue update the asset event table if required
							if(implResponse.get(i).getEventId()!=0)
							{
								int actualServiceScheduleId = implResponse.get(i).getServiceScheduleId();
								int actualEventId = implResponse.get(i).getEventId();
								Query seviceQuery = session.createQuery(" from AssetEventEntity where serialNumber='"+serialNumber+"' " +
										" and eventId="+actualEventId+" and activeStatus=1 and serviceScheduleId="+actualServiceScheduleId);
								Iterator serviceItr = seviceQuery.list().iterator();
								int present =0;
								AssetEventEntity assetEvent=null;
								while(serviceItr.hasNext())
								{
									assetEvent = (AssetEventEntity)serviceItr.next();
									present=1;
								}
	
								if(present==0)
								{
									Timestamp currentTime = new Timestamp(new Date().getTime());
									//Make any service schedule event that is in active mode for the Given VIN as Inactive
	        						Query serviceAlertUpdate = session.createQuery(" update AssetEventEntity set activeStatus=0," +
	        								" eventClosedTime='"+alertClosedTime+"' where serialNumber='"+serialNumber+"'" +
	        										" and eventTypeId=1 and activeStatus=1 ");
	        						int updatedRows = serviceAlertUpdate.executeUpdate();
	
	
									Query eventQuery = session.createQuery(" from EventEntity where eventId="+implResponse.get(i).getEventId());
									Iterator eventItr = eventQuery.list().iterator();
									EventEntity serviceEvent =null;
									while(eventItr.hasNext())
									{
										serviceEvent = (EventEntity)eventItr.next();
									}
	
									//DF20140120 - Rajani Nagaraju - Service Alert Close before generating new Service Alert
									//If any other service alert is there for the VIN, nullify  the same before generating the new service alert
									Query closeServAlertQry = session.createQuery(" update AssetEventEntity set activeStatus=0, eventClosedTime='"+currentTime+"' " +
											" where serialNumber='"+serialNumber+"' and eventTypeId="+serviceEvent.getEventTypeId().getEventTypeId()+" and activeStatus=1");
									int updateRows = closeServAlertQry.executeUpdate();
	
									AssetEntity asset =null;
	        						Query assetQuery = session.createQuery(" from AssetEntity where serial_number='"+serialNumber+"'");
	        						Iterator assetItr = assetQuery.list().iterator();
	        						while(assetItr.hasNext())
	        						{
	        							asset = (AssetEntity)assetItr.next();
	        						}
	
	        						//Insert the New Service Alert - This might be the case where in the machine has not communicated, but is due/overdue 
	        						//for service based on the service date. Since Service alert generation based on Date/EngineHours is calculated
	        						//when a log/event packet is received, if the machine has not communicated, then the alert will not be generated if
	        						//it is on date. This service will help to solve that issue since this service is scheduled atleast once in a day.
	        						AssetEventEntity newServiceEvent = new AssetEventEntity();
	        						newServiceEvent.setActiveStatus(1);
	        						newServiceEvent.setEventGeneratedTime(alertClosedTime);
	        						newServiceEvent.setEventId(serviceEvent);
	        						newServiceEvent.setEventSeverity(serviceEvent.getEventSeverity());
	        						newServiceEvent.setEventTypeId(serviceEvent.getEventTypeId());
	        						newServiceEvent.setSerialNumber(asset);
	        						newServiceEvent.setServiceScheduleId(actualServiceScheduleId);
	        						session.save(newServiceEvent);
	
									Query  engineHoursQuery = session.createQuery(" select b from AssetMonitoringHeaderEntity a, AssetMonitoringDetailEntity b" +
											" where a.transactionNumber = b.transactionNumber and" +
											" a.serialNumber='"+serialNumber+"' and a.transactionTime = ( select max(n.transactionTime) " +
											" from AssetMonitoringHeaderEntity n where n.serialNumber='"+serialNumber+"')" +
									" and b.parameterId in (1,2,4)");
									Iterator engineHoursItr = engineHoursQuery.list().iterator();
									String engineHours = null;
									String latitude =null;
									String longitude =null;
									while(engineHoursItr.hasNext())
									{
										AssetMonitoringDetailEntity detailData = (AssetMonitoringDetailEntity)engineHoursItr.next();
										if(detailData.getParameterId().getParameterId()==4)
											engineHours = detailData.getParameterValue();
										else if(detailData.getParameterId().getParameterId()==1)
											latitude = detailData.getParameterValue();
										else if(detailData.getParameterId().getParameterId()==2)
											longitude = detailData.getParameterValue();
									}
									HashMap<EventEntity, String> eventIdValueMap = new HashMap<EventEntity, String>();
									eventIdValueMap = new HashMap<EventEntity, String>();
									eventIdValueMap.put(serviceEvent, engineHours);
	
									eventDetails.alertGenerationLogic(serialNumber, currentTime, eventIdValueMap, true, false, latitude, longitude, null, actualServiceScheduleId, "1");
	
								}
							}
						}
	
	
						if(! (session.isOpen() ))
						{
							session = HibernateUtil.getSessionFactory().getCurrentSession();
							session.getTransaction().begin();
						}
					}

					//Get the Current Engine hours of the machine
					Query engineHourQuery = session.createQuery(" select b.parameterValue from AssetMonitoringHeaderEntity a, " +
							" AssetMonitoringDetailEntity b, MonitoringParameters c where" +
							" a.transactionNumber = b.transactionNumber and " +
							" b.parameterId = c.parameterId and" +
							" a.transactionTime = (select max(x.transactionTime) from AssetMonitoringHeaderEntity x where " +
							" x.serialNumber='"+serialNumber+"')" +
							" and a.serialNumber='"+serialNumber+"' and " +
					" c.parameterId = (select max(y.parameterId) from MonitoringParameters y where y.parameterName like 'Hour%')");
					Iterator engineHourItr = engineHourQuery.list().iterator();
					while(engineHourItr.hasNext())
					{
						String currentEngineHour = (String)engineHourItr.next();
						reportEntity.setTotalEngineHours(currentEngineHour);
					}
	
					//Set the last updated date
					reportEntity.setLastUpdated(new Timestamp((new Date()).getTime()));
	
					session.update(reportEntity);
				}
				
				catch(Exception e)
        		{
        			fLogger.fatal(e);
        		}
				
        		if(rowUpdateCounter>10)
				{
        			rowUpdateCounter=0;
					try
					{
						if (session.getTransaction().isActive()) 
						{
							session.getTransaction().commit();
						}
					}
					catch(Exception e)
					{
						fLogger.fatal(e);
						
						if (session.isOpen()) 
						{
							session.clear();
						}
						if (session.isOpen()) 
						{
							session.close();
						}
					}
					
					finally
					{
						if (session.isOpen()) 
						{
							session.flush();
							session.close();
						}
					}
					
					if(! (session.isOpen() ))
		            {
		                        session = HibernateUtil.getSessionFactory().getCurrentSession();
		                        session.getTransaction().begin();
		            }
				}
			}


			//STEP2: Insert the service details for the VIN which has not yet entered into reporting table
			int rowInsertCounter=0;
			Query assetSerSchQuery = session.createQuery(" select distinct serialNumber from AssetServiceScheduleEntity where " +
			" serialNumber not in ( select serialNumber from ServiceDetailsReportEntity )");
			Iterator assetSerSchItr = assetSerSchQuery.list().iterator();

			while(assetSerSchItr.hasNext())
			{
				rowInsertCounter++;
				
				try
				{
					ServiceDetailsReportEntity reportEntity = new ServiceDetailsReportEntity();

					AssetEntity asset = (AssetEntity)assetSerSchItr.next();
					String serialNumber = asset.getSerial_number().getSerialNumber();
	
					reportEntity.setSerialNumber(serialNumber);

					//Get the Last service History details of the VIN
					ServiceHistoryEntity serviceHistoryObj = null;
					Query serviceHistoryQuery = session.createQuery(" select b.serviceName, " +
							" a.serviceDate " +
							" from ServiceHistoryEntity a, ServiceScheduleEntity b " +
							" where a.dbmsPartCode = b.dbmsPartCode and " +
							" serviceDate = (select max(serviceDate) from " +
							" ServiceHistoryEntity where serialNumber='"+serialNumber+"') and serialNumber='"+serialNumber+"'");
					Iterator serviceHistoryItr = serviceHistoryQuery.list().iterator();
					Object[] result =null;
					while(serviceHistoryItr.hasNext())
					{
						result = (Object[]) serviceHistoryItr.next();
						if(result[0]!=null)
							reportEntity.setLastServiceName(result[0].toString());
						if(result[1]!=null)
							reportEntity.setLastServiceDate((Timestamp)result[1]);
					}

					if(result!=null)
					{
						String servicedDate = sdf.format((Timestamp)result[1]);
						//Get the Last_Service_hour - Engine hour of the machine when the machine got serviced
						Query amdQuery = session.createQuery(" select b.parameterValue from AssetMonitoringHeaderEntity a, AssetMonitoringDetailEntity b," +
								" MonitoringParameters q " +
								" where a.transactionNumber = b.transactionNumber " +
								" and b.parameterId = q.parameterId " +
								" and a.serialNumber='"+serialNumber+"'" +
								" and a.transactionTime = ( select max(c.transactionTime) from AssetMonitoringHeaderEntity c " +
								" where c.serialNumber='"+serialNumber+"' and c.transactionTime <= '"+servicedDate+"') " +
						" and q.parameterName like 'Hour%'");
						Iterator amdItr = amdQuery.list().iterator();
						while(amdItr.hasNext())
						{
							String machineHour = (String)amdItr.next();
							reportEntity.setLastServiceHours(machineHour);
						}
					}


					//Get the Next Scheduled service for the VIN
					//List<AssetServiceScheduleImpl> implResponse=new ServiceDetailsBO2().getAssetServiceScheduleBO(serialNumber);
					//DF20140612 - Rajani Nagaraju - Calling the Updated Class for service alert details
					List<AssetServiceScheduleImpl> implResponse=new ServiceScheduleNewBO2().getServiceSchedule(serialNumber);
					if(! (session.isOpen() ))
					{
						session = HibernateUtil.getSessionFactory().getCurrentSession();
						session.getTransaction().begin();
					}

					for(int i=0; i<implResponse.size(); i++)
					{
						if(implResponse.get(i).getHoursToNextService()!=null)
						{
							reportEntity.setServiceScheduleName(implResponse.get(i).getScheduleName());
	
							reportEntity.setNextServiceName(implResponse.get(i).getServiceName());
	
							Timestamp nextScheduledDate = Timestamp.valueOf(implResponse.get(i).getScheduledDate());
							reportEntity.setNextServiceDate(nextScheduledDate);
	
							reportEntity.setNextServiceHours(String.valueOf(implResponse.get(i).getEngineHoursSchedule()));
	
							reportEntity.setEventId(implResponse.get(i).getEventId());
	
							//DefectID: DF20131230 - Rajani Nagaraju - To update the data into asset event based on Service Date to determine the service alert
							//Only if the Next Service is in Due/OverDue update the asset event table if required
							if(implResponse.get(i).getEventId()!=0)
							{
								int actualServiceScheduleId = implResponse.get(i).getServiceScheduleId();
								int actualEventId = implResponse.get(i).getEventId();
								Query seviceQuery = session.createQuery(" from AssetEventEntity where serialNumber='"+serialNumber+"' " +
										" and eventId="+actualEventId+" and activeStatus=1 and serviceScheduleId="+actualServiceScheduleId);
								Iterator serviceItr = seviceQuery.list().iterator();
								int present =0;
								while(serviceItr.hasNext())
								{
									AssetEventEntity assetEvent = (AssetEventEntity)serviceItr.next();
									present=1;
								}
	
								if(present==0)
								{
									Timestamp currentTime = new Timestamp(new Date().getTime());
									//Make any service schedule event that is in active mode for the Given VIN as Inactive
	        						Query serviceAlertUpdate = session.createQuery(" update AssetEventEntity set activeStatus=0," +
	        								" eventClosedTime='"+alertClosedTime+"' where serialNumber='"+serialNumber+"'" +
	        										" and eventTypeId=1 and activeStatus=1 ");
	        						int updatedRows = serviceAlertUpdate.executeUpdate();
	
	
									Query eventQuery = session.createQuery(" from EventEntity where eventId="+implResponse.get(i).getEventId());
									Iterator eventItr = eventQuery.list().iterator();
									EventEntity serviceEvent =null;
									while(eventItr.hasNext())
									{
										serviceEvent = (EventEntity)eventItr.next();
									}
	
	
									//DF20140120 - Rajani Nagaraju - Service Alert Close before generating new Service Alert
									//If any other service alert is there for the VIN, nullify  the same before generating the new service alert
									Query closeServAlertQry = session.createQuery(" update AssetEventEntity set activeStatus=0, eventClosedTime='"+currentTime+"' " +
											" where serialNumber='"+serialNumber+"' and eventTypeId="+serviceEvent.getEventTypeId().getEventTypeId()+" and activeStatus=1");
									int updateRows = closeServAlertQry.executeUpdate();
	
									AssetEntity asset =null;
	        						Query assetQuery = session.createQuery(" from AssetEntity where serial_number='"+serialNumber+"'");
	        						Iterator assetItr = assetQuery.list().iterator();
	        						while(assetItr.hasNext())
	        						{
	        							asset = (AssetEntity)assetItr.next();
	        						}
	
	        						//Insert the New Service Alert - This might be the case where in the machine has not communicated, but is due/overdue 
	        						//for service based on the service date. Since Service alert generation based on Date/EngineHours is calculated
	        						//when a log/event packet is received, if the machine has not communicated, then the alert will not be generated if
	        						//it is on date. This service will help to solve that issue since this service is scheduled atleast once in a day.
	        						AssetEventEntity newServiceEvent = new AssetEventEntity();
	        						newServiceEvent.setActiveStatus(1);
	        						newServiceEvent.setEventGeneratedTime(alertClosedTime);
	        						newServiceEvent.setEventId(serviceEvent);
	        						newServiceEvent.setEventSeverity(serviceEvent.getEventSeverity());
	        						newServiceEvent.setEventTypeId(serviceEvent.getEventTypeId());
	        						newServiceEvent.setSerialNumber(asset);
	        						newServiceEvent.setServiceScheduleId(actualServiceScheduleId);
	        						session.save(newServiceEvent);
	
									Query  engineHoursQuery = session.createQuery(" select b from AssetMonitoringHeaderEntity a, AssetMonitoringDetailEntity b" +
											" where a.transactionNumber = b.transactionNumber and" +
											" a.serialNumber='"+serialNumber+"' and a.transactionTime = ( select max(n.transactionTime) " +
											" from AssetMonitoringHeaderEntity n where n.serialNumber='"+serialNumber+"')" +
									" and b.parameterId in (1,2,4)");
									Iterator engineHoursItr = engineHoursQuery.list().iterator();
									String engineHours = null;
									String latitude =null;
									String longitude =null;
									while(engineHoursItr.hasNext())
									{
										AssetMonitoringDetailEntity detailData = (AssetMonitoringDetailEntity)engineHoursItr.next();
										if(detailData.getParameterId().getParameterId()==4)
											engineHours = detailData.getParameterValue();
										else if(detailData.getParameterId().getParameterId()==1)
											latitude = detailData.getParameterValue();
										else if(detailData.getParameterId().getParameterId()==2)
											longitude = detailData.getParameterValue();
									}
									HashMap<EventEntity, String> eventIdValueMap = new HashMap<EventEntity, String>();
									eventIdValueMap = new HashMap<EventEntity, String>();
									eventIdValueMap.put(serviceEvent, engineHours);
	
									eventDetails.alertGenerationLogic(serialNumber, currentTime, eventIdValueMap, true, false, latitude, longitude, null, actualServiceScheduleId, "1");
	
								}
							}
						}
	
						if(! (session.isOpen() ))
						{
							session = HibernateUtil.getSessionFactory().getCurrentSession();
							session.getTransaction().begin();
						}
					}
	
					//Get the Current Engine hours of the machine
					Query engineHourQuery = session.createQuery(" select b.parameterValue from AssetMonitoringHeaderEntity a, " +
							" AssetMonitoringDetailEntity b, MonitoringParameters c where" +
							" a.transactionNumber = b.transactionNumber and " +
							" b.parameterId = c.parameterId and" +
							" a.transactionTime = (select max(x.transactionTime) from AssetMonitoringHeaderEntity x where " +
							" x.serialNumber='"+serialNumber+"')" +
							" and a.serialNumber='"+serialNumber+"' and " +
					" c.parameterId = (select max(y.parameterId) from MonitoringParameters y where y.parameterName like 'Hour%')");
					Iterator engineHourItr = engineHourQuery.list().iterator();
					while(engineHourItr.hasNext())
					{
						String currentEngineHour = (String)engineHourItr.next();
						reportEntity.setTotalEngineHours(currentEngineHour);
					}
	
					//Set the last updated date
					reportEntity.setLastUpdated(new Timestamp((new Date()).getTime()));
	
					session.save(reportEntity);
				}
				
				catch(Exception e)
        		{
        			fLogger.fatal(e);
        		}
				
        		if(rowInsertCounter>10)
				{
        			rowInsertCounter=0;
					try
					{
						if (session.getTransaction().isActive()) 
						{
							session.getTransaction().commit();
						}
					}
					catch(Exception e)
					{
						fLogger.fatal(e);
						
						if (session.isOpen()) 
						{
							session.clear();
						}
						if (session.isOpen()) 
						{
							session.close();
						}
					}
					
					finally
					{
						if (session.isOpen()) 
						{
							session.flush();
							session.close();
						}
					}
					
					if(! (session.isOpen() ))
		            {
		                        session = HibernateUtil.getSessionFactory().getCurrentSession();
		                        session.getTransaction().begin();
		            }
				}
			}


		}

		catch(Exception e)
		{ 
			e.printStackTrace();
			fLogger.fatal("Exception :"+e);
			if (session.isOpen()) 
			{
				session.clear();
			}
			if (session.isOpen()) 
			{
				session.close();
			}
		}

		finally
		{
			try
			{
				if (session.getTransaction().isActive()) 
					session.getTransaction().commit();
			}
			
			catch(Exception e)
			{
				fLogger.fatal(e);
			}

			finally
			{
				if (session.isOpen()) 
				{
					session.flush();
					session.close();
				}
			}

		}

		return status;
	*/
		
		//END OLD LOGIC
		
	}
	
	
	//********************************************* SET Service details for a specific VIN - START *****************************************
		//DF20191021 - Rajani Nagaraju - Extended Warranty Changes - START 
		public String setServiceDetails(String serialNumber)
		{

			 Logger iLogger = InfoLoggerClass.logger;

		      Logger fLogger = FatalLoggerClass.logger;

		      ExecutorService executors = null;

		      Future<String> taskResult = null;

		      CompletionService<String> taskCompletionService = null;

		    

		      int maxNoOfThreads = 0;

		      try {

		            Callable<String> callable = null;
		            Session session = HibernateUtil.getSessionFactory().openSession();
		            
		            try{

			     
		            if(serialNumber!=null)
		            	maxNoOfThreads=1;
		            
		            else
		            {
				            //STEP 2 : getting max segmentID from asset table ,NO. of Threads = No. of Segments
			
				            Query maxSegmentQuery = session.createQuery("select max(segmentId) from AssetEntity"); 
			
				            Iterator itr = maxSegmentQuery.list().iterator();
			
				            if(itr.hasNext()){
			
				                maxNoOfThreads = (Integer) itr.next();
				                iLogger.info("setServiceDetails::maxNoOfThreads ::"+maxNoOfThreads);
			              }
		            }
		            
		            }
		            catch(Exception e){
		            	e.printStackTrace();
		            	 return "FAILURE";
		            }
		            finally{
		            	
		            	if (session!=null && session.isOpen()) 
						{
						session.close();
						}
		            }

		            if(maxNoOfThreads!=0)

		            {

		                  executors = Executors.newFixedThreadPool(maxNoOfThreads);

		                  taskCompletionService = new ExecutorCompletionService<String>(executors);

		            }


		            int segementIDThread = 0;

		          
		            while(segementIDThread < maxNoOfThreads ){

		                   callable = new ReportDetailsBO(segementIDThread, serialNumber);
		                		   
		                		   //setServiceDetailsViaExecutor(segementIDThread);

		                    taskCompletionService.submit(callable);

		                     segementIDThread++;
		                   
		                 }
		            
	             for(int i=1;i<=maxNoOfThreads;i++){

		                  taskResult = taskCompletionService.take();

		                  if(taskResult.get() != null){

		                	  iLogger.info("setServiceDetails::"+"Thread "+i+" has succefully completed and returned "+taskResult.get());

		                  }

		            }

		            executors.shutdown();

		            iLogger.info("setServiceDetails::Exiting from the multithread:");

		            executors.awaitTermination(Long.MAX_VALUE, TimeUnit.MILLISECONDS);

		           

		      }

		     

		      catch(Exception e){

		            e.printStackTrace();
		            return "FAILURE";

		      }

		     
		      return "SUCCESS";
		}
		//DF20191021 - Rajani Nagaraju - Extended Warranty Changes - END 
		//********************************************* SET service details for a specific VIN - END **********************************************
		

	//********************************************* END of Set Service Details for all VINs *********************************************

	public HashMap<String, Integer> getserialNumberList(List<Integer> tenancyIdList,List<Integer> machineGroupIdList,
			List<Integer> machineProfileIdList,List<Integer> modelIdList){
		
		Session session = HibernateUtil.getSessionFactory().openSession();
		session.beginTransaction();

		ListToStringConversion conversionObj = new ListToStringConversion();
		String tenancyIdStringList = conversionObj.getIntegerListString(tenancyIdList).toString();
		List<String> serNumList = new LinkedList<String>();

		String serNum=null;

		HashMap<String, Integer>serTenacyID = new HashMap<String, Integer>();

		try {			
			String selectQuery=null;
			String fromQuery=null;
			String whereQuery=null;
			String finalQuery=null;
			selectQuery = " select a.serial_number,a.primary_owner_id,atm.tenancy_id,t.tenancy_name,s.group_id as machineGroupId, s.group_name as machineGroupName " ;
			fromQuery =	" from AssetCustomGroupMapping y RIGHT OUTER JOIN y.serial_number x  LEFT OUTER JOIN y.group_id s , TenancyBridgeEntity b , AccountTenancyMapping atm , AssetEntity a , TenancyEntity t ";
			whereQuery = " where b.parentId in ("+ tenancyIdStringList+") and b.childId=atm.tenancy_id and atm.account_id = a.primary_owner_id and atm.tenancy_id = t.tenancy_id and x.serial_number = a.serial_number ";

			if (!(machineGroupIdList == null || machineGroupIdList.isEmpty())) 
			{
				String customAssetGroupStringList = conversionObj.getIntegerListString(machineGroupIdList).toString();
				whereQuery = whereQuery	+ " and s.group_id in ("+ customAssetGroupStringList + ")";
			}

			if ((!(machineProfileIdList == null || machineProfileIdList.isEmpty()))	|| (!(modelIdList == null || modelIdList.isEmpty()))) 
			{
				fromQuery = fromQuery+ " , ProductEntity p ";
				whereQuery = whereQuery	+ " and x.productId = p.productId ";

			}

			if (!(machineProfileIdList == null || machineProfileIdList.isEmpty())) 
			{
				String machineProfileIdStringList = conversionObj.getIntegerListString(machineProfileIdList).toString();
				whereQuery = whereQuery + " and p.assetGroupId in ( "+ machineProfileIdStringList + ") ";
			}

			if (!(modelIdList == null || modelIdList.isEmpty())) 
			{
				String modelIdStringList = conversionObj.getIntegerListString(modelIdList).toString();
				whereQuery = whereQuery + " and p.assetTypeId in ( "+ modelIdStringList + " )";
			}

			finalQuery =  selectQuery + fromQuery + whereQuery;

			Query query1 = session.createQuery(finalQuery);
			Iterator itr = query1.list().iterator();
			Object[] result = null;
			AssetControlUnitEntity	assetSerNum=null;
			TenancyEntity tenancyentity=null;
			int primaryOwnerId=0;
			int tenancyID=0;

			String tenancyName=null;
			int groupID=0;
			String groupName=null;
			while(itr.hasNext()){
				result = (Object[]) itr.next();
				assetSerNum=(AssetControlUnitEntity)result[0];
				serNum=assetSerNum.getSerialNumber();
				serNumList.add(serNum);
				primaryOwnerId=(Integer) result[1];
				tenancyentity=(TenancyEntity) result[2];
				tenancyID=tenancyentity.getTenancy_id();
				tenancyName=(String) result[3];
				groupID = 0;
				groupName=null;
				if(result[4]!=null){					
					groupID=(Integer) result[4];
				}
				if(result[5]!=null){					
					groupName=(String) result[5];
				}
				serTenacyID.put(serNum, tenancyID);
				serGroupID.put(serNum, groupID);
				TenancyData.put(tenancyID, tenancyName);
				GroupData.put(groupID, groupName);
			}
		}
		finally {
			if (session.getTransaction().isActive()) {
				session.getTransaction().commit();
			}

			if (session.isOpen()) {
				session.flush();
				session.close();
			}

		}
		return serTenacyID;
	}


	//***********************************************Notification Report Details Service ***********************

	//added by smitha...Defect ID-20131024 on oct 24th 2013
	/*public List<NotificationReportDetailsImpl> getNotificationReportDetails(String fromDate,String toDate,
			List<String> serialNumberList,List<Integer> TenancyIdList,List<Integer> LoginTenancyIdList,List<Integer> alertTypeIdList, List<Integer> MachineGroupIdList, List<Integer> ModelidList, List<Integer> MachineProfileIdList){
        
        Logger iLogger = InfoLoggerClass.logger;
        List<NotificationReportDetailsImpl> listNotifications = new LinkedList<NotificationReportDetailsImpl>();
        iLogger.info("Entering getNotificationReportDetails()");
        long startTimeTaken = System.currentTimeMillis();
        String basicSelectQuery = null;
        String basicFromQuery = null;
        String basicWhereQuery = null;
        String basicOrderByQuery = null;
        String finalQuery = null;
        ListToStringConversion conversionObj = new ListToStringConversion();
        NotificationReportDetailsImpl implmObj = null;
        DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
        DateFormat dateFormat1 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        Date fromdate1=null;
        String fromdate2=null;
        String todate2=null; 
        List<String> serialNumberListFinal = new LinkedList<String>();
        List<String> serNumList = new LinkedList<String>();
        Session session = HibernateUtil.getSessionFactory().getCurrentSession();
        session.beginTransaction();
        String tenancyIdStringList = null; 
        Calendar calendar1 = Calendar.getInstance();
        if(!(fromDate == null && toDate==null))
        {                 
              try { 

                    fromdate1 = (Date)dateFormat.parse(fromDate);   
                    //                            Keerhti : 24/09/14 : fromdate timestamp will be prev day 6:30PM
                    calendar1.setTime(fromdate1);
                    // get previous day
                    calendar1.add(Calendar.DAY_OF_YEAR, -1);
                    fromdate2 = dateFormat.format(calendar1.getTime());
                    fromdate2 = fromdate2 + " 18:30:00";
                    String fromdate=dateFormat.format(fromdate1);
                    fromdate2=dateFormat1.format(fromdate1);                        
                    Date todate1=(Date)dateFormat.parse(toDate);                      
                    String todate=dateFormat.format(todate1);
                    todate2=dateFormat1.format(todate1);      
                    //DF:20131203: code changes done by Juhi on 3-december-2013
                    //                      Keerhti : 24/09/14 : todate timestamp will be upto that day 6:30PM
                    todate2=dateFormat.format((Date)dateFormat.parse(todate2))+" 18:29:59";
                    iLogger.info("from date "+fromdate2+ "  todate "+todate2);
              } catch (ParseException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
              }                                   
        }   
        
        if (serialNumberList != null && serialNumberList.size()<=200) {

             serialNumberListFinal.addAll(serialNumberList);
			  String serialNumberAsStringList = conversionObj.getStringList(
                    serialNumberListFinal).toString();
		
		basicSelectQuery = " select ae.serialNumber,et.eventTypeName,e.eventName,e.eventDescription,ae.activeStatus,ae.eventSeverity,ae.eventGeneratedTime,ae.address,a.nick_name ";
        basicFromQuery = " from AssetEntity a,AssetEventEntity ae,EventEntity e,EventTypeEntity et ";
        basicWhereQuery = "where ae.serialNumber in ("
              + serialNumberAsStringList
              + ")" +
              " and ae.eventGeneratedTime between '"+fromdate2+"' and '"+todate2+"' and ae.serialNumber = a.serial_number " +
              " and ae.eventId = e.eventId and ae.eventTypeId = e.eventTypeId and e.eventTypeId = et.eventTypeId ";     
        basicOrderByQuery = " order by ae.serialNumber,e.eventTypeId,e.eventId";
        if( (!(alertTypeIdList==null)) && (alertTypeIdList.size()>0)) {
              String alertTypeIdString = conversionObj.getIntegerListString(alertTypeIdList).toString();
              basicWhereQuery = basicWhereQuery +" AND ae.eventTypeId IN ("+alertTypeIdString+")";
        }
        finalQuery = basicSelectQuery + basicFromQuery + basicWhereQuery + basicOrderByQuery ;
        }

        else {
      // TenancyIdList = getSubTenancyIds(TenancyIdList,session);    
    tenancyIdStringList = conversionObj.getIntegerListString(TenancyIdList).toString();

    basicSelectQuery = " select ae.serialNumber,et.eventTypeName,e.eventName,e.eventDescription,ae.activeStatus,ae.eventSeverity,ae.eventGeneratedTime,ae.address,a.nick_name ";
	basicFromQuery = " from AssetEntity a,AssetEventEntity ae,EventEntity e,EventTypeEntity et,AssetCustomGroupMapping w RIGHT OUTER JOIN w.serial_number x LEFT OUTER JOIN w.group_id c,NotificationFactEntity_DayAgg n ,TenancyDimensionEntity g ,AssetClassDimensionEntity d, TenancyBridgeEntity t  ";
	basicWhereQuery = " where ae.serialNumber = n.SerialNumber " +
		" and ae.eventGeneratedTime between '"+fromdate2+"' and '"+todate2+"' and ae.serialNumber = a.serial_number " +
		" and ae.eventId = e.eventId and ae.eventTypeId = e.eventTypeId and e.eventTypeId = et.eventTypeId and x.serial_number = ae.serialNumber" +
		" and n.Time_Key between '"+fromdate2+"' and '"+todate2+"' and n.Tenancy_Id = g.tenacy_Dimension_Id and " +
		"  n.AssetClass_Id = d.assetClassDimensionId and  g.tenancyId=t.childId and t.parentId in (" + tenancyIdStringList +") "; 
	basicOrderByQuery = " order by ae.serialNumber,e.eventTypeId,e.eventId";
	if( (!(alertTypeIdList==null)) && (alertTypeIdList.size()>0)) {
		String alertTypeIdString = conversionObj.getIntegerListString(alertTypeIdList).toString();
		basicWhereQuery = basicWhereQuery +" AND ae.eventTypeId IN ("+alertTypeIdString+")";
	}
	if (!((MachineProfileIdList == null) || (MachineProfileIdList.isEmpty()))) {
		String machineProfileIdListStringList = conversionObj.getIntegerListString(MachineProfileIdList).toString();
		basicWhereQuery = basicWhereQuery + " and d.assetGroupId in ("+ machineProfileIdListStringList + ")";
	}
	if (!((ModelidList == null) || (ModelidList.isEmpty()))) {
		String modelIdListStringList = conversionObj.getIntegerListString(ModelidList).toString();
		basicWhereQuery = basicWhereQuery + " and d.assetTypeId in ("+ modelIdListStringList + ")";
	}
	if (!(MachineGroupIdList == null || MachineGroupIdList.isEmpty())) {
		String customAssetGroupStringList = conversionObj
		.getIntegerListString(MachineGroupIdList).toString();
		basicWhereQuery = basicWhereQuery + " and c.group_id in ("
		+ customAssetGroupStringList + ")";
	}

	
	finalQuery = basicSelectQuery + basicFromQuery + basicWhereQuery + basicOrderByQuery ;			
        }            
         AssetEntity asset=null;
        String sNum=null;
        Set<String> landmarkAlertPIns = new HashSet<String>();
        try {

              Query query = session.createQuery(finalQuery);
              Iterator itrt = query.list().iterator();          
              Object[] result=null;String category = null;
              while(itrt.hasNext())
              {                 
                    result = (Object[]) itrt.next();
                    if(result[1]!=null){
                          category = result[1].toString();
                    }
                    if(result[0]!=null){

                          asset=(AssetEntity)result[0];
                          sNum=asset.getSerial_number().getSerialNumber();
                    }
                    if(!category.equals("Landmark")){//Keerthi : 24/12/2013:skipping landmark alerts
                          implmObj = new NotificationReportDetailsImpl();

                          if(result[0]!=null){

                                asset=(AssetEntity)result[0];
                                sNum=asset.getSerial_number().getSerialNumber();
                                implmObj.setSerialNumber(sNum);
                          }
                          if(result[1]!=null){
                                implmObj.setCategory(result[1].toString());
                          }
                          if(result[2]!=null){
                                implmObj.setAlertName(result[2].toString());
                          }
                          if(result[3]!=null){
                                implmObj.setDescription(result[3].toString());
                          }
                          if(result[4]!=null){
                                implmObj.setStatus(result[4].toString());
                          }
                          if(result[5]!=null){
                                implmObj.setSeverity(result[5].toString());
                          }
                          if(result[6]!=null){
                                implmObj.setDateRaised(result[6].toString());
                          }
                          if(result[7]!=null){
                                implmObj.setLocation(result[7].toString());
                          }
                          if(result[8]!=null){
                                implmObj.setMachineName(result[8].toString());
                          }
                          listNotifications.add(implmObj);
                    }
                    else if(category.equals("Landmark")){
                          //                      Keerthi : 10/01/2014 : getting landmark details of a PIN in one shot to maintain order of PIN in fianl list
                          if(!landmarkAlertPIns.contains(sNum)){
                                landmarkAlertPIns.add(sNum);
                                List<NotificationReportDetailsImpl> landmarkAlertDetails =getLandmarkDetails(sNum,LoginTenancyIdList,fromdate2,todate2,session);
                                listNotifications.addAll(landmarkAlertDetails);
                          }

                    }
                    //added by smitha on Dec 17th 2013...DefectID:20131217...for non communicated VIN's
                    if(!serNumList.contains(sNum)){
                          serNumList.add(sNum);
                    }
                    //ended ...DefectID:20131217...for non communicated VIN's
              }
              //Keerthi : 24/12/2013 : Selecting landmark alert details of logged in tenancy's defined landmarks here
              //           Keerthi : 13/01/14 : PIN details with no alerts is not needed.
              //DefectId: DF20131213 - Smitha - To display the VINs that has not communicated for the given time period 
              Query ownerListQuery = session.createQuery(" select distinct c.serialNumber " +
                                                                                " from TenancyBridgeEntity a, AccountTenancyMapping b, AssetAccountMapping c " +
                                                                                " where a.childId= b.tenancy_id " +
                                                                                " and b.account_id= c.accountId " +
                                                                                " and a.parentId in ("+tenancyIdStringList+") and" +
                                                                                " ( (c.ownershipStartDate between '"+fromdate2+"' and '"+todate2+"') OR " +
                                                                                "   (c.ownershipStartDate = ( select max(y.ownershipStartDate) from AssetAccountMapping y " +
                                                                                                                          " where y.serialNumber= c.serialNumber" +
                                                                                                                          " and y.ownershipStartDate <='"+fromdate2+"')" +
                                                                                "    )" +
                                                                                " )");
              Iterator ownerListItr = ownerListQuery.list().iterator();
              List<String> actualOwnerVINList = new LinkedList<String>();
              HashMap<String, String> serNickNameList = new HashMap<String, String>();
              while(ownerListItr.hasNext())
              {
                    AssetEntity assetList = (AssetEntity)ownerListItr.next();
                    actualOwnerVINList.add(assetList.getSerial_number().getSerialNumber());
                    //added by smitha on Dec 17th 2013...DefectID:20131217...for non communicated VIN's
                    serNickNameList.put(assetList.getSerial_number().getSerialNumber(),assetList.getNick_name());
                    //ended ...DefectID:20131217...for non communicated VIN's
              }

              //Get only the List of VINs which has not communicated for the Given period

              //added by smitha on Dec 17th 2013...DefectID:20131217...for non communicated VIN's
              actualOwnerVINList.removeAll(serNumList);
              //ended ...DefectID:20131217...for non communicated VIN's
              String actualOwnerVinListString = conversionObj.getStringList(actualOwnerVINList).toString();
              String nickName=null;
              for(String serNum:actualOwnerVINList){
              implmObj = new NotificationReportDetailsImpl(); 
              implmObj.setAlertName(null);
              implmObj.setCategory(null);
              implmObj.setDateRaised(null);
              implmObj.setDescription(null);
              implmObj.setLocation(null);
              //added by smitha on Dec 17th 2013...DefectID:20131217...for non communicated VIN's
              nickName = serNickNameList.get(serNum);
              implmObj.setMachineName(nickName);
              //ended ...DefectID:20131217...for non communicated VIN's
              implmObj.setSerialNumber(serNum);
              implmObj.setSeverity(null);
              implmObj.setStatus(null);
              listNotifications.add(implmObj);
              }
              //ended----DefectId: DF20131213 - Smitha - Non Communicated VIN's
                             
              long endTimeTaken = System.currentTimeMillis();
              long totalTimeTaken = endTimeTaken - startTimeTaken;

              iLogger.info("TotalTimeTaken is   " + totalTimeTaken);
              iLogger.info("Exiting getNotificationReportDetails()");
        } catch (Exception e) {
              e.printStackTrace();
        } finally {
              if (session.getTransaction().isActive()) {
                    session.getTransaction().commit();
              }

              if (session.isOpen()) {
                    session.flush();
                    session.close();
              }

        }
        return listNotifications;} */
	public List<NotificationReportDetailsImpl> getNotificationReportDetails(String fromDate,String toDate,
			List<String> serialNumberList,List<Integer> TenancyIdList,List<Integer> LoginTenancyIdList,List<Integer> alertTypeIdList, List<Integer> MachineGroupIdList, List<Integer> ModelidList, List<Integer> MachineProfileIdList){

		Logger iLogger = InfoLoggerClass.logger;
		List<NotificationReportDetailsImpl> listNotifications = new LinkedList<NotificationReportDetailsImpl>();
		iLogger.info("Entering getNotificationReportDetails()");
		long startTimeTaken = System.currentTimeMillis();
		String basicSelectQuery = null;
		String basicFromQuery = null;
		String basicWhereQuery = null;
		String basicOrderByQuery = null;
		String finalQuery = null;
		ListToStringConversion conversionObj = new ListToStringConversion();
		NotificationReportDetailsImpl implmObj = null;
		DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
		DateFormat dateFormat1 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		Date fromdate1=null;
		String fromdate2=null;
		String todate2=null; 
		List<String> serialNumberListFinal = new LinkedList<String>();
		List<String> serNumList = new LinkedList<String>();
		Session session = HibernateUtil.getSessionFactory().getCurrentSession();
		session.beginTransaction();
		String tenancyIdStringList = null; 
		Calendar calendar1 = Calendar.getInstance();
		if(!(fromDate == null && toDate==null))
		{                 
			try { 

				fromdate1 = (Date)dateFormat.parse(fromDate);   
				//                            Keerhti : 24/09/14 : fromdate timestamp will be prev day 6:30PM
				calendar1.setTime(fromdate1);
				// get previous day
				calendar1.add(Calendar.DAY_OF_YEAR, -1);
				fromdate2 = dateFormat.format(calendar1.getTime());
				fromdate2 = fromdate2 + " 18:30:00";
				/*String fromdate=dateFormat.format(fromdate1);
                    fromdate2=dateFormat1.format(fromdate1);  */                      
				Date todate1=(Date)dateFormat.parse(toDate);                      
				String todate=dateFormat.format(todate1);
				todate2=dateFormat1.format(todate1);      
				//DF:20131203: code changes done by Juhi on 3-december-2013
				//                      Keerhti : 24/09/14 : todate timestamp will be upto that day 6:30PM
				todate2=dateFormat.format((Date)dateFormat.parse(todate2))+" 18:29:59";
				iLogger.info("from date "+fromdate2+ "  todate "+todate2);
			} catch (ParseException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}                                   
		}   

		if (serialNumberList != null && serialNumberList.size()<=100) {

			serialNumberListFinal.addAll(serialNumberList);
			String serialNumberAsStringList = conversionObj.getStringList(
					serialNumberListFinal).toString();

			basicSelectQuery = " select ae.serialNumber,et.eventTypeName,e.eventName,e.eventDescription,ae.activeStatus,ae.eventSeverity,ae.eventGeneratedTime,ae.address,a.nick_name ";
			basicFromQuery = " from AssetEntity a,AssetEventEntity ae,EventEntity e,EventTypeEntity et ";
			basicWhereQuery = "where ae.serialNumber in ("
					+ serialNumberAsStringList
					+ ")" +
					" and ae.eventGeneratedTime between '"+fromdate2+"' and '"+todate2+"' and ae.serialNumber = a.serial_number " +
					" and ae.eventId = e.eventId and ae.eventTypeId = e.eventTypeId and e.eventTypeId = et.eventTypeId ";     
			basicOrderByQuery = " order by ae.serialNumber,e.eventTypeId,e.eventId";
			if( (!(alertTypeIdList==null)) && (alertTypeIdList.size()>0)) {
				String alertTypeIdString = conversionObj.getIntegerListString(alertTypeIdList).toString();
				basicWhereQuery = basicWhereQuery +" AND ae.eventTypeId IN ("+alertTypeIdString+")";
			}
			finalQuery = basicSelectQuery + basicFromQuery + basicWhereQuery + basicOrderByQuery ;
		}

		else {
			// TenancyIdList = getSubTenancyIds(TenancyIdList,session);
			List<Integer> parentTenancyIdsList = new LinkedList<Integer>();
			List<Integer> childTenancyIdsList = new LinkedList<Integer>();
			int i=0;
			for(i=0; i<TenancyIdList.size();i++)
			{
				if(LoginTenancyIdList.contains(TenancyIdList.get(i)))

				{
					parentTenancyIdsList.add(TenancyIdList.get(i))	;
				}
				else
				{
					childTenancyIdsList.add(TenancyIdList.get(i));
				}
			}
			/* TenancyIdList.removeAll(LoginTenancyIdList);
            tenancyIdStringList = conversionObj.getIntegerListString(TenancyIdList).toString();*/
			if(parentTenancyIdsList.size()!=0 && parentTenancyIdsList.size()>0)
			{
				tenancyIdStringList = conversionObj.getIntegerListString(parentTenancyIdsList).toString();
			}
			else
			{
				tenancyIdStringList = conversionObj.getIntegerListString(childTenancyIdsList).toString();	
			}

			List<Integer> parentAccountEntityList = new LinkedList<Integer>();
			Query queryAccount1 = session.createQuery("from AccountTenancyMapping where tenancy_id in " +
					" ("+tenancyIdStringList+")");
			Iterator itrAccount1 = queryAccount1.list().iterator();

			while(itrAccount1.hasNext())
			{
				AccountTenancyMapping accountTenancy = (AccountTenancyMapping) itrAccount1.next();
				parentAccountEntityList.add(accountTenancy.getAccount_id().getAccount_id());
			}
			String parentAccountEntityListString = conversionObj.getIntegerListString(parentAccountEntityList).toString();

			basicSelectQuery = " select ae.serialNumber,et.eventTypeName,e.eventName,e.eventDescription,ae.activeStatus,ae.eventSeverity,ae.eventGeneratedTime,ae.address,a.nick_name ";
			basicFromQuery = " from AssetEntity a,AssetEventEntity ae,EventEntity e,EventTypeEntity et,AssetOwnerSnapshotEntity aos,AssetCustomGroupMapping w RIGHT OUTER JOIN w.serial_number x LEFT OUTER JOIN w.group_id c ";
			basicWhereQuery = "where ae.serialNumber = aos.serialNumber " +
					" and ae.eventGeneratedTime between '"+fromdate2+"' and '"+todate2+"' and ae.serialNumber = a.serial_number " +
					" and ae.eventId = e.eventId and ae.eventTypeId = e.eventTypeId and e.eventTypeId = et.eventTypeId and aos.accountId in("+parentAccountEntityListString+")  and x.serial_number = ae.serialNumber";     
			basicOrderByQuery = " order by ae.serialNumber,e.eventTypeId,e.eventId ";
			if( (!(alertTypeIdList==null)) && (alertTypeIdList.size()>0)) {
				String alertTypeIdString = conversionObj.getIntegerListString(alertTypeIdList).toString();
				basicWhereQuery = basicWhereQuery +" AND ae.eventTypeId IN ("+alertTypeIdString+")";
			}
			if (!((MachineProfileIdList == null) || (MachineProfileIdList.isEmpty()))) {
				String machineProfileIdListStringList = conversionObj.getIntegerListString(MachineProfileIdList).toString();
				basicWhereQuery = basicWhereQuery + " and aos.assetGroupId in ("+ machineProfileIdListStringList + ")";
			}
			if (!((ModelidList == null) || (ModelidList.isEmpty()))) {
				String modelIdListStringList = conversionObj.getIntegerListString(ModelidList).toString();
				basicWhereQuery = basicWhereQuery + " and aos.assetTypeId in ("+ modelIdListStringList + ")";
			}
			if (!(MachineGroupIdList == null || MachineGroupIdList.isEmpty())) {
				String customAssetGroupStringList = conversionObj
						.getIntegerListString(MachineGroupIdList).toString();
				basicWhereQuery = basicWhereQuery + " and c.group_id in ("
						+ customAssetGroupStringList + ")";
			}


			finalQuery = basicSelectQuery + basicFromQuery + basicWhereQuery + basicOrderByQuery ;			
		}            
		AssetEntity asset=null;
		String sNum=null;
		Set<String> landmarkAlertPIns = new HashSet<String>();
		try {

			Query query = session.createQuery(finalQuery);
			Iterator itrt = query.list().iterator();          
			Object[] result=null;String category = null;
			while(itrt.hasNext())
			{                 
				result = (Object[]) itrt.next();
				if(result[1]!=null){
					category = result[1].toString();
				}
				if(result[0]!=null){

					asset=(AssetEntity)result[0];
					sNum=asset.getSerial_number().getSerialNumber();
				}
				if(!category.equals("Landmark")){//Keerthi : 24/12/2013:skipping landmark alerts
					implmObj = new NotificationReportDetailsImpl();

				if(result[0]!=null){

					asset=(AssetEntity)result[0];
					sNum=asset.getSerial_number().getSerialNumber();
					implmObj.setSerialNumber(sNum);
				}
				if(result[1]!=null){
					implmObj.setCategory(result[1].toString());
				}
				if(result[2]!=null){
					implmObj.setAlertName(result[2].toString());
				}
				if(result[3]!=null){
					implmObj.setDescription(result[3].toString());
				}
				if(result[4]!=null){
					implmObj.setStatus(result[4].toString());
				}
				if(result[5]!=null){
					implmObj.setSeverity(result[5].toString());
				}
				if(result[6]!=null){
					implmObj.setDateRaised(result[6].toString());
				}
				if(result[7]!=null){
					implmObj.setLocation(result[7].toString());
				}
				if(result[8]!=null){
					implmObj.setMachineName(result[8].toString());
				}
				listNotifications.add(implmObj);
				}
				else if(category.equals("Landmark")){
					//                      Keerthi : 10/01/2014 : getting landmark details of a PIN in one shot to maintain order of PIN in fianl list
					if(!landmarkAlertPIns.contains(sNum)){
						landmarkAlertPIns.add(sNum);
						List<NotificationReportDetailsImpl> landmarkAlertDetails =getLandmarkDetails(sNum,LoginTenancyIdList,fromdate2,todate2,session);
						listNotifications.addAll(landmarkAlertDetails);
					}

				}
				//added by smitha on Dec 17th 2013...DefectID:20131217...for non communicated VIN's
				if(!serNumList.contains(sNum)){
					serNumList.add(sNum);
				}
				//ended ...DefectID:20131217...for non communicated VIN's
			}

			long endTimeTaken = System.currentTimeMillis();
			long totalTimeTaken = endTimeTaken - startTimeTaken;

			iLogger.info("TotalTimeTaken is   " + totalTimeTaken);
			iLogger.info("Exiting getNotificationReportDetails()");
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (session.getTransaction().isActive()) {
				session.getTransaction().commit();
			}

			if (session.isOpen()) {
				session.flush();
				session.close();
			}

		}
		return listNotifications;} 
	//ended on oct 24th 2013....DefectID-20131024

	//	Keerthi : 16-12-2013 : Defect ID : 1555 : GMT to IST conversion : START
	/**
	 * method for utilization detail report
	 */
	public List<UtilizationDetailReportImpl> getUtilizationDetailReport(
			String loginId, List<Integer> tenancyIdList,
			List<Integer> machineGroupIdList,
			List<Integer> machineProfileIdList, List<Integer> modelIdList,
			String period, List<String> serialNumList) {
		
		Logger iLogger = InfoLoggerClass.logger;
		Logger fLogger = FatalLoggerClass.logger;
		List<UtilizationDetailReportImpl> implRespList = new LinkedList<UtilizationDetailReportImpl>();
		UtilizationDetailReportImpl implObj = null;

		TreeMap<String, String> newTimeMap = null;
		TreeMap<String, String> newDateTimeMap = new TreeMap<String, String>();
		TreeMap<String, String> newDateTimeMaptemp = new TreeMap<String, String>();
		TreeMap<String, String> newCurrentDayTimeMap = null;
		TreeMap<String, TreeMap<String, String>> timeMap = null;
		TreeMap<String, TreeMap<String, String>> timeMap2 = null;
		TreeMap<String, TreeMap<String, TreeMap<String, String>>> newSerialNoMap = new TreeMap<String, TreeMap<String, TreeMap<String, String>>>();

		List<String> dateRangeList = new LinkedList<String>();

		Session session = HibernateUtil.getSessionFactory().openSession();
		session.beginTransaction();
		ListToStringConversion conversionObj = new ListToStringConversion();
		String tenancyIdStringList = conversionObj.getIntegerListString(
				tenancyIdList).toString();
		Iterator iterator = null;
		SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
		SimpleDateFormat dateFormat1 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		DateFormat dayFormat = new SimpleDateFormat("EEEE");
		dateRangeList = getDateRangeList(period);
		Calendar calendar1 = Calendar.getInstance();
		Date now = new Date();
		SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm ");
		try {
			DecimalFormat df2 = new DecimalFormat("###.#");
			if (serialNumList == null) {
				serialNumList = new LinkedList<String>();
				Date currentDate = new Date();
				DateUtil dateUtilObj = new DateUtil();
				dateUtilObj = dateUtilObj.getCurrentDateUtility(currentDate);
				int year = dateUtilObj.getYear();

				tenancyIdStringList = conversionObj.getIntegerListString(
						tenancyIdList).toString();

				String ownershipStartDate=null,ownershipEndDate=null;

				if(period!=null){
					if(period.equalsIgnoreCase("Week") || period.equalsIgnoreCase("Last Week")){
						if(dateRangeList.size()>=7){
							ownershipStartDate = dateRangeList.get(0);
							ownershipEndDate = dateRangeList.get(6);
						}	

					}
				}

				String basicQueryString =" select distinct c.serialNumber " +
				" from TenancyBridgeEntity a, AccountTenancyMapping b, AssetAccountMapping c, AssetMonitoringFactDataYearAgg g ";
				String basicWhereQuery =		" where a.childId= b.tenancy_id " +
				" and b.account_id= c.accountId " +
				" and a.parentId in ("+tenancyIdStringList+") and" +
				" ( (c.ownershipStartDate between '"+ownershipStartDate+"' and '"+ownershipEndDate+"') OR " +
				"   (c.ownershipStartDate = ( select max(y.ownershipStartDate) from AssetAccountMapping y " +
				" where y.serialNumber= c.serialNumber" +
				" and y.ownershipStartDate <='"+ownershipStartDate+"')" +
				"    )" +
				" ) and  g.year="+year+" and c.serialNumber=g.serialNumber";



				if ((!(machineProfileIdList == null || machineProfileIdList
						.isEmpty()))
						|| (!(modelIdList == null || modelIdList.isEmpty()))) {
					basicQueryString = basicQueryString
					+ " JOIN g.assetClassDimensionId d ";

					if (!(machineProfileIdList == null || machineProfileIdList
							.isEmpty())) {
						String machineProfileIdStringList = conversionObj
						.getIntegerListString(machineProfileIdList)
						.toString();
						basicWhereQuery = basicWhereQuery
						+ " and d.assetGroupId in ( "
						+ machineProfileIdStringList + " )";
					}

					if (!(modelIdList == null || modelIdList.isEmpty())) {
						String modelIdStringList = conversionObj
						.getIntegerListString(modelIdList).toString();
						basicWhereQuery = basicWhereQuery
						+ " and d.assetTypeId in ( "
						+ modelIdStringList + " )";
					}
				}

				if (!(machineGroupIdList == null || machineGroupIdList
						.isEmpty())) {
					String machineGroupIdStringList = conversionObj
					.getIntegerListString(machineGroupIdList)
					.toString();
					basicQueryString = basicQueryString
					+ " , CustomAssetGroupEntity cag, AssetCustomGroupMapping h ";
					basicWhereQuery = basicWhereQuery
					+ " and cag.group_id = h.group_id and cag.group_id in ("
					+ machineGroupIdStringList + ") and "
					+ " h.serial_number = g.serialNumber ";
				}

				basicQueryString = basicQueryString + basicWhereQuery;
				Query query = session.createQuery(basicQueryString);
				iterator = query.list().iterator();
				Object[] result = null;
				AssetEntity asset = null;
				while (iterator.hasNext()) {
					asset = (AssetEntity) iterator.next();
					if(asset!=null){
						serialNumList.add(asset.getSerial_number().getSerialNumber());
					}					
				}
			}

			int parameterId = 0; // Parameter Id for EngineON - that would be
			String parameterName = null;

			Properties prop = new Properties();
			try {
				prop.load(getClass()
						.getClassLoader()
						.getResourceAsStream(
						"remote/wise/resource/properties/configuration.properties"));
			} catch (IOException e) {
				e.printStackTrace();
			}
			parameterName = prop.getProperty("EngineON");

			Query query = session
			.createQuery("select parameterId from MonitoringParameters where parameterName ='"
					+ parameterName + "' order by parameterId desc");
			query.setMaxResults(1);
			iterator = query.list().iterator();

			while (iterator.hasNext()){
				parameterId = (Integer) iterator.next();
			}
			iLogger.info(df.format(now));
			String currentTime = df.format(now);
			Date currentTime1 = null;
			try {
				currentTime1 = (Date) df.parse(currentTime);
			} catch (ParseException e) {
				e.printStackTrace();
			}
			Date rounded = new Date(
					Math.round((currentTime1.getTime() / (1000.0 * 60 * 10)))
					* (1000 * 60 * 10));
			String exactTime = df.format(rounded);
			if (exactTime != null) {
				currentDateFinal = exactTime.substring(0, 10);
				time = exactTime.substring(11);
			}

			String serialNumberAsStringList = conversionObj.getStringList(
					serialNumList).toString();
			Query query5 = null;
			iterator = dateRangeList.iterator();
			String strCurrDate = null, prevDate = null;
			String currDate = null;	
			List resultList = null;

			double EngineRunningBand1 = 0.0;
			double EngineRunningBand2 = 0.0;
			double EngineRunningBand3 = 0.0;
			double EngineRunningBand4 = 0.0;
			double EngineRunningBand5 = 0.0;
			double EngineRunningBand6 = 0.0;
			double EngineRunningBand7 = 0.0;
			double EngineRunningBand8 = 0.0;
			double workingTime = 0.0;
			double idleTime = 0.0;
			double EngineRunDuration = 0.0;
			double machineUtilizationPerct1 = 0.0;
			String prevtransactionDate=null;
			String transactionDay = null;
			String presentStatus = null, prevStatus = "0";
			String serialNumber = null;
			Object[] resultSet = null;
			String prevSerialNumber = null;
			TreeMap<String, TreeMap<String, ArrayList<String>>> otherValuesMap = new TreeMap<String, TreeMap<String, ArrayList<String>>>();
			TreeMap<String, ArrayList<String>> otherValuesTimeMap = new TreeMap<String, ArrayList<String>>();
			TreeMap<String, ArrayList<String>> otherValuesTimeMaptemp = new TreeMap<String, ArrayList<String>>();
			int index = 0;
			timeMap = new TreeMap<String, TreeMap<String, String>>();
			timeMap2 = new TreeMap<String, TreeMap<String, String>>();
			TreeMap<String, String> updatedMap = null;
			TreeMap<String, LinkedList<String>> PINDates = new TreeMap<String, LinkedList<String>>();
			List<String> nonCommunicatedDates = null;
			ArrayList<String> otherValuesList = new ArrayList<String>();
			List<String> tempDateListRange = null;
			String transactionTimeStamp = null;
			Timestamp transactionTimeStamp1 = null;
			Iterator iteratorOther = null;
			Iterator iterateDate = null;
			//Keerthi : 18/12/2013 : othervalues required = false
			boolean otherValuesRequired = false;
			while (iterator.hasNext()) {
				currDate =(String)iterator.next();
				strCurrDate = currDate;

				Date date3 = dateFormat.parse(strCurrDate);
				Timestamp currTimestamp=new Timestamp(date3.getTime());
				/*//				Date date4 = dateFormat1.parse(currDate);
				calendar1.setTime(date3);
				// get previous day
				calendar1.add(Calendar.DAY_OF_YEAR, -1);

				prevDate = dateFormat.format(calendar1.getTime());
				// data will be take from previous day 6:30 to today 6:20
				prevDate = prevDate + " 18:30:00";
				strCurrDate = strCurrDate + " 18:20:00";*/
				/*query5 = session
						.createSQLQuery("select distinct DATE_ADD(DATE_FORMAT(b.Transaction_Timestamp,'%Y-%m-%d %H:00:00'),INTERVAL      ( (CAST(((MINUTE(b.Transaction_Timestamp))/10) as DECIMAL))*10 ) MINUTE) as Transaction_Timestamp, a.Parameter_Value, b.Serial_Number from asset_monitoring_detail_data a,asset_monitoring_header b  "
								+ "where b.Transaction_Timestamp BETWEEN '"
								+ prevDate
								+ "' and '"
								+ strCurrDate
								+ "' and b.Serial_Number in ("
								+ serialNumberAsStringList
								+ ") and a.Transaction_Number=b.Transaction_Number and a.Parameter_ID="
								+ parameterId
								+ " order by b.Serial_Number ,b.Transaction_Timestamp ASC");
				 */
				/*query5 = session
				.createSQLQuery("select b.Transaction_Timestamp as Transaction_Timestamp, a.Parameter_Value, b.Serial_Number from asset_monitoring_detail_data a,asset_monitoring_header b  "
						+ "where b.Transaction_Timestamp BETWEEN '"
						+ prevDate
						+ "' and '"
						+ strCurrDate
						+ "' and b.Serial_Number in ("
						+ serialNumberAsStringList
						+ ") and a.Transaction_Number=b.Transaction_Number and a.Parameter_ID="
						+ parameterId
						+ " order by b.Serial_Number ,b.Transaction_Timestamp ASC");*/
				query5 = session
				.createSQLQuery("select b.Transaction_Timestamp as Transaction_Timestamp, a.Parameter_Value, b.Serial_Number from asset_monitoring_detail_data a,asset_monitoring_header b  "
						+ "where b.Transaction_Timestamp LIKE '"
						+ currDate
						/*+ "' and '"
						+ strCurrDate*/
						+ "%' and b.Serial_Number in ("
						+ serialNumberAsStringList
						+ ") and a.Transaction_Number=b.Transaction_Number and a.Parameter_ID="
						+ parameterId
						+ " order by b.Serial_Number ,b.Transaction_Timestamp ASC");

				resultList = query5.list();
				iterateDate = resultList.iterator();
				prevSerialNumber = null;
				prevtransactionDate = null;
				otherValuesRequired = false;
				while (iterateDate.hasNext()) {
					resultSet = (Object[]) iterateDate.next();
					if (resultSet[0] != null) {
						transactionTimeStamp1 = (Timestamp) resultSet[0];
					}
					if (resultSet[1] != null) {
						presentStatus = (String) resultSet[1];
					}
					if (resultSet[2] != null) {
						serialNumber = resultSet[2].toString();
					}
					transactionTimeStamp = String.valueOf(transactionTimeStamp1);
					//					transactionTimeStamp1 = Timestamp.valueOf(transactionTimeStamp);					
					transactionDay = dayFormat.format(currTimestamp);
					if (!serialNumber.equals(prevSerialNumber)) {
						otherValuesTimeMap = new TreeMap<String, ArrayList<String>>();
						timeMap = new TreeMap<String, TreeMap<String, String>>();
						newCurrentDayTimeMap = null;
						if (currentDateFinal.equals(currDate)
								&& newCurrentDayTimeMap == null) {
							newTimeMap = getCurrentDateMap();
							newCurrentDayTimeMap = newTimeMap;
						} else {
							newTimeMap = getTimeMap();
						}
						otherValuesRequired = false;
						prevStatus = "0";
					}
					otherValuesRequired = false;
					if (!presentStatus.equals(prevStatus)) {
						if (newTimeMap.equals(newCurrentDayTimeMap)) {
							updatedMap = fillMethod(transactionTimeStamp1,
									presentStatus, newTimeMap, true);
						} else {
							updatedMap = fillMethod(transactionTimeStamp1,
									presentStatus, newTimeMap, false);
						}
					} else {
						updatedMap = newTimeMap;
					}
					timeMap.put(currDate, updatedMap);

					if (newSerialNoMap.containsKey(serialNumber)) {
						if (updatedMap != null) {
							timeMap2 = newSerialNoMap.get(serialNumber);
							timeMap2.put(currDate, updatedMap);
							newSerialNoMap.remove(serialNumber);
							newSerialNoMap.put(serialNumber, timeMap2);
						}
						nonCommunicatedDates = PINDates.get(serialNumber);
						if(nonCommunicatedDates.contains(currDate)){
							nonCommunicatedDates.remove(currDate);
						}					 
						PINDates.put(serialNumber, (LinkedList<String>) nonCommunicatedDates);

					} else if (!newSerialNoMap.containsKey(serialNumber)) {
						newSerialNoMap.put(serialNumber, timeMap);
						tempDateListRange = new LinkedList<String>();
						Iterator<String> rangeIterator = dateRangeList
						.iterator();
						while (rangeIterator.hasNext()) {
							tempDateListRange.add(rangeIterator.next());
						}
						nonCommunicatedDates = tempDateListRange;
						if (nonCommunicatedDates.contains(currDate)) {
							nonCommunicatedDates.remove(currDate);
						}
						PINDates.put(serialNumber,
								(LinkedList<String>) nonCommunicatedDates);
					}

					if (!otherValuesMap.containsKey(serialNumber)){
						otherValuesRequired = true;
					}
					else{
						otherValuesTimeMap = otherValuesMap.get(serialNumber);
						if(!otherValuesTimeMap.containsKey(currDate)){
							otherValuesRequired = true;
						}	

					}
					if(otherValuesRequired){
						index = 0;
						otherValuesList = new ArrayList<String>();
						otherValuesList.add(index++, currDate);

						otherValuesList.add(index++, transactionDay);

						String queryNick = "from AssetEntity where serial_number='"
							+ serialNumber + "'";
						iteratorOther = session.createQuery(queryNick).list()
						.iterator();
						String nickName = null;
						while (iteratorOther.hasNext()) {
							AssetEntity asset = (AssetEntity)iteratorOther.next();
							if(asset!=null){
								if(asset.getNick_name()!=null){
									nickName = asset.getNick_name();
								}
							}

						}
						otherValuesList.add(index++, nickName);
						String subtime = transactionTimeStamp.substring(0, 10);
						String queryFact = "select c.engineOffHours,c.EngineRunningBand1,c.EngineRunningBand2,c.EngineRunningBand3,c.EngineRunningBand4,c.EngineRunningBand5,c.EngineRunningBand6,c.EngineRunningBand7,c.EngineRunningBand8 from AssetMonitoringFactDataDayAgg c where  c. serialNumber='"
							+ serialNumber
							+ "' and c.timeKey like '"
							+ currDate + "%'";
						iteratorOther = session.createQuery(queryFact).list()
						.iterator();
						Object[] resultFact = null;
						while (iteratorOther.hasNext()) {
							resultFact = (Object[]) iteratorOther.next();
							if (resultFact[0] != null) {
								double a = Double.valueOf(df2.format((Double) resultFact[0]));
								String b = String.valueOf(a);
								otherValuesList.add(index++, b);

							} else {
								otherValuesList.add(index++, "0");
							}

							EngineRunningBand1 = (Double) resultFact[1];
							EngineRunningBand2 = (Double) resultFact[2];
							EngineRunningBand3 = (Double) resultFact[3];
							EngineRunningBand4 = (Double) resultFact[4];
							EngineRunningBand5 = (Double) resultFact[5];
							EngineRunningBand6 = (Double) resultFact[6];
							EngineRunningBand7 = (Double) resultFact[7];
							EngineRunningBand8 = (Double) resultFact[8];

							workingTime = (EngineRunningBand3
									+ EngineRunningBand4 + EngineRunningBand5
									+ EngineRunningBand6 + EngineRunningBand7 + EngineRunningBand8);
							idleTime = (EngineRunningBand1 + EngineRunningBand2);
							EngineRunDuration = (workingTime + idleTime);
						}

						otherValuesList.add(index++,
								String.valueOf(EngineRunDuration));
						otherValuesList.add(index++,
								String.valueOf(workingTime));
						machineUtilizationPerct1 = (workingTime / 24) * 100;
						otherValuesList.add(index++,
								String.valueOf(machineUtilizationPerct1));
						otherValuesTimeMap
						.put(currDate, otherValuesList);

						if (!otherValuesMap.containsKey(serialNumber)) {
							otherValuesMap
							.put(serialNumber, otherValuesTimeMap);
						}
						else{
							otherValuesTimeMaptemp = otherValuesMap.get(serialNumber);
							otherValuesTimeMaptemp.put(currDate, otherValuesList);
							otherValuesMap.put(serialNumber, otherValuesTimeMaptemp);

						}
					}
					prevSerialNumber = serialNumber;
					prevStatus = presentStatus;
					prevtransactionDate = currDate;
				}
			}

			AssetDetailsBO assetDetailsBO = new AssetDetailsBO();
			AssetEntity assetEntity = null;
			String nonCommDate = null;
			if (PINDates.size() > 0 && !PINDates.isEmpty()) {
				for (String PIN : PINDates.keySet()) {
					assetEntity = assetDetailsBO.getAssetEntity(PIN);
					nonCommunicatedDates = PINDates.get(PIN);
					Iterator<String> dateIterator = nonCommunicatedDates
					.iterator();
					while (dateIterator.hasNext()) {
						nonCommDate = dateIterator.next();
						iLogger.info(PIN + " non communicated date : "
								+ nonCommDate);
						index = 0;
						otherValuesList = new ArrayList<String>();
						otherValuesList.add(index++, nonCommDate);
						Date nonCommunicatedDate = dateFormat
						.parse(nonCommDate);
						otherValuesList.add(index++,
								String.valueOf(nonCommunicatedDate));
						if (assetEntity != null) {
							otherValuesList.add(index++,
									assetEntity.getNick_name());
						}
						//Keerthi : 20/12/2013 : setting engine off in minutes
						otherValuesList.add(index++, "24.0");
						otherValuesList.add(index++, "0");
						otherValuesList.add(index++, "0");
						otherValuesList.add(index++, "0");
						otherValuesTimeMap = new TreeMap<String, ArrayList<String>>();
						otherValuesTimeMap.put(nonCommDate, otherValuesList);

						if (!otherValuesMap.containsKey(PIN)) {
							otherValuesMap
							.put(serialNumber, otherValuesTimeMap);
						} else {
							otherValuesTimeMaptemp = otherValuesMap.get(PIN);
							if (otherValuesTimeMaptemp != null) {
								otherValuesTimeMaptemp.put(nonCommDate,
										otherValuesList);
								otherValuesMap.put(PIN, otherValuesTimeMaptemp);
							}

						}

						if (nonCommDate.equals(currentDateFinal)) {
							newDateTimeMap = getCurrentDateMap();
						} else {
							newDateTimeMap = getTimeMap();
						}
						if (newSerialNoMap != null) {
							timeMap2 = newSerialNoMap.get(PIN);
							if (timeMap2 != null) {
								timeMap2.put(nonCommDate, newDateTimeMap);
								newSerialNoMap.put(PIN, timeMap2);
							}

						}

					}

				}
			}
			otherValuesList = null;
			for (String entry : otherValuesMap.keySet()) {
				otherValuesTimeMap = otherValuesMap.get(entry);
				for (String dateObj : otherValuesTimeMap.keySet()) {
					otherValuesList = otherValuesTimeMap.get(dateObj);
					implObj = new UtilizationDetailReportImpl();

					implObj.setSerialNumber(entry);
					implObj.setDateInString(otherValuesList.get(0));
					implObj.setDayInString(otherValuesList.get(1));
					implObj.setNickName(otherValuesList.get(2));
					Double engineOffDuration = Double
					.parseDouble(otherValuesList.get(3));
					implObj.setEngineOffDuration(engineOffDuration);
					implObj.setEngineRunDuration(Double
							.parseDouble(otherValuesList.get(4)));
					implObj.setEngineWorkingDuration(Double
							.parseDouble(otherValuesList.get(5)));
					if (otherValuesList.size() == 7) {
						implObj.setMachineUtilizationPerct(Double
								.parseDouble(otherValuesList.get(6)));
					}
					timeMap = newSerialNoMap.get(entry);
					updatedMap = timeMap.get(dateObj);
					if (updatedMap == null) {
						if (otherValuesList.get(0).equals(currentDateFinal)) {
							newDateTimeMaptemp = getCurrentDateMap();
							implObj.setTimeMachineStatusMap(newDateTimeMaptemp);
						} else {
							newDateTimeMaptemp = getTimeMap();
							implObj.setTimeMachineStatusMap(newDateTimeMaptemp);
						}
					} else {
						implObj.setTimeMachineStatusMap(updatedMap);
					}
					implRespList.add(implObj);
				}
			}

			Iterator iterResult = implRespList.iterator();
			String serNum = null;
			iterResult = serialNumList.iterator();

			while (iterResult.hasNext()) {
				serNum = (String) iterResult.next();
				if (newSerialNoMap !=null){
				if (!newSerialNoMap.containsKey(serNum)) {
					iLogger.info(serNum
							+ " not present in neither header nor fact table");
					assetEntity = assetDetailsBO.getAssetEntity(serNum);
					for (String date : dateRangeList) {
						implObj = new UtilizationDetailReportImpl();
						implObj.setDateInString(date);
						Date nonCommunicatedDate = dateFormat.parse(date);
						implObj.setDayInString(dayFormat
								.format(nonCommunicatedDate));
						implObj.setDaysWithNoEngineRun(0);
						//						Keerthi : 20/12/2013
						implObj.setEngineOffDuration(24d);
						implObj.setEngineRunDuration(0.0d);
						implObj.setEngineWorkingDuration(0.0d);
						implObj.setMachineUtilizationPerct(0.0d);
						if (assetEntity != null) {
							implObj.setNickName(assetEntity.getNick_name());
						}
						implObj.setSerialNumber(serNum);
						if (date.equals(currentDateFinal)) {
							newDateTimeMap = getCurrentDateMap();
						} else {
							newDateTimeMap = getTimeMap();
						}
						implObj.setTimeMachineStatusMap(newDateTimeMap);
						implRespList.add(implObj);
					}
				}
				}

			}
			iLogger
			.info(" final impl resp list size " + implRespList.size());
		} catch (Exception e) {
			e.printStackTrace();
			fLogger.fatal("Exception :" + e);

		}

		finally {
			if (session.getTransaction().isActive()) {
				session.getTransaction().commit();
			}

			if (session.isOpen()) {
				session.flush();
				session.close();
			}

		}

		return implRespList;
	}

	/**
	 * method for fleet utilization details 
	 */
	public List<UtilizationDetailReportImpl> getFleetUtilizationDetails(
			String loginId, List<Integer> tenancyIdList,
			List<Integer> machineGroupIdList,
			List<Integer> machineProfileIdList, List<Integer> modelIdList,
			String period, List<String> serialNumList) {
		Logger fLogger = FatalLoggerClass.logger;
		Logger bLogger = BusinessErrorLoggerClass.logger;
		Logger iLogger = InfoLoggerClass.logger;
		List<UtilizationDetailReportImpl> implRespList = new LinkedList<UtilizationDetailReportImpl>();
		UtilizationDetailReportImpl implObj = null;

		
		HashMap asset2SegID = new HashMap();
		TreeMap<String, String> newTimeMap = null;
		TreeMap<String, String> newDateTimeMap = new TreeMap<String, String>();
		TreeMap<String, String> newDateTimeMaptemp = new TreeMap<String, String>();
		TreeMap<String, String> newCurrentDayTimeMap = null;
		TreeMap<String, TreeMap<String, String>> timeMap = null;
		TreeMap<String, TreeMap<String, String>> timeMap2 = null;
		TreeMap<String, TreeMap<String, TreeMap<String, String>>> newSerialNoMap = new TreeMap<String, TreeMap<String, TreeMap<String, String>>>();

		List<String> dateRangeList = new LinkedList<String>();

		Session session = HibernateUtil.getSessionFactory().openSession();
		session.beginTransaction();
		ListToStringConversion conversionObj = new ListToStringConversion();
		String tenancyIdStringList = conversionObj.getIntegerListString(
				tenancyIdList).toString();
		Iterator iterator = null;
		SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
		SimpleDateFormat dateFormat1 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		DateFormat dayFormat = new SimpleDateFormat("EEEE");
		dateRangeList = getDateRangeList(period);
		Calendar calendar1 = Calendar.getInstance();
		Date now = new Date();
		SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm ");
		try {
			DecimalFormat df2 = new DecimalFormat("###.#");
			if (serialNumList == null) {
				serialNumList = new LinkedList<String>();
				Date currentDate = new Date();
				DateUtil dateUtilObj = new DateUtil();
				dateUtilObj = dateUtilObj.getCurrentDateUtility(currentDate);
				int year = dateUtilObj.getYear();

				tenancyIdStringList = conversionObj.getIntegerListString(
						tenancyIdList).toString();

				String ownershipStartDate=null,ownershipEndDate=null;

				if(period!=null){
					if(period.equalsIgnoreCase("Week") || period.equalsIgnoreCase("Last Week")){
						if(dateRangeList.size()>=7){
							ownershipStartDate = dateRangeList.get(0);
							ownershipEndDate = dateRangeList.get(6);
						}	

					}
				}

				String basicQueryString =" select distinct c.serialNumber " +
				" from TenancyBridgeEntity a, AccountTenancyMapping b, AssetAccountMapping c, AssetMonitoringFactDataYearAgg g ";
				String basicWhereQuery =		" where a.childId= b.tenancy_id " +
				" and b.account_id= c.accountId " +
				" and a.parentId in ("+tenancyIdStringList+") and" +
				" ( (c.ownershipStartDate between '"+ownershipStartDate+"' and '"+ownershipEndDate+"') OR " +
				"   (c.ownershipStartDate = ( select max(y.ownershipStartDate) from AssetAccountMapping y " +
				" where y.serialNumber= c.serialNumber" +
				" and y.ownershipStartDate <='"+ownershipStartDate+"')" +
				"    )" +
				" ) and  g.year="+year+" and c.serialNumber=g.serialNumber";



				if ((!(machineProfileIdList == null || machineProfileIdList
						.isEmpty()))
						|| (!(modelIdList == null || modelIdList.isEmpty()))) {
					basicQueryString = basicQueryString
					+ " JOIN g.assetClassDimensionId d ";

					if (!(machineProfileIdList == null || machineProfileIdList
							.isEmpty())) {
						String machineProfileIdStringList = conversionObj
						.getIntegerListString(machineProfileIdList)
						.toString();
						basicWhereQuery = basicWhereQuery
						+ " and d.assetGroupId in ( "
						+ machineProfileIdStringList + " )";
					}

					if (!(modelIdList == null || modelIdList.isEmpty())) {
						String modelIdStringList = conversionObj
						.getIntegerListString(modelIdList).toString();
						basicWhereQuery = basicWhereQuery
						+ " and d.assetTypeId in ( "
						+ modelIdStringList + " )";
					}
				}

				if (!(machineGroupIdList == null || machineGroupIdList
						.isEmpty())) {
					String machineGroupIdStringList = conversionObj
					.getIntegerListString(machineGroupIdList)
					.toString();
					basicQueryString = basicQueryString
					+ " , CustomAssetGroupEntity cag, AssetCustomGroupMapping h ";
					basicWhereQuery = basicWhereQuery
					+ " and cag.group_id = h.group_id and cag.group_id in ("
					+ machineGroupIdStringList + ") and "
					+ " h.serial_number = g.serialNumber ";
				}

				basicQueryString = basicQueryString + basicWhereQuery;
				iLogger.info(">>>>>basicQueryString ::"+basicQueryString);
				Query query = session.createQuery(basicQueryString);
				iterator = query.list().iterator();
				Object[] result = null;
				AssetEntity asset = null;
				while (iterator.hasNext()) {
					asset = (AssetEntity) iterator.next();
					if(asset!=null){
						serialNumList.add(asset.getSerial_number().getSerialNumber());
						asset2SegID.put(asset.getSerial_number().getSerialNumber(), asset.getSegmentId());
					}					
				}
			}
			else{
				AssetEntity asset = null;
				for(String assetID : serialNumList){
					asset = new AssetDetailsBO().getAssetEntity(assetID);
					asset2SegID.put(asset.getSerial_number().getSerialNumber(), asset.getSegmentId());
				}
			}
			
		/*	int parameterId = 0; // Parameter Id for EngineON - that would be
			String parameterName = null;

			Properties prop = new Properties();
			try {
				prop.load(getClass()
						.getClassLoader()
						.getResourceAsStream(
						"remote/wise/resource/properties/configuration.properties"));
			} catch (IOException e) {
				e.printStackTrace();
			}
			parameterName = prop.getProperty("EngineON");

			Query query = session
			.createQuery("select parameterId from MonitoringParameters where parameterName ='"
					+ parameterName + "' order by parameterId desc");
			query.setMaxResults(1);
			iterator = query.list().iterator();

			while (iterator.hasNext()){
				parameterId = (Integer) iterator.next();
			}*/
			iLogger.info(df.format(now));
			String currentTime = df.format(now);
			Date currentTime1 = null;
			try {
				currentTime1 = (Date) df.parse(currentTime);
			} catch (ParseException e) {
				e.printStackTrace();
			}
			Date rounded = new Date(
					Math.round((currentTime1.getTime() / (1000.0 * 60 * 10)))
					* (1000 * 60 * 10));
			String exactTime = df.format(rounded);
			if (exactTime != null) {
				currentDateFinal = exactTime.substring(0, 10);
				time = exactTime.substring(11);
			}

			String serialNumberAsStringList = conversionObj.getStringList(
					serialNumList).toString();
			Query query5 = null;
			iterator = dateRangeList.iterator();
			String strCurrDate = null, prevDate = null;
			String currDate = null;	
			//List resultList = null;
			List<AssetMonitoringParametersDAO> resultList = null;
			double EngineRunningBand1 = 0.0;
			double EngineRunningBand2 = 0.0;
			double EngineRunningBand3 = 0.0;
			double EngineRunningBand4 = 0.0;
			double EngineRunningBand5 = 0.0;
			double EngineRunningBand6 = 0.0;
			double EngineRunningBand7 = 0.0;
			double EngineRunningBand8 = 0.0;
			double workingTime = 0.0;
			double idleTime = 0.0;
			double EngineRunDuration = 0.0;
			double machineUtilizationPerct1 = 0.0;
			String prevtransactionDate=null;
			String transactionDay = null;
			String presentStatus = null, prevStatus = "0";
			String serialNumber = null;
			Object[] resultSet = null;
			String prevSerialNumber = null;
			TreeMap<String, TreeMap<String, ArrayList<String>>> otherValuesMap = new TreeMap<String, TreeMap<String, ArrayList<String>>>();
			TreeMap<String, ArrayList<String>> otherValuesTimeMap = new TreeMap<String, ArrayList<String>>();
			TreeMap<String, ArrayList<String>> otherValuesTimeMaptemp = new TreeMap<String, ArrayList<String>>();
			int index = 0;
			timeMap = new TreeMap<String, TreeMap<String, String>>();
			timeMap2 = new TreeMap<String, TreeMap<String, String>>();
			TreeMap<String, String> updatedMap = null;
			TreeMap<String, LinkedList<String>> PINDates = new TreeMap<String, LinkedList<String>>();
			List<String> nonCommunicatedDates = null;
			ArrayList<String> otherValuesList = new ArrayList<String>();
			List<String> tempDateListRange = null;
			String transactionTimeStamp = null;
			Timestamp transactionTimeStamp1 = null;
			Iterator iteratorOther = null;
			Iterator iterateDate = null;
			//Keerthi : 18/12/2013 : othervalues required = false
			boolean otherValuesRequired = false;
			
			/*List parametreIDList = new LinkedList();
			parametreIDList.add(parameterId);*/
			
			while (iterator.hasNext()) {
				currDate =(String)iterator.next();
				strCurrDate = currDate;

				Date date3 = dateFormat.parse(strCurrDate);
				Timestamp currTimestamp=new Timestamp(date3.getTime());
				//				Date date4 = dateFormat1.parse(currDate);
				calendar1.setTime(date3);
				// get previous day
				calendar1.add(Calendar.DAY_OF_YEAR, -1);

				prevDate = dateFormat.format(calendar1.getTime());
				// data will be take from previous day 6:30 to today 6:20
				prevDate = prevDate + " 18:30:00";
				strCurrDate = strCurrDate + " 18:20:00";
				/*query5 = session
						.createSQLQuery("select distinct DATE_ADD(DATE_FORMAT(b.Transaction_Timestamp,'%Y-%m-%d %H:00:00'),INTERVAL      ( (CAST(((MINUTE(b.Transaction_Timestamp))/10) as DECIMAL))*10 ) MINUTE) as Transaction_Timestamp, a.Parameter_Value, b.Serial_Number from asset_monitoring_detail_data a,asset_monitoring_header b  "
								+ "where b.Transaction_Timestamp BETWEEN '"
								+ prevDate
								+ "' and '"
								+ strCurrDate
								+ "' and b.Serial_Number in ("
								+ serialNumberAsStringList
								+ ") and a.Transaction_Number=b.Transaction_Number and a.Parameter_ID="
								+ parameterId
								+ " order by b.Serial_Number ,b.Transaction_Timestamp ASC");
				 */
				/*query5 = session
				.createSQLQuery("select b.Transaction_Timestamp as Transaction_Timestamp, a.Parameter_Value, b.Serial_Number from asset_monitoring_detail_data a,asset_monitoring_header b  "
						+ "where b.Transaction_Timestamp BETWEEN '"
						+ prevDate
						+ "' and '"
						+ strCurrDate
						+ "' and b.Serial_Number in ("
						+ serialNumberAsStringList
						+ ") and a.Transaction_Number=b.Transaction_Number and a.Parameter_ID="
						+ parameterId
						+ " order by b.Serial_Number ,b.Transaction_Timestamp ASC");*/
				
				//DF20161222 @Roopa changing asset_monitoring_header and detail data table to one single TAssetMonData table which is having txndata as json column
				
				
				resultList = new DynamicAMH_DAL().getAMPValuesInTxnRange(asset2SegID, currDate, period);
				
				
				//resultList = new DynamicAMH_DAL().getAMPValuesInTxnRange(asset2SegID, currDate, parametreIDList);
				/*query5 = session
				.createSQLQuery("select b.Transaction_Timestamp as Transaction_Timestamp, a.Parameter_Value, b.Serial_Number from asset_monitoring_detail_data a,asset_monitoring_header b  "
						+ "where b.Transaction_Timestamp LIKE '"
						+ currDate
						+ "' and '"
						+ strCurrDate
						+ "%' and b.Serial_Number in ("
						+ serialNumberAsStringList
						+ ") and a.Transaction_Number=b.Transaction_Number and a.Parameter_ID="
						+ parameterId
						+ " order by b.Serial_Number ,b.Transaction_Timestamp ASC");*/

				//resultList = query5.list();
				iterateDate = resultList.iterator();
				prevSerialNumber = null;
				prevtransactionDate = null;
				otherValuesRequired = false;
				while (iterateDate.hasNext()) {
					AssetMonitoringParametersDAO daoObject = (AssetMonitoringParametersDAO) iterateDate.next();
					if (daoObject.getTransactionTS() != null) {
						transactionTimeStamp1 = daoObject.getTransactionTS();
					}
					if (daoObject.getParameterValue() != null) {
						presentStatus = daoObject.getParameterValue();
						//System.out.println("presentStatus"+presentStatus);
					}
					if (daoObject.getSerial_Number() != null) {
						serialNumber = daoObject.getSerial_Number();
					}
					
					
					
					transactionTimeStamp = String.valueOf(transactionTimeStamp1);
					//					transactionTimeStamp1 = Timestamp.valueOf(transactionTimeStamp);					
					transactionDay = dayFormat.format(currTimestamp);
					if (!serialNumber.equals(prevSerialNumber)) {
						otherValuesTimeMap = new TreeMap<String, ArrayList<String>>();
						timeMap = new TreeMap<String, TreeMap<String, String>>();
						newCurrentDayTimeMap = null;
						if (currentDateFinal.equals(currDate)
								&& newCurrentDayTimeMap == null) {
							newTimeMap = getCurrentDateMap();
							newCurrentDayTimeMap = newTimeMap;
						} else {
							newTimeMap = getTimeMap();
						}
						otherValuesRequired = false;
						prevStatus = "0";
					}
					otherValuesRequired = false;
					if (!presentStatus.equals(prevStatus)) {
						if (newTimeMap.equals(newCurrentDayTimeMap)) {
							updatedMap = fleetFillMethod(transactionTimeStamp1,
									presentStatus, newTimeMap, true);
						} else {
							updatedMap = fleetFillMethod(transactionTimeStamp1,
									presentStatus, newTimeMap, false);
						}
					} else {
						updatedMap = newTimeMap;
					}
					timeMap.put(currDate, updatedMap);

					if (newSerialNoMap.containsKey(serialNumber)) {
						if (updatedMap != null) {
							timeMap2 = newSerialNoMap.get(serialNumber);
							timeMap2.put(currDate, updatedMap);
							newSerialNoMap.remove(serialNumber);
							newSerialNoMap.put(serialNumber, timeMap2);
						}
						nonCommunicatedDates = PINDates.get(serialNumber);
						if(nonCommunicatedDates.contains(currDate)){
							nonCommunicatedDates.remove(currDate);
						}					 
						PINDates.put(serialNumber, (LinkedList<String>) nonCommunicatedDates);

					} else if (!newSerialNoMap.containsKey(serialNumber)) {
						newSerialNoMap.put(serialNumber, timeMap);
						tempDateListRange = new LinkedList<String>();
						Iterator<String> rangeIterator = dateRangeList
						.iterator();
						while (rangeIterator.hasNext()) {
							tempDateListRange.add(rangeIterator.next());
						}
						nonCommunicatedDates = tempDateListRange;
						if (nonCommunicatedDates.contains(currDate)) {
							nonCommunicatedDates.remove(currDate);
						}
						PINDates.put(serialNumber,
								(LinkedList<String>) nonCommunicatedDates);
					}

					if (!otherValuesMap.containsKey(serialNumber)){
						otherValuesRequired = true;
					}
					else{
						otherValuesTimeMap = otherValuesMap.get(serialNumber);
						if(!otherValuesTimeMap.containsKey(currDate)){
							otherValuesRequired = true;
						}	

					}
					if(otherValuesRequired){
						index = 0;
						otherValuesList = new ArrayList<String>();
						otherValuesList.add(index++, currDate);

						otherValuesList.add(index++, transactionDay);
						String nickName=null;

					/*	String queryNick = "select nick_name from AssetEntity where serial_number='"
							+ serialNumber + "'";
						iteratorOther = session.createQuery(queryNick).list()
						.iterator();
						Object[] nickNameobj = null;
						String nickName=null;
						if (iteratorOther.hasNext()) {
							if(iteratorOther.next()!=null){
								nickNameobj = (Object[]) iteratorOther.next();
							nickName=(String) nickNameobj[0];
							}
						}*/
						otherValuesList.add(index++, nickName);
						String subtime = transactionTimeStamp.substring(0, 10);
						String queryFact = "select c.engineOffHours,c.EngineRunningBand1,c.EngineRunningBand2,c.EngineRunningBand3,c.EngineRunningBand4,c.EngineRunningBand5,c.EngineRunningBand6,c.EngineRunningBand7,c.EngineRunningBand8 from AssetMonitoringFactDataDayAgg c where  c. serialNumber='"
							+ serialNumber
							+ "' and c.timeKey like '"
							+ currDate + "%'";
						iteratorOther = session.createQuery(queryFact).list()
						.iterator();
						Object[] resultFact = null;
						while (iteratorOther.hasNext()) {
							resultFact = (Object[]) iteratorOther.next();
							if (resultFact[0] != null) {
								double a = Double.valueOf(df2.format((Double) resultFact[0]));
								String b = String.valueOf(a);
								otherValuesList.add(index++, b);

							} else {
								otherValuesList.add(index++, "0");
							}

							EngineRunningBand1 = (Double) resultFact[1];
							EngineRunningBand2 = (Double) resultFact[2];
							EngineRunningBand3 = (Double) resultFact[3];
							EngineRunningBand4 = (Double) resultFact[4];
							EngineRunningBand5 = (Double) resultFact[5];
							EngineRunningBand6 = (Double) resultFact[6];
							EngineRunningBand7 = (Double) resultFact[7];
							EngineRunningBand8 = (Double) resultFact[8];

							workingTime = (EngineRunningBand3
									+ EngineRunningBand4 + EngineRunningBand5
									+ EngineRunningBand6 + EngineRunningBand7 + EngineRunningBand8);
							idleTime = (EngineRunningBand1 + EngineRunningBand2);
							EngineRunDuration = (workingTime + idleTime);
						}

						otherValuesList.add(index++,
								String.valueOf(EngineRunDuration));
						otherValuesList.add(index++,
								String.valueOf(workingTime));
						machineUtilizationPerct1 = (workingTime / 24) * 100;
						otherValuesList.add(index++,
								String.valueOf(machineUtilizationPerct1));
						otherValuesTimeMap
						.put(currDate, otherValuesList);

						if (!otherValuesMap.containsKey(serialNumber)) {
							otherValuesMap
							.put(serialNumber, otherValuesTimeMap);
						}
						else{
							otherValuesTimeMaptemp = otherValuesMap.get(serialNumber);
							otherValuesTimeMaptemp.put(currDate, otherValuesList);
							otherValuesMap.put(serialNumber, otherValuesTimeMaptemp);

						}
					}
					prevSerialNumber = serialNumber;
					prevStatus = presentStatus;
					prevtransactionDate = currDate;
				}
			}

			AssetDetailsBO assetDetailsBO = new AssetDetailsBO();
			AssetEntity assetEntity = null;
			String nonCommDate = null;
			if (PINDates.size() > 0 && !PINDates.isEmpty()) {
				for (String PIN : PINDates.keySet()) {
					assetEntity = assetDetailsBO.getAssetEntity(PIN);
					nonCommunicatedDates = PINDates.get(PIN);
					Iterator<String> dateIterator = nonCommunicatedDates
					.iterator();
					while (dateIterator.hasNext()) {
						nonCommDate = dateIterator.next();
						iLogger.info(PIN + " non communicated date : "
								+ nonCommDate);
						index = 0;
						otherValuesList = new ArrayList<String>();
						otherValuesList.add(index++, nonCommDate);
						Date nonCommunicatedDate = dateFormat
						.parse(nonCommDate);
						otherValuesList.add(index++,
								String.valueOf(nonCommunicatedDate));
						if (assetEntity != null) {
							otherValuesList.add(index++,
									assetEntity.getNick_name());
						}
						//Keerthi : 20/12/2013 : setting engine off in minutes
						otherValuesList.add(index++, "24.0");
						otherValuesList.add(index++, "0");
						otherValuesList.add(index++, "0");
						otherValuesList.add(index++, "0");
						otherValuesTimeMap = new TreeMap<String, ArrayList<String>>();
						otherValuesTimeMap.put(nonCommDate, otherValuesList);

						if (!otherValuesMap.containsKey(PIN)) {
							otherValuesMap
							.put(serialNumber, otherValuesTimeMap);
						} else {
							otherValuesTimeMaptemp = otherValuesMap.get(PIN);
							if (otherValuesTimeMaptemp != null) {
								otherValuesTimeMaptemp.put(nonCommDate,
										otherValuesList);
								otherValuesMap.put(PIN, otherValuesTimeMaptemp);
							}

						}

						if (nonCommDate.equals(currentDateFinal)) {
							newDateTimeMap = getCurrentDateMap();
						} else {
							newDateTimeMap = getTimeMap();
						}
						if (newSerialNoMap != null) {
							timeMap2 = newSerialNoMap.get(PIN);
							if (timeMap2 != null) {
								timeMap2.put(nonCommDate, newDateTimeMap);
								newSerialNoMap.put(PIN, timeMap2);
							}

						}

					}

				}
			}
			otherValuesList = null;
			for (String entry : otherValuesMap.keySet()) {
				otherValuesTimeMap = otherValuesMap.get(entry);
				for (String dateObj : otherValuesTimeMap.keySet()) {
					otherValuesList = otherValuesTimeMap.get(dateObj);
					implObj = new UtilizationDetailReportImpl();

					implObj.setSerialNumber(entry);
					implObj.setDateInString(otherValuesList.get(0));
					implObj.setDayInString(otherValuesList.get(1));
					implObj.setNickName(otherValuesList.get(2));
					Double engineOffDuration = Double
					.parseDouble(otherValuesList.get(3));
					implObj.setEngineOffDuration(engineOffDuration);
					implObj.setEngineRunDuration(Double
							.parseDouble(otherValuesList.get(4)));
					implObj.setEngineWorkingDuration(Double
							.parseDouble(otherValuesList.get(5)));
					if (otherValuesList.size() == 7) {
						implObj.setMachineUtilizationPerct(Double
								.parseDouble(otherValuesList.get(6)));
					}
					timeMap = newSerialNoMap.get(entry);
					updatedMap = timeMap.get(dateObj);
					if (updatedMap == null) {
						if (otherValuesList.get(0).equals(currentDateFinal)) {
							newDateTimeMaptemp = getCurrentDateMap();
							implObj.setTimeMachineStatusMap(newDateTimeMaptemp);
						} else {
							newDateTimeMaptemp = getTimeMap();
							implObj.setTimeMachineStatusMap(newDateTimeMaptemp);
						}
					} else {
						implObj.setTimeMachineStatusMap(updatedMap);
					}
					implRespList.add(implObj);
				}
			}

			Iterator iterResult = implRespList.iterator();
			String serNum = null;
			iterResult = serialNumList.iterator();

			while (iterResult.hasNext()) {
				serNum = (String) iterResult.next();
				if (!newSerialNoMap.containsKey(serNum)) {
					iLogger.info(serNum
							+ " not present in neither header nor fact table");
					assetEntity = assetDetailsBO.getAssetEntity(serNum);
					for (String date : dateRangeList) {
						implObj = new UtilizationDetailReportImpl();
						implObj.setDateInString(date);
						Date nonCommunicatedDate = dateFormat.parse(date);
						implObj.setDayInString(dayFormat
								.format(nonCommunicatedDate));
						implObj.setDaysWithNoEngineRun(0);
						//						Keerthi : 20/12/2013
						implObj.setEngineOffDuration(24d);
						implObj.setEngineRunDuration(0.0d);
						implObj.setEngineWorkingDuration(0.0d);
						implObj.setMachineUtilizationPerct(0.0d);
						if (assetEntity != null) {
							implObj.setNickName(assetEntity.getNick_name());
						}
						implObj.setSerialNumber(serNum);
						if (date.equals(currentDateFinal)) {
							newDateTimeMap = getCurrentDateMap();
						} else {
							newDateTimeMap = getTimeMap();
						}
						implObj.setTimeMachineStatusMap(newDateTimeMap);
						implRespList.add(implObj);
					}
				}

			}
			iLogger
			.info(" final impl resp list size " + implRespList.size());
		} catch (Exception e) {
			e.printStackTrace();
			fLogger.fatal("Exception :" + e);

		}

		finally {
			if (session.getTransaction().isActive()) {
				session.getTransaction().commit();
			}

			if (session.isOpen()) {
				session.flush();
				session.close();
			}

		}

		return implRespList;
	}
	/**
	 * method to get date range list
	 * @param period
	 * @return
	 */
	
	//Commenting the old logic @Roopa since the diff in days is not working properly
/*	public List<String> getDateRangeList(String period) {
		List<String> dateRangeList = new LinkedList<String>();
		String firstDay = null, secondDay = null, thirdDay = null, fourthDay = null, fifthDay = null, sixthDay = null, seventhDay = null;
		String startDateTime = null;
		SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
		long diff = 0l;
		String endDateTime = null;
		Date currentDate = new Date();
		DateUtil dateUtilObj = new DateUtil();
		if (period.equalsIgnoreCase("Week")) {
			dateUtilObj = dateUtilObj.getCurrentDateUtility(currentDate);
		} else if (period.equalsIgnoreCase("Last Week")) {
			dateUtilObj = dateUtilObj.getPreviousDateUtility(currentDate);
		}
		int week = dateUtilObj.getWeek();
		Calendar cal = Calendar.getInstance();
		if (period.equalsIgnoreCase("Week")) {
			cal.setTime(new Date());
			cal.set(Calendar.WEEK_OF_YEAR, week);
			cal.set(Calendar.DAY_OF_WEEK, Calendar.SUNDAY);
			startDateTime = dateFormat.format(cal.getTime());

			firstDay = dateFormat.format(cal.getTime());
			endDateTime = dateFormat.format(currentDate);
			diff = differnceInDays(firstDay, endDateTime);
			//			diff = diff-1;//avoiding today's data in chart as ETL data not available for today
			cal.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY);
			secondDay = dateFormat.format(cal.getTime());
			cal.set(Calendar.DAY_OF_WEEK, Calendar.TUESDAY);
			thirdDay = dateFormat.format(cal.getTime());
			cal.set(Calendar.DAY_OF_WEEK, Calendar.WEDNESDAY);
			fourthDay = dateFormat.format(cal.getTime());
			cal.set(Calendar.DAY_OF_WEEK, Calendar.THURSDAY);
			fifthDay = dateFormat.format(cal.getTime());
			cal.set(Calendar.DAY_OF_WEEK, Calendar.FRIDAY);
			sixthDay = dateFormat.format(cal.getTime());
			if (diff == 0l) {
				dateRangeList.add(firstDay);
			} else if (diff == 1l) {
				dateRangeList.add(firstDay);
				//dateRangeList.add(endDateTime);
			} else if (diff == 2l) {
				dateRangeList.add(firstDay);
				dateRangeList.add(secondDay);
				//dateRangeList.add(endDateTime);
			} else if (diff == 3l) {
				dateRangeList.add(firstDay);
				dateRangeList.add(secondDay);
				dateRangeList.add(thirdDay);
				//dateRangeList.add(endDateTime);
			} else if (diff == 4l) {
				dateRangeList.add(firstDay);
				dateRangeList.add(secondDay);
				dateRangeList.add(thirdDay);
				dateRangeList.add(fourthDay);
				//dateRangeList.add(endDateTime);
			} else if (diff == 5l) {
				dateRangeList.add(firstDay);
				dateRangeList.add(secondDay);
				dateRangeList.add(thirdDay);
				dateRangeList.add(fourthDay);
				dateRangeList.add(fifthDay);
				//dateRangeList.add(endDateTime);
			} else if (diff == 6l) {
				dateRangeList.add(firstDay);
				dateRangeList.add(secondDay);
				dateRangeList.add(thirdDay);
				dateRangeList.add(fourthDay);
				dateRangeList.add(fifthDay);
				dateRangeList.add(sixthDay);
				//dateRangeList.add(endDateTime);
			}

		} else if (period.equalsIgnoreCase("Today")) {
			cal.setTime(new Date());
			startDateTime = dateFormat.format(cal.getTime());
			dateRangeList.add(startDateTime);
		} else if ((period.equalsIgnoreCase("Last Week"))) {
			cal.set(Calendar.WEEK_OF_YEAR, week);
			cal.set(Calendar.DAY_OF_WEEK, Calendar.SUNDAY);
			startDateTime = dateFormat.format(cal.getTime());

			firstDay = dateFormat.format(cal.getTime());
			cal.set(Calendar.DAY_OF_WEEK, Calendar.SATURDAY);
			endDateTime = dateFormat.format(cal.getTime());
			seventhDay = dateFormat.format(cal.getTime());
			cal.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY);
			secondDay = dateFormat.format(cal.getTime());
			cal.set(Calendar.DAY_OF_WEEK, Calendar.TUESDAY);
			thirdDay = dateFormat.format(cal.getTime());
			cal.set(Calendar.DAY_OF_WEEK, Calendar.WEDNESDAY);
			fourthDay = dateFormat.format(cal.getTime());
			cal.set(Calendar.DAY_OF_WEEK, Calendar.THURSDAY);
			fifthDay = dateFormat.format(cal.getTime());
			cal.set(Calendar.DAY_OF_WEEK, Calendar.FRIDAY);
			sixthDay = dateFormat.format(cal.getTime());
			dateRangeList.add(firstDay);
			dateRangeList.add(secondDay);
			dateRangeList.add(thirdDay);
			dateRangeList.add(fourthDay);
			dateRangeList.add(fifthDay);
			dateRangeList.add(sixthDay);
			dateRangeList.add(seventhDay);
		}
		return dateRangeList;
	}*/
	
	//DF20160603 @ Roopa changed the logic to take diff in days from two dates.
		public static List<String> getDateRangeList(String period) {
			List<String> dateRangeList = new LinkedList<String>();
			String firstDay = null, secondDay = null, thirdDay = null, fourthDay = null, fifthDay = null, sixthDay = null, seventhDay = null;
			String startDateTime = null;
			SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
			
			Date currentDate = new Date();
			DateUtil dateUtilObj = new DateUtil();
			String stringWeekDate=null; //Declared by Zakir
			Calendar cal = Calendar.getInstance();

			if (period.equalsIgnoreCase("Week")) {
				dateUtilObj = dateUtilObj.getCurrentDateUtility(currentDate);
			} else if (period.equalsIgnoreCase("Last Week")) {
				dateUtilObj = dateUtilObj.getPreviousDateUtility(currentDate);
			}
			//DF20190107 @ Zakir created the logic to get fleet utilization charts-Monthly (4 weeks)
			//period format will be in Week|yyyy-MM-dd
			else if(period.contains("|")) {
				//splits the string based on pipe
				stringWeekDate = period.split("\\|")[1];
				period = period.split("\\|")[0];
				Date WeekDate = null;
				try {
					WeekDate = dateFormat.parse(stringWeekDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}
				//System.out.println(period + "\n" + WeekDate);
				dateUtilObj = dateUtilObj.getCurrentDateUtility(WeekDate);
				cal.setTime(WeekDate); 
			}
			
			int week = dateUtilObj.getWeek();
			//System.out.println("Week number::"+week);
			/*Calendar cal = Calendar.getInstance();   Commented by Zakir and created this variable at the beginning of this method*/
			if (period.equalsIgnoreCase("Week")) {
				//cal.setTime(new Date());
				cal.set(Calendar.WEEK_OF_YEAR, week);
				int currDay = 0;
				
				//DF20190107 @ Zakir created below logic to set currDay as 7 if stringWeekDate is not empty/null so as to get report of 7 days in that week
				if(stringWeekDate==null){
					cal.setTime(new Date());
					 currDay = cal.get(Calendar.DAY_OF_WEEK); //gives the cuurent day number in the week
				}
				else{
					 currDay=7;
				}
			
				//*************************************DF20190107-END******************************************
				
				/* int currDay = cal.get(Calendar.DAY_OF_WEEK); //gives the cuurent day number in the week
				Above code needs to be removed */
				
				cal.set(Calendar.DAY_OF_WEEK, Calendar.SUNDAY);
				firstDay = dateFormat.format(cal.getTime());
				
				//System.out.println("First day::"+firstDay);
				
				cal.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY);
				secondDay = dateFormat.format(cal.getTime());
				
				//System.out.println("secondDay day::"+secondDay);
				
				cal.set(Calendar.DAY_OF_WEEK, Calendar.TUESDAY);
				thirdDay = dateFormat.format(cal.getTime());
				//System.out.println("thirdDay day::"+thirdDay);
				cal.set(Calendar.DAY_OF_WEEK, Calendar.WEDNESDAY);
				fourthDay = dateFormat.format(cal.getTime());
				//System.out.println("fourthDay day::"+fourthDay);
				cal.set(Calendar.DAY_OF_WEEK, Calendar.THURSDAY);
				fifthDay = dateFormat.format(cal.getTime());
				//System.out.println("fifthDay day::"+fifthDay);
				cal.set(Calendar.DAY_OF_WEEK, Calendar.FRIDAY);
				sixthDay = dateFormat.format(cal.getTime());
				
				//DF20190119-KO369761-Saturday was also included into the calender object as it was missed and throwing a null pointer exception.
				cal.set(Calendar.DAY_OF_WEEK, Calendar.SATURDAY);
				seventhDay = dateFormat.format(cal.getTime());
				
				//System.out.println("sixthDay day::"+sixthDay);
				
				
	            //System.out.println("Cuurent day::"+currDay);
				//DF20170822: SU334449 - Currentday was also included in the daterange list.
				switch (currDay) {
				    case Calendar.SUNDAY:
				       dateRangeList.add(firstDay);
				       break;

				    case Calendar.MONDAY:
				        dateRangeList.add(firstDay);
				        dateRangeList.add(secondDay);
				    	break;
				    case Calendar.TUESDAY:
				    	dateRangeList.add(firstDay);
						dateRangeList.add(secondDay);
						dateRangeList.add(thirdDay);
						break;
				    case Calendar.WEDNESDAY:
				    	dateRangeList.add(firstDay);
						dateRangeList.add(secondDay);
						dateRangeList.add(thirdDay);
						dateRangeList.add(fourthDay);
						break;
				    case Calendar.THURSDAY:
				    	dateRangeList.add(firstDay);
						dateRangeList.add(secondDay);
						dateRangeList.add(thirdDay);
						dateRangeList.add(fourthDay);
						dateRangeList.add(fifthDay);
						break;
				    case Calendar.FRIDAY:
				    	dateRangeList.add(firstDay);
						dateRangeList.add(secondDay);
						dateRangeList.add(thirdDay);
						dateRangeList.add(fourthDay);
						dateRangeList.add(fifthDay);
						dateRangeList.add(sixthDay);
						break;
				    case Calendar.SATURDAY:	
						dateRangeList.add(firstDay);
						dateRangeList.add(secondDay);
						dateRangeList.add(thirdDay);
						dateRangeList.add(fourthDay);
						dateRangeList.add(fifthDay);
						dateRangeList.add(sixthDay);
						dateRangeList.add(seventhDay);
						break;
				}
		

			} else if (period.equalsIgnoreCase("Today")) {
				cal.setTime(new Date());
				startDateTime = dateFormat.format(cal.getTime());
				dateRangeList.add(startDateTime);
			} else if ((period.equalsIgnoreCase("Last Week"))) {
				cal.set(Calendar.WEEK_OF_YEAR, week);
				cal.set(Calendar.DAY_OF_WEEK, Calendar.SUNDAY);
				startDateTime = dateFormat.format(cal.getTime());

				firstDay = dateFormat.format(cal.getTime());
				cal.set(Calendar.DAY_OF_WEEK, Calendar.SATURDAY);
				seventhDay = dateFormat.format(cal.getTime());
				cal.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY);
				secondDay = dateFormat.format(cal.getTime());
				cal.set(Calendar.DAY_OF_WEEK, Calendar.TUESDAY);
				thirdDay = dateFormat.format(cal.getTime());
				cal.set(Calendar.DAY_OF_WEEK, Calendar.WEDNESDAY);
				fourthDay = dateFormat.format(cal.getTime());
				cal.set(Calendar.DAY_OF_WEEK, Calendar.THURSDAY);
				fifthDay = dateFormat.format(cal.getTime());
				cal.set(Calendar.DAY_OF_WEEK, Calendar.FRIDAY);
				sixthDay = dateFormat.format(cal.getTime());
				dateRangeList.add(firstDay);
				dateRangeList.add(secondDay);
				dateRangeList.add(thirdDay);
				dateRangeList.add(fourthDay);
				dateRangeList.add(fifthDay);
				dateRangeList.add(sixthDay);
				dateRangeList.add(seventhDay);
			}
			return dateRangeList;
		}
		
		//END //DF20160603 
		
	/**
	 * method to set status in time-status map
	 * @param transactionTimeStamp
	 * @param status
	 * @param updatedMap
	 * @param isCurrentDay
	 * @return
	 */
	public TreeMap<String, String> fillMethod(Timestamp transactionTimeStamp,
			String status, TreeMap<String, String> updatedMap,
			boolean isCurrentDay) {
		String endPoint = "23:59";
		int endpointHour=0,endpointMin = 0, startpointHour=0,startpointMin = 0;
		String startPoint = null;
		Timestamp convertedTimeStamp = null;
		//		IstGmtTimeConversion conversionObj = new IstGmtTimeConversion();
		if (transactionTimeStamp != null) {
			// convert to IST and put to map
			//			convertedTimeStamp = conversionObj.convertGmtToIst(transactionTimeStamp);
			//			if (convertedTimeStamp != null) {
			startPoint = String.valueOf(transactionTimeStamp).substring(11,
					16);
			if (updatedMap.containsKey(startPoint)) {
				updatedMap.put(startPoint, status);
			}
			//			}
		}
		convertedTimeStamp = add1Minutes(transactionTimeStamp);
		if (convertedTimeStamp != null) {
			//			convertedTimeStamp = conversionObj.convertGmtToIst(convertedTimeStamp);
			startPoint = String.valueOf(convertedTimeStamp).substring(11, 16);

			if(!isCurrentDay){
				while (!startPoint.equals(endPoint)) {
					if (updatedMap.containsKey(startPoint)) {
						updatedMap.put(startPoint, status);
					}
					convertedTimeStamp = add1Minutes(convertedTimeStamp);
					if (convertedTimeStamp != null) {
						startPoint = String.valueOf(convertedTimeStamp).substring(
								11, 16);
					}
				}
				updatedMap.put("23:59", status);
			}
			else{
				//				Keerthi : 17/12/2013 : updating status when startpoint is <= endpoint
				SimpleDateFormat dateFormat1 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");		
				Timestamp endTimeStamp = Timestamp.valueOf(dateFormat1.format(new Date()));
				startpointHour = Integer.parseInt(startPoint.substring(0, 2));
				startpointMin = Integer.parseInt(startPoint.substring(3,5));
				while (convertedTimeStamp.before(endTimeStamp)) {
					if (updatedMap.containsKey(startPoint)) {
						updatedMap.put(startPoint, status);
					}
					convertedTimeStamp = add1Minutes(convertedTimeStamp);
					if (convertedTimeStamp != null) {
						startPoint = String.valueOf(convertedTimeStamp).substring(
								11, 16);
					}
					startpointHour = Integer.parseInt(startPoint.substring(0, 2));
					startpointMin = Integer.parseInt(startPoint.substring(3,5));
				}
			}

		}


		return updatedMap;
	}

	/**
	 * method to set status in time-status map
	 * @param transactionTimeStamp
	 * @param status
	 * @param updatedMap
	 * @param isCurrentDay
	 * @return
	 */
	public TreeMap<String, String> fleetFillMethod(Timestamp transactionTimeStamp,
			String status, TreeMap<String, String> updatedMap,
			boolean isCurrentDay) {
		String endPoint = "23:59";
		int endpointHour=0,endpointMin = 0, startpointHour=0,startpointMin = 0;
		String startPoint = null;
		Timestamp convertedTimeStamp = null;
		IstGmtTimeConversion conversionObj = new IstGmtTimeConversion();
		if (transactionTimeStamp != null) {
			// convert to IST and put to map
			convertedTimeStamp = conversionObj.convertGmtToIst(transactionTimeStamp);
			if (convertedTimeStamp != null) {
				startPoint = String.valueOf(convertedTimeStamp).substring(11,
						16);
				if (updatedMap.containsKey(startPoint)) {
					updatedMap.put(startPoint, status);
				}
			}
		}
		convertedTimeStamp = add1Minutes(transactionTimeStamp);
		if (convertedTimeStamp != null) {
			convertedTimeStamp = conversionObj.convertGmtToIst(convertedTimeStamp);
			startPoint = String.valueOf(convertedTimeStamp).substring(11, 16);

			if(!isCurrentDay){
				while (!startPoint.equals(endPoint)) {
					if (updatedMap.containsKey(startPoint)) {
						updatedMap.put(startPoint, status);
					}
					convertedTimeStamp = add1Minutes(convertedTimeStamp);
					if (convertedTimeStamp != null) {
						startPoint = String.valueOf(convertedTimeStamp).substring(
								11, 16);
					}
				}
				updatedMap.put("23:59", status);
			}
			else{
				//					Keerthi : 17/12/2013 : updating status when startpoint is <= endpoint
				SimpleDateFormat dateFormat1 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");		
				Timestamp endTimeStamp = Timestamp.valueOf(dateFormat1.format(new Date()));
				startpointHour = Integer.parseInt(startPoint.substring(0, 2));
				startpointMin = Integer.parseInt(startPoint.substring(3,5));
				while (convertedTimeStamp.before(endTimeStamp)) {
					if (updatedMap.containsKey(startPoint)) {
						updatedMap.put(startPoint, status);
					}
					convertedTimeStamp = add1Minutes(convertedTimeStamp);
					if (convertedTimeStamp != null) {
						startPoint = String.valueOf(convertedTimeStamp).substring(
								11, 16);
					}
					startpointHour = Integer.parseInt(startPoint.substring(0, 2));
					startpointMin = Integer.parseInt(startPoint.substring(3,5));
				}
			}

		}


		return updatedMap;
	}
	/**
	 * method to add 10 minutes to timestamp
	 * @param transactionTimeStamp
	 * @return
	 */
	public Timestamp add10Minutes(Timestamp transactionTimeStamp) {
		// add 10 minutes
		Calendar calendar = Calendar.getInstance();
		calendar.setTime(transactionTimeStamp);
		calendar.add(Calendar.MINUTE, 10);
		Timestamp added5Mins = new Timestamp(calendar.getTime().getTime());
		return added5Mins;
	}

	/**
	 * method to add 10 minutes to timestamp
	 * @param transactionTimeStamp
	 * @return
	 */
	public Timestamp add1Minutes(Timestamp transactionTimeStamp) {
		// add 10 minutes
		Calendar calendar = Calendar.getInstance();
		calendar.setTime(transactionTimeStamp);
		calendar.add(Calendar.MINUTE, 1);
		Timestamp added1Min = new Timestamp(calendar.getTime().getTime());
		return added1Min;
	}

	/**
	 *method to get time-status map for today(filling 'h')
	 * @return
	 */
	public TreeMap<String, String> getCurrentDateMap() {
		
		Logger iLogger = InfoLoggerClass.logger;
		
		TreeMap<String, String> currentDateMap = null;
		TreeMap<String, String> tempCurrentDateMap = null;
		tempCurrentDateMap = getTimeMap();
		// current date and current hour calculation.....18th oct 2013
		// Create a Date object set to the current date and time
		Date now = new Date();
		SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm ");

		// Print the date in the default timezone
		iLogger.info(df.format(now));
		String currentTime = df.format(now);
		Date currentTime1 = null;
		Timestamp currentTimestamp = null;
		try {
			java.util.Date date = new java.util.Date();
			currentTimestamp = new Timestamp(date.getTime());

			currentTime1 = (Date) df.parse(currentTime);
		} catch (ParseException e) {
			e.printStackTrace();
		}
		Date rounded = new Date(
				Math.round((currentTime1.getTime() / (1000.0 * 60 * 10)))
				* (1000 * 60 * 10));
		/*currentTimestamp = new Timestamp(
				Math.round((currentTime1.getTime() / (1000.0 * 60 * 10)))
		 * (1000 * 60 * 10));*/
		String exactTime = df.format(rounded);

		currentDateFinal = exactTime.substring(0, 10);
		time = exactTime.substring(11);

		String status = null;
		status = "h";
		currentDateMap = fillForToday(currentTimestamp, status,
				tempCurrentDateMap);
		return currentDateMap;

	}

	/**
	 * method to get time-status map
	 * @return
	 */
	public TreeMap<String, String> getTimeMapOld() {

		TreeMap<String, String> TimeMap = new TreeMap<String, String>();
		int j = 0, min = 0, hour = 0;
		TimeMap.put("00:00","0");
		for (int i = 0; i < 143; i++) {
			if (j == 5) {
				j = 0;
				min = 00;
				hour = hour + 1;
				if (hour <= 9) {
					TimeMap.put("0" + hour + ":" + min + "0", "0");
				} else {
					TimeMap.put(hour + ":" + min + "0", "0");
				}
			} else {
				j++;
				min = min + 10;
				if (hour <= 9) {
					TimeMap.put("0" + hour + ":" + min, "0");
				} else {
					TimeMap.put(hour + ":" + min, "0");
				}
			}

		}
		return TimeMap;
	}
	//Keerthi : time map with key as for each minute
	public TreeMap<String, String> getTimeMap() {

		TreeMap<String, String> TimeMap = new TreeMap<String, String>();
		int j = 0, min = 0, hour = 0;
		TimeMap.put("00:00","0");
		while(hour<=23) {

			if(min==59){
				min =-1;hour=hour+1;
			}
			//			Keerthi : 22/01/14 : hour = 24 break
			if(hour==24){
				break;
			}
			min = min + 1;
			if (hour <= 9) {
				if(min<=9){
					TimeMap.put("0" + hour + ":" + "0"+min, "0");
				}
				else{
					TimeMap.put("0" + hour + ":" + min, "0");
				}

			} else {
				if(min<=9){
					TimeMap.put(hour + ":" + "0"+min, "0");
				}
				else{
					TimeMap.put(hour + ":" + min, "0");
				}

			}

		}
		return TimeMap;
	}
	/**
	 * method to fill 'h' for today
	 * @param transactionTimeStamp
	 * @param status
	 * @param updatedMap
	 * @return
	 */
	public TreeMap<String, String> fillForToday(Timestamp transactionTimeStamp,
			String status, TreeMap<String, String> updatedMap) {
		String startPoint = null;
		Timestamp convertedTimeStamp = null;
		if (transactionTimeStamp != null) {
			startPoint = String.valueOf(transactionTimeStamp).substring(11, 16);
			if (updatedMap.containsKey(startPoint)) {
				updatedMap.put(startPoint, status);
			}
			convertedTimeStamp = add1Minutes(transactionTimeStamp);
			if (convertedTimeStamp != null) {
				startPoint = String.valueOf(convertedTimeStamp).substring(11,16);
				while (!startPoint.equals("23:59")) {
					if (updatedMap.containsKey(startPoint)) {
						updatedMap.put(startPoint, status);
					}
					convertedTimeStamp = add1Minutes(convertedTimeStamp);
					if (convertedTimeStamp != null) {
						startPoint = String.valueOf(convertedTimeStamp)
						.substring(11, 16);
					}
				}
			}
			updatedMap.put("23:59", status);

		}
		return updatedMap;
	}
	/**
	 * method to get difference in days
	 */
	public long differnceInDays(String startDate, String endDate) {

		long diffInMillisec = 0;
		long diffInDays = 0;
		Calendar firstDate = null;
		Calendar secondDate = null;
		int firstDateYear = 0, firstDateMonth = 0, firstDateRange = 0, secondDateYear = 0, secondDateMonth = 0, secondDateRange = 0;
		secondDateYear = Integer.valueOf(startDate.substring(0, 4));
		secondDateMonth = Integer.valueOf(startDate.substring(5, 7));
		secondDateRange = Integer.valueOf(startDate.substring(8));

		firstDateYear = Integer.valueOf(endDate.substring(0, 4));
		firstDateMonth = Integer.valueOf(endDate.substring(5, 7));
		firstDateRange = Integer.valueOf(endDate.substring(8));
		try {
			firstDate = Calendar.getInstance();
			secondDate = Calendar.getInstance();

			firstDate.set(firstDateYear, firstDateMonth, firstDateRange);
			secondDate.set(secondDateYear, secondDateMonth, secondDateRange);

			diffInMillisec = firstDate.getTimeInMillis()
			- secondDate.getTimeInMillis();

			diffInDays = diffInMillisec / (24 * 60 * 60 * 1000);

		} catch (Exception ex) {
			ex.printStackTrace();
		}
		return diffInDays;
	}
	//	Keerthi : 16-12-2013 : Defect ID : 1555 : IST conversion : END
	//Keerthi : 24/12/2013 : for usage alert report : landmark alert details : START
	/**
	 * method to get landmark count for usage alerts report
	 * returns landmark count for those landamrks defined by logged-in-tenancy-id
	 */
	public TreeMap<String,Long> getLandmarkCount(Set<String> serialNoList,List<Integer> tenancyId,String startDate,String endDate,Session session){
		TreeMap<String,Long> landmarkCountMap = null;
		ListToStringConversion conversionObj = new ListToStringConversion();
		String loginTenIdListString = conversionObj.getIntegerListString(tenancyId).toString();
		List<Object> landmarkDetails   = getLandmarkTypeDetails(session);
		int eventTypeId = 0;
		//		Keerthi : 06/01/2014 : landmark details size changed from 4 to 2		
		if(landmarkDetails!=null && landmarkDetails.size()>=2){
			eventTypeId = (Integer)landmarkDetails.get(0);
		}
		if(serialNoList!=null && serialNoList.size()>0){
			String serialNoString = conversionObj.getStringListFromSet(serialNoList).toString();
			//			Keerthi : 08/01/2014 : landmark count query changed
			/*SELECT ae.serial_number,count(*)
			FROM asset_event ae
			WHERE ae.serial_number in(
			SELECT distinct(la.serial_number)
			FROM
			landmark_asset la,
			landmark_dimension ld,
			landmark_catagory lc
			where la.serial_number in ('EEEEE123456789101','BBBBB123456789101') and
			 la.landmark_id = ld.LandMark_ID 
			and ld.LandMark_Category_ID = lc.Landmark_Category_ID
			and lc.Tenancy_ID = 102)
			and ae.Event_Generated_Time between '2014-01-01%' and '2014-01-08%'
			and ae.event_type_id=5
			group by ae.serial_number*/
			String seleclQuery = "SELECT aee.serialNumber,count(*) ";
			String fromQuery = " FROM AssetEventEntity aee";
			String whereQuery = " WHERE aee.serialNumber IN (" +
			" SELECT DISTINCT(lae.Serial_number) "+
			" FROM LandmarkCategoryEntity lce,LandmarkDimensionEntity lde,LandmarkAssetEntity lae "+
			" WHERE lae.Serial_number IN ("+serialNoString+")" +
			" AND  lae.Landmark_id = lde.landMarkId"+
			" AND lde.landMarkCategoryId=lce.Landmark_Category_ID " +
			" AND lce.Tenancy_ID IN ("+loginTenIdListString+"))"+					
			" AND aee.eventGeneratedTime between '"+startDate+"%' AND '"+endDate+"%'" +
			/*" AND aee.assetEventId = llde.assetEventId"+
					" AND llde.landmarkId = lde.landMarkId"+
//					Keerthi : 10/01/2014 : taking latest landmark id from landmark dimension
					" AND lde.landmarkDimensionId = " +
					"(SELECT MAX(ldet.landmarkDimensionId) FROM LandmarkDimensionEntity ldet" +
					" WHERE lde.landMarkId=ldet.landMarkId)"+*/
			" AND aee.eventTypeId="+eventTypeId;

			String orderByQuery = " GROUP BY aee.serialNumber";
			String serialNumber=null; long count =0l;
			Query landmarkQuery = session.createQuery(seleclQuery+fromQuery+whereQuery+orderByQuery);
			List resultList = landmarkQuery.list();
			Object[] result = null;
			Iterator iterator = resultList.iterator();
			while(iterator.hasNext()){
				if(landmarkCountMap==null){
					landmarkCountMap = new TreeMap<String, Long>();
				}
				result = (Object[])iterator.next();
				NotificationSummaryReportImpl implObj= new NotificationSummaryReportImpl();

				if(result[0]!=null){
					serialNumber = ((AssetEntity)result[0]).getSerial_number().getSerialNumber();
				}
				if(result[1]!=null){				
					count =(Long)result[1];				
				}
				landmarkCountMap.put(serialNumber, count);
			}
		}

		return landmarkCountMap;
	}

	/**
	 * method to get landmark count for usage alerts report
	 * returns landmark count for those landamrks defined by logged-in-tenancy-id
	 */
	public List<NotificationReportDetailsImpl> getLandmarkDetails(String serialNo,List<Integer> tenancyId,String startDate,String endDate,Session session){
		List<NotificationReportDetailsImpl> landmarkAlertDetails = null;
		List<NotificationReportDetailsImpl> implList = new ArrayList<NotificationReportDetailsImpl>();
		List<Object> landmarkDetails   = getLandmarkTypeDetails(session);
		int eventTypeId = 0;String eventTypeName = null;
		try{
			Properties prop = new Properties();
			prop.load(getClass().getClassLoader().getResourceAsStream("remote/wise/resource/properties/configuration.properties"));
			String propLandmarkName = prop.getProperty("LandmarkName");
			String eventLandmark = "<"+propLandmarkName+">";
			if(landmarkDetails!=null && landmarkDetails.size()>=2){
				eventTypeId = (Integer)landmarkDetails.get(0);
				eventTypeName = (String)landmarkDetails.get(1);
			}

			ListToStringConversion conversionObj = new ListToStringConversion();
			String loginTenIdListString = conversionObj.getIntegerListString(tenancyId).toString();
			if(serialNo!=null ){
				//				Keerthi : 08/01/2014 : landmark details query changed
				/*String seleclQuery = "SELECT aee.serialNumber,ee.eventName,aee.eventGeneratedTime,aee.eventSeverity,aee.activeStatus,ee.eventDescription,aee.address,asset.nick_name,lde.landMarkName";
				String fromQuery = " FROM LandmarkCategoryEntity lce,LandmarkDimensionEntity lde,LandmarkAssetEntity lae,AssetEventEntity aee,EventEntity ee, AssetEntity asset ";
				String whereQuery = " WHERE lce.Tenancy_ID IN ("+loginTenIdListString +
						") AND lce.Landmark_Category_ID=lde.landMarkCategoryId" +
						" AND lde.landMarkId =lae.Landmark_id AND lae.Serial_number IN ("+serialNoString+")" +
						" AND lae.Serial_number = aee.serialNumber AND aee.eventGeneratedTime between '"+startDate+"%' AND '"+endDate+"%'" +
						" AND aee.eventTypeId="+eventTypeId +" AND aee.eventId = ee.eventId AND aee.serialNumber=asset.serial_number";
				String orderByQuery = " ORDER BY aee.serialNumber";*/
				String seleclQuery = "SELECT aee.serialNumber,ee.eventName,aee.eventGeneratedTime,aee.eventSeverity,aee.activeStatus,ee.eventDescription,aee.address,asset.nick_name,lde.landMarkName";
				String fromQuery = " FROM AssetEventEntity aee,LandmarkLogDetailsEntity llde,LandmarkDimensionEntity lde,EventEntity ee, AssetEntity asset";
				String whereQuery = " WHERE aee.serialNumber IN (" +
				" SELECT DISTINCT(lae.Serial_number) "+
				" FROM LandmarkCategoryEntity lce,LandmarkDimensionEntity lde,LandmarkAssetEntity lae "+
				" WHERE lae.Serial_number = '"+serialNo+"'" +
				" AND  lae.Landmark_id = lde.landMarkId"+
				" AND lde.landMarkCategoryId=lce.Landmark_Category_ID " +
				" AND lce.Tenancy_ID IN ("+loginTenIdListString+"))"+					
				" AND aee.eventGeneratedTime between '"+startDate+"%' AND '"+endDate+"%'" +
				" AND aee.eventTypeId="+eventTypeId+" AND aee.eventId = ee.eventId"+
				" AND aee.assetEventId = llde.assetEventId"+
				" AND llde.landmarkId = lde.landMarkId"+
				//						Keerthi : 10/01/2014 : taking latest landmark id from landmark dimension
				" AND lde.landmarkDimensionId = " +
				"(SELECT MAX(ldet.landmarkDimensionId) FROM LandmarkDimensionEntity ldet" +
				" WHERE lde.landMarkId=ldet.landMarkId)"+
				" AND aee.serialNumber=asset.serial_number";
				String orderByQuery = " ORDER BY aee.serialNumber,aee.eventGeneratedTime";
				String serialNumber=null; long count =0l;
				Query landmarkQuery = session.createQuery(seleclQuery+fromQuery+whereQuery+orderByQuery);
				List resultList = landmarkQuery.list();
				Object[] result = null;
				Iterator iterator = resultList.iterator();
				NotificationReportDetailsImpl implObj= null;
				String landmarkName = null, description=null;
				while(iterator.hasNext()){

					result = (Object[])iterator.next();
					implObj= new NotificationReportDetailsImpl();

					if(result[0]!=null){
						implObj.setSerialNumber(((AssetEntity)result[0]).getSerial_number().getSerialNumber());
					}
					if(result[1]!=null){				
						implObj.setAlertName((String)result[1]);		
					}
					if(result[2]!=null){			
						implObj.setDateRaised(result[2].toString());
					}

					if(result[3]!=null){				
						implObj.setSeverity((String)result[3]);		
					}
					if(result[4]!=null){				
						implObj.setStatus(String.valueOf(result[4]));		
					}
					//					Keerthi : 26/12/2013 : replacing actual landmark name in description
					if(result[8]!=null){				
						landmarkName = String.valueOf(result[8]);		
					}
					if(result[5]!=null){	
						description = String.valueOf(result[5]);
						if(description.contains(propLandmarkName)){
							description=description.replace(eventLandmark, landmarkName);
						}
						implObj.setDescription(description);		
					}
					if(result[6]!=null){				
						implObj.setLocation(String.valueOf(result[6]));		
					}
					if(result[7]!=null){				
						implObj.setMachineName(String.valueOf(result[7]));		
					}				
					implObj.setCategory(eventTypeName);
					implList.add(implObj);
				}
			}			
		}
		catch(Exception e){
			e.printStackTrace();
		}

		return implList;
	}
	/**
	 * method to get landmark event type details
	 * @param session
	 * @return
	 */

	public List<Object> getLandmarkTypeDetails(Session session){
		List<Object> landmarkDetails = null;
		String queryString = "SELECT ete.eventTypeId,ete.eventTypeName FROM EventTypeEntity ete WHERE ete.eventTypeName LIKE 'Landmark%'";

		Query query = session.createQuery(queryString);
		List resultList = query.list();
		Object[] result = null;
		int index = 0;
		Iterator iterator = resultList.iterator();
		while(iterator.hasNext()){
			if(landmarkDetails==null){
				landmarkDetails = new ArrayList<Object>();
			}
			index = 0;
			result = (Object[])iterator.next();
			if(result[0]!=null){
				landmarkDetails.add(index++,(Integer)result[0]);
			}
			
			if(result[1]!=null){
				landmarkDetails.add(index++,(String)result[1]);
			}
		}
		return landmarkDetails ;
	}
	//	Keerthi : 24/12/2013 : for usage alert report : landmark alert details : END
	
	
	/*//*************************************** DF20140108 - Rajani Nagaraju - Machine Communication Report - New Report Implementation *******************
	public List<MachineCommReportRespContract> getDailyCommunicationReport()
	{
		Session session = HibernateUtil.getSessionFactory().getCurrentSession();
		session.beginTransaction();
		Logger fLogger = FatalLoggerClass.logger;
		//Logger bLogger = BusinessErrorLoggerClass.logger;
		Logger iLogger = InfoLoggerClass.logger;
		List<MachineCommReportRespContract> responseList = new LinkedList<MachineCommReportRespContract>();
		SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		SimpleDateFormat date = new SimpleDateFormat("yyyy-MM-dd");
		//List<AssetEntity> serialNumberList = new LinkedList<AssetEntity>();
		//HashMap<String,MachineCommReportRespContract> vinRespObjMap = new  HashMap<String,MachineCommReportRespContract>();
		
		try
		{
			//1) Get the List of all Active Machines which are communicated and are with Dealer/Customer
			Query mcrQ1= session.createQuery("select ams.serialNumber as Serial_Number, aos.accountId as Dealer_AccountId, " +
					" dealerAcc.accountCode as Dealer_Code,dealerAcc.account_name as Dealer_Name," +
					" address.city as City, address.state as State, acc.account_name as Owner," +
					" amd.parameterValue as Machine_Hours, amh.fwVersionNumber as FW_Version,  " +
					" amh.transactionTime as Pkt_created_TS, ams.latestCreatedTimestamp as Pkt_Recd_TS," +
					" ass.dateTime as Roll_Off_date " +
					" from AssetMonitoringSnapshotEntity ams,AssetMonitoringHeaderEntity amh,AssetMonitoringDetailEntity amd," +
					" AssetEntity ass, AccountEntity acc, AssetOwnerSnapshotEntity aos, AccountEntity dealerAcc, AddressEntity address" +
					" where ams.transactionNumber=amh.transactionNumber and ams.transactionNumber=amd.transactionNumber " +
					" and ams.serialNumber=ass.serial_number and ass.primary_owner_id=acc.account_id " +
					" and amd.parameterId = 4 and ams.serialNumber=aos.serialNumber " +
					" and aos.accountType='Dealer' and aos.accountId= dealerAcc.account_id " +
					" and dealerAcc.addressId=address.AddressId and ass.active_status=1 " +
					" and acc.status=true and  dealerAcc.status=true"+
					" order by amh.createdTimestamp desc ");
			Iterator mcrItr1= mcrQ1.list().iterator();
			Object[] mcrResult1 = null;
			int count1=0;
			while(mcrItr1.hasNext())
			{
				mcrResult1 = (Object[])mcrItr1.next();
				count1++;

				// Fill the Response Object
				AssetEntity asset =null;
				MachineCommReportRespContract responseObj = new MachineCommReportRespContract();
				if(mcrResult1[0]!=null)
				{
					asset = (AssetEntity)mcrResult1[0];
					responseObj.setSerialNumber(asset.getSerial_number().getSerialNumber());
					
				}
				if(mcrResult1[1]!=null)
				{
					AccountEntity account = (AccountEntity)mcrResult1[1];
					responseObj.setDealerAccountId(account.getAccount_id());
				}
				if(mcrResult1[2]!=null)
					responseObj.setDealerCode(mcrResult1[2].toString());
				
				if(mcrResult1[3]!=null)
					responseObj.setDealerName(mcrResult1[3].toString());
				
				if(mcrResult1[4]!=null)
					responseObj.setCity(mcrResult1[4].toString());
				
				if(mcrResult1[5]!=null)
					responseObj.setState(mcrResult1[5].toString());
				
				if(mcrResult1[6]!=null)
					responseObj.setOwnerName(mcrResult1[6].toString());
				
				if(mcrResult1[7]!=null)
					responseObj.setMachineHours(mcrResult1[7].toString());
				
				if(mcrResult1[8]!=null)
					responseObj.setFwVersion(mcrResult1[8].toString());
				
				if(mcrResult1[9]!=null)
				{
					//Packet Created Timestamp - i.e., Transaction Time in IST
					Timestamp pktTxnTime = (Timestamp)mcrResult1[9];
					pktTxnTime.setTime(pktTxnTime.getTime()+(330*60*1000));
					responseObj.setPktCreatedTimestamp(dateFormat.format(pktTxnTime));
				}
				
				if(mcrResult1[10]!=null)
				{
					Timestamp pktRcvdTime = (Timestamp)mcrResult1[10];
					responseObj.setPktReceivedTimestamp(dateFormat.format(pktRcvdTime));
					responseObj.setPktReceivedDate(date.format(pktRcvdTime));
				}
				
				else
				{
					//DF20150119 - Rajani Nagaraju - latestCreatedTimestamp of AMS will be NULL for the first packet received for the VIN at AMH
					// Since during that point record doesnot exists in AMS and hence created_timestamp cannot to updated to latest_created_timestamp
					Query amhQ = session.createQuery("select max(a.createdTimestamp) from AssetMonitoringHeaderEntity a " +
							" where a.serialNumber='"+asset.getSerial_number().getSerialNumber()+"' group by a.serialNumber ");
					Iterator amhItr = amhQ.list().iterator();
					//Object res[] = null;
					while(amhItr.hasNext())
					{
						Timestamp pktRcvdTime = (Timestamp)amhItr.next();
						responseObj.setPktReceivedTimestamp(dateFormat.format(pktRcvdTime));
						responseObj.setPktReceivedDate(date.format(pktRcvdTime));
						
					}
			
				}
				
				if(mcrResult1[11]!=null)
				{
					Timestamp rolledOffDate = (Timestamp)mcrResult1[11];
					responseObj.setRolledOffDate(dateFormat.format(rolledOffDate));
				}
				
				
				responseList.add(responseObj);
			}
			
			
			//2) Get the List of all Active Machines which are communicated and are still with JCB
			Query mcrQ2 = session.createQuery("select ams.serialNumber as Serial_Number, '' as Dealer_AccountId, " +
					" '' as Dealer_Code, '' as Dealer_Name, '' as City, '' as State, acc.account_name as Owner, " +
					" amd.parameterValue as Machine_Hours, amh.fwVersionNumber as FW_Version, " +
					" amh.transactionTime as Pkt_created_TS, ams.latestCreatedTimestamp as Pkt_Recd_TS," +
					" ass.dateTime as Roll_Off_date " +
					" from AssetMonitoringSnapshotEntity ams,AssetMonitoringHeaderEntity amh,AssetMonitoringDetailEntity amd," +
					" AssetEntity ass, AccountEntity acc " +
					" where acc.status=true and ams.transactionNumber=amh.transactionNumber and ams.transactionNumber=amd.transactionNumber " +
					" and ams.serialNumber=ass.serial_number and ass.primary_owner_id=acc.account_id " +
					" and amd.parameterId = 4 and ass.primary_owner_id=2001 and ass.active_status=1 " +
					" order by amh.createdTimestamp desc ");
			Iterator mcrItr2 = mcrQ2.list().iterator();
			Object[] mcrResult2 = null;
			int count2=0;
			while(mcrItr2.hasNext())
			{
				mcrResult2 = (Object[])mcrItr2.next();
				//To Do -- Fill the Response Object
				count2++;
				
				// Fill the Response Object
				MachineCommReportRespContract responseObj = new MachineCommReportRespContract();
				AssetEntity asset =null;
				if(mcrResult2[0]!=null)
				{
					asset = (AssetEntity)mcrResult2[0];
					responseObj.setSerialNumber(asset.getSerial_number().getSerialNumber());
					
				}
				
				responseObj.setDealerAccountId(0);
				
				responseObj.setDealerCode("");
				
				responseObj.setDealerName("");
				
				responseObj.setCity("");
				
				responseObj.setState("");
				
				if(mcrResult2[6]!=null)
					responseObj.setOwnerName(mcrResult2[6].toString());
				
				if(mcrResult2[7]!=null)
					responseObj.setMachineHours(mcrResult2[7].toString());
				
				if(mcrResult2[8]!=null)
					responseObj.setFwVersion(mcrResult2[8].toString());
				
				if(mcrResult2[9]!=null)
				{
					//Packet Created Timestamp - i.e., Transaction Time in IST
					Timestamp pktTxnTime = (Timestamp)mcrResult2[9];
					pktTxnTime.setTime(pktTxnTime.getTime()+(330*60*1000));
					responseObj.setPktCreatedTimestamp(dateFormat.format(pktTxnTime));
				}
				
				if(mcrResult2[10]!=null)
				{
					Timestamp pktRcvdTime = (Timestamp)mcrResult2[10];
					responseObj.setPktReceivedTimestamp(dateFormat.format(pktRcvdTime));
					responseObj.setPktReceivedDate(date.format(pktRcvdTime));
				}
				
				else
				{
					//DF20150119 - Rajani Nagaraju - latestCreatedTimestamp of AMS will be NULL for the first packet received for the VIN at AMH
					// Since during that point record doesnot exists in AMS and hence created_timestamp cannot to updated to latest_created_timestamp
					Query amhQ = session.createQuery("select max(a.createdTimestamp) from AssetMonitoringHeaderEntity a " +
							" where a.serialNumber='"+asset.getSerial_number().getSerialNumber()+"' group by a.serialNumber ");
					Iterator amhItr = amhQ.list().iterator();
					//Object res[] = null;
					while(amhItr.hasNext())
					{
						Timestamp pktRcvdTime = (Timestamp)amhItr.next();
						responseObj.setPktReceivedTimestamp(dateFormat.format(pktRcvdTime));
						responseObj.setPktReceivedDate(date.format(pktRcvdTime));
						
					}
				}
				
				if(mcrResult2[11]!=null)
				{
					Timestamp rolledOffDate = (Timestamp)mcrResult2[11];
					responseObj.setRolledOffDate(dateFormat.format(rolledOffDate));
				}
				
				responseList.add(responseObj);
			}
			
			
			//3) List of All Non communicated Machines with Dealer/Customer
			Query mcrQ3 = session.createQuery("select ass.serial_number as Serial_Number, aos.accountId as Dealer_AccountId, " +
					" dealerAcc.accountCode as Dealer_Code,dealerAcc.account_name as Dealer_Name," +
					" address.city as City, address.state as State, acc.account_name as Owner," +
					" '' as Machine_Hours, '' as FW_Version, '' as Pkt_created_TS, '' as Pkt_Recd_TS, ass.dateTime as Roll_Off_date " +
					" from AssetEntity ass, AccountEntity acc, AssetOwnerSnapshotEntity aos, AccountEntity dealerAcc, AddressEntity address " +
					" where ass.serial_number not in (select serialNumber from AssetMonitoringSnapshotEntity) " +
					" and ass.primary_owner_id=acc.account_id and ass.serial_number=aos.serialNumber" +
					" and aos.accountType='Dealer' and aos.accountId= dealerAcc.account_id " +
					" and acc.status=true and dealerAcc.status=true"+
					" and dealerAcc.addressId=address.AddressId and ass.active_status=1 " );
			Iterator mcrItr3 = mcrQ3.list().iterator();
			Object[] mcrResult3 = null;
			int count3=0;
			while(mcrItr3.hasNext())
			{
				mcrResult3 = (Object[])mcrItr3.next();
				
				//--- Fill the Response Object
				// Fill the Response Object
				count3++;
				MachineCommReportRespContract responseObj = new MachineCommReportRespContract();
				if(mcrResult3[0]!=null)
				{
					AssetControlUnitEntity asset = (AssetControlUnitEntity)mcrResult3[0];
					responseObj.setSerialNumber(asset.getSerialNumber());
				}
				if(mcrResult3[1]!=null)
				{
					AccountEntity account = (AccountEntity)mcrResult3[1];
					responseObj.setDealerAccountId(account.getAccount_id());
				}
				if(mcrResult3[2]!=null)
					responseObj.setDealerCode(mcrResult3[2].toString());
				
				if(mcrResult3[3]!=null)
					responseObj.setDealerName(mcrResult3[3].toString());
				
				if(mcrResult3[4]!=null)
					responseObj.setCity(mcrResult3[4].toString());
				
				if(mcrResult3[5]!=null)
					responseObj.setState(mcrResult3[5].toString());
				
				if(mcrResult3[6]!=null)
					responseObj.setOwnerName(mcrResult3[6].toString());
				
				responseObj.setMachineHours("");
				
				responseObj.setFwVersion("");
				
				responseObj.setPktCreatedTimestamp("");
				
				responseObj.setPktReceivedTimestamp("");
				
				responseObj.setPktReceivedDate("");
				
				if(mcrResult3[11]!=null)
				{
					Timestamp rolledOffDate = (Timestamp)mcrResult3[11];
					responseObj.setRolledOffDate(dateFormat.format(rolledOffDate));
				}
				
				
				responseList.add(responseObj);
				
			}
			
			
			//4) List of all Non communicated Machines which are still with JCB
			Query mcrQ4 = session.createQuery("select ass.serial_number as Serial_Number, '' as Dealer_AccountId, '' as Dealer_Code," +
					" '' as Dealer_Name, '' as City, '' as State, acc.account_name as Owner, '' as Machine_Hours," +
					" '' as FW_Version, '' as Pkt_created_TS, '' as Pkt_Recd_TS, ass.dateTime as Roll_Off_date " +
					" from AssetEntity ass, AccountEntity acc where ass.primary_owner_id=acc.account_id " +
					" and ass.primary_owner_id=2001 and ass.active_status=1 and acc.status=true and " +
					" ass.serial_number not in (select serialNumber from AssetMonitoringSnapshotEntity)");
			Iterator mcrItr4 = mcrQ4.list().iterator();
			Object[] mcrResult4 = null;
			int count4=0;
			while(mcrItr4.hasNext())
			{
				mcrResult4 = (Object[])mcrItr4.next();
				// -- Fill the Response Object
				// Fill the Response Object
				count4++;
				
				MachineCommReportRespContract responseObj = new MachineCommReportRespContract();
				if(mcrResult4[0]!=null)
				{
					AssetControlUnitEntity asset = (AssetControlUnitEntity)mcrResult4[0];
					responseObj.setSerialNumber(asset.getSerialNumber());
				}
				
				responseObj.setDealerAccountId(0);
				
				responseObj.setDealerCode("");
				
				responseObj.setDealerName("");
				
				responseObj.setCity("");
				
				responseObj.setState("");
				
				if(mcrResult4[6]!=null)
					responseObj.setOwnerName(mcrResult4[6].toString());
				
				responseObj.setMachineHours("");
				
				responseObj.setFwVersion("");
				
				responseObj.setPktCreatedTimestamp("");
				
				responseObj.setPktReceivedTimestamp("");
				
				responseObj.setPktReceivedDate("");
				
				
				if(mcrResult4[11]!=null)
				{
					Timestamp rolledOffDate = (Timestamp)mcrResult4[11];
					responseObj.setRolledOffDate(dateFormat.format(rolledOffDate));
				}
				
				responseList.add(responseObj);
			}
			
			iLogger.info("Query1 Count: "+count1);
			iLogger.info("Query2 Count: "+count2);
			iLogger.info("Query3 Count: "+count3);
			iLogger.info("Query4 Count: "+count4);
			
			//-------------- Update Packet Received Timestamp and Packet Received Date in Response Object - Based on Latest Created time
			// ------- and not on latest transaction time to let know the latest time of when the pkt received from machine
			infoLogger.info("Set CreatedTimestamp - START");
			Query latestCreatedTimeQ = session.createQuery(" select a.serialNumber, max(a.createdTimestamp) as createdTime " +
					" from AssetMonitoringHeaderEntity a " +
					" where a.serialNumber in (:list) group by a.serialNumber ").setParameterList("list", serialNumberList);
			Iterator latestCreatedTimeItr = latestCreatedTimeQ.list().iterator();
			Object[] result=null;
			while(latestCreatedTimeItr.hasNext())
			{
				result = (Object[])latestCreatedTimeItr.next();
				if(result[0]!=null && result[1]!=null)
				{
					String serNum = ((AssetEntity)result[0]).getSerial_number().getSerialNumber();
					Timestamp pktRcvdTime = (Timestamp)result[1];
					//infoLogger.info("serNum:"+serNum+", pktRcvdTime:"+dateFormat.format(pktRcvdTime)+", PktReceivedDate:"+date.format(pktRcvdTime));
					MachineCommReportRespContract responseObj = vinRespObjMap.get(serNum);
					responseObj.setPktReceivedTimestamp(dateFormat.format(pktRcvdTime));
					responseObj.setPktReceivedDate(date.format(pktRcvdTime));
					
				}
			}
			infoLogger.info("Set CreatedTimestamp - END");
		}
		
		catch(Exception e)
		{
			fLogger.fatal("Exception :"+e);
			
			Writer result = new StringWriter();
    	    PrintWriter printWriter = new PrintWriter(result);
    	    e.printStackTrace(printWriter);
    	    String err = result.toString();
    	    fLogger.fatal("Exception trace: "+err);
    	    try 
    	    {
    	    	printWriter.close();
        	    result.close();
			} 
    	    
    	    catch (IOException e1) 
    	    {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
    	    
    	    
		}

		finally
		{
			if(session.isOpen())
				if(session.getTransaction().isActive())
				{
					session.getTransaction().commit();
				}

			if(session.isOpen())
			{
				session.flush();
				session.close();
			}

		}
		
		return responseList;
	}*/
	
	//S Suresh implemented DAL Layer
		public List<MachineCommReportRespContract> getDailyCommunicationReport()
		{
			Session session = HibernateUtil.getSessionFactory().getCurrentSession();
			session.beginTransaction();
			Logger fLogger = FatalLoggerClass.logger;
			//Logger bLogger = BusinessErrorLoggerClass.logger;
			Logger iLogger = InfoLoggerClass.logger;
			List<MachineCommReportRespContract> responseList = new LinkedList<MachineCommReportRespContract>();
			SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
			SimpleDateFormat date = new SimpleDateFormat("yyyy-MM-dd");
			//List<AssetEntity> serialNumberList = new LinkedList<AssetEntity>();
			//HashMap<String,MachineCommReportRespContract> vinRespObjMap = new  HashMap<String,MachineCommReportRespContract>();
			String dealerAccountType = "DEALER";
			String JCBAccountType = "JCB";
			
			try
			{
				//1) Get the List of all Active Machines which are communicated and are with Dealer/Customer
				/*Query mcrQ1= session.createQuery("select ams.serialNumber as Serial_Number, aos.accountId as Dealer_AccountId, " +
						" dealerAcc.accountCode as Dealer_Code,dealerAcc.account_name as Dealer_Name," +
						" address.city as City, address.state as State, acc.account_name as Owner," +
						" amd.parameterValue as Machine_Hours, amh.fwVersionNumber as FW_Version,  " +
						" amh.transactionTime as Pkt_created_TS, ams.latestCreatedTimestamp as Pkt_Recd_TS," +
						" ass.dateTime as Roll_Off_date " +
						" from AssetMonitoringSnapshotEntity ams,AssetMonitoringHeaderEntity amh,AssetMonitoringDetailEntity amd," +
						" AssetEntity ass, AccountEntity acc, AssetOwnerSnapshotEntity aos, AccountEntity dealerAcc, AddressEntity address" +
						" where ams.transactionNumber=amh.transactionNumber and ams.transactionNumber=amd.transactionNumber " +
						" and ams.serialNumber=ass.serial_number and ass.primary_owner_id=acc.account_id " +
						" and amd.parameterId = 4 and ams.serialNumber=aos.serialNumber " +
						" and aos.accountType='Dealer' and aos.accountId= dealerAcc.account_id " +
						" and dealerAcc.addressId=address.AddressId and ass.active_status=1 " +
						" and acc.status=true and  dealerAcc.status=true"+
						" order by amh.createdTimestamp desc ");*/
				
				String txnKey = "ReportDetailsBO:getDailyCommunicationReport";
				DynamicAMS_DAL amsDALObject = new DynamicAMS_DAL();
				List<CommunicationMachinesDAO> commList = amsDALObject.getDailyCommunicatedMachines(txnKey, dealerAccountType);
				Iterator mcrItr1= commList.iterator();
				CommunicationMachinesDAO mcrResult1 = null;
				int count1=0;
				while(mcrItr1.hasNext())
				{
					mcrResult1 = (CommunicationMachinesDAO)mcrItr1.next();
					count1++;

					// Fill the Response Object
					AssetEntity asset =null;
					MachineCommReportRespContract responseObj = new MachineCommReportRespContract();
					if(mcrResult1.getSerialNumber()!=null)
					{
						//asset = (AssetEntity)mcrResult1[0];
						responseObj.setSerialNumber(mcrResult1.getSerialNumber());
						
					}
					if(mcrResult1.getDealerAccountId()!=0)
					{
						//AccountEntity account = (AccountEntity)mcrResult1[1];
						responseObj.setDealerAccountId(mcrResult1.getDealerAccountId());
					}
					if(mcrResult1.getDealerCode()!=null)
						responseObj.setDealerCode(mcrResult1.getDealerCode());
					
					if(mcrResult1.getDealerName()!=null)
						responseObj.setDealerName(mcrResult1.getDealerName());
					
					if(mcrResult1.getCity()!=null)
						responseObj.setCity(mcrResult1.getCity());
					
					if(mcrResult1.getState()!=null)
						responseObj.setState(mcrResult1.getState());
					
					if(mcrResult1.getOwnerName()!=null)
						responseObj.setOwnerName(mcrResult1.getOwnerName());
					
					if(mcrResult1.getMachineHours()!=null)
						responseObj.setMachineHours(mcrResult1.getMachineHours());
					
					if(mcrResult1.getFwVersion()!=null)
						responseObj.setFwVersion(mcrResult1.getFwVersion());
					
					if(mcrResult1.getPktCreatedTimestamp()!=null)
					{
						//Packet Created Timestamp - i.e., Transaction Time in IST
						//Timestamp pktTxnTime = mcrResult1.getPktCreatedTimestamp();
						//pktTxnTime.setTime(pktTxnTime.getTime()+(330*60*1000));
						responseObj.setPktCreatedTimestamp(mcrResult1.getPktCreatedTimestamp());
					}
					
					if(mcrResult1.getPktReceivedTimestamp()!=null)
					{
						//Timestamp pktRcvdTime = (Timestamp)mcrResult1[10];
						responseObj.setPktReceivedTimestamp(mcrResult1.getPktReceivedTimestamp());
						responseObj.setPktReceivedDate(mcrResult1.getPktReceivedDate());
					}
					
					/*else
					{
						//DF20150119 - Rajani Nagaraju - latestCreatedTimestamp of AMS will be NULL for the first packet received for the VIN at AMH
						// Since during that point record doesnot exists in AMS and hence created_timestamp cannot to updated to latest_created_timestamp
						Query amhQ = session.createQuery("select max(a.createdTimestamp) from AssetMonitoringHeaderEntity a " +
								" where a.serialNumber='"+asset.getSerial_number().getSerialNumber()+"' group by a.serialNumber ");
						Iterator amhItr = amhQ.list().iterator();
						//Object res[] = null;
						while(amhItr.hasNext())
						{
							Timestamp pktRcvdTime = (Timestamp)amhItr.next();
							responseObj.setPktReceivedTimestamp(dateFormat.format(pktRcvdTime));
							responseObj.setPktReceivedDate(date.format(pktRcvdTime));
							
						}
				
					}*/
					
					if(mcrResult1.getRolledOffDate()!=null)
					{
						//Timestamp rolledOffDate = (Timestamp)mcrResult1[11];
						responseObj.setRolledOffDate(mcrResult1.getRolledOffDate());
					}
					
					
					responseList.add(responseObj);
				}
				
				
				//2) Get the List of all Active Machines which are communicated and are still with JCB
				/*Query mcrQ2 = session.createQuery("select ams.serialNumber as Serial_Number, '' as Dealer_AccountId, " +
						" '' as Dealer_Code, '' as Dealer_Name, '' as City, '' as State, acc.account_name as Owner, " +
						" amd.parameterValue as Machine_Hours, amh.fwVersionNumber as FW_Version, " +
						" amh.transactionTime as Pkt_created_TS, ams.latestCreatedTimestamp as Pkt_Recd_TS," +
						" ass.dateTime as Roll_Off_date " +
						" from AssetMonitoringSnapshotEntity ams,AssetMonitoringHeaderEntity amh,AssetMonitoringDetailEntity amd," +
						" AssetEntity ass, AccountEntity acc " +
						" where acc.status=true and ams.transactionNumber=amh.transactionNumber and ams.transactionNumber=amd.transactionNumber " +
						" and ams.serialNumber=ass.serial_number and ass.primary_owner_id=acc.account_id " +
						" and amd.parameterId = 4 and ass.primary_owner_id=2001 and ass.active_status=1 " +
						" order by amh.createdTimestamp desc ");*/
				
				
				//amsDALObject = new DynamicAMS_DAL();
				commList = amsDALObject.getDailyCommunicatedMachines(txnKey, JCBAccountType);
				mcrItr1= commList.iterator();
				mcrResult1 = null;
				int count2=0;
				while(mcrItr1.hasNext())
				{
					mcrResult1 = (CommunicationMachinesDAO)mcrItr1.next();
					count2++;

					// Fill the Response Object
					AssetEntity asset =null;
					MachineCommReportRespContract responseObj = new MachineCommReportRespContract();
					if(mcrResult1.getSerialNumber()!=null)
					{
						//asset = (AssetEntity)mcrResult1[0];
						responseObj.setSerialNumber(mcrResult1.getSerialNumber());
						
					}
					responseObj.setDealerAccountId(0);
					
					responseObj.setDealerCode("");
					
					responseObj.setDealerName("");
					
					responseObj.setCity("");
					
					responseObj.setState("");
					
					if(mcrResult1.getOwnerName()!=null)
						responseObj.setOwnerName(mcrResult1.getOwnerName());
					
					if(mcrResult1.getMachineHours()!=null)
						responseObj.setMachineHours(mcrResult1.getMachineHours());
					
					if(mcrResult1.getFwVersion()!=null)
						responseObj.setFwVersion(mcrResult1.getFwVersion());
					
					if(mcrResult1.getPktCreatedTimestamp()!=null)
					{
						//Packet Created Timestamp - i.e., Transaction Time in IST
						//Timestamp pktTxnTime = mcrResult1.getPktCreatedTimestamp();
						//pktTxnTime.setTime(pktTxnTime.getTime()+(330*60*1000));
						responseObj.setPktCreatedTimestamp(mcrResult1.getPktCreatedTimestamp());
					}
					
					if(mcrResult1.getPktReceivedTimestamp()!=null)
					{
						//Timestamp pktRcvdTime = (Timestamp)mcrResult1[10];
						responseObj.setPktReceivedTimestamp(mcrResult1.getPktReceivedTimestamp());
						responseObj.setPktReceivedDate(mcrResult1.getPktReceivedDate());
					}
					
					/*else
					{
						//DF20150119 - Rajani Nagaraju - latestCreatedTimestamp of AMS will be NULL for the first packet received for the VIN at AMH
						// Since during that point record doesnot exists in AMS and hence created_timestamp cannot to updated to latest_created_timestamp
						Query amhQ = session.createQuery("select max(a.createdTimestamp) from AssetMonitoringHeaderEntity a " +
								" where a.serialNumber='"+asset.getSerial_number().getSerialNumber()+"' group by a.serialNumber ");
						Iterator amhItr = amhQ.list().iterator();
						//Object res[] = null;
						while(amhItr.hasNext())
						{
							Timestamp pktRcvdTime = (Timestamp)amhItr.next();
							responseObj.setPktReceivedTimestamp(dateFormat.format(pktRcvdTime));
							responseObj.setPktReceivedDate(date.format(pktRcvdTime));
							
						}
				
					}*/
					
					if(mcrResult1.getRolledOffDate()!=null)
					{
						//Timestamp rolledOffDate = (Timestamp)mcrResult1[11];
						responseObj.setRolledOffDate(mcrResult1.getRolledOffDate());
					}
					
					
					responseList.add(responseObj);
				}
				
				
				
				//3) List of All Non communicated Machines with Dealer/Customer
				/*Query mcrQ3 = session.createQuery("select ass.serial_number as Serial_Number, aos.accountId as Dealer_AccountId, " +
						" dealerAcc.accountCode as Dealer_Code,dealerAcc.account_name as Dealer_Name," +
						" address.city as City, address.state as State, acc.account_name as Owner," +
						" '' as Machine_Hours, '' as FW_Version, '' as Pkt_created_TS, '' as Pkt_Recd_TS, ass.dateTime as Roll_Off_date " +
						" from AssetEntity ass, AccountEntity acc, AssetOwnerSnapshotEntity aos, AccountEntity dealerAcc, AddressEntity address " +
						" where ass.serial_number not in (select serialNumber from AssetMonitoringSnapshotEntity) " +
						" and ass.primary_owner_id=acc.account_id and ass.serial_number=aos.serialNumber" +
						" and aos.accountType='Dealer' and aos.accountId= dealerAcc.account_id " +
						" and acc.status=true and dealerAcc.status=true"+
						" and dealerAcc.addressId=address.AddressId and ass.active_status=1 " );*/
				
				//DynamicAMS_DAL amsDALObject = new DynamicAMS_DAL();
				List<CommunicationMachinesDAO> nonCommList = amsDALObject.getDailyNonCommunicatedMachines(txnKey, dealerAccountType);
				mcrItr1= nonCommList.iterator();
				mcrResult1 = null;
				
				int count3=0;
				
				while(mcrItr1.hasNext())
				{
					mcrResult1 = (CommunicationMachinesDAO)mcrItr1.next();
					count3++;

					// Fill the Response Object
					AssetEntity asset =null;
					MachineCommReportRespContract responseObj = new MachineCommReportRespContract();
					if(mcrResult1.getSerialNumber()!=null)
					{
						//asset = (AssetEntity)mcrResult1[0];
						responseObj.setSerialNumber(mcrResult1.getSerialNumber());
						
					}
					if(mcrResult1.getDealerAccountId()!=0)
					{
						//AccountEntity account = (AccountEntity)mcrResult1[1];
						responseObj.setDealerAccountId(mcrResult1.getDealerAccountId());
					}
					if(mcrResult1.getDealerCode()!=null)
						responseObj.setDealerCode(mcrResult1.getDealerCode());
					
					if(mcrResult1.getDealerName()!=null)
						responseObj.setDealerName(mcrResult1.getDealerName());
					
					if(mcrResult1.getCity()!=null)
						responseObj.setCity(mcrResult1.getCity());
					
					if(mcrResult1.getState()!=null)
						responseObj.setState(mcrResult1.getState());
					
					if(mcrResult1.getOwnerName()!=null)
						responseObj.setOwnerName(mcrResult1.getOwnerName());
					
					responseObj.setMachineHours("");
					
					responseObj.setFwVersion("");
					
					responseObj.setPktCreatedTimestamp("");
					
					responseObj.setPktReceivedTimestamp("");
					
					responseObj.setPktReceivedDate("");
					
					/*else
					{
						//DF20150119 - Rajani Nagaraju - latestCreatedTimestamp of AMS will be NULL for the first packet received for the VIN at AMH
						// Since during that point record doesnot exists in AMS and hence created_timestamp cannot to updated to latest_created_timestamp
						Query amhQ = session.createQuery("select max(a.createdTimestamp) from AssetMonitoringHeaderEntity a " +
								" where a.serialNumber='"+asset.getSerial_number().getSerialNumber()+"' group by a.serialNumber ");
						Iterator amhItr = amhQ.list().iterator();
						//Object res[] = null;
						while(amhItr.hasNext())
						{
							Timestamp pktRcvdTime = (Timestamp)amhItr.next();
							responseObj.setPktReceivedTimestamp(dateFormat.format(pktRcvdTime));
							responseObj.setPktReceivedDate(date.format(pktRcvdTime));
							
						}
				
					}*/
					
					if(mcrResult1.getRolledOffDate()!=null)
					{
						//Timestamp rolledOffDate = (Timestamp)mcrResult1[11];
						responseObj.setRolledOffDate(mcrResult1.getRolledOffDate());
					}
					
					
					responseList.add(responseObj);
				}
			
				
				
				//4) List of all Non communicated Machines which are still with JCB
				/*Query mcrQ4 = session.createQuery("select ass.serial_number as Serial_Number, '' as Dealer_AccountId, '' as Dealer_Code," +
						" '' as Dealer_Name, '' as City, '' as State, acc.account_name as Owner, '' as Machine_Hours," +
						" '' as FW_Version, '' as Pkt_created_TS, '' as Pkt_Recd_TS, ass.dateTime as Roll_Off_date " +
						" from AssetEntity ass, AccountEntity acc where ass.primary_owner_id=acc.account_id " +
						" and ass.primary_owner_id=2001 and ass.active_status=1 and acc.status=true and " +
						" ass.serial_number not in (select serialNumber from AssetMonitoringSnapshotEntity)");*/
				
				nonCommList = amsDALObject.getDailyNonCommunicatedMachines(txnKey, dealerAccountType);
				mcrItr1= nonCommList.iterator();
				mcrResult1 = null;
				/*Iterator mcrItr4 = mcrQ4.list().iterator();
				Object[] mcrResult4 = null;*/
				int count4=0;
				
				while(mcrItr1.hasNext())
				{
					mcrResult1 = (CommunicationMachinesDAO)mcrItr1.next();
					count4++;

					// Fill the Response Object
					AssetEntity asset =null;
					MachineCommReportRespContract responseObj = new MachineCommReportRespContract();
					if(mcrResult1.getSerialNumber()!=null)
					{
						//asset = (AssetEntity)mcrResult1[0];
						responseObj.setSerialNumber(mcrResult1.getSerialNumber());
						
					}
					responseObj.setDealerAccountId(0);
					
					responseObj.setDealerCode("");
					
					responseObj.setDealerName("");
					
					responseObj.setCity("");
					
					responseObj.setState("");
					
					if(mcrResult1.getOwnerName()!=null)
						responseObj.setOwnerName(mcrResult1.getOwnerName());
					
					responseObj.setMachineHours("");
					
					responseObj.setFwVersion("");
					
					responseObj.setPktCreatedTimestamp("");
					
					responseObj.setPktReceivedTimestamp("");
					
					responseObj.setPktReceivedDate("");
					
					/*else
					{
						//DF20150119 - Rajani Nagaraju - latestCreatedTimestamp of AMS will be NULL for the first packet received for the VIN at AMH
						// Since during that point record doesnot exists in AMS and hence created_timestamp cannot to updated to latest_created_timestamp
						Query amhQ = session.createQuery("select max(a.createdTimestamp) from AssetMonitoringHeaderEntity a " +
								" where a.serialNumber='"+asset.getSerial_number().getSerialNumber()+"' group by a.serialNumber ");
						Iterator amhItr = amhQ.list().iterator();
						//Object res[] = null;
						while(amhItr.hasNext())
						{
							Timestamp pktRcvdTime = (Timestamp)amhItr.next();
							responseObj.setPktReceivedTimestamp(dateFormat.format(pktRcvdTime));
							responseObj.setPktReceivedDate(date.format(pktRcvdTime));
							
						}
				
					}*/
					
					if(mcrResult1.getRolledOffDate()!=null)
					{
						//Timestamp rolledOffDate = (Timestamp)mcrResult1[11];
						responseObj.setRolledOffDate(mcrResult1.getRolledOffDate());
					}
					
					
					responseList.add(responseObj);
				}
				
				
				iLogger.info("Query1 Count: "+count1);
				iLogger.info("Query2 Count: "+count2);
				iLogger.info("Query3 Count: "+count3);
				iLogger.info("Query4 Count: "+count4);
				
				//-------------- Update Packet Received Timestamp and Packet Received Date in Response Object - Based on Latest Created time
				// ------- and not on latest transaction time to let know the latest time of when the pkt received from machine
				/*infoLogger.info("Set CreatedTimestamp - START");
				Query latestCreatedTimeQ = session.createQuery(" select a.serialNumber, max(a.createdTimestamp) as createdTime " +
						" from AssetMonitoringHeaderEntity a " +
						" where a.serialNumber in (:list) group by a.serialNumber ").setParameterList("list", serialNumberList);
				Iterator latestCreatedTimeItr = latestCreatedTimeQ.list().iterator();
				Object[] result=null;
				while(latestCreatedTimeItr.hasNext())
				{
					result = (Object[])latestCreatedTimeItr.next();
					if(result[0]!=null && result[1]!=null)
					{
						String serNum = ((AssetEntity)result[0]).getSerial_number().getSerialNumber();
						Timestamp pktRcvdTime = (Timestamp)result[1];
						//infoLogger.info("serNum:"+serNum+", pktRcvdTime:"+dateFormat.format(pktRcvdTime)+", PktReceivedDate:"+date.format(pktRcvdTime));
						MachineCommReportRespContract responseObj = vinRespObjMap.get(serNum);
						responseObj.setPktReceivedTimestamp(dateFormat.format(pktRcvdTime));
						responseObj.setPktReceivedDate(date.format(pktRcvdTime));
						
					}
				}
				infoLogger.info("Set CreatedTimestamp - END");*/
			}
			
			catch(Exception e)
			{
				fLogger.fatal("Exception :"+e);
				
				Writer result = new StringWriter();
	    	    PrintWriter printWriter = new PrintWriter(result);
	    	    e.printStackTrace(printWriter);
	    	    String err = result.toString();
	    	    fLogger.fatal("Exception trace: "+err);
	    	    try 
	    	    {
	    	    	printWriter.close();
	        	    result.close();
				} 
	    	    
	    	    catch (IOException e1) 
	    	    {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				}
	    	    
	    	    
			}

			finally
			{
				if(session.isOpen())
					if(session.getTransaction().isActive())
					{
						session.getTransaction().commit();
					}

				if(session.isOpen())
				{
					session.flush();
					session.close();
				}

			}
			
			return responseList;
		}


	//DF20160711 @Roopa for Updating service detail report via executor service
	@Override
	public String call() throws Exception {
		// TODO Auto-generated method stub
		
		setServiceDetailsViaExecutor();
		return null;
	}
	
	//*************************************** DF20140108 - Rajani Nagaraju - Machine Communication Report - New Report Implementation *******************
	
}


